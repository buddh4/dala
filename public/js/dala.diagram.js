(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
require('./ui/jqueryPlugins');
require('./svg/draggable');

if(!window.dala) {
    dala = {};
}

dala_env = window.dala_env || {};
dala_env.initial_templates = {};

//TODO: better namespace handling... export to module
var globalModules =  {
    'templateManager': require('./diagram/templateManager')
};

dala.require = function(id) {
    return globalModules[id];
};



if(!window.dala.SVG) {
    window.dala.SVG = require('./svg/svg');
}

if(!window.dala.Diagram) {
    window.dala.Diagram = require('./diagram/diagram');
}


},{"./diagram/diagram":16,"./diagram/templateManager":36,"./svg/draggable":50,"./svg/svg":59,"./ui/jqueryPlugins":66}],2:[function(require,module,exports){
var object = require('../util/object');
var dom = require('../dom/dom');
var string = require('../util/string');

var Cache = function() {
    this.queryCache = {};
    this.svgCache = {};
};

Cache.prototype.clearBySuffix = function(suffix) {
    for(key in this.queryCache) {
        if(this.queryCache.hasOwnProperty(key) && string.endsWith(key, suffix)) {
            delete this.queryCache[key];
        };
    }

    for(key in this.svgCache) {
        if(this.svgCache.hasOwnProperty(key) && string.endsWith(key, suffix)) {
            delete this.svgCache[key];
        };
    }
};

Cache.prototype.$ = function(obj, preventCache) {
    if(!obj) {
        return;
    }

    if(this.queryCache[obj]) {
        return this.queryCache[obj];
    }

    var settings = this.getCacheSettings(obj, this.queryCache);
    return this.cacheCheck(settings.key, settings.$node, this.queryCache, preventCache);
};

Cache.prototype.svg = function(obj, preventCache) {
    if(!obj) {
        return;
    }

    if(this.svgCache[obj]) {
        return this.svgCache[obj];
    }

    var settings = this.getCacheSettings(obj, this.svgCache);
    return this.cacheCheck(settings.key, $.svg(settings.$node), this.svgCache, preventCache);
};

Cache.prototype.getCacheSettings = function(obj, cache) {
    var settings = {};

    if(object.isString(obj)){
        settings.$node = this.queryCache[obj] || $(obj);
        settings.key = obj;
    } else if(obj.jQuery) {
        settings.$node = obj;
        settings.key = dom.getIdSelector(obj.attr('id'));
    } else {
            settings.$node = $(obj);
            settings.key = dom.getIdSelector(settings.$node.attr('id'));
    }

    return settings;
}

Cache.prototype.cacheCheck = function(key, obj, cache, preventCache) {
    preventCache = preventCache || false;
    if(key && obj) {
        return (!preventCache) ? cache[key] = obj : obj;
    } else {
        return obj;
    }
}

Cache.prototype.remove = function(obj) {
    if(object.isString(obj)) {
        delete this.queryCache[obj];
    }
};

Cache.prototype.exists = function(selector) {
    return object.isDefined(queryCach[selector]);
};

Cache.prototype.sub = function() {
    return new Cache();
};

module.exports = new Cache();
},{"../dom/dom":44,"../util/object":71,"../util/string":72}],3:[function(require,module,exports){
var event = require('./event');
var object = require('../util/object');
var string = require('../util/string');

var Response = function(data) {
    this.data = data;
};

Response.prototype.isConfirmation = function() {
    return this.data && (this.data.status === 0);
};

Response.prototype.isError = function() {
    return this.data && this.data.status && (this.data.status > 0);
};

Response.prototype.getError = function() {
    return this.data.error;
};

Response.prototype.getErrorCode = function() {
    return this.data.errorCode;
};

Response.prototype.toString = function() {
    return "{ status: "+this.data.status+" error: "+this.data.error+" data: "+this.data.data+" }";
};

var config = {
    host : 'localhost',
    port : 3000
};

var errorHandler = function(cfg, xhr,type,errorThrown, errorCode) {
    errorCode = (xhr) ? xhr.status : parseInt(errorCode);
    console.warn("ajaxError: "+type+" "+errorThrown+" - "+errorCode);

    if(cfg.errorMessage) {
        if(object.isString(cfg.errorMessage)) {
            event.trigger('error', cfg.errorMessage);
        } else if(object.isObject(cfg.errorMessage, errorCode)) {
            var msg = cfg.errorMessage[errorCode] || cfg.errorMessage['default'];
            if(object.isDefined(msg)) {
                event.trigger('error', msg);
            }
        }
    }

    if(cfg.error && object.isFunction(cfg.error)) {
        // "timeout", "error", "abort", "parsererror" or "application"
        cfg.error(errorThrown, errorCode, type);
    } else if(cfg.error) {
        var msg = cfg.error[errorCode] || cfg.error['default'];
        if(object.isDefined(msg)) {
            event.trigger('error', msg);
        }
    }

    if(!cfg.error && !cfg.errorMessage) {
        console.warn('Unhandled ajax error: '+path+" type"+type+" error: "+errorThrown);
    }
};

module.exports = {
    test: function(settings) {
        this.ping(settings);
    },
    ping: function(settings) {
        settings = settings || config;
        var result = false;
        $.ajax({
            url: "http://"+settings.host+":"+settings.port+"/service/ping",
            //crossDomain: true,
            type : "GET",
            data: {'ping':true},
            async : false,
            dataType: "json",
            success: function (response) {
                result = true;
            },
            error: function (xhr, status, msg) {
                result = false;
            }
        });

        return result;
    },
    ajax: function(path, data, cfg) {
        var cfg = cfg || {};
        var async = cfg.async || true;
        var dataType = cfg.dataType || "json";

        var error = function(xhr,type,errorThrown, errorCode) {
            errorHandler(cfg, xhr,type,errorThrown, errorCode);
        };

        var success = function(response) {
            var responseWrapper = new Response(response);

            if(responseWrapper.isError()) { //Application errors
                return error(undefined,"application",responseWrapper.getError(), responseWrapper.getErrorCode());
            } else if(cfg.success) {
                if(object.isString(cfg.success)) {
                    event.trigger('info', cfg.success);
                } else {
                    cfg.success(responseWrapper);
                }
            }

            if (cfg.successMessage) {
                event.trigger('info', cfg.successMessage);
            }
        };

        var that = this;
        $.ajax({
            url: that.getUrl(path),
            //crossDomain: true, //TODO: read from config
            type : cfg.type,
            processData : cfg.processData,
            contentType: cfg.contentType,
            data: data,
            async : async,
            dataType: dataType,
            success: success,
            error: error
        });
    },
    post: function(path, data, cfg) {
        cfg = cfg || {};
        cfg.type = 'POST';
        this.ajax(path, data, cfg);
    },
    get: function(path, cfg) {
        cfg = cfg || {};
        cfg.type = 'GET';
        this.ajax(path, cfg.data, cfg);
    },
    xml: function(path, cfg) {
        cfg = cfg || {};
        cfg.dataType = 'xml';
        return this.get(path,cfg);
    },
    getScript: function(path, cfg) {
        cfg = cfg || {};

        return $.getScript(path)
            .done(function(s, Status) {
                if(cfg.success) {
                    cfg.success(s, Status);
                }
            }).fail(function(xhr, settings, exception) {
                errorHandler(cfg, xhr,'error',exception);
            });
    },
    restGet: function(path, id, cfg) {
        var path = string.endsWith(path, '/')? path+id : path+'/'+id;
        this.get(path, cfg);
    },
    getUrl: function(addition) {
        var url = "http://"+config.host+":"+config.port;
        if(addition) {
            url += addition;
        }
        return url;
    },
    set: function(settings) {
        config = settings;
    },
    getSettings: function() {
        return config;
    }
}
},{"../util/object":71,"../util/string":72,"./event":7}],4:[function(require,module,exports){
var object = require('../util/object');

var CommandAction = function(client, action) {
    this.client = client;
    this.action = action;
};

CommandAction.prototype.exec = function(args) {
    return this.action.apply(this.client, args);
};

var Command = function(client, doAction, undoAction) {
    if(arguments.length > 0) {
        //Call the exec setter
        this.exec(client,doAction);
        this.undo(client,undoAction);
    }
    this.timestamp = Date.now();
};

Command.prototype.exec = function(client, action, args) {
    return this.action('do', client, action, args);
};

Command.prototype.undo = function(client, action, args) {
    return this.action('undo', client, action, args);
};

Command.prototype.instance = function(doArgs, undoArgs) {
    var instance = $.extend(true, {}, this);

    //If given, we overwrite the argument settings for the actions
    if(doArgs) {
        instance.doArgs = doArgs;
    }

    if(undoArgs) {
        instance.undoArgs = undoArgs;
    }
    return instance;
};

/**
 * Just a helper to unify the logic for doAction and undoAction.
 *
 * - if just the type is given we assume all necessary action data is given for this type (do/undo) and call the action
 * - if a there is another argument beside the type we assume an args array and call the action with the given array
 * - if there are more args given, we assume a setter call to set the action data (do/undo)
 *
 * @param type do or undo
 * @param client client object used as this
 * @param action the function to call
 * @param args arguments
 * @returns {Command}
 */
Command.prototype.action = function(type, client, action, args) {
    if(args) {
        this[type + 'Args'] = args;
    }

    if(client && action) {
        this[type + 'Action'] = new CommandAction(client, action);
    } else {
        //Execute either with args settings from this or from argument list
        this[type + 'Args'] = arguments[1] || this[type + 'Args'];
        var action = this[type + 'Action'];
        if(action) {
            return action.exec(this[type + 'Args']);
        }
    }

    return this;
};

module.exports = Command;


},{"../util/object":71}],5:[function(require,module,exports){
var util = require('../util/util');
var object = util.object;
var dom = util.dom;
var event = require('./event');

//Command instances for diagrams
var instances = {};

var sub = function(subId, updateHandler) {
    return instances[subId] = new CommandManager(subId, updateHandler);
};

var CommandManager = function(subId, updateHandler) {
    this.subId = subId;
    this.commands = {};
    this.undoCommands = [];
    this.redoCommands = [];
    this.updateHandler = updateHandler;
};

/**
 * We can register a new command for this given command instance (mostly a command for a specific diagram instance)
 * which is identified by its string id.
 *
 * The client and action attribute for the do and undo action should be set for the given actions.
 *
 * @param cmdId string id
 * @param cmd command instance
 */
CommandManager.prototype.register = function(cmdId, cmd) {
    this.commands[cmdId] = cmd;
};

CommandManager.prototype.exec = function(cmdId, doArgs, undoArgs) {
    var cmdInstance = this.add(cmdId, doArgs, undoArgs);
    if(cmdInstance) {
        console.log('Execute command '+cmdInstance.id);
        return cmdInstance.exec();
    }
};

CommandManager.prototype.add = function(cmdId, doArgs, undoArgs) {
    var command = this.commands[cmdId];
    if(command) {
        this.updated(command);
        var cmdInstance = command.instance(doArgs,undoArgs);
        if(cmdInstance) {
            cmdInstance.id = cmdId+'_'+Date.now();
            console.log('Add command '+cmdInstance.id);
            this.undoCommands.push(cmdInstance);
            this.redoCommands = [];
        }
        return cmdInstance
    } else {
        console.warn('Unregistered command '+cmdId+' was called.');
    }
};

CommandManager.prototype.undo = function() {
    var command = this.undoCommands.pop();
    if(object.isDefined(command) && object.isDefined(command.undo)) {
        command.undo.apply(command);
        console.log('Undo command '+command.id);
        this.redoCommands.push(command);
        this.updated(command);
    }
};

CommandManager.prototype.redo = function() {
    var command = this.redoCommands.pop();
    if(object.isDefined(command) && object.isDefined(command.exec)) {
        command.exec.apply(command);
        console.log('Redo command '+command.id);
        this.undoCommands.push(command);
        this.updated(command);
    }
};

CommandManager.prototype.updated = function(command) {
    this.lastChange = Date.now();
    if(this.updateHandler) {
        this.updateHandler(command);
    }
}

module.exports = {
    sub : sub
};


},{"../util/util":73,"./event":7}],6:[function(require,module,exports){
var object = require('../util/object');

var values = {};

module.exports = {
    val : function(key, defaultVal) {
        if(object.isDefined(key)) {
            var result = values[key];
            return (object.isDefined(result)) ? result : defaultVal;
        }
    },

    debug : function(val) {
        if(object.isBoolean(val)) {
            this.setVal('debug', val);
        }
        return this.val('debug', false);
    },

    setVal : function(key, value) {
        if(object.isDefined(key) && object.isDefined(value)) {
            values[key] = value;
            var val = this.val(key);
        }
    },

    replaceConfigValues : function(text, config) {
        var result = text;
        object.each(config, function(key, value) {
            var regExp = new RegExp("{" + key + "}", "g");
            result = result.replace(regExp, value);
        });
        return result;
    }
};
},{"../util/object":71}],7:[function(require,module,exports){
var events = {};

var object = require('../util/object');
var config = require('../core/config');
var SubEvent = require('./subEvent');

var Promise = require('bluebird');

var hasHandler = function(type) {
    return events[type];
};

mouse = {};

$(document).on( 'mousemove', function(e) {
    mouse = e;
});


module.exports = {
    mouse : function() {
        return mouse;
    },
    listen:  function(type, handler, module) {
        if(!object.isFunction(handler)) {
            return;once
        }

        var eventConfig = {
            handler : handler,
            module : module
        };

        if(!events[type]) {
            events[type] = [eventConfig];
        } else {
            events[type].push(eventConfig);
        }
    },

    unlisten: function(type, func) {
        if(events[type]) {
            var index = events[type].indexOf(func);
            if(index > -1) {
                events[type].splice(index, 1);
            }
        }
    },

    sub: function(context) {
        return new SubEvent(context, this);
    },

    command: function(command, execute) {
        if(execute) {
            this.trigger('command_execute', command);
        } else {
            this.trigger('command_add', command);
        }
    },

    trigger: function(type, data, rootEvt) {
        var that = this;
        return new Promise(function(resolve, reject) {
            var event = rootEvt || {};

            event.data = data;
            event.type = type;

            if(hasHandler(event.type)) {
                var handlerArr = events[event.type];
                object.each(handlerArr, function(index, eventConfig) {
                    var handler = eventConfig.handler;
                    var module;
                    try {
                        module = eventConfig.module;
                        if(eventConfig.module) {
                            handler.call(eventConfig.module, event);
                        } else {
                            handler(event);
                        }
                    } catch(err) {
                        var modText = (module && module.constructor && module.constructor.name)?module.constructor.name:'unknown';
                        if(modText === 'unknown' && config.debug()) {
                            console.error('Event handler error - module: '+modText+' event: '+event.type, handler, err);
                        } else {
                            console.error('Event handler error - module: '+modText+' event: '+event.type, err);
                        }
                        that.trigger('error', 'An error occured while executing the last action !');
                    }
                });
            }

            //We just resolve in all cases since the caller of trigger should remain independent of handler modules
            resolve();
        });
    },

    on: function(node, event, selector, data, handler) {
        $(node).on(event,selector,data, handler);
    },

    off: function(node, event, selector, handler) {
        $(node).off(event, selector, handler);
    },

    once: function(node, event, selector, data, handler) {
        $(node).one(event,selector,data, handler);
    },

    triggerDom: function(node, event) {
       $(node).trigger(event);
    }
};
},{"../core/config":6,"../util/object":71,"./subEvent":8,"bluebird":75}],8:[function(require,module,exports){
var object = require('../util/object');

var SubEvent = function(context, event) {
    this.context = context;
    this.event = event;
}

SubEvent.prototype.getSubType = function(type) {
    return this.context+':'+type;
}

SubEvent.prototype.listen = function(type, handler, module) {
    //TODO: implement bubble
    this.event.listen(this.getSubType(type), handler, module);
};

SubEvent.prototype.unlisten = function(type, func) {
    this.event.unlisten(this.getSubType(type), func);
};

SubEvent.prototype.trigger = function(type, data, rootEvt, preventBubble) {
    this.event.trigger(this.getSubType(type), data, rootEvt);
    if(!preventBubble) {
        this.event.trigger(type, data, rootEvt);
    }
};

SubEvent.prototype.command = function(command, execute) {
    this.event.command(command, execute);
};

SubEvent.prototype.on = function(node, event, selector, data, handler) {
    this.event.on(node, event, selector, data, handler);
};

SubEvent.prototype.off = function(node, event, selector, handler) {
    this.event.off(node, event, selector, handler);
};

SubEvent.prototype.once = function(node, event, selector, data, handler) {
    this.event.once(node, event, selector, data, handler);
};

SubEvent.prototype.triggerDom = function(node, event) {
    this.event.triggerDom(node,event);
}

SubEvent.prototype.sub = function(context) {
    return new SubEvent(context, this);
}

module.exports = SubEvent;
},{"../util/object":71}],9:[function(require,module,exports){
var object = require('../util/object');
var app = require('../util/app');
var dom = require('../dom/dom');
var Transform = require('../svg/transform');

var DEFAULT_OPACITY = 0.5;
var DEFAULT_KNOB_RADIUS = 5;

var Knob = function(diagram, p, cfg, group) {
    this.diagram = diagram;
    this.event = diagram.event;
    this.group = group;
    this.init(p, cfg);
};

Knob.prototype.clearRelativeOrientation = function() {
    delete this.relativePosition;
};

Knob.prototype.isSelected = function() {
    return this.node.selected;
};

Knob.prototype.relativeOrientation = function(position) {
    if(position) {
        this.relativePosition = {
            x : position.x,
            y : position.y
        };
    }
    return this.relativePosition;
};

Knob.prototype.init = function(position, cfg) {
    this.config = object.extend({radius : DEFAULT_KNOB_RADIUS}, cfg);
    this.node = this.diagram.createKnobNode(position, this.group, this.config);
    this.config = this.node.config;
    this.root = this.node.root;
    this.node.knob = this;

    var that = this;
    var select = cfg.select || function() {
            that.activeStyle();
        };

    var deselect = cfg.deselect || function() {
            that.inactiveStyle();
        };


    this.on('select', select).on('deselect', deselect);
    this.event.trigger('knob_added', this);
};

Knob.prototype.x = function() {
    return this.node.x();
};

Knob.prototype.y = function() {
    return this.node.y();
};

Knob.prototype.position = function() {
    return this.node.getCenter();
};

Knob.prototype.draggable = function(handler) {
    this.node.draggable(handler);
    this.triggerDrag = function(dx,dy) {
        this.node.triggerDrag(dx,dy);
    };
    return this;
};

Knob.prototype.initDrag = function(evt) {
    this.node.initDrag(evt);
};

Knob.prototype.hide = function() {
    this.node.root.hide();
    this.node.root.attr('r', 0); //TODO: perhaps not wanted for all knob types.
};

Knob.prototype.show = function(opacity) {
    opacity = opacity || this.config['fill-opcaity'] || 1;
    this.node.root.show(DEFAULT_OPACITY);
    this.node.root.attr('r', this.config['radius']);
};

Knob.prototype.select = function() {
    this.selected = true;
    this.node.trigger('select');
    return this;
};

Knob.prototype.deselect = function() {
    this.selected = false;
    this.node.trigger('deselect');
    return this;
};

Knob.prototype.fill = function(color) {
    this.node.root.fill(color);
};

Knob.prototype.stroke = function(color) {
    this.node.root.stroke(color);
    this.node.root.strokeWidth(1);
};

Knob.prototype.activeStyle = function() {
    this.fill(this.config['fill-active']);
    this.show();
};

Knob.prototype.deselect = function() {
    this.inactiveStyle();
    return this;
};

Knob.prototype.inactiveStyle = function() {
    this.fill(this.config['fill']);
    this.show();
};

Knob.prototype.hoverable = function(handler) {
    var that = this;
    this.node.root.hoverable(handler);
    return this;
};

Knob.prototype.on = function(handler, args) {
    this.node.on(handler, args);
    return this;
};

Knob.prototype.remove = function() {
    this.node.trigger('remove');
};

Knob.prototype.move = function(dx,dy) {
    this.node.root.move(dx,dy);
    this.node.trigger('move' [dx,dy]);
};

Knob.prototype.moveTo = function(x,y) {
    this.node.root.moveTo(x,y);
    this.node.trigger('moveTo', [x,y]);
};

Knob.prototype.toString = function() {
    return '('+this.x()+'/'+this.y()+')';
};

module.exports = Knob;
},{"../dom/dom":44,"../svg/transform":63,"../util/app":68,"../util/object":71}],10:[function(require,module,exports){
var dom = require('../dom/dom');
var object = require('../util/object');
var EditPanel = require('../ui/editPanel');

var editPanel = new EditPanel();

var AbstractEditAddition = function(editable, editFunctions, config) {
    this.editable = editable;
    this.editFunctions = editFunctions;
    this.config = config;
    this.initEditTrigger();
};

AbstractEditAddition.prototype.initEditTrigger = function() {
    var that = this;
    object.each(this.config, function(key, editItem) {
        if(object.isDefined(editItem.trigger)) {
            that.addEditTextTrigger(key);
        }
    });
};

AbstractEditAddition.prototype.addEditTrigger = function(key) {
    switch(type) {
        case 'text':
        case 'textarea':
            this.addEditTextTrigger(key);
            break;
    }
};

AbstractEditAddition.prototype.addEditTextTrigger = function(key) {
    var editItem = this.getEditItem(key);
    var that = this;

    var selector = this.editable.selector(editItem.trigger);
    $(selector).css('cursor', 'pointer');

    //TODO: evtl move this to text.editable();
    this.editable.root.$().on('click', selector,  function(evt) {
        if(that.isTriggerAllowed()) {
            switch(editItem.type) {
                case 'textarea':
                    editPanel.createTextAreaEdit(evt.pageX, evt.pageY,
                        function() {
                            return that.getValue(key).trim();
                        },
                        function(value) {
                            that.setValue(key, value);
                        });
                    break;
                case 'text':
                    editPanel.createTextEdit(evt.pageX, evt.pageY, function() {
                            return that.getValue(key).trim();
                        },
                        function(value) {
                            that.setValue(key, value);
                        });
                    break;
            }
        }
    });
};

AbstractEditAddition.prototype.getValue = function(key) {
    var editItem = this.getEditItem(key);
    var editFunction = this.editFunctions[editItem.type];
    if(editFunction && !object.isString(editFunction)) {
        return this.editFunctions[editItem.type].get.call(this, editItem, key);
    } else if(editFunction && object.isString(editFunction)) {
        return this.editable.getInnerSVG(editItem.bind)[editFunction]();
    }
};

AbstractEditAddition.prototype.setValue = function(key, value) {
    var editItem = this.getEditItem(key);
    var oldValue = this.getValue(key);
    var editFunction = this.editFunctions[editItem.type];
    if(editFunction && !object.isString(editFunction)) {
        this.editFunctions[editItem.type].set.call(this, editItem, value);
        this.onSetValue(editItem, value);
    } else if(editFunction && object.isString(editFunction)) {
        this.editable.getInnerSVG(editItem.bind)[editFunction](value);
        this.onSetValue(editItem, value);
    }

    if(this.editable.exec) {
        this.editable.exec('edit', [key, value, oldValue]);
    }
};

/**
 * This method either returns a clone of the editItem for normal keys like 'title', or
 * creates a new editItem out of a combined key like 'title_text-size' with key title and type text-size
 */
AbstractEditAddition.prototype.getEditItem = function(key) {
    var type;
    var editItem;
    if(key.indexOf('_') > -1) {
        var splitted = key.split('_');
        editItem = object.cloneObject(this.config[splitted[0]]);
        editItem.type = splitted[1];
    } else {
        editItem = this.config[key];
    }
    return editItem;
};

AbstractEditAddition.prototype.isTriggerAllowed = function() {
    return !this.lastSelect || (Date.now() - this.lastSelect > 200);
};

AbstractEditAddition.prototype.setTextAreaContent = function($textAreaNode, txtAreaContent) {
    this.editable.diagram.svg.get($textAreaNode).content(txtAreaContent);
};

AbstractEditAddition.prototype.getTextAreaContent = function($textAreaNode) {
    return this.editable.diagram.svg.get($textAreaNode).content();
};

AbstractEditAddition.prototype.deselect = function() {
    this.remove();
};

AbstractEditAddition.prototype.select = function() {
    this.lastSelect = Date.now();
};

AbstractEditAddition.prototype.remove = function() {
    editPanel.close();
};

AbstractEditAddition.prototype.update = function() {
    this.remove();
};

AbstractEditAddition.prototype.activate = function() {
    this.remove();
};

AbstractEditAddition.prototype.onSetValue = function(editItem, value) { };

module.exports = AbstractEditAddition;
},{"../dom/dom":44,"../ui/editPanel":65,"../util/object":71}],11:[function(require,module,exports){
var util = require('../util/util');
var event = require('../core/event');
var Command = require('../core/command');

var Manager = function(diagram) {
    this.diagram = diagram;
    this.event = diagram.event;
};

Manager.prototype.command = function(cmdId, doAction, undoAction) {
    this.diagram.registerCommand(cmdId, new Command(this, doAction, undoAction));
};

Manager.prototype.exec = function(cmdId, doArgs, undoArgs) {
    return this.diagram.executeCommand(cmdId, doArgs, undoArgs);
};

Manager.prototype.addCmd = function(cmdId, doArgs, undoArgs) {
    this.diagram.addCommand(cmdId, doArgs, undoArgs);
};

Manager.prototype.listen = function(eventId, handler) {
    this.event.listen(eventId, handler, this);
}

Manager.prototype.getNodeById = function(id) {
    return this.diagram.getNodeById(id);
};

Manager.prototype.getTransitionById = function(id) {
    return this.diagram.getTransitionById(id);
};

Manager.prototype.getSVG = function(id) {
    return $.svg(id);
};

Manager.prototype.getNodeMgr = function(command) {
    return this.diagram.nodeMgr;
};

Manager.prototype.getTransitionMgr = function(command) {
    return this.diagram.transitionMgr;
};

Manager.prototype.getSelectionMgr = function(command) {
    return this.diagram.selectionMgr;
};

module.exports = Manager;
},{"../core/command":4,"../core/event":7,"../util/util":73}],12:[function(require,module,exports){
var PathData = require('../svg/pathData');
var object = require('../util/object');

var AbstractPathManager = function(transition) {
    this.transition = transition;
};

AbstractPathManager.prototype.activate = function() {
    this.path =  this.transition.getLine().d();
    return this;
};

AbstractPathManager.prototype.fromString = function(pathDataStr) {
    this.path = new PathData().loadFromString(pathDataStr);
};

AbstractPathManager.prototype.dragLine = function(position) {
    // Init path if no path was created yet
    if(!this.path) {
        this._init(position)
    }

    // Create full path if the path only consist of the start path part yet or update the end position of the path
    if(this.path.length() === 1) {
        this.create(position);
    } else {
        this.path.end(position);
    }

    this.update();
};

AbstractPathManager.prototype._init = function(position) {
    this.path = new PathData().start(position);
};

AbstractPathManager.prototype.updatePart = function(index, position) {
    this.path.setTo(index, position);
    this.update();
};

AbstractPathManager.prototype.addPathPart = function(index, position) {
    if(!this.path) {
        this._init(position);
    } else {
        this.add(index,position);
        this.update();
    }
};

AbstractPathManager.prototype.removePathPart = function(index) {
    if(this.path) {
        this.path.removePath(index);
    }
};

AbstractPathManager.prototype.replace = function(old, positions) {
    this._init(positions[0]);

    for(var i  = 1; i < positions.length; i++) {
        this.add(i, positions[i]);
    }

    this.update();

    //We set our created path data to the existing path, since the transition line and linearea are dependent on this path instance
    old.path.data = this.path.data;
    this.path = old.path;

    this.transition.pathManager = this;
    return this;
};

AbstractPathManager.prototype.create = function(position) {/*Abstract*/};
AbstractPathManager.prototype.update = function(position) {/*Abstract*/};
AbstractPathManager.prototype.add = function(index, position) {/*Abstract*/};

module.exports = AbstractPathManager;
},{"../svg/pathData":56,"../util/object":71}],13:[function(require,module,exports){
var additions = {};
var event = require('../core/event');

var AdditionFactory = function() {
    this.additions = {};
};

AdditionFactory.prototype.register = function(key, addition) {
    this.additions[key] = addition;
};

AdditionFactory.prototype.initAddition = function(key, host) {
    if (!host.additions) {
        host.additions = {};
    }

    var addition = this.additions[key];

    if(addition && host && _checkConfigRequirement(addition, host, key)) {
        host.additions[key] = new addition(host);
    } else if(!addition){
        event.trigger('warn', 'Tried to initiate an unknown addition '+key+' some functionality may not available.');
    }
};

var nodeAdditions = new AdditionFactory();
var transitionAdditions = new AdditionFactory();

var _checkConfigRequirement = function(addition, host, key) {
    return !addition.requireConfig || (addition.requireConfig && (host.config && host.config[key]));
};

module.exports = {
    registerNodeAddition : function(key, addition) {nodeAdditions.register(key,addition)},
    initNodeAddition : function(key, host) {nodeAdditions.initAddition(key, host)},
    registerTransitionAddition : function(key, addition) {transitionAdditions.register(key,addition)},
    initTransitionAddition : function(key, host) {transitionAdditions.initAddition(key, host)}
};
},{"../core/event":7}],14:[function(require,module,exports){
var Promise = require('bluebird');

var DiagramAPI = function(diagram) {
    this.diagram = diagram;
};

DiagramAPI.prototype.createNode = function(tmplId, position) {
    var that = this;
    return new Promise(function(resolve, reject) {
        that.loadTemplate(tmplId)
            .then(function(template) {
                resolve(that.diagram.nodeMgr.createNodeCommand(template, position));
            }, function(err) {
                reject(err);
            });
    });

};

DiagramAPI.prototype.getSelectedTransition = function(tmpl, position) {
    return this.diagram.selectionMgr.selectedTransition;
};

DiagramAPI.prototype.loadTemplate = function(tmpl) {
    var that = this;
    return new Promise(function(resolve, reject) {
        that.diagram.templateMgr.getTemplate(tmpl)
            .then(function(template) {
                resolve(template);
            }, function(err) {
                reject(err);
            });
    });
};

DiagramAPI.prototype.getSelectedNodes = function(tmpl, position) {
    return this.diagram.selectionMgr.getSelectedNodes();
};

DiagramAPI.prototype.getNodeById = function(id) {
    return this.diagram.nodeMgr.getNode(id);
};

DiagramAPI.prototype.createTransition = function(node1, node2) {
    return node1.additions.transition.startNewTransition(node2);
};

module.exports = DiagramAPI;
},{"bluebird":75}],15:[function(require,module,exports){
var AbstractPathManager = require('./abstractPathManager');
var util = require('../util/util');

var CurvedPathManager = function(transition) {
    AbstractPathManager.call(this, transition);
    this.type = CurvedPathManager.type;
};

util.inherits(CurvedPathManager, AbstractPathManager);

CurvedPathManager.type = 'curved';

CurvedPathManager.prototype.create = function(position) {
    this.path.cBezier(undefined, undefined, position);
};

CurvedPathManager.prototype.add = function(index, position) {
    this.path.insertCBezier(index,undefined, undefined, position);
};

CurvedPathManager.prototype.update = function() {
    this.path.smoothen();
};

module.exports = CurvedPathManager;

},{"../util/util":73,"./abstractPathManager":12}],16:[function(require,module,exports){
/**
 * This class represents an instance of a diagram and is responsible for initializing and
 * building the stage. Furthermore it contains diagram related utility functionality.
 *
 * An instance of this class offers the access to all nodes/transitions and templates of the
 * diagram.
 *
 * This class is designed to be able to manage multiple diagrams within one
 * application instance.
 */
var util = require('../util/util');
var event = require('../core/event');
var SVG = require('../svg/svg');
var PathData = require('../svg/pathData'); //Rather implement svg.createpath().start().line()...
var templateManager = require('./templateManager').init();
var commandManager = require('../core/commandManager');
var SelectionManager = require('./selectionManager');
var NodeManager = require('./nodeManager');
var TransitionManager = require('./transitionManager');
var DiagramAPI = require('./api');

var KnobManager = require('./knobManager');
require('./knobTemplate');
var xml = require('../util/xml');

var Promise = require('bluebird');

var Helper = require('./helper');

var object = util.object;
var dom = util.dom;


var CONTAINER_SELECTOR = '#svgStage';
// Contains the parent dom node (div) of the SVG element
var $CONTAINER_NODE = $(CONTAINER_SELECTOR);

/**
 * Constructor for initiating a new diagram instance within the containerID.
 *
 * @param {type} containerID The parent of the new SVG diagram
 * @param {type} cfg
 */
 var Diagram = function(cfg) {
    cfg = cfg || {};

    if(!cfg.id) {
        console.warn('Created diagram without id');
    }

    this.uniqueIds = [];

    this.id = cfg.id || 'not specified';
    this.projectId = cfg.projectId || 'default';
    this.title = cfg.title || 'new';

    //Diagram intern event context
    this.event = event.sub(this.id);

    if(cfg.container) {
        this.$container = $(cfg.container);
    } else {
        this.$container = $CONTAINER_NODE;
    }

    var that = this;
    this.commandMgr = commandManager.sub(this.id, function(cmd) {
        that.triggerUpdate();
    });

    // Handles the loading and creation of templates
    this.templateMgr = templateManager;
    // Responsible for creating and maintaining nodes
    this.nodeMgr = new NodeManager(this);
    // Responsible for creating and maintaining transitions
    this.transitionMgr = new TransitionManager(this);
    // This helper class manages the selection of nodes/transitions
    this.selectionMgr = new SelectionManager(this);
    // Responsible for tracking and accessing all dockings on the diagram
    this.knobMgr = new KnobManager(this);

    // Build the SVG stage within the container
    this.svg = new SVG(this.$container.attr('id'), {"xmlns:dala" : "http://www.dala.com"});

    // Init stage related and key events
    this.initEvents();

    this.scale = 1;

    var that = this;
    this.initDefs()
        .then(function() {
            that.mainPart = that.svg.createPart('main', true);
            that.helper = new Helper(this);
            that.trigger('initialized');
        }, function(err) {
            console.error('Could not load defs initialisation failed!');
        });
};

Diagram.prototype = {
    get api () {
        if(!this._api) {
            this._api = new DiagramAPI(this);
        }
        return this._api;
    }
};

Diagram.prototype.getRootSVG = function() {
    return this.svg.root;
};

Diagram.prototype.triggerUpdate = function() {
    this.trigger('diagram_updated', this.id);
};

Diagram.prototype.getNodes = function(filter) {
    return this.nodeMgr.getNodes(filter);
};

Diagram.prototype.trigger = function(evt, args) {
    //perhaps also listen to diagram intern events not only dom events.
    this.svg.root.trigger(evt, args);
    this.event.trigger(event, args);
};

Diagram.prototype.on = function(evt, handler) {
    //perhaps also listen to diagram intern events not only dom events.
    this.svg.root.on(evt, handler);
};

Diagram.prototype.one = function(evt, handler) {
    //perhaps also listen to diagram intern events not only dom events.
    this.svg.root.one(evt, handler);
};

Diagram.prototype.off = function(evt) {
    this.svg.root.off(evt);
};

/*
 * Initializes Stage Mouse and Key events.
 */
Diagram.prototype.initEvents = function() {
    var that = this;
    // Double clicks on the stage area will create new nodes of the selected
    // template type. Only if we do not dbclick another node in this case
    // we start a transition drag.
    this.on('dblclick', function(evt) {
        if (!that.selectionMgr.isElementHover()) {
            that.event.trigger('node_create', that.templateMgr.getSelectedTemplate(), evt);
        }
    });

    this.on('mousedown', function(evt) {
        var startPosition = that.getStagePosition(evt);

        if(evt.ctrlKey) {
            //Move main part
            that.mainPart.draggable({
                once: true,
                cursor: 'all-scroll',
                dragMove: function(event, dx, dy) {
                    that.event.trigger('viewport_update', this.position());
                },
                dragEnd: function(event) {
                    that.event.trigger('viewport_updated', this.position());
                },
                restrictionX: function(event, dx, dy) {
                  return (this.x() + dx <= 0)? dx : 0;
                },
                restrictionY: function(event, dx, dy) {
                    return (this.y() + dy <= 0)? dy : 0;
                },
                getScale: function() {
                    return that.scale;
                }
            });
            that.mainPart.trigger('mousedown');;
        } else {
            that.selectionMgr.dragSelectionStart(evt, startPosition);
        }

    });

    this.on('mouseup', function() {
        that.selectionMgr.dragSelectionEnd();
    });

    event.on(document, "dragstart", function(e) {
        if (e.target.nodeName.toUpperCase() === "POLYLINE" || e.target.nodeName.toUpperCase() === 'PATH' || e.target.nodeName.toUpperCase() === 'CIRCLE') {
            e.preventDefault();
            return false;
        }
    });
};

Diagram.prototype.part = function(id) {
    return this.svg.part(id);
};

Diagram.prototype.import = function(svg, part, prepend) {
    return this.svg.import(svg, part, prepend);
};

Diagram.prototype.part = function(id) {
    return this.svg.part(id);
};

Diagram.prototype.initDefs = function() {
    var that = this;
    return new Promise(function(resolve, reject) {
        that.templateMgr.getTemplate('defs_marker')
            .then(function (tmpl) {
                if (tmpl) {
                    tmpl.createNode({diagramId: that.id}, that).init('root', true);
                    resolve();
                } else {
                    reject('Could initialize defs template result undefined');
                }
            }, function (err) {
                reject(err);
            });
    });
};

Diagram.prototype.createKnobNode = function(p, group, cfg) {
    return this.knobMgr.createKnobNode(p, group, cfg);
};

Diagram.prototype.uniqueId = function() {
    var newId = this.checkId(Date.now() + '');
    this.uniqueIds.push(newId);
    return newId;
};

/**
 * Prevent duplicates
 */
Diagram.prototype.checkId = function(id) {
    return ($.inArray(id, this.uniqueIds) > -1) ? this.checkId('u'+id) : id;
};

Diagram.prototype.getHoverNode = function() {
    return this.nodeMgr.hoverNode;
};

Diagram.prototype.isMultiSelection = function() {
    return this.selectionMgr.isMultiSelection();
};

Diagram.prototype.isPoint = function(value) {
    return object.isDefined(value.x);
};

Diagram.prototype.newDiagram = function() {
    //TODO: we should unify this with the constructor svg creation technique
    this.loadDiagram('<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="svgStage_svg" xmlns:dala="http://www.dala.com" height="100%" width="100%"></svg>');
    this.initDefs();
};

Diagram.prototype.loadDiagram = function(svgString) {
    //TODO: rather handle this per event
    this.selectionMgr.clear();
    this.nodeMgr.clear();
    this.$container.empty();
    this.svg.setRoot(dom.importSVG(this.svg.$container, svgString));
    this.activateNodes();
    this.activateTransitions();
    this.initEvents();
};

Diagram.prototype.triggerDockingVisibility = function() {
    if(this.knobMgr.hideDocking) {
        this.knobMgr.showKnobs();
    } else {
        this.knobMgr.hideKnobs();
    }
};

Diagram.prototype.activateNodes = function() {
    var that = this;
    $('.element_root').each(function() {
        that.activateNode(this);
    });
};

Diagram.prototype.activateNode = function(domNode) {
    this.nodeMgr.activateByDomNode(domNode);
};

//TODO: move to transitionmgr
Diagram.prototype.activateTransitions = function() {
    this.transitionMgr.activateTransition($('.transition'));
};

Diagram.prototype.getNodeById = function(nodeId) {
    return this.nodeMgr.getNode(nodeId);
};

Diagram.prototype.getTransitionById = function(id) {
    return this.transitionMgr.getNode(id);
};

Diagram.prototype.zoomIn = function() {
    this.scale += 0.1;
    this.part('main').scale(this.scale);
};

Diagram.prototype.zoomOut = function() {
    if(this.scale > 0) {
        this.scale -= 0.1;
        this.part('main').scale(this.scale);
    }
};

/**
 * This method determines the relative stage coordinates for a given
 * window position either by providing the x and y position or an event
 * object with given pageX and pageY attributes or an point with x,y attributes.
 *
 * @param {type} x either an event object with pageX, pageY or an point with x,y
 *                 or just the plain x coordinate.
 * @param {type} y the y coordinate is just mandatory if the fisrst arg is the plain x
 * @returns {Diagram_L13.Diagram.prototype.getStagePosition.DiagramAnonym$2}
 */
Diagram.prototype.getStagePosition = function(x, y) {
    if(object.isDefined(x.pageX)) {
        y = x.pageY;
        x = x.pageX;
    } else if(object.isDefined(x.x)) {
        y = x.y;
        x = x.x;
    }

    var stagePosition = this.$container.offset();
    var viewPointAlignment = this.mainPart.position();

    //TODO: viewbox alignement ?
    return {
        x : parseInt((x  - stagePosition.left - viewPointAlignment.x) / this.scale),
        y : parseInt((y  - stagePosition.top - viewPointAlignment.y) / this.scale)
    };
};

/**
 * Checks if a given position is within the boundaries of a diagram node.
 * TODO: either return all overlay nodes or just the one with the biggest index...
 * @param {type} position
 * @returns {Boolean}
 */
Diagram.prototype.getNodeByPosition = function(position) {
    var result;
    object.each(this.nodeMgr.nodes, function() {
        if (this.overlays(position)) {
            result = this;
            return false;
        }
    });

    return result;
};

Diagram.prototype.asString = function() {
    return this.svg.asString();
};

Diagram.prototype.undoCommand = function() {
    this.commandMgr.undo();
};

Diagram.prototype.redoCommand = function() {
    this.commandMgr.redo();
};

Diagram.prototype.registerCommand = function(cmdId, cmd) {
    this.commandMgr.register(cmdId, cmd);
};

Diagram.prototype.executeCommand = function(cmdId, doArgs, undoArgs) {
    return this.commandMgr.exec(cmdId, doArgs, undoArgs);
};

Diagram.prototype.addCommand = function(cmdId, doArgs, undoArgs) {
    this.commandMgr.add(cmdId, doArgs, undoArgs);
};

module.exports = Diagram;


},{"../core/commandManager":5,"../core/event":7,"../svg/pathData":56,"../svg/svg":59,"../util/util":73,"../util/xml":74,"./api":14,"./helper":22,"./knobManager":25,"./knobTemplate":26,"./nodeManager":29,"./selectionManager":33,"./templateManager":36,"./transitionManager":42,"bluebird":75}],17:[function(require,module,exports){
/**
 * This utility module provies build-in docking techniques for transitions and other
 * dockable elements. The docking type can be configured within the template
 * with the config key "dockingType".
 *
 * Example:
 *  <config>
 *      {
 *          "nodeID" : "eer_entityDefault",
 *          "docking" : {type: 'RECT', orientation:'center', ...}
 *          ...
 *      }
 * </config>
 */

var util = require('../util/util');
var dom = util.dom;
var math = util.math;

var checkOrientationBoundary = function(node, p) {
    var dockingType = (node.config.docking && node.config.docking.type) ? node.config.docking.type : 'RECT';
    switch(node.config.docking.type.toUpperCase()) {
        case 'CENTER':
            return false;
        case 'CIRCLE':
            return CIRCLE_BOUNDARY.call(node, p);
        case 'ELLIPSE':
            return ELLIPSE_BOUNDARY.call(node, p);
        case 'SQUARE':
        case 'RECT':
            return RECT_BOUNDARY.call(node, p);
    };
};

var calculateDockingPosition = function(node, orientationOut, orientationIn) {
    var dockingType = (node.config.docking && node.config.docking.type) ? node.config.docking.type : 'RECT';
    switch(node.config.docking.type.toUpperCase()) {
        case 'SIMPLE':
            return SIMPLE.call(node, orientationOut, orientationIn);
        case 'CENTER':
            return CENTER.call(node, orientationOut, orientationIn);
        case 'CIRCLE':
            return CIRCLE.call(node, orientationOut, orientationIn);
        case 'ELLIPSE':
            return ELLIPSE.call(node, orientationOut, orientationIn);
        case 'SQUARE':
        case 'RECT':
            return RECT.call(node,orientationOut, orientationIn);
        case 'FREE':
            return FREE.call(node,orientationOut, orientationIn);
        default:
            return CENTER.call(node, orientationOut, orientationIn);

    };
};

var FREE = function(position , orientationIn) {
    return orientationIn;
};

var ELLIPSE = function(position , orientationIn) {
    var rx = this.width() / 2;
    var ry = this.height() / 2;
    var ellipse = new math.Ellipse(this.getCenter(), rx, ry);
    var result = ellipse.calcLineIntercept(position, orientationIn);

    return (result.length > 0)?result[0]:orientationIn;

};

var ELLIPSE_BOUNDARY = function(position) {
    var rx = this.width() / 2;
    var ry = this.height() / 2;
    return new math.Ellipse(this.getCenter(), rx, ry).overlays(position);
};

var CIRCLE = function(position, orientationIn) {
    //Note the stroke is not included in some browsers...
    var radius = this.width() / 2;
    var circle = new math.Circle(this.getCenter(), radius);
    var result = circle.calcLineIntercept(position, orientationIn);

    return (result.length > 0)?result[0]:orientationIn;
};

var CIRCLE_BOUNDARY = function(position) {
    var center = this.getCenter();
    var radius = this.width() / 2;
    return new math.Circle(this.getCenter(), radius).overlays(position);
};

/**
 * This technique uses the center of the node as orientation point and
 * returns the intersection of the node boundary and the line from the outer
 * orientation point to the center of the node as result.
 *
 * __________
 * |        |
 * |        |
 * |    x   |<----------------x
 * |        |
 * |        |
 * ----------
 *
 * @param {type} position the outer orientation point
 * @returns {DockingType_L20@call;getCenter}
 */
var RECT = function(position, orientation) {
    if(this.overlays(position)) {
        return orientation;
    }

    var transition = new math.Line(position, orientation);

    if(this.isRightOf(position)) {
        var result = transition.calcFX(this.x());
        if(this.overlays(result)) {
            return result;
        }
    }

    if(this.isLeftOf(position)) {
        var result = transition.calcFX(this.getRightX());
        if(this.overlays(result)) {
            return result;
        }
    }

    if(this.isOver(position)) {
        var bottomY = this.getBottomY();

        if(transition.isVertical()) {
            return {x: orientation.x, y: bottomY};
        }

        if(orientation.x === position.x) {
            return {x:orientation.x, y:bottomY};
        }
        var bottomLine = new math.Line({x:1,y:bottomY}, {x:2,y:bottomY});
        var result = transition.calcLineIntercept(bottomLine);
        //We explicitly set this because of possible calculation deviations
        result.y = bottomY;
        return result;
    } else {
        if(transition.isHorizontal()) {
            return {x:orientation.x, y: this.y()};
        }

        if(orientation.x === position.x) {
            return {x:orientation.x, y:this.y()};
        }
        var topLine = new math.Line({x:1,y:this.y()}, {x:2,y:this.y()});
        var result = transition.calcLineIntercept(topLine);
        //We explicitly set this because of possible calculation deviations
        result.y = this.y();
        return result;
    }
};

var RECT_BOUNDARY = function(p) {
    return this.overl
};

/**
 * This technique just returns the center of the node as result.
 * Note that line will start or end within the node.
 *
 * @param {type} position
 * @returns {DockingType_L20.CENTER@call;getCenter}
 */
var CENTER = function(position) {
    return this.getCenter();
};

/**
 * This technique provides 4 different docking points (top/right/bottom/left)
 * and returns the most suitable docking point for the given outer position.
 *
 * @param {type} position
 */
var SIMPLE = function(position, orientationIn) {
    //The position is within the node
    if(this.overlays(position)) {
        return orientationIn;
    }

    if(this.isLeftOf(position)) {
        return {
            x: this.getRightX(),
            y: orientationIn.y
        };
    } else if(this.isRightOf(position)) {
        return {
            x: this.root.x(),
            y: orientationIn.y
        };
    } else if(this.isOver(position)) {
        return {
            x: orientationIn.x,
            y: this.getBottomY()
        };
    } else if(this.isUnder(position)) {
        return {
            x: orientationIn.x,
            y: this.root.y()
        };
    } else {
        //The position is not outside of the element itself
    }
};

module.exports = {
    CENTER : CENTER ,
    SIMPLE : SIMPLE ,
    DEFAULT : CENTER,
    calculateDockingPosition : calculateDockingPosition,
    checkOrientationBoundary : checkOrientationBoundary
};
},{"../util/util":73}],18:[function(require,module,exports){
var util = require('../util/util');
var config = require('../core/config');

var object = util.object;
var DEF_TOLERANCE = 10;

var Alignment = function(tolerance, dimension) {
    this.dimension = dimension;
    this.tolerance = tolerance;
    this.actualD = 0;
};

Alignment.prototype.check = function(source, sourceIndexArr,target, d) {
    if(this.checkRange(source, target, d)) {
        // We keep the source position for the realignment
        if(!this.wasAligned) {
            this.source = source;
            this.sourceIndex = sourceIndexArr;
        }
        // Calculate d between target and source before drag
        this.d = (target[this.dimension] - (source[this.dimension]));
        this.target = target;
        // Keep track of the actual drag while beeing aligned for the realign
        this.actualD += d;
    }
};

Alignment.prototype.checkRange = function(source, target, d) {
    //Check if the difference between source (after drag) and target is within the tolerane
    return util.math.checkRangeDiff(target[this.dimension], (source[this.dimension] + this.actualD + d), this.tolerance);
};

Alignment.prototype.realign = function(alignConfig, d) {
    // We just have to calculate the realignment if an alignment was set
    var result;
    if(this.wasAligned) {
        //Now we retrieve the current position of the aligned source by our sourceIndex
        var currentSourcePosition = alignConfig[this.sourceIndex[0]].source[this.sourceIndex[1]];
        result = (this.source[this.dimension] + this.actualD + d) - currentSourcePosition[this.dimension];
    } else {
        result = d;

    }
    this.actualD = 0;
    return result;
};

Alignment.prototype.reset = function(initialize) {
    if(!initialize) {
        this.wasAligned = this.isAligned();
    } else {
        this.wasAligned = false;
    }

    delete this.target;
    delete this.d;
};

Alignment.prototype.isAligned = function() {
    return object.isDefined(this.target);
};

var DragAlignment = function(diagram, getConfig, tolerance) {
    this.diagram = diagram;
    this.tolerance = tolerance || DEF_TOLERANCE;
    this.getConfig = getConfig;
    this.alignX = new Alignment(this.tolerance, 'x');
    this.alignY = new Alignment(this.tolerance, 'y');
    this.actualDrag = {x:0, y:0};
};

DragAlignment.prototype.check = function(dx, dy) {
    var result;
    if(config.val('dragAlign', true) && !this.diagram.isMultiSelection()) {
        var that = this;

        // Reset the alignments to notify a new search loop
        this.alignX.reset();
        this.alignY.reset();

        var alignmentConfig = this.getConfig(dx, dy);
        object.each(alignmentConfig, function(configIndex, value) {
            var sourceArr = value.source;
            var targetArr = value.target;
            object.each(sourceArr, function(sourceIndex, value) {
                that.checkAlignment(value, targetArr, [configIndex, sourceIndex], dx, dy);

                if(that.alignX.isAligned() && that.alignY.isAligned()) {
                    return false; //Escape the each loop since we found both alingments
                }
            })
        });

        result = {
            dx : (this.alignX.isAligned()) ? this.alignX.d : this.alignX.realign(alignmentConfig, dx),
            dy : (this.alignY.isAligned()) ? this.alignY.d : this.alignY.realign(alignmentConfig, dy)
        };
    } else {
        this.alignX.reset(true);
        this.alignY.reset(true);
        result = {dx : dx, dy : dy};
    }

    return result;
};

DragAlignment.prototype.checkAlignment = function(source, targets, sourceIndexArr, dx, dy) {
    var that = this;
    object.each(targets, function(index, target) {
        if(!that.alignX.isAligned()) {
            that.alignX.check(source,sourceIndexArr, target, dx);
        }

        if(!that.alignY.isAligned()) {
            that.alignY.check(source,sourceIndexArr, target, dy);
        }

        if(that.alignX.isAligned() && that.alignY.isAligned()) {
            return false; //Escape the each loop since we found both alingments
        }
    });
}

DragAlignment.prototype.reset = function() {
    this.alignX.reset(true);
    this.alignY.reset(true);
};

DragAlignment.prototype.isAligned = function() {
    return this.alignX.isAligned || this.alignY.isAligned();
};

module.exports = DragAlignment;


},{"../core/config":6,"../util/util":73}],19:[function(require,module,exports){
require('../svg/draggable');
var util = require('../util/util');
var DragAlignment = require('./dragAlignment');
var Node = require('./node');

var dom = util.dom;
var object = util.object;

var lastDrag;

var DragContext = function(node, cfg) {
    this.cfg = cfg || {};
    this.node = node;
    this.dxSum = 0;
    this.dySum = 0;
};

DragContext.prototype.dragStart = function(evt) {
    this.dxSum = 0;
    this.dySum = 0;
    this.from = this.node.position();
    delete this.to;
    if(this.cfg.dragStart) {
        this.cfg.dragStart(evt);
    }
};

DragContext.prototype.wasMoved = function(evt) {
    return this.dxSum > 0 || this.dySum > 0;
};

DragContext.prototype.dragMove = function(evt, dx, dy) {
    this.dxSum += dx;
    this.dySum += dy;
    if(this.cfg.dragMove) {
        this.cfg.dragMove(evt, dx,dy);
    }
};

DragContext.prototype.dragEnd = function(evt) {
    if(this.dxSum != 0 || this.dySum != 0) {
        this.to = this.node.position();
        if (this.cfg.dragEnd) {
            this.cfg.dragEnd(evt);
        }
    }
};

DragContext.prototype.clone = function() {
    return {
        dxSum : this.dxSum,
        dySum : this.dySum,
        from : this.from,
        to : this.to
    }
};

Node.prototype.draggable = function(cfg) {
    cfg = cfg || {};
    var that = this;
    this.dragContext = new DragContext(this, cfg);

    var dragConfig = {
        cursor: 'all-scroll',
        dragStart: function(evt) {
            that.dragContext.dragStart(evt);
            lastDrag = that.dragContext;
            that.exec('dragStart', [evt]);
        },
        dragMove : function(evt, dx , dy) {
            that.dragContext.dragMove(evt, dx, dy);
            //that.exec('dragMove', [dx,dy, evt]);
            //We skip the the domEvent dragMove here cause of performance...
            that.exec('dragMove', [dx,dy, evt], true);

        },
        dragEnd : function(evt) {
            if(that.dragContext.wasMoved()) {
                that.dragContext.dragEnd(evt);
                that.exec('dragEnd', [evt]);
            }
        },
        getScale: function() {
            return that.diagram.scale;
        },
        restrictionX : cfg.restrictionX,
        restrictionY : cfg.restrictionY,
        cursor : cfg.cursor
    };

    if(!cfg.preventAlignment) {
        var dragAlignment;
        if(cfg.dragAlignment) {
            dragAlignment = (cfg.dragAlignment instanceof DragAlignment)
                ? cfg.dragAlignment : new DragAlignment(this.diagram, cfg.dragAlignment);
        } else {
            dragAlignment = new DragAlignment(that.diagram,
                function() {
                    var alignments = that.getTransitionAlignmentTargets();
                    alignments.push({source:[that.getCenter()], target:that.getNodeAlignmentTargets()});
                    return alignments;
                });
        }
        dragConfig.dragAlignment = dragAlignment;
    }


    this.root.draggable(dragConfig, this.getDragElement());

    //Simulates an drag start event
    this.initDrag = this.root.initDrag;

    //For manual dragging a svg element the triggerEvent is used to identify this event was triggered manually
    this.triggerDrag = this.root.triggerDrag;

    return this;
};

Node.prototype.getTransitionAlignmentTargets = function() {
    return this.additions.transition.getTransitionAlignmentTargets();
};

Node.prototype.getNodeAlignmentTargets = function() {
    var result = [];
    var that = this;

    object.each(this.diagram.getNodes(), function(key, node) {
        if(node.id !== that.id && !node.knob) {
            result.push(node.getCenter());
        }
    });

    return result;
};

Node.prototype.getDragElement = function() {
    //TODO: we have to use the [class~=bla] selector since ie, edge (who else) throwing errors for .class selectors in jquery
    //this may change in following jqery versions.
    return dom.findIncludeSelf(this.getRootSVG().instance(), '[class~='+this.getNodeSelector('dragRoute_')+']');
};

module.exports = {
    getLastDrag : function() {
        return lastDrag;
    }
}


},{"../svg/draggable":50,"../util/util":73,"./dragAlignment":18,"./node":27}],20:[function(require,module,exports){
var util = require('../util/util');
var AbstractEditAddition = require('./abstractEditAddition');

var editFunctions = {
    stroke : 'stroke',
    'stroke-width' : 'strokeWidth',
    'stroke-dash' : 'strokeDashType',
    color : 'fill',
    text : {
        get : function(editItem) {
            return $(this.node.getNodeSelector(editItem.bind)).text();
        },
        set : function(editItem, value) {
            $(this.node.getNodeSelector(editItem.bind)).text(value);
        }
    },
    textarea : {
        get : function(editItem) {
            return this.getTextAreaContent(this.node.getNodeSelector(editItem.bind));
        },
        set : function(editItem, value) {
            var $editSVGNode = $(this.node.getNodeSelector(editItem.bind));
            this.setTextAreaContent($editSVGNode,value);
        }
    },
    'text-size' : {
        get : function(editItem) {
            var definition = this.node.getInnerSVG(editItem.bind).style('font-size');
            if(definition) {
                return definition.substring(0, definition.length - 2);
            }
        },
        set : function(editItem, value) {
            this.node.getInnerSVG(editItem.bind).style('font-size', value+'px');
        }
    }
};

var EditNodeAddition = function(node) {
    AbstractEditAddition.call(this, node, editFunctions, node.config.edit);
    this.node = node;
};

util.inherits(EditNodeAddition, AbstractEditAddition);

EditNodeAddition.prototype.onSetValue = function() {
    this.node.event.trigger('node_edit', this.node);
};

EditNodeAddition.requireConfig = true;

module.exports = EditNodeAddition;
},{"../util/util":73,"./abstractEditAddition":10}],21:[function(require,module,exports){
var util = require('../util/util');
var AbstractEditAddition = require('./abstractEditAddition');

var EditTransitionAddition = function(transition) {
    AbstractEditAddition.call(this, transition, editFunctions, config);
    this.transition = transition;
};

util.inherits(EditTransitionAddition, AbstractEditAddition );

var editFunctions = {
    stroke : {
        get : function(editItem) {
            return this.transition.line.stroke();
        },
        set : function(binding, value) {
            this.transition.line.stroke(value);
        }
    },
    'stroke-width' : {
        get : function(editItem) {
            return this.transition.strokeWidth();
        },
        set : function(binding, value) {
            this.transition.strokeWidth(value);
        }
    },
    'stroke-dash' : {
        get : function(editItem) {
            return this.transition.line.strokeDashType();
        },
        set : function(editItem, value) {
            this.transition.line.strokeDashType(value);
        }
    },
    text : {
        get : function(editItem) {
            return $(this.transition.getTransitionSelector(editItem.bind)).text();
        },
        set : function(editItem, value) {
            $(this.transition.getTransitionSelector(editItem.bind)).text(value);
        }
    },
    textarea : {
        get : function(editItem) {
            return this.getTextAreaContent(this.transition.getTransitionSelector(editItem.bind));
        },
        set : function(editItem, value) {
            var $editSVGNode = $(this.transition.getTransitionSelector(editItem.bind));
            this.setTextAreaContent($editSVGNode,value);
        }
    },
    'text-size' : {
        get : function(editItem) {
            var definition = this.transition.getInnerSVG(editItem.bind).style('font-size');
            if(definition) {
                return definition.substring(0, definition.length - 2);
            }
        },
        set : function(editItem, value) {
            this.transition.getInnerSVG(editItem.bind).style('font-size', value+'px');
        }
    },
    'type' : {
        get : function(editItem) {
            return this.transition.type();
        },
        set : function(editItem, value) {
            this.transition.type(value);
            this.transition.group.dala('transitionType', value);
        }
    },
    'startMarker' : {
        get : function(editItem) {
            return this.transition.startMarkerValue();
        },
        set : function(editItem, value) {
            value = value || '';
            this.transition.startMarker(value);
        }
    },
    'endMarker' : {
        get : function(editItem) {
            return this.transition.endMarkerValue();
        },
        set : function(editItem, value) {
            value = value || '';
            this.transition.endMarker(value);
        }
    }
};

var config = {
    'text0' : {type : 'text', bind : 'text0', trigger : 'text0'},
    'text1' : {type : 'text', bind : 'text1', trigger : 'text1'},
    'text2' : {type : 'text', bind : 'text2', trigger : 'text2'},
    'text3' : {type : 'text', bind : 'text3', trigger : 'text3'},
    'text4' : {type : 'text', bind : 'text4', trigger : 'text4'},
    'text5' : {type : 'text', bind : 'text5', trigger : 'text5'},
    'type'  : {type : 'type', bind : 'line'},
    'transition' : { type : 'stroke', bind : 'line'},
    'startMarker' : { type : 'startMarker', bind : 'line'},
    'endMarker' : { type : 'endMarker', bind : 'line'}
};

module.exports = EditTransitionAddition;
},{"../util/util":73,"./abstractEditAddition":10}],22:[function(require,module,exports){
var Helper = function(diagram) {
    this.diagram = diagram;
    this.points = {};
};

Helper.prototype.point = function(id, p, color, prevText) {
    color = color || 'red';
    var text = id+'(x:'+p.x + ' y:'+p.y+')';
    if(!this.points[id]) {
        var point = this.diagram.svg.circle({
            r:2,
            style:'fill:'+color
        });
        var t = this.diagram.svg.text(text);
        var group = this.diagram.svg.g({id:'helper_'+id}, t, point);
        this.points[id] = {
            group : group,
            text : t,
            point : point
        }

        if(prevText) {
            t.hide();
        }
    }

    this.points[id].point.moveTo(p);
    this.points[id].text.$().text(text);
    this.points[id].text.moveTo(p);
};

module.exports = Helper;

},{}],23:[function(require,module,exports){
var object = require('../util/object');
var SVGShape = require('../svg/genericShape');
var event = require('../core/event');

SVGShape.prototype.hoverable = function(handler) {
    if(object.isBoolean(handler)) {
        this.hoverFlag = handler;
        return;
    } else {
        handler = handler || {};
        this.hoverFlag = true;
    }

    handler = handler || {};
    var that = this;

    this.on('mouseenter', function(evt) {
        if(that.hoverFlag) {
            that.hovered = true;
            event.trigger('element_hoverIn', that);
            if (handler.in) {
                handler.in.apply(that, [evt]);
            }
        }
    });

    this.on('mouseleave', function(evt) {
        if(that.hoverFlag) {
            that.hovered = false;
            event.trigger('element_hoverOut', that);
            if (handler.out) {
                handler.out.apply(that, [evt]);
            }
        }
    });

    return this;
};
},{"../core/event":7,"../svg/genericShape":53,"../util/object":71}],24:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"../dom/dom":44,"../svg/transform":63,"../util/app":68,"../util/object":71,"dup":9}],25:[function(require,module,exports){
var object = require('../util/object');

var KnobManager = function(diagram) {
    this.knobs = [];
    this.hideDocking = false;
    this.diagram = diagram;
    this.templateMgr = diagram.templateMgr;
    diagram.event.listen('knob_added', this.addKnobListener, this);
    diagram.event.listen('knob_delete', this.deleteKnobListener, this);
};

KnobManager.prototype.addKnobListener = function(evt) {
    if(evt.data) {
        this.knobs.push(evt.data);
    }
};

KnobManager.prototype.createKnobNode = function(p, group, cfg) {
    var knobId = this.diagram.uniqueId();
    var config = object.extend({node_id:'docking_'+knobId, x: p.x, y: p.y, type:'circle'}, cfg);
    var tmpl_id = 'knob_'+config.type.toLowerCase();
    var node = this.templateMgr.getTemplateSync(tmpl_id).createNode(config, this.diagram).init();
    if(group) {
        this.diagram.svg.addToGroup(group, node.root);
    }
    return node;
};

KnobManager.prototype.deleteKnobListener = function(evt) {
    if(object.isDefined(evt.data)) {
        var index = this.knobs.indexOf(evt.data);
        if(index > -1) {
            this.knobs.splice(index, 1);
        }
        evt.data.remove();
    }
};

KnobManager.prototype.hideKnobs = function() {
    this.hideDocking = true;
    this.executeOnAllKnobs(function(knob) {
        knob.hide();
    });
};

KnobManager.prototype.showKnobs = function() {
    this.hideDocking = false;
    this.executeOnAllKnobs(function(knob) {
        knob.show();
    });
};

KnobManager.prototype.executeOnAllKnobs = function(func) {
    object.each(this.knobs, function(index, knob) {
        func(knob);
    });
}

module.exports = KnobManager;

},{"../util/object":71}],26:[function(require,module,exports){
require('./template');
require('./node');
var object = require('../util/object');

var templateMgr = require('./templateManager');

var defaultConfig = {
    dockingType: "CENTER",
    fill: "silver",
    'fill-active': 'green',
    'fill-opacity': '0.5',
    radius: 5,
    stroke: '#7C7C7C',
    'stroke-width': '1',
    'cssClass': 'knob',
    preventSelection: true
};

var circleConfig = object.extend({}, defaultConfig,
    {
        rootName: 'circle',
        svg :'<circle cx="0" cy="0" r="{radius}" id="{node_id}" class="{cssClass}" style="stroke-width:{stroke-width};stroke:{stroke};fill:{fill};fill-opacity:{fill-opacity};" transform="translate({x} {y})"></circle>'
    });

templateMgr.registerTemplate('knob_circle', circleConfig);

var rectConfig = object.extend({}, defaultConfig,
    {
        rootName: 'rect',
        svg :'<rect x="0" y="0" id="{node_id}" height="{size}" width="{size}" class="{cssClass}" style="stroke-width:{stroke-width};stroke:{stroke};fill:{fill};fill-opacity:{fill-opacity};" transform="translate({x} {y})"></rect>'
    });

templateMgr.registerTemplate('knob_rect', rectConfig);
},{"../util/object":71,"./node":27,"./template":35,"./templateManager":36}],27:[function(require,module,exports){
/**
 * This class represents the nodes of a diagram. Every note has a unique ID and
 * a template defining the type of the node.
 */
var util = require('../util/util');
var dockingType = require('./docking');
var SVG = require('../svg/svg');
var nodeAdditions = require('./nodeAdditions');

var object = util.object;
var dom = util.dom;

/**
 * The constructor does not render a node to the stage. To render a node
 * the init method has to be called.
 */
var Node = function(tmpl, config, diagram) {
    this.config = config || {};
    this.diagram = diagram;
    this.isNode = true;
    this.event = diagram.event;
    this.id = config.node_id;
    this.template = tmpl;
    this.selectable = object.isDefined(this.config.selectable) ? this.config.selectable : true;
    this.visible = true;
};

/**
 * This method renders the node to the stage and initializes all event handlers
 * With the part argument we can import the node to another svg part than the default which is the main stage.
 * This is used for example for the defs (which is technically not a real node)
 *
 * @returns {Node_L7.Node.prototype}
 */
Node.prototype.init = function(part, prepend) {
    //ADD Element to stage
    this.diagram.import(this.template.getSVGString(this.config), part, prepend);
    return this.activate();
};

Node.prototype.getCorners = function() {
    var x = this.x();
    var y = this.y();
    var bottomy = this.getBottomY();
    var rightx = this.getRightX();
    return [
        {x:x,y:y},
        {x:rightx, y:y},
        {x:rightx, y:bottomy},
        {x:x,y:bottomy}
    ];
};

/**
 * Activates the the node and handler functions by means of the given config
 *
 * @returns itself
 */
Node.prototype.activate = function(nodeID) {

    if(nodeID) {
        this.id = this.config.node_id = nodeID;
    }

    //Note: there are some special node types without an nodeId like defs.
    if(this.id) {
        //The root element of the node, its supposed to be a group node in most cases
        this.root = $.svg('#'+this.id);
    }

    nodeAdditions.init(this);

    if(this.root) {
        this.initEventFunctions(this.config);
        this.root.attr({'dala:tmpl' : this.template.id});
    }

    this.exec('activate');
    return this;
};

Node.prototype.initEventFunctions = function() {
    var that = this;

    if(this.root.hoverable) {
        this.root.hoverable();
    }

    this.on('dblclick', function(evt) {
        that.exec('dbclick', [evt], true);
    });

    this.on('mousedown', function(evt) {
        if(!evt.ctrlKey && that.isVisible()) {
            evt.stopPropagation();
            that.exec('mousedown', [evt], true);
            if(!that.selected) {
                that.select();
            }
        }
    });
};

Node.prototype.isVisible = function() {
    return this.root.isVisible();
};

Node.prototype.hide = function() {
    this.root.hide();
};

Node.prototype.show = function(opacity) {
    this.root.show(opacity);
};

Node.prototype.index = function() {
    return this.root.$().index();
};

Node.prototype.firstChild = function() {
    //TODO: this should be cached to reduce dom calls !
    return this.root.firstChild();
};

Node.prototype.moveUp = function() {
    //We switch UP/Down here because the first node in the dom tree is the
    //last node (back) in the svg view.

    //TODO: as command event !
    this.root.up();
    this.exec('moveUp');
};

Node.prototype.moveDown = function() {
    //We switch UP/Down here because the first node in the dom tree is the
    //last node (back) in the svg view.

    //TODO: as command event !
    this.root.down();
    this.exec('moveDown');
};

Node.prototype.remove = function() {
    this.exec('remove');
    this.root.remove();
};

Node.prototype.moveTo = function(x, y) {
    this.root.moveTo(x, y);
    this.exec('moveTo');
};

Node.prototype.position = function(x,y) {
    return {
        x : this.x(),
        y : this.y()
    };
};

Node.prototype.getInnerSVG = function(prefix) {
    return $.qCache().svg(this.getNodeSelector(prefix));
};

Node.prototype.updateAdditions = function(type) {
    this.exec('update');
};

Node.prototype.addOutgoingTransition = function(value) {
    return this.additions.transition.addOutgoingTransition(value);
};

Node.prototype.removeOutgoingTransition = function(transition) {
    this.additions.transition.removeOutgoingTransition(transition);
};

Node.prototype.addIncomingTransition = function(transition) {
    this.additions.transition.addIncomingTransition(transition);
};

Node.prototype.removeIncomingTransition = function(transition) {
    this.additions.transition.removeIncomingTransition(transition);
};

Node.prototype.getRootSVG = function() {
    return this.root;
};

Node.prototype.instance = function() {
    if(object.isDefined(this.root)) {
        return this.root.instance();
    }
};

Node.prototype.selector = function(prefix) {
    if(object.isArray(prefix)) {
        var stringSelector = [];
        var that = this;
        object.each(prefix, function(index, val) {
            stringSelector.push(that.selector(val));
        });
        return stringSelector.join(', ');
    } else {
        return this.getNodeSelector(prefix);
    }
};

Node.prototype.getNodeSelector = function(prefix) {
    var result = '';

    if(!util.string.startsWith(prefix, '#') && !util.string.startsWith(prefix, '.')) {
        result = '#'+prefix;
    } else {
        result = prefix;
    }

    return util.string.endsWith(prefix, '_')
        ? result + this.id
        : result + '_' + this.id;
};

Node.prototype.getRootNode = function() {
    return this.root.getRootNode();
};

Node.prototype.exec = function(func, args, prevDomEvent) {
    args = args || this;
    this.executeAddition(func, args);
    if(this.root && !prevDomEvent) {
        this.trigger(func, args);
    }
};

Node.prototype.executeAddition = function(func, args) {
    object.each(this.additions, function(key, addition) {
        if(object.isDefined(addition) && object.isFunction(addition[func])) {
            addition[func].apply(addition, args);
        }
    });
};

Node.prototype.select = function(shifted) {
    this.selected = true;
    this.exec('select', [shifted]);
};

Node.prototype.deselect = function() {
    this.selected = false;
    this.exec('deselect');
};

Node.prototype.one = function(evt, handler) {
    this.root.$().one(evt, handler);
    return this;
};

Node.prototype.on = function(evt, handler) {
    this.root.$().on(evt, handler);
    return this;
};

Node.prototype.trigger = function(evt, args) {
    this.root.$().trigger(evt, args);
    return this;
};

Node.prototype.off = function(evt, handler) {
    this.root.$().off(evt, handler);
};

Node.prototype.extractNodeId = function(rawId) {
    var splitted = rawId.split('_');
    return splitted[splitted.length - 1];
};

Node.prototype.x = function() {
    return this.root.x();
};

Node.prototype.y = function() {
    return this.root.y();
};

Node.prototype.height = function() {
    return this.root.height();
};

Node.prototype.width = function() {
    return this.root.width();
};

Node.prototype.getRightX = function() {
    return this.root.getRightX();
};

Node.prototype.getBottomY = function() {
    return this.root.getBottomY();
};

Node.prototype.isLeftOf = function(mousePosition) {
    return mousePosition.x > (this.getRightX());
};

Node.prototype.isRightOf = function(mousePosition) {
    return mousePosition.x < (this.x());
};

Node.prototype.isOver = function(mousePosition) {
    return mousePosition.y > (this.getBottomY());
};

Node.prototype.overlays = function() {
    return this.root.overlays.apply(this.root, arguments);
    //return this.root.overlayCheck(mousePosition);
};

Node.prototype.isUnder = function(mousePosition) {
    return mousePosition.y < (this.getBottomY());
};

Node.prototype.getCenter = function() {
    return this.root.getCenter();
};

Node.prototype.getRelativeCenter = function() {
    return {
        x: this.width() / 2,
        y: this.height() / 2
    }
};

Node.prototype.getRelativePosition = function(pageX,pageY) {
    var p = util.math.getPoint(pageX,pageY);
    return {
        x: p.x - this.x(),
        y: p.y - this.y()
    };
};

/**
 * Determines the location of a given position relative to the node node.
 *
 * @param node
 * @param position
 * @returns {*}
 */
Node.prototype.getRelativeLocation = function(position) {
    return this.root.getRelativeLocation(position);
};

Node.prototype.getOrientation = function(relative) {
    if(!object.isDefined(relative)) {
        return this.getCenter();
    } else {
        return {
            x : this.x() + relative.x,
            y : this.y() + relative.y
        };
    }
};

module.exports = Node;
},{"../svg/svg":59,"../util/util":73,"./docking":17,"./nodeAdditions":28}],28:[function(require,module,exports){
var additions = require('./additions');

//Init default additions
additions.registerNodeAddition('resize', require('./resizeAddition'));
additions.registerNodeAddition('edit', require('./editNodeAddition'));
additions.registerNodeAddition('transition', require('./transitionAddition'));

module.exports = {
    init : function(node) {
        additions.initNodeAddition('transition', node);
        additions.initNodeAddition('edit', node);
        additions.initNodeAddition('resize', node);
    }
}
},{"./additions":13,"./editNodeAddition":20,"./resizeAddition":32,"./transitionAddition":38}],29:[function(require,module,exports){
require('./draggable');
require('./hoverable');

var util = require('../util/util');
var xml = require('../util/xml');
var event = require('../core/event');
var Node = require('./node');
var AbstractManager = require('./abstractManager');

var cache = require('../core/cache');
var object = util.object;
var dom = util.dom;

var EVT_CREATE = 'node_create';
var EVT_DELETE = 'node_delete';
var EVT_COPY = 'node_copy';

var EVT_RESIZED = 'node_resized';
var EVT_ADDED = 'node_added';
var EVT_SELECTED = 'node_selected';
var EVT_DESELECTED = 'node_deselected';
var EVT_REMOVED = 'node_removed';

var CMD_ADD = 'node_add';
var CMD_DELETE = 'node_delete';
var CMD_COPY = 'node_copy';
var CMD_DROP = 'node_drop';
var CMD_RESIZE = 'node_resize';
var CMD_EDIT = 'node_edit';

var NodeManager = function(diagram) {
    // Contains all nodes added to the diagram
    AbstractManager.call(this, diagram);
    this.nodes = {};

    this.selectionMgr = diagram.selectionMgr;
    this.templateMgr = diagram.templateMgr;

    this.listen(EVT_CREATE, this.createNodeListener);
    this.listen(EVT_DELETE, this.deleteNodeListener);
    this.listen(EVT_COPY, this.copyNodeListener);
    this.listen(EVT_RESIZED, this.resizeNodeListener);

    this.command(CMD_ADD, this.createNode, this.deleteNode);
    this.command(CMD_DELETE, this.deleteNode, this.importNode);
    this.command(CMD_COPY, this.importNode, this.deleteNode);
    this.command(CMD_DROP, this.moveNode, this.moveNode);
    this.command(CMD_RESIZE, this.resizeNode, this.resizeNode);
    this.command(CMD_EDIT, this.editNode, this.undoEdit);
};

util.inherits(NodeManager, AbstractManager);

NodeManager.prototype.createNodeListener = function(evt) {
    try {
        var stagePosition = this.diagram.getStagePosition(evt);
        this.createNodeCommand(evt.data, stagePosition);
    } catch(err) {
        console.error(err);
        event.trigger('error', 'Error occured while creating node !');
    }
};

NodeManager.prototype.createNodeCommand = function(tmpl, config) {
    config = config || {};

    if(!tmpl) {
        event.trigger('warn', 'Could not create Node: No template selected!');
        return;
    }

    config.node_id = this.diagram.uniqueId();
    config.diagramId = this.diagram.id;
    return this.exec(CMD_ADD, [tmpl, config], [config.node_id]);
};

NodeManager.prototype.createNode = function(tmpl, config) {
    var that = this;
    var node = tmpl.createNode(config, this.diagram).init();
    if(!config.preventDrag) {
        node.draggable();
        node.on('select', function() {
            that.event.trigger(EVT_SELECTED, node);
        }).on('deselect', function() {
            that.event.trigger(EVT_DESELECTED, node);
        }).on('remove', function() {
            that.event.trigger(EVT_REMOVED, node);
        }).on('edit', function(evt, key, value, oldValue) {
            that.addCmd(CMD_EDIT, [node.id, key, value], [node.id, key, oldValue]);
        }).on('dragEnd', function() {
            //We just add the command since we don't want to execute the drag twice
            that.addCmd(CMD_DROP,
                [node.id, node.dragContext.dxSum, node.dragContext.dySum],
                [node.id, (-1 * node.dragContext.dxSum), (-1 * node.dragContext.dySum)]);
        });
    }
    this.addNode(node);
    return node;
};

NodeManager.prototype.addNode = function(node) {
    this.nodes[node.id] = node;
    this.event.trigger(EVT_ADDED, node);
};


NodeManager.prototype.activateByDomNode = function(domNode) {
    var attributes = dom.getAttributes(domNode);
    var that = this;
    return new Promise(function(resolve, reject) {
        var tmpl = that.templateMgr.getTemplate(attributes['dala:tmpl'])
            .then(function (tmpl) {
                resolve(that.activate(attributes['id'], tmpl));
            }, reject);
    });
};

NodeManager.prototype.activate = function(elementId, tmpl) {
    var node = tmpl.createNode({}, this.diagram)
        .activate(elementId)
        .draggable();

    this.addNode(node);
    return node;
};

NodeManager.prototype.deleteNodeListener = function(evt) {
    try {
        var node = this.getNode(evt.data);
        if(node.knob) {
            //CMD is handled by transitionMgr
            node.remove();
        } else if(node) {
            return this.exec(CMD_DELETE, [node.id], [this.getNodeAsString(node)]);
        }
    } catch(err) {
        console.error(err);
        event.trigger('error', 'Could not delete node('+node.id+')');
    }
};

NodeManager.prototype.deleteNode = function(node) {
    node = this.getNode(node);
    if(node) {
        node.remove();
        delete this.nodes[node.id];
        cache.clearBySuffix(node.id);
    } else {
        console.warn('delete node was called for unknown node');
    }
};

NodeManager.prototype.importNode = function(nodeStr, cfg) {
    cfg = cfg || {};

    //If set we replace the old node id with a new one e.g. when we copy a node
    if(cfg.newId && cfg.oldId) {
        nodeStr = nodeStr.replace(new RegExp(cfg.oldId, 'g'), cfg.newId);
    }

    //Insert to dom and activate the new node
    var targetInstance = this.diagram.import(nodeStr);
    var node = this.diagram.activateNode(targetInstance);

    //If set we move the new node to a given position
    if(cfg.mouse) {
        var stagePosition = this.diagram.getStagePosition(cfg.mouse);
        node.moveTo(stagePosition.x, stagePosition.y);
    }
};

NodeManager.prototype.getNodeAsString = function(node) {
    node = this.getNode(node);
    return xml.serializeToString(node.instance());
};

NodeManager.prototype.copyNodeListener = function(evt) {
    try {
        var node = this.getNode(evt.data);
        if(object.isDefined(node)) {
            var nodeStr = this.getNodeAsString(node);
            var newNodeId = Date.now();
            return this.exec(CMD_COPY, [nodeStr,
                {
                    mouse : evt.mouse,
                    oldId : node.id,
                    newId : newNodeId
                }], [newNodeId]);
        }
    } catch(err) {
        console.log(err);
        event.trigger('error', 'Could not copy node !');
    }
};

NodeManager.prototype.moveNode = function(node, dxSum, dySum) {
    node = this.getNode(node);
    if(node) {
        node.triggerDrag(dxSum, dySum);
    }
};

/**
 * TODO: listen through node event !
 * @param evt
 */
NodeManager.prototype.resizeNodeListener = function(evt) {
    try {
        var node = evt.data;
        if(node) {
            var resizeInstance = node.additions.resize.get();
            this.addCmd(CMD_RESIZE,
                [node.id, resizeInstance.dx, resizeInstance.dy, resizeInstance.knob],
                [node.id, (-1*resizeInstance.dx), (-1*resizeInstance.dy), resizeInstance.knob]);
        }
    } catch(err) {
        console.log(err);
    }
};

NodeManager.prototype.resizeNode = function(node, dx, dy, knob) {
    node = this.getNode(node);
    if(node) {
        node.additions.resize.get().resize(dx,dy,knob);
    } else {
        console.warn('resizeNode was for unknown node :'+node.toString());
    }
};

NodeManager.prototype.getNode = function(id) {
    if(object.isString(id) && !isNaN(id)) {
        return this.nodes[parseInt(id)];
    } else if(!isNaN(id)) {
        return this.nodes[id];
    } else if(id instanceof Node) {
        //We assume a node instance
        return id;
    } else {
        console.warn('getNode call with no result for :'+id);
    }
};

NodeManager.prototype.getNodes = function(filter) {
    if(!filter) {
        return object.toArray(this.nodes);
    } else {
        var result = [];
        object.each(this.nodes, function(key, value) {
            if(filter(value)) {
                result.push[value];
            }
        });
        return result;
    }
};

NodeManager.prototype.editNode = function(node, editKey, newValue) {
    node = this.getNode(node);
    node.additions.edit.setValue(editKey, newValue);
};

NodeManager.prototype.undoEdit = function(node, editKey, newValue) {
    node = this.getNode(node);
    node.additions.edit.setValue(editKey, newValue);
};

NodeManager.prototype.clear = function() {
    this.nodes = {};
};

module.exports = NodeManager;
},{"../core/cache":2,"../core/event":7,"../util/util":73,"../util/xml":74,"./abstractManager":11,"./draggable":19,"./hoverable":23,"./node":27}],30:[function(require,module,exports){
var config = require('../core/config');
var CurvePathManager = require('./curvedPathManager');
var StraightPathManager = require('./straightPathManager');
var pathManager = {};

var register =   function(constructor) {
    pathManager[constructor.type] = constructor;
};

register(CurvePathManager);
register(StraightPathManager);

module.exports =  {
    register : register,
    get : function(transition, id) {
        id = id || config.val('transition_type', StraightPathManager.type);
        if(pathManager[id]) {
            return new pathManager[id](transition);
        }
    }
};
},{"../core/config":6,"./curvedPathManager":15,"./straightPathManager":34}],31:[function(require,module,exports){
var util = require('../util/util');
var event = require('../core/event');
var Command = require('../core/command');
var Transform = require('../svg/transform');
var SVG = require('../svg/svg');
var DragConfig = require('../svg/dragConfig');
var Knob = require('./knob');

var object = util.object;
var dom = util.dom;

// Used to identify the different knobs from north west clockwise
var KNOB_NW = 0;
var KNOB_N = 1;
var KNOB_NE = 2;
var KNOB_E = 3;
var KNOB_SE = 4;
var KNOB_S = 5;
var KNOB_SW = 6;
var KNOB_W = 7;


// specifies the space between node and resize knob
var DIF = 3;

// specifies the size of a knob
var SIZE = 5;

// used for calculating the position of the knobs
var DIF_REL = DIF + SIZE;

var Resize = function(node, diagram) {
    this.diagram = diagram;
    this.event = diagram.event;
    this.knobs = [];
    this.node = node;
    this.config = this.node.template.config.resize;
};

/**
 * Renders the knobs around the node.
 */
Resize.prototype.activateKnobs = function() {
    var positions = this.calculateKnobPosition();

    var translX = this.node.x() - DIF_REL;
    var translY = this.node.y() - DIF_REL;
    this.group = this.diagram.svg.g({}).translate(translX, translY);

    //Initialize the different knobs with different drag restricitons
    this.createKnob(KNOB_NW,positions[KNOB_NW],new DragConfig());
    this.createKnob(KNOB_N, positions[KNOB_N],new DragConfig().yOnly());
    this.createKnob(KNOB_NE,positions[KNOB_NE],new DragConfig());
    this.createKnob(KNOB_E, positions[KNOB_E],new DragConfig().xOnly());
    this.createKnob(KNOB_SE,positions[KNOB_SE],new DragConfig());
    this.createKnob(KNOB_S, positions[KNOB_S], new DragConfig().yOnly());
    this.createKnob(KNOB_SW,positions[KNOB_SW],new DragConfig());
    this.createKnob(KNOB_W, positions[KNOB_W],new DragConfig().xOnly());


};

/**
 * Renders a knob to the given position and configures the drag and hover
 * logic. The total drag amount of one drag is can be acessed through
 * this.dx and this.dy.
 */
Resize.prototype.createKnob = function(knob, p, dragCfg) {
    var that = this;
    // Initialize draglogic
    var dragHook = dragCfg
        .dragStart(function(evt) {
            that.dx = 0;
            that.dy = 0;
            that.dragKnob = knob;
        })
        .dragMove(function(evt, dx, dy) {
            //We keep track of the total drag movement
            that.dx += dx;
            that.dy += dy;
            that.resize(dx,dy);
        })
        .dragEnd(function(evt) {
            that.event.trigger('node_resized', that.node);
        })
        .getScale(function() {
            return that.diagram.scale;
        }).get();

    dragHook.preventAlignment = true;

    // Render the knob on stage
    this.knobs[knob] = new Knob(this.diagram, p, {type:'rect', fill:'black', stroke:'none', selectable:false, 'stroke-width':0, size:SIZE, 'fill-opacity':1}, this.group)
        .draggable(dragHook).hoverable();
};

/**
 * Determines all svg elements participating in the resize process, which
 * are configured in the resize config bind attribute
 */
Resize.prototype.getResizeElements = function() {
    var result = [];
    var that = this;
    object.each(this.config, function(index, value) {
        var svgSelector = that.node.getNodeSelector(value.bind);
        result[index] = $.qCache().svg(svgSelector);
    });
    return result;
};

/**
 * Updates the resize logic
 */
Resize.prototype.update = function() {
    this.resize(0,0);
};

/**
 * Resizes the node by applying the configured resize logic to the inner
 * svg elements of the nodes. The dx and dy values specifie the resize
 * amount of the x- and y-axis. After the actual resize process the knobs
 * are aligned to the new node dimension.
 */
Resize.prototype.resize = function(dx, dy) {
    this.updateNodes(dx,dy);
    this.updateKnobs(true);
};

/**
 * Aligns a single knob to the
 * @param {type} resizeKnob
 * @returns {undefined}
 */
Resize.prototype.updateKnobs = function(resizeKnob) {
    if(object.isDefined(this.group)) {
        if(object.isDefined(resizeKnob) && resizeKnob) {
            var positions = this.calculateKnobPosition();

            this.knobs[KNOB_NW].moveTo(positions[KNOB_NW]);
            this.knobs[KNOB_N].moveTo(positions[KNOB_N]);
            this.knobs[KNOB_NE].moveTo(positions[KNOB_NE]);
            this.knobs[KNOB_E].moveTo(positions[KNOB_E]);
            this.knobs[KNOB_SE].moveTo(positions[KNOB_SE]);
            this.knobs[KNOB_S].moveTo(positions[KNOB_S]);
            this.knobs[KNOB_SW].moveTo(positions[KNOB_SW]);
            this.knobs[KNOB_W].moveTo(positions[KNOB_W]);
            this.node.exec('resize');
        } else {
            //If the flag is not set we just do an update probably from simple node drag/drop
            var translX = this.node.root.getTransformation().translate().x - DIF_REL;
            var translY = this.node.root.getTransformation().translate().y - DIF_REL;
            this.group.translate(translX, translY);
        }
    }
};

Resize.prototype.calculateKnobPosition = function() {
    var rightX = SIZE + (DIF*2) + this.node.width();
    var centerX = rightX / 2;
    var bottomY = SIZE + (DIF*2) + this.node.height();
    var centerY = bottomY / 2;

    var result = [];
    result[KNOB_NW] = {x:0, y:0};
    result[KNOB_N] = {x:centerX, y:0};
    result[KNOB_NE] = {x:rightX, y:0};
    result[KNOB_E] = {x:rightX, y:centerY};
    result[KNOB_SE] = {x:rightX, y:bottomY};
    result[KNOB_S] = {x:centerX, y:bottomY};
    result[KNOB_SW] = {x:0, y:bottomY};
    result[KNOB_W] = {x:0, y:centerY};
    return result;

};

Resize.prototype.removeKnobs = function() {
    if(object.isDefined(this.group)) {
        this.group.remove();
    }
    delete this.group;
};

Resize.prototype.updateNodes = function(dx,dy) {
    var that = this;
    if(!object.isDefined(this.resizeElements)) {
        this.resizeElements = this.getResizeElements();
    }

    object.each(this.resizeElements, function(index, element) {
        that.updateNode(index,element,dx,dy);
    }) ;
};

Resize.prototype.updateNode = function(index, element, dx, dy) {
    dx = (!object.isDefined(dx))? 0 : dx;
    dy = (!object.isDefined(dy))? 0 : dy;

    var elementConfig = this.config[index];
    if(object.isDefined(elementConfig.value)) {
        if(elementConfig.value[0].type !== 'vertical') {
            this.setResize(element, elementConfig, elementConfig.value[0], dx, 'width');
        }
        //We just set one dimension for a circle
        if(elementConfig.value[0].type !== 'circle' || this.dragKnob === KNOB_S || this.dragKnob === KNOB_N) {
            this.setResize(element,elementConfig, elementConfig.value[1], dy, 'height');
        }
    }

    if(object.isDefined(elementConfig.min)) {
        this.alignValueLimit(element, elementConfig.min[0], 'width', 'min');
        this.alignValueLimit(element, elementConfig.min[1], 'height', 'min');
    }

    if(object.isDefined(elementConfig.max)) {
        this.alignValueLimit(element, elementConfig.max[0], 'width', 'max');
        this.alignValueLimit(element, elementConfig.max[1], 'height', 'max');
    }

    if(object.isDefined(elementConfig.position)) {
        this.alignPosition(element, elementConfig);
    }
};

Resize.prototype.setResize = function(svgElement, elementConfig, setting, d, dimension) {
    switch(setting.type) {
        case 'static':
        case 'none':
            break;
        case 'vertical':
            var newY = parseInt(svgElement.attr('y2')) + d;
            svgElement.attr('y2', newY);
        case 'parent':
            //We could check the resize settings of the parent if this is static
            //we do not have to change anything when resizing.
            svgElement[dimension](1);

            //Get the dimension from parent node
            var parentVal = svgElement.$().parent().get(0).getBBox()[dimension];
            svgElement[dimension](parentVal + setting.value);
            break;
        default:
            var currentVal = svgElement[dimension](false) ;
            var newValue = (currentVal + d);
            if(newValue > 0) {
                svgElement[dimension]((currentVal + d));
            }
            break;
    }
};

Resize.prototype.alignValueLimit = function(svgElement, setting, dimension, type) {
    var value = setting.type;
    var limit;

    if(value === 'parent') {
        limit = svgElement.$().parent()[0].getBBox()[dimension];
    } else if(!isNaN(value)) {
        limit = parseInt(value);
    } else if(util.string.startsWith(value, '#')) {
        limit = $.qCache(this.node.getNodeSelector(value))[0].getBBox()[dimension];
    } else {
        return;
    }

    if(object.isDefined(setting.value)) {
        limit += setting.value;
    }

    var currentVal = svgElement[dimension](false)
    if((type === 'min' && currentVal < limit) || (type === 'max' && currentVal > limit)) {
        svgElement[dimension](limit);
    }
};

Resize.prototype.alignPosition = function(svgElement, elementConfig) {
    //var setting = elementConfig.
    //TODO: set alignElement id in config !
    var x = this.getAlignedPosition(svgElement,elementConfig.position[0], elementConfig.alignto, 'width' , 'x');
    var y = this.getAlignedPosition(svgElement,elementConfig.position[1], elementConfig.alignto, 'height', 'y');

    if(object.isDefined(x)) {
        svgElement.moveX(x);
    }

    if(object.isDefined(y)) {
        svgElement.moveY(y);
    }
};

Resize.prototype.getAlignedPosition = function(svgElement, settings, alignto, dimension, dimensionCoord) {
    switch(settings.type) {
        case 'none':
            break;
        case 'center':
            var alignSVG = this.getAlignElement(alignto, svgElement);
            if(object.isDefined(alignSVG)) {
                var alignVal = alignSVG.getCenter()[dimensionCoord];
                return alignVal - (svgElement[dimension]() / 2) - settings.value;
                //return (alignVal - svgElement[dimension]()) / 2 + settings.value;
            };
            break;
        case 'relative':
            var $prevNode = svgElement.$().prev();
            if($prevNode.length) {
                var prevSVG = $.qCache().svg($prevNode);
                var prevVal = prevSVG[dimension]();
                var prevCoord = prevSVG[dimensionCoord]();
                return (prevCoord + prevVal) + settings.value;
            } else {
                //No prev sibling
                return 0;
            };
            break;
        case 'right':
        case 'bottom':
            var alignSVG = this.getAlignElement(alignto, svgElement);
            if(object.isDefined(alignSVG)) {
                var alignVal = (settings.type === 'right')? alignSVG.getRightX():alignSVG.getBottomY();
                return (alignVal - svgElement[dimension]()) - settings.value;
            };
            break;
        default:
            return;
    }
};

Resize.prototype.getAlignElement = function(alignto, svgElement) {
    var elementToAlign;
    //The alignto setting can be the parent-, root- or an explicit element default is the previous sibling element
    if(!alignto || alignto === 'prev') {
        elementToAlign = $.qCache().svg(svgElement.$().prev());
    }else if(!alignto || alignto === 'parent') {
        elementToAlign = $.qCache().svg(svgElement.$().parent());;
    } else if(alignto === 'root') {
        elementToAlign = this.node.root;
    } else {
        elementToAlign = $.qCache.svg(this.node.getNodeSelector(alignto));
    }

    if(!elementToAlign) {
        console.warn('Could not determine alignto element "'+alignto+'" for node '+this.node.id);
    }

    return elementToAlign;
};

module.exports = Resize;

},{"../core/command":4,"../core/event":7,"../svg/dragConfig":49,"../svg/svg":59,"../svg/transform":63,"../util/util":73,"./knob":24}],32:[function(require,module,exports){
var object = require('../util/object');
var Resize = require('./resize');

var ResizeAddition = function(node) {
    this.node = node;
    this.resize = new Resize(this.node, this.node.diagram);
};

ResizeAddition.prototype.resizeNode = function(dx, dy) {
    //This is the api way to resize a node we imitate the dragevent.
    this.resize.updateNodes(dx,dy);
    this.resize.dragKnob = 4; //We set the KNOB_SE knob as dragKnob for the redo command
    this.resize.dx = dx;
    this.resize.dy = dy;
    this.node.event.trigger('node_resized', this.node);
};

ResizeAddition.prototype.select = function() {
    this.resize.activateKnobs();
};

ResizeAddition.prototype.deselect = function() {
    this.resize.removeKnobs();
};

ResizeAddition.prototype.remove = function() {
    this.deselect();
};

ResizeAddition.prototype.dragMove = function() {
    this.resize.updateKnobs();
};

ResizeAddition.prototype.edit = function() {
    this.resize.update();
};

ResizeAddition.prototype.update = function() {
    //TODO: Through EVENTS !
    this.resize.updateKnobs();
};

ResizeAddition.prototype.activate = function() {
    this.resize.updateNodes();
};

ResizeAddition.prototype.get = function() {
    return this.resize;
};

ResizeAddition.requireConfig = true;

module.exports = ResizeAddition;
},{"../util/object":71,"./resize":31}],33:[function(require,module,exports){
var util = require('../util/Util');
var event = require('../core/event');
var PathData = require('../svg/PathData');

var object = util.object;
var dom = util.dom;

var SelectionManager = function(diagram) {
    this.diagram = diagram;
    this.event = diagram.event;
    this.selectedNodes = [];
    this.selectedTransitions = [];
    this.copyNodes = [];
    this.selectedTransition;
    this.hoverElement;

    event.listen('key_up_press', this.upListener, this);
    event.listen('key_down_press', this.downListener, this);
    event.listen('key_copy_press', this.copyListener, this);
    event.listen('key_paste_press', this.pasteListener, this);
    event.listen('key_del_press', this.deleteListener, this);
    event.listen('tab_activated', this.clear, this);

    this.event.listen('transition_added', this.transitionAddedListener, this);
    this.event.listen('node_added', this.nodeAddedListener, this);
    this.event.listen('knob_added', this.knobAddedListener, this);

    //These are currently global events not diagram context events
    event.listen('element_hoverIn', this.hoverInElementListener, this);
    event.listen('element_hoverOut', this.hoverOutElementListener, this);
};

SelectionManager.prototype.getSelectedNodes = function() {
    return this.selectedNodes.slice();
};

SelectionManager.prototype.knobAddedListener = function(evt) {
    var knob = evt.data;
    var that = this;
    this.addNodeEvents(knob.node);
    if(knob.node.selectable) {
        knob.node.on('select', function () {
            if (that.dragSelection || evt.shiftKey && knob.transition) {
                if (knob.transition.selected) {
                    knob.transition.deselect();
                }
            } else {
                if (!knob.transition.selected) {
                    knob.transition.select();
                }
            }
        });
    }
};

SelectionManager.prototype.nodeAddedListener = function(evt) {
    this.addNodeEvents(evt.data);
};

SelectionManager.prototype.addNodeEvents = function(node, shifted) {
    if(node.selectable) {
        var that = this;
        node.on('select', function (evt, shifted) {
            that.setNodeSelection(node, shifted);
        }).on('deselect', function () {
            that.removeSelectedNode(node);
        }).on('remove', function () {
            that.removeSelectedNode(node);
        }).select();
    }
    return node;
};

SelectionManager.prototype.transitionAddedListener = function(evt) {
    var that = this;
    var transition = evt.data;
    transition.on('select', function(evt, shifted) {
        that.setTransitionSelection(transition);
    }).on('deselect', function() {
        that.removeSelectedTransition(transition);
    }).on('remove', function() {
        that.removeSelectedTransition(transition);
    }).select(evt.shiftKey);
};

SelectionManager.prototype.copyListener = function(evt) {
    this.copyNodes = object.cloneArray(this.selectedNodes);

};

SelectionManager.prototype.pasteListener = function(evt) {
    evt.preventDefault();
    var that = this;
    object.each(this.copyNodes, function(index, node) {
        that.event.trigger('node_copy', node, evt);
    });
};

SelectionManager.prototype.upListener = function(evt) {
    if(evt.ctrlKey) {
        evt.preventDefault();
        object.each(this.selectedNodes, function(index, node) {
            if(object.isDefined(node)) {
                node.moveUp();
            }
        });
    }
};

SelectionManager.prototype.downListener = function(evt) {
    if(evt.ctrlKey) {
        evt.preventDefault();
        object.each(this.selectedNodes, function(index, node) {
            if(object.isDefined(node)) {
                node.moveDown();
            }
        });
    }
};

SelectionManager.prototype.hoverInElementListener = function(evt) {
    this.hoverElement = evt.data;
};

SelectionManager.prototype.hoverOutElementListener = function(evt) {
    delete this.hoverElement;
};

SelectionManager.prototype.removedTransitionListener = function(evt) {
    if(object.isDefined(evt.data)) {
        if(evt.data === this.selectedTransition) {
            delete this.selectedTransition;
        }
    }
};

SelectionManager.prototype.removedNodeListener = function(evt) {
    if(object.isDefined(evt.data)) {
        //Remove the node from the selection
        object.removeFromArray(this.selectedNodes, evt.data);

        //Check if we have to remove the hoverElement too
        if(evt.data.root === this.hoverElement) {
            this.hoverOutElementListener();
        }
    }
};

SelectionManager.prototype.deleteListener = function(evt) {
    this.deleteSelectionNodes();

    //Remove selected transition
    if(object.isDefined(this.selectedTransition)) {
        this.event.trigger('transition_delete', this.selectedTransition);
    };

    this.clear();
};

SelectionManager.prototype.deleteSelectionNodes = function() {
    var arrClone = this.selectedNodes.slice(0);
    var that = this;
    object.each(arrClone, function(index, node) {
        if(object.isDefined(node)) {
            that.event.trigger('node_delete', node);
        } else {
            //If there is a undefined value we remove it from the selection
            that.selectedNodes.splice(0, 1);
        }
    });
};

SelectionManager.prototype.transitionCreatedListener = function(evt) {
    this.selectedTransition = evt.data;
};

SelectionManager.prototype.isElementHover = function() {
    return object.isDefined(this.hoverElement);
};

SelectionManager.prototype.setTransitionSelection = function(transition) {
    //We do not call this.clear because we would hide the edit fields trough the triggered event
    this.clearNodes(function(node) {return !transition.ownsKnobNode(node)});
    if(transition !== this.selectedTransition) {
        this.clearTransition();
        this.selectedTransition = transition;
    }
};

SelectionManager.prototype.setNodeSelection = function(selectedNode, shifted) {
    //some templates or nodes are should not affect the selection (e.g. resize knobs)
    if(!selectedNode.selectable) {
        return;
    };

    if(!this.containsNode(selectedNode)) {
        var that = this;

        //Clear the current selection if not shifted or dragSelection
        if(!shifted && !this.dragSelection) {
            this.clearNodes(function(node) {return selectedNode.id !== node.id});
        }

        this.selectedTemplate = selectedNode.template;
        this.addSelectedNode(selectedNode);
        this.clearTransition(selectedNode, object.isDefined(this.dragSelection));

        //Trigger drag for all selected nodes if one selection is dragged
        //We use additon style instead of on event for a performance gain (on.dragMove is deactivated see draggable.js)
        //We don't have to remove this addition after reselect because only selected nodes can be dragged anyways.
        var that = this;
        selectedNode.additions['multiSelectionDrag'] = {
            dragMove : function(dx,dy, evt) {
                if (!evt.triggerEvent) {
                    object.each(that.selectedNodes, function (index, node) {
                        if (selectedNode.id !== node.id) {
                            node.triggerDrag(dx, dy);
                        }
                    });
                }
            }
        }
    } else if(shifted && !this.dragSelection) {
        this.removeSelectedNode(selectedNode);
    }
};

SelectionManager.prototype.dragSelectionStart = function(evt, startPosition) {
    var that = this;
    // INIT drag selection
    if (!this.isElementHover()) {
        this.clear();
        evt.preventDefault();
        this.diagram.on('mousemove', function (evt) {
            var stagePosition = that.diagram.getStagePosition(evt);
            if (!that.dragSelection) {
                that.dragSelection = that.diagram.svg.path({style: 'stroke:gray;stroke-width:1px;stroke-dasharray:5,5;fill:none;'});
                that.dragSelection.d().start(startPosition)
                    .line(startPosition)
                    .line(stagePosition)
                    .line(stagePosition)
                    .complete();
            } else {
                //Move selection away from mouse pointer
                var alignedMouseX = stagePosition.x - 1;
                var alignedMouseY = stagePosition.y - 1;

                //Update pathdata
                that.dragSelection.d().clear().start(startPosition)
                    .line({x: startPosition.x, y: alignedMouseY})
                    .line({x: alignedMouseX, y: alignedMouseY})
                    .line({x: alignedMouseX, y: startPosition.y})
                    .complete();

                //Check for hovered elements to select
                object.each(that.diagram.nodeMgr.nodes, function (id, node) {
                    that.dragSelect(node);
                });

                object.each(that.diagram.knobMgr.knobs, function(id, knob) {
                    that.dragSelect(knob.node);
                });
            }

            //Trigger attribute update
            that.dragSelection.update();
        });
    };
};

SelectionManager.prototype.dragSelect = function(node) {
    if(!node.selectable) {
        return;
    }
    if(this.dragSelection.overlays(node.getCenter())) {
        if(!node.selected) {
            node.select();
        }
    } else if(node.selected) {
        node.deselect();
    }
};

SelectionManager.prototype.dragSelectionEnd = function() {
    this.diagram.off('mousemove');
    if(this.dragSelection) {
        this.dragSelection.remove();
        delete this.dragSelection;
    }
};

/**
 * This method just adds new nodes to the selection if it have not been
 * added yet without any additional restrictions.
 *
 * All selected transitions are deselected since the mixed selection
 * is not implemented yet.
 *
 * @param {type} selectedNode
 * @returns {undefined}
 */
SelectionManager.prototype.addSelectedNode = function(selectedNode) {
    this.selectedNodes.push(selectedNode);
};

SelectionManager.prototype.removeSelectedTransition = function(transition) {
    if(this.selectedTransition === transition) {
        delete this.selectedTransition;
    }
};

SelectionManager.prototype.removeSelectedNode = function(node) {
    var index = this.selectedNodes.indexOf(node);
    if(index >= 0) {
        this.selectedNodes.splice(index, 1);
    }
};

SelectionManager.prototype.containsNode = function(node) {
    return this.selectedNodes.indexOf(node) > -1;
};

SelectionManager.prototype.clear = function() {
    this.clearNodes();
    this.clearTransition();
    this.event.trigger('selection_clear');
};

SelectionManager.prototype.clearNodes = function(filter) {
    var that = this;
    filter = filter || function() {return true;};
    //We clone the array since the original array can be manipulated while deselection.
    var selectedNodesArr = object.cloneArray(this.selectedNodes);
    object.each(selectedNodesArr, function(index, node) {
        if(node.selectable && filter(node)) {
            node.deselect();
        }
    });
};

SelectionManager.prototype.clearTransition = function(node, force) {
    if(!this.selectedTransition) {
        return;
    }
    if(force || !node  || !node.knob || !this.selectedTransitionOwnsKnobNode(node)) {
        this.selectedTransition.deselect();
    }
};

SelectionManager.prototype.selectedTransitionOwnsKnobNode = function(node) {
    return this.selectedTransition && this.selectedTransition.ownsKnobNode(node);
};

SelectionManager.prototype.isMultiSelection = function() {
    var count = 0;
    count += this.selectedNodes.length;
    return count > 1;
};

module.exports = SelectionManager;

},{"../core/event":7,"../svg/PathData":46,"../util/Util":67}],34:[function(require,module,exports){
/**
 * Simple implementation of path manager
 * @type {PathData|exports|module.exports}
 */
var AbstractPathManager = require('./abstractPathManager');
var util = require('../util/util');

var LinePathManager = function(transition) {
    AbstractPathManager.call(this, transition);
    this.type = LinePathManager.type;
};

util.inherits(LinePathManager, AbstractPathManager);

LinePathManager.type = 'straight';

LinePathManager.prototype.create = function(position) {
    this.path.line(position);
};

LinePathManager.prototype.add = function(index, position) {
    this.path.insertLine(index, position);
};

LinePathManager.prototype.update = function(position) {/* Nothing to do here */};

module.exports = LinePathManager;

},{"../util/util":73,"./abstractPathManager":12}],35:[function(require,module,exports){
var util = require('../util/util');
var xml = require('../util/xml');
var Node = require('./node');
var config = require('../core/config');

var object = util.object;
var dom = util.dom;

var Template = function(id, cfg) {
    this.config = cfg || {};

    if(this.config.fromDom) { //Load tmpl from dom script node
        this.id = id;
        this.tmplXML = dom.parseNodeXML($.qCache('#'+id));
    } else if(object.isString(id)) { //Remote tmpl is initialized later (after loading xml)
        this.id = id;
        this.tmplXML = (this.config.svg) ? xml.parseXML(this.config.svg) : undefined;
    } else { //id is templateXML
        this.tmplXML = id;
        this.id = $(this.tmplXML).attr('id');
    }

    //Remote templates are initialized later;
    if(this.tmplXML) {
        this.init();
    }

    if(object.isDefined(this.config)) {
        if(object.isDefined(this.config.resize)) {
            this.initResizeConfig();
        }
    }
};

Template.prototype.init = function(tmplXML) {
    this.config.rootName = this.config.rootName || 'g';

    if(tmplXML) {
        this.tmplXML = tmplXML;
    }

    this.svg = xml.serializeToString($(this.tmplXML).find(this.config.rootName)[0]);
};

Template.prototype.isInitialized = function() {
    return !!this.svg;
};


/**
 * The resize addition allows to configure a resize behaviour for svg elements
 * by means of defining the logic for changes of x (width) and y (height)
 * in the following form:
 * e.g.:
 *
 * parent(5) default
 *
 * where the x value is
 * @param {type} resizeConfig
 * @returns {undefined}
 */
Template.prototype.initResizeConfig = function() {
    var that = this;
    object.each(this.config.resize, function(index, resizeItem) {
        // Here we just parse the raw string to an array of feature settings
        that.setupSettings(index, resizeItem, 'value');
        that.setupSettings(index, resizeItem, 'position');
        that.setupSettings(index, resizeItem, 'max');
        that.setupSettings(index, resizeItem, 'min');
    });
};

Template.prototype.setupSettings = function(index, item, setting) {
    if(object.isDefined(item[setting])) {
        var values = util.app.parseFeatureStrings(item[setting], 0);

        //If ther is just one value given we use it for both x and y
        if(values.length === 1) {
            values[1] = values[0];
        }

        this.config.resize[index][setting] = values;
    }
};

Template.prototype.resizable = function() {
    return object.isDefined(this.config.resize);
};

Template.prototype.createNode = function(config, diagram) {
    var resultConfig = this.getConfig(config);
    return new Node(this, resultConfig, diagram);
};

Template.prototype.getSVGString = function(cfg) {
    return config.replaceConfigValues(this.svg, cfg);
};

Template.prototype.getSVGXML = function(cfg) {
    return dom.parseXML(getSVGString(cfg));
};

Template.prototype.getFunctions = function(cfg) {
    if(this.function) {
        return config.replaceConfigValues(this.functions, cfg);
    }
};

Template.prototype.getConfig = function(cfg) {
    return object.extend({}, this.config, cfg);
};

module.exports = Template;
},{"../core/config":6,"../util/util":73,"../util/xml":74,"./node":27}],36:[function(require,module,exports){
var object = require('../util/object');
var Template = require('./template');
var event = require('../core/event');
var client = require('../core/client');

var Promise = require('bluebird');

var PATH_PANELS = '/template/panel';
var PATH_TEMPLATES = '/templates';

var EVENT_PANEL_LOADED = 'template_panel_loaded';

var panels = {};
var templates = {};
var selectedTemplate;

/**
 * Initializes listeners and loads the initial template panels set in dala_env.initial_templates array.
 */
var init = function() {
    event.listen('node_selected', nodeSelectionListener);
    event.listen('template_select', templateSelectListener);

    if(dala_env.initial_templates && dala_env.initial_templates.panels) {
        $.each(dala_env.initial_templates.panels, function(index, panelId) {
            _loadPanel(panelId);
        });
    }
};

var nodeSelectionListener = function(evt) {
    _setSelectedTemplate(evt.data.template);
};

var templateSelectListener = function(evt) {
    if(evt.data) {
        _setSelectedTemplate(evt.data);
    }
};

var _setSelectedTemplate = function(tmplId) {
    if(!object.isDefined(tmplId)) {
        return;
    };

    var instance;

    if(!object.isString(tmplId)) {
        if(!tmplId.config.preventSelection) {
            selectedTemplate = tmplId;
        }
    } else {
        getTemplate(tmplId)
            .then(function(template) {
                if(template && !template.config.preventSelection) {
                    selectedTemplate = template;
                } else {
                    console.warn('Coult not determine template: '+tmplId);
                }
            }, function(err) {
                console.warn('Error while determining template: '+tmplId+' - '+err);
            });
    }
};

/**
 * Returns a templateinstance, the template will be loaded and initialized if not loaded yet.
 *
 * @param tmplId
 * @param tmplRootEl
 * @returns {bluebird|exports|module.exports}
 */
var getTemplate = function(tmplId) {
    return new Promise(function(resolve, reject) {
        var panelId = tmplId.substring(0, tmplId.indexOf('_'));
        if(templates[tmplId]) { //Template is loaded
            var tmpl = templates[tmplId];
            if(!tmpl.isInitialized()) { //Template is not initialized yet so load svg
                _loadRemoteTemplateSVGasXML(tmplId, panelId).
                    then(function() {
                        resolve(tmpl);
                    }, function(err) {
                        reject(err);
                    });
            }
            resolve(templates[tmplId]);
        } else { //Template not loaded yet
            var panelId = tmplId.substring(0, tmplId.indexOf('_'));
            if(panelId) { //Load and initialize template
                //TODO: here we have to consider other loading mechanism as dom loading / browser cache first
                _loadRemoteTemplate(panelId, tmplId, true)
                    .then(function() {
                        resolve(templates[tmplId]);
                    }, function(err) {
                        reject(err);
                    });
            } else {
                resolve(_createTemplate(tmplId));
            }
        }
    });
};

/**
 * This simply returns a template if its already loaded. This should only be used for templates which are registered
 * on startup and already loaded.
 *
 * @param tmplId
 * @returns {*}
 */
var getTemplateSync = function(tmplId) {
    return templates[tmplId];
};

/**
 * Loads a panel definition from the server. When loaded the panel will register itself to the templateManager.
 * The function returns a Promise.
 *
 * @param panelId
 * @returns {bluebird|exports|module.exports}
 * @private
 */
var _loadPanel = function(panelId) {
    return new Promise(function(resolve, reject) {
        client.getScript(PATH_TEMPLATES+'/'+panelId+'/'+panelId+'.js', {
            success : function() {
                resolve();
            },
            error : function() {
                reject();
            },
            errorMessage : {
                404: 'Could not load panel '+panelId+' file was not found on the server !',
                'default': 'Could not load panel '+panelId+' something went wrong !'
            }
        });
    });
};

/**
 * Loads a remote tamplate from the server. When loaded the template will register itself to the templateManager
 * This function returns a Promise without result.
 *
 * @param panelId
 * @param tmplId
 * @returns {bluebird|exports|module.exports}
 * @private
 */
var _loadRemoteTemplate = function(panelId, tmplId, fetchSVG) {
    return new Promise(function(resolve, reject) {
        client.getScript(PATH_TEMPLATES+'/'+panelId+'/'+tmplId+'.js', {
            success : function(response) {
                if(fetchSVG) {
                     _loadRemoteTemplateSVGasXML(tmplId, panelId).then(resolve,reject);
                } else {
                    resolve();
                }
            },
            error: function(errorMsg) {
                reject(errorMsg);
            },
            errorMessage : {
                404: 'Could not load template "'+tmplId+'" file was not found on the server !',
                'default': 'Could not load template "'+tmplId+'" something went wrong !'
            }
        });
    });
};

/**
 * Registers a template by creating a new Template instance out of the given arguments.
 * @param templateId
 * @param panelId
 * @param config
 */
var registerTemplate = function(templateId, config) {
    _addTemplate(new Template(templateId, config));
};

/**
 * Loads the template svg as xml document for the given tmplId.
 * @param tmplId
 * @param panelId
 * @returns {bluebird|exports|module.exports}
 * @private
 */
var _loadRemoteTemplateSVGasXML = function(tmplId, panelId) {
    return new Promise(function(resolve, reject) {
        client.xml('/templates/'+panelId+'/'+tmplId+'.svg', {
            success : function(response) {
                _initTemplate(tmplId, response.data);
                resolve(response.data);
            },
            error : function(err) {
                reject(err);
            },
            errorMessage :  {
                404: 'Could not load template "'+tmplId+'" file was not found on the server !',
                'default': 'Could not load template "'+tmplId+'" something went wrong !'
            }
        });
    });

};

var _initTemplate = function(tmplId, svgXML) {
    templates[tmplId].init(svgXML);
};

/**
 * Registers a new panel.
 * @param cfg
 */
var registerPanel = function(cfg) {
  if(cfg.id) {
      panels[cfg.id] = cfg;
      event.trigger(EVENT_PANEL_LOADED, cfg);
  }
};

var _createTemplate = function(tmplId, tmplRootEl) {
    return _addTemplate(new Template(tmplId, true, tmplRootEl));
};

var _addTemplate = function(tmpl) {
    templates[tmpl.id] = tmpl;
    return tmpl;
};

var getSelectedTemplate = function() {
    return selectedTemplate;
};

var getPanel = function(panelId) {
    return panels[panelId];
}

module.exports = {
    registerPanel : registerPanel,
    registerTemplate : registerTemplate,
    getPanel: getPanel,
    getTemplate: getTemplate,
    getTemplateSync : getTemplateSync,
    getSelectedTemplate: getSelectedTemplate,
    init : function() {
        init();
        return this;
    }
};

},{"../core/client":3,"../core/event":7,"../util/object":71,"./template":35,"bluebird":75}],37:[function(require,module,exports){
var util = require('../util/util');
var event = require('../core/event');
var config = require('../core/config');

var TransitionKnobManager = require('./transitionKnobManager');
var TransitionDockingManager = require('./transitionDockingManager');
var TransitionPathManager = require('./curvedPathManager');
var transitionAdditions = require('./transitionAdditions');

var pathManagerFactory = require('./pathManagerFactory');

var STYLE_TRANSITION_ACTIVE = "stroke:blue;stroke-width:1;fill:none;";
var STYLE_TRANSITION_INACTIVE = "stroke:black;stroke-width:1;fill:none;";
var STYLE_AREA = "stroke:grey;stroke-opacity:0.0;stroke-width:11;fill:none;";

var object = util.object;
var dom = util.dom;

var Transition = function(node, startPosition) {
    if(node.isNode) {
        this.diagram = node.diagram;
        this.event = this.diagram.event;
        this.svg = this.diagram.svg;
        this.init(node, startPosition);
    } else { //node = diagram, startPosition = domGroup of transition
        this.diagram = node;
        this.event = this.diagram.event;
        this.svg = this.diagram.svg;
        this.activate(startPosition);
    }
};

Transition.prototype.getPath = function() {
    return this.pathManager.path;
};

Transition.prototype.type = function(value) {
    if(value && value !== this.pathManager.type) {
        var newPathManager = pathManagerFactory.get(this, value);
        if(newPathManager) {
            newPathManager.replace(this.pathManager, this.knobManager.getKnobPositions());
            this.update();
        }
    } else {
        return this.pathManager.type;
    }
};

Transition.prototype.activate = function(domGroup) {
    this.root = this.group = $.svg(domGroup);
    this.id = this.group.attr('id');

    transitionAdditions.init(this);

    //Remove all existing knobs (except orientation knobs)
    this.group.$().children('.knob').remove();

    //Get line and linearea from dom
    this.line = this.getLine();
    this.lineArea = this.getLineArea();
    this.lineArea.d(this.line.d());

    //Init Manager
    this.dockingManager = new TransitionDockingManager(this).activate();
    this.pathManager = pathManagerFactory.get(this, this.group.dala('transitionType')).activate();
    this.knobManager = new TransitionKnobManager(this).activate();
    this.initEvents();
    return this;
};

Transition.prototype.getLine = function() {
    if(!this.line && this.group) {
        this.line = this.getInnerSVG('line');
    }
    return this.line;
};

Transition.prototype.getLineArea = function() {
    if(!this.lineArea && this.group) {
        this.lineArea = this.getInnerSVG('lineArea');
    }
    return this.lineArea;
};

/**
 * Initializes a new transition by creating the svg nodes and startdocking
 *
 * @param {type} mouse
 */
Transition.prototype.init = function(node, mouse) {
    //TODO: user UUID.new or something
    this.id = this.diagram.uniqueId();
    //Initializes the transition group container
    this.initSVGGroup();

    transitionAdditions.init(this);

    //Initialize the transition docking mechanism (start/end) docking to nodes.
    this.dockingManager = new TransitionDockingManager(this, node, mouse);
    //Initialize the path creator which creates the path with the help of the knobs and a given transitiontype.
    this.pathManager = pathManagerFactory.get(this);
    this.group.dala('transitionType', this.pathManager.type);

    //Initialize the transition knob mechanism for (start/end) and inner knobs for manipulating transitions
    this.knobManager = new TransitionKnobManager(this);

    //Calculate start position for outer orientation (mouse position)
    var startDockingPosition = this.dockingManager.calculateStart(mouse);

    //Init knob for startPosition
    this.exec('setStartNode', [node]);

    //Create SVG Elements in dom and transition events
    this.initTransitionSVG();
    this.initEvents();
    this.update(mouse);
    return this;
};

Transition.prototype.initSVGGroup = function() {
    this.root = this.group = this.svg.g({"class":'transition', 'xmlns:dala':"http://www.dala.com", id : this.id});
};

Transition.prototype.getStartAlignment = function() {
    var result = {source:[this.dockingManager.startDocking.position()]};
    if(!this.knobManager.hasInnerKnobs()) {
        result.target = [this.dockingManager.endDocking.position()];
    } else {
        result.target = [this.knobManager.getKnob(1).position()];
    }
    return result;
};

Transition.prototype.getEndAlignment = function() {
    var result = {source:[this.dockingManager.endDocking.position()]};
    if(!this.knobManager.hasInnerKnobs()) {
        result.target = [this.dockingManager.startDocking.position()];
    } else {
        result.target = [this.knobManager.getKnob(-2).position()];
    }
    return result;
};

Transition.prototype.start = function() {
    return this.knobManager.start();
};

Transition.prototype.end = function() {
    return this.knobManager.end();
};


Transition.prototype.getStartLocation = function() {
    return this.dockingManager.startNode.getRelativeLocation(this.start());
};

Transition.prototype.getEndLocation = function() {
    return this.dockingManager.endNode.getRelativeLocation(this.end());
};

Transition.prototype.dragStartOrientation = function(dx, dy) {
    this.dockingManager.dragStartOrientation(dx, dy);
};

Transition.prototype.dragEndOrientation = function(dx, dy) {
    this.dockingManager.dragEndOrientation(dx, dy);
};

Transition.prototype.strokeWidth = function(value) {
    var result = this.line.strokeWidth(value);
    if(value) {
        this.lineArea.strokeWidth(value + 11);
    }
    return result;
};

Transition.prototype.getInnerSVG = function(prefix) {
    return $.svg(this.getTransitionSelector(prefix));
};

Transition.prototype.initTransitionSVG = function() {
    var path = this.pathManager.path;

    //Note we share the path between line and lineArea an update
    this.line = this.svg.path({
        d : path,
        id : 'line_'+this.id,
        style  : STYLE_TRANSITION_ACTIVE
    });

    this.lineArea = this.svg.path({
        d : path,
        id: 'lineArea_'+this.id,
        style  : STYLE_AREA
    });

    //TODO: make this configurable in node template or something !!!
    this.endMarker('trianglefill');

    this.group.prepend(this.lineArea, this.line);
};

Transition.prototype.initEvents = function() {
    var that = this;
    this.lineArea.hoverable({
        in: function() {
            that.hover();
        },
        out: function() {
            that.hoverOut();
        }
    });

    this.on('mousedown', function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        if(!that.selected) {
            that.select();
        }

        var dragInitiated = false;
        var startPosition = that.diagram.getStagePosition(evt.pageX, evt.pageY);
        var knobIndex = that.getPath().getPathIndexForPosition(startPosition);

        if (knobIndex) {
            event.once(document, "mouseup", function(evt) {
                that.diagram.off('mousemove');
            });
            that.diagram.on("mousemove", function(event) {
                var movePosition = that.diagram.getStagePosition(event.pageX, event.pageY);

                //We just start the drag event in case we move more thant 5px away
                if(!dragInitiated && util.app.isMinDist(startPosition, movePosition, 5)) {
                    var knob = that.knobManager.addKnob(startPosition, knobIndex);
                    knob.initDrag(event);
                    dragInitiated = true;
                }
            });
        }
    });
};

Transition.prototype.ownsKnobNode = function(knobNode) {
    return this.knobManager.ownsKnobNode(knobNode);
};

Transition.prototype.update = function(mouse) {
    this.updateEnd(mouse);
    this.updateStart(mouse);
    this.redraw();
    this.exec('update',[], true);
};

Transition.prototype.redraw = function() {
    if(this.line && this.lineArea) {
        this.line.update();
        this.lineArea.update();
    }
};

Transition.prototype.updateStart = function(mouse) {
    var outerOrientation = mouse || this.knobManager.getPosition(1);
    this.knobManager.updateStartKnob(this.dockingManager.calculateStart(outerOrientation));
};

Transition.prototype.updateEnd = function(mouse) {
    if(this.isInitState()) {
        mouse = this.alignEndPositionForMouse(mouse);
        this.pathManager.dragLine(mouse);
    } else {
        var outerOrientation = this.knobManager.getPosition(-2);
        this.knobManager.updateEndKnob(this.dockingManager.calculateEnd(outerOrientation));
    }
};

Transition.prototype.isInitState = function() {
    return !this.dockingManager.endNode;
};

Transition.prototype.alignEndPositionForMouse = function(mouse) {
    //This prevents the line rendering to overlap the exact mouse position
    return {
        x : (this.knobManager.startKnob.x() < mouse.x) ? mouse.x - 1 : mouse.x + 1,
        y : (this.knobManager.startKnob.y() < mouse.y) ? mouse.y - 1 : mouse.y + 1
    };
};

Transition.prototype.setStartNode = function(node) {
    this.exec('setStartNode', [node]);
    if(!this.isInitState()) {
        this.checkDomPosition();
    }
    this.update();
};

Transition.prototype.setEndNode = function(node, mousePosition) {
    this.exec('setEndNode', [node, mousePosition]);
    this.checkDomPosition();
    this.update();
};

Transition.prototype.checkDomPosition = function() {
    var maxNodeIndex = Math.max(this.dockingManager.startNode.index(), this.dockingManager.endNode.index());
    var transitionIndex = this.index();

    if(transitionIndex < maxNodeIndex) {
        dom.insertAfterIndex(this.group.instance(), maxNodeIndex);
    }
};

Transition.prototype.remove = function() {
    this.removed = true;
    this.group.remove();
    this.dockingManager.remove();
};

/**
 * Needed by Interface editable // See abstractEditAddition
 */
Transition.prototype.exec = function(func, args, prevDomEvent) {
    this.executeAddition(func, args);
    if(!prevDomEvent) {
        this.trigger(func, args);
    }
};

Transition.prototype.executeAddition = function(func, args) {
    object.each(this.additions, function(key, addition) {
        if(object.isDefined(addition) && object.isFunction(addition[func])) {
            addition[func].apply(addition, args);
        }
    });
};

Transition.prototype.index = function() {
    return this.group.$().index();
};

Transition.prototype.instance = function() {
    if(this.group) {
        return this.group.instance();
    }
};

Transition.prototype.endMarker = function(marker) {
    return this.marker('end', marker);
};

Transition.prototype.endMarkerValue = function() {
    return this.markerValue('end');
};

Transition.prototype.startMarker = function(marker) {
    return this.marker('start', marker);
};

Transition.prototype.startMarkerValue = function() {
    return this.markerValue('start');
};

Transition.prototype.marker = function(type, marker) {
    var key = 'marker-'+type;
    if(util.object.isDefined(marker)) {
        this.line.attr(key, this.getMarkerValueString(marker));
    } else {
        var markerStr = this.line.attr(key);
        if(markerStr) {
            return markerStr.substring(5, markerStr.length - 1);
        }
    }
};

Transition.prototype.selector = function(prefix) {
    var stringSelector;
    if(object.isArray(prefix)) {
        stringSelector = [];
        var that = this;
        object.each(prefix, function(index, val) {
            stringSelector.push(that.selector(val));
        });
        stringSelector = stringSelector.join(', ');
    } else {
        stringSelector = prefix;
    }
    return this.getTransitionSelector(stringSelector);
};

Transition.prototype.getTransitionSelector = function(prefix) {
    var result = '';

    if(!util.string.startsWith(prefix, '#') && !util.string.startsWith(prefix, '.')) {
        result = '#'+prefix;
    } else {
        result = prefix;
    }

    return util.string.endsWith(prefix, '_')
        ? result + this.id
        : result + '_' + this.id;
};

Transition.prototype.markerValue = function(type, marker) {
    var markerString = this.marker(type, marker);
    if(markerString) { // triangle_s_12312423 --> triangle_s
        return markerString.substring(0, markerString.length - this.diagram.id.length - 1);
    }
};


Transition.prototype.getMarkerValueString = function(markerId) {
    markerId = (util.string.endsWith(markerId, this.diagram.id)) ? markerId : markerId + '_' + this.diagram.id;
    return 'url(#' + markerId + ')';
};

Transition.prototype.select = function() {
    this.selected = true;
    this.activeStyle();
    this.exec('select');
};

Transition.prototype.hover = function() {
    this.exec('hover');
};

Transition.prototype.hoverOut = function() {
    this.exec('hoverOut');
};

Transition.prototype.activeStyle = function() {
    this.line.attr({style:STYLE_TRANSITION_ACTIVE});
};

Transition.prototype.deselect = function() {
    this.inactiveStyle();
    this.selected = false;
    this.exec('deselect');
};

Transition.prototype.inactiveStyle = function() {
    this.line.attr({style:STYLE_TRANSITION_INACTIVE});
};

Transition.prototype.on = function(evt, handler) {
    this.lineArea.on(evt, handler);
    return this;
};

Transition.prototype.trigger = function(evt) {
    if(this.lineArea) {
        this.lineArea.trigger(evt);
    }
    return this;
};

Transition.prototype.off = function(evt) {
    this.lineArea.off(evt);
    return this;
};

module.exports = Transition;
},{"../core/config":6,"../core/event":7,"../util/util":73,"./curvedPathManager":15,"./pathManagerFactory":30,"./transitionAdditions":39,"./transitionDockingManager":40,"./transitionKnobManager":41}],38:[function(require,module,exports){
var object = require('../util/object');
var event = require('../core/event');
var Transition = require('./transition');

/**
 * The transitionaddition for nodes is responsible for creating and updating/rendering the incoming and outgoing
 * transitions of a node.
 *
 * @param node
 * @constructor
 */
var TransitionAddition = function(node) {
    this.node = node;
    this.event = node.event;
    this.diagram = this.node.diagram;
    this.transitionMgr = this.diagram.transitionMgr;
    this.outgoingTransitions = [];
    this.incomingTransitions = [];
};

TransitionAddition.prototype.dragMove = function(dx, dy) {
    this.updateOrientations(dx ,dy);
    this.update();
};

TransitionAddition.prototype.updateOrientations = function(dx ,dy) {
    this.executeOnOutgoingTransitions(function(transition) {
        transition.dragStartOrientation(dx,dy);
    });

    this.executeOnIncomingTransitions(function(transition) {
        transition.dragEndOrientation(dx,dy);
    });
};

TransitionAddition.prototype.resize = function() {
    this.update();
};

TransitionAddition.prototype.update = function() {
    this.executeOnAllTransitions(function(transition) {
        transition.update();
    });
};

TransitionAddition.prototype.remove = function() {
    this.executeOnAllTransitions(function( transition) {
        transition.remove();
    });
};

TransitionAddition.prototype.moveUp = function() {
    this.executeOnAllTransitions(function(transition) {
        transition.checkDomPosition();
    });
};

/**
 * Node dbclick triggers the creation of a transition.
 */
TransitionAddition.prototype.dbclick = function(evt) {
    this.startNewTransition(undefined, this.diagram.getStagePosition(evt));
};

/**
 * This function starts a new transition either by providing a endNode or by using the transitiondrag
 * @param endNode
 */
TransitionAddition.prototype.startNewTransition = function(endNode, mouse) {
    if(this.transitionMgr.isDragTransition()) {
        return this.diagram.transitionMgr.getDragTransition();
    }

    var transition = this.transitionMgr.startDragTransition(this.node, mouse);

    if(!endNode) {
        //If no endNode was provided we start the mouse listener for the transitiondrag
        var that = this;
        event.on(this.diagram.svg.getRootNode(), "mousemove", function(event) {
            that.transitionDrag(event, true);
        });
    } else {
        //If an endNode was provided we imitate the transitiondrag and set the endNode
        this.transitionDrag(endNode.getCenter());
        endNode.additions.transition.endTransitionDrag();
    }

    return transition;
};

TransitionAddition.prototype.transitionDrag = function(mouse, isEvt) {
    mouse = (isEvt)? this.diagram.getStagePosition(mouse) : mouse;
    //Update the current dragTransition
    this.transitionMgr.getDragTransition().update(mouse);
};

/**
 * Node mousedown ends a transitionDrag even (if there is one) and sets this node as endnode
 */
TransitionAddition.prototype.mousedown = function(evt) {
    // Stop transition drag event and set end node
    if(this.transitionMgr.isDragTransition()) {
        this.endTransitionDrag(evt);
    }
};

TransitionAddition.prototype.endTransitionDrag = function(mouseEvt) {
    mouseEvt = mouseEvt || this.node.getCenter();
    var transition = this.transitionMgr.getDragTransition();
    transition.setEndNode(this.node, this.diagram.getStagePosition(mouseEvt));
    this.transitionMgr.endDragTransition();
    event.off(this.diagram.svg.getRootNode(), 'mousemove');
};

TransitionAddition.prototype.addOutgoingTransition = function(transition) {
    this.outgoingTransitions.push(transition);
    return transition;
};

TransitionAddition.prototype.undockStart = function(transition) {
    this.edgeDockingDragListener(transition, 'Start');
};

TransitionAddition.prototype.undockEnd = function(transition) {
    this.edgeDockingDragListener(transition, 'End');
};

TransitionAddition.prototype.undockEdgeDocking = function(transition, dockingType) {
    var that = this;
    //We wait till the drag event stops (mouseup)
    event.once(this.diagram.svg.getRootNode(), "mouseup", function(mouseUpEvent) {
        var mouse = that.diagram.getStagePosition(mouseUpEvent);
        var hoverNode = that.diagram.overlaysNode(mouse);
        if(hoverNode !== transition['get'+dockingType+'Node']()) {
            //If we are hovering another node we swap start/end node
            transition['set'+dockingType+'Node'](hoverNode);
        } else if(hoverNode === transition['get'+dockingType+'Node']()){
            //If we are hovering the same node we set a relative docking
            transition['setRelative'+dockingType+'Knob'](mouse.x, mouse.y);
            transition.update();
        } else {
            //Mouse is hovering empty space
            transition.update();
        }
    });
};

TransitionAddition.prototype.executeOnAllTransitions = function(handler) {
    this.executeOnOutgoingTransitions(handler);
    this.executeOnIncomingTransitions(handler);
};

TransitionAddition.prototype.executeOnOutgoingTransitions = function(handler) {
    object.each(this.outgoingTransitions, function(index, transition) {
        if(transition) {
            handler(transition);
        }
    });
};

TransitionAddition.prototype.executeOnIncomingTransitions = function(handler) {
    object.each(this.incomingTransitions, function(index, transition) {
        if(transition) {
            handler(transition);
        }
    });
};

TransitionAddition.prototype.getTransitionAlignmentTargets = function() {
    var result = [];
    object.each(this.outgoingTransitions, function(index, transition) {
        if(object.isDefined(transition)) {
            result.push(transition.getStartAlignment());
        }
    });

    object.each(this.incomingTransitions, function(index, transition) {
        if (object.isDefined(transition)) {
            result.push(transition.getEndAlignment());
        }
    });
    return result;
};

TransitionAddition.prototype.removeOutgoingTransition = function(transition) {
    var index = this.outgoingTransitions.indexOf(transition);
    if (index !== -1) {
        this.outgoingTransitions.splice(index, 1);
    }
};

TransitionAddition.prototype.addIncomingTransition = function(transition) {
    this.incomingTransitions.push(transition);
};

TransitionAddition.prototype.removeIncomingTransition = function(transition) {
    var index = this.incomingTransitions.indexOf(transition);
    if (index !== -1) {
        this.incomingTransitions.splice(index, 1);
    }
};

TransitionAddition.requireConfig = false;

module.exports = TransitionAddition;


},{"../core/event":7,"../util/object":71,"./transition":37}],39:[function(require,module,exports){
var additions = require('./additions');

//Init default additions
additions.registerTransitionAddition('text', require('./transitionTextAddition'));
additions.registerTransitionAddition('edit', require('./editTransitionAddition'));

module.exports = {
    init : function(transition) {
        additions.initTransitionAddition('text', transition);
        additions.initTransitionAddition('edit', transition);
    }
};
},{"./additions":13,"./editTransitionAddition":21,"./transitionTextAddition":43}],40:[function(require,module,exports){
var util = require('../util/util');
var Knob = require('./Knob');
var dockingType = require('./docking');

var TransitionDocking = function(dockingManager, node, mouse, type) {
        this.node = node;
        this.type = type;
        this.transition = dockingManager.transition;
        this.dockingManager = dockingManager;
        if(!node.knob) {
            this.initOrientation(mouse);
        }
};

TransitionDocking.prototype.initOrientation = function(startPosition) {
    var orientationPosition = _getStartOrientationPosition(this.node, startPosition);
    this.knob = new Knob(this.transition.diagram, orientationPosition, {'cssClass':'orientationKnob', 'fill-active':'orange', fill:'orange', selectable:false}, this.transition.group);
    this.initKnobEvents();
};

var _getStartOrientationPosition = function(node, mouse) {
    var orientationType = (node.config.docking && node.config.docking.orientation)
                          ? node.config.docking.orientation : 'center';
    switch(orientationType.toUpperCase()) {
        case 'FREE':
            return mouse;
        case  'CENTER':
        default:
            return node.getCenter();
    }

};

TransitionDocking.prototype.initKnobEvents = function() {
    var that = this;
    this.knob.draggable({
        restrictionX : function(evt, dx, dy) {
            var dragCenter = that.knob.position();
            dragCenter.x += dx;
            return that.node.overlays(dragCenter) ? dx : 0;
            //return (dockingType.checkOrientationBoundary(that.node, dragCenter)) ? dx : 0;
        },
        restrictionY : function(evt, dx, dy) {
            var dragCenter = that.knob.position();
            dragCenter.y += dy;
            return that.node.overlays(dragCenter) ? dy : 0;
            //return (dockingType.checkOrientationBoundary(that.node, dragCenter)) ? dy : 0;
        },
        dragAlignment : function() {
            //We align our knob center to the node center and also to our transition alignment point
            var alignment = (that.type === 'start')
                ? that.transition.getStartAlignment() : that.transition.getEndAlignment();
            alignment.target.push(that.node.getCenter());
            return [alignment];
        },
        dragMove : function(evt, dx ,dy) {
            that.transition.update();
        }
    });
};

TransitionDocking.prototype.position = function() {
    if(this.knob) {
        return this.knob.position();
    } else {
        return this.node.getCenter();
    }
};

TransitionDocking.prototype.triggerDrag = function(dx, dy) {
    if(this.knob) {
        this.knob.triggerDrag(dx, dy);
    }
};

TransitionDocking.prototype.calculateDockingPosition = function(outerOrientation) {
    if(this.node.knob) {
        return this.node.getCenter();
    }
    return dockingType.calculateDockingPosition(this.node, outerOrientation, this.position());
};

TransitionDocking.prototype.inactiveStyle = function() {
    if(this.knob) {
        this.knob.inactiveStyle();
    }
};

TransitionDocking.prototype.hide = function() {
    if(this.knob) {
        this.knob.hide();
    }
};

TransitionDocking.prototype.remove = function() {
    if(this.knob) {
        this.knob.remove();
    }
};

var TransitionDockingManager = function(transition, startNode, mouse) {
    this.diagram = transition.diagram;
    this.transition = transition;

    if(startNode) {
        this.setStartNode(startNode, mouse);
    }

    var that = this;
    this.transition.additions['dockingManager'] = {
        setEndNode : function(node, mousePosition) {
            that.setEndNode(node, mousePosition);
        },
        setStartNode : function(node) {
            that.setStartNode(node);
        },
        select : function() {
            that.inactiveStyle();
        },
        deselect : function() {
            that.hide();
        },
        hover : function() {
            that.inactiveStyle();
        },
        hoverOut : function() {
            if(!that.transition.selected) {
                that.hide();
            }
        }

    };
};

TransitionDockingManager.prototype.activate = function() {
    var currentOrientationNodes = this.transition.group.$().children('.orientationKnob');
    this.setStartNode(this.diagram.getNodeById(this.getStartNodeFeature()));
    this.setEndNode(this.diagram.getNodeById(this.getEndNodeFeature()));
    var that = this;
    $.each(currentOrientationNodes, function(index, orientationNode) {
        var svgNode = $.svg(orientationNode);
        if(that.startNode.overlays(svgNode.position())) {
            that.startDocking.knob.moveTo(svgNode.position());
        } else if(that.endNode.overlays(svgNode.position())) {
            that.endDocking.knob.moveTo(svgNode.position());
        } else {
            console.warn('Detected orientation knob not hovering a start/end node.');
        }
        svgNode.remove();
    });
    return this;
};

TransitionDockingManager.prototype.setStartNode = function(node, mousePosition) {
    if(this.startNode && this.startNode.id === node.id) {
        return;
    } else if(this.startNode) {
        this.startNode.removeOutgoingTransition(this.transition);
    }

    if(this.startDocking) {
        this.startDocking.remove();
    }

    this.startNode = node;
    this.startNode.addOutgoingTransition(this.transition);
    this.startDocking = new TransitionDocking(this, node, mousePosition, 'start');
    this.setStartNodeFeature();
};

TransitionDockingManager.prototype.getStartNodeFeature = function() {
    return this.transition.group.dala('start');
};

TransitionDockingManager.prototype.setStartNodeFeature = function() {
    this.transition.group.dala('start', this.startNode.id);
};

TransitionDockingManager.prototype.calculateStart = function(outerOrientation) {
    return this.startDocking.calculateDockingPosition(outerOrientation);
};

TransitionDockingManager.prototype.dragStartOrientation = function(dx,dy) {
    this.startDocking.triggerDrag(dx,dy);
};

TransitionDockingManager.prototype.setEndNode = function(node, mousePosition) {
    if(this.endNode) {
        this.endNode.removeIncomingTransition(this.transition);
    }

    if(this.endDocking) {
        this.endDocking.remove();
    }

    this.endNode = node;
    this.endNode.addIncomingTransition(this.transition);
    this.endDocking = new TransitionDocking(this, node, mousePosition, 'end');
    this.setEndNodeFeature();
};

TransitionDockingManager.prototype.dragEndOrientation = function(dx,dy) {
    this.endDocking.triggerDrag(dx,dy);
};

TransitionDockingManager.prototype.calculateEnd = function(outerOrientation) {
    return this.endDocking.calculateDockingPosition(outerOrientation);
};

TransitionDockingManager.prototype.getEndNodeFeature = function() {
    return this.transition.group.dala('end');
};


TransitionDockingManager.prototype.setEndNodeFeature = function() {
    if(this.endNode) {
        this.transition.group.dala('end', this.endNode.id);
    }
};

TransitionDockingManager.prototype.inactiveStyle = function() {
    this.startDocking.inactiveStyle();
    if(this.endDocking) {
        this.endDocking.inactiveStyle();
    }
};

TransitionDockingManager.prototype.hide = function() {
    this.startDocking.hide();
    if(this.endDocking) {
        this.endDocking.hide();
    }
};

TransitionDockingManager.prototype.remove = function() {
    if(this.startNode) {
        this.startNode.removeOutgoingTransition(this.transition);
        this.startDocking.remove();
    }

    if(this.endNode) {
        this.endNode.removeIncomingTransition(this.transition);
        this.endDocking.remove();
    }
};

module.exports = TransitionDockingManager;
},{"../util/util":73,"./Knob":9,"./docking":17}],41:[function(require,module,exports){
/**
 * This module manages the transition data like knobs and pathdata.
 *
 */
var util = require('../util/util');
var Knob = require('./knob');
var DragAlignment = require('./dragAlignment');
var event = require('../core/event');

var dom = util.dom;
var object = util.object;

var TransitionKnobManager = function(transition) {
    this.transition = transition;
    this.dockingManager = transition.dockingManager;
    this.event = transition.event;
    this.init();

    var that = this;
    this.transition.additions['knobManager'] = {
        setEndNode : function(node) {
            var knob = (that.isInitState()) ? that.addKnob(node.getCenter()) : that.getEndKnob();

            if(node.knob) {
                knob.hoverable(false);
            } else {
                knob.hoverable(true);
            }
        },
        setStartNode : function(node) {
            var knob = (that.isInitState()) ? that.addKnob(node.getCenter(), 0) : that.getStartKnob();

            if(node.knob) {
                knob.hoverable(false);
            } else {
                knob.hoverable(true);
            }
        },
        select : function() {
            that.inactiveStyle();
        },
        deselect : function() {
            that.hide();
        },
        hover : function() {
            that.inactiveStyle();
        },
        hoverOut : function() {
            if(!that.transition.selected) {
                that.hide();
            }
        }

    };
};

TransitionKnobManager.prototype.init = function() {
    this.knobs = [];
};

TransitionKnobManager.prototype.activate = function() {
    var polynoms = this.transition.getLine().d().polynoms();
    for(var i = 0; i < polynoms.length; i++) {
        var to = polynoms[i];
        this.addKnob(to, i, true, (i === 0 || i === polynoms.length - 1));
    }
    return this;
};

TransitionKnobManager.prototype.addKnob = function(position, index, activate, isBoundaryKnob) {
    var index = index || this.size();
    var isBoundaryKnob = (!activate)? this.isInitState() : isBoundaryKnob;
    var knob = this.initKnob(index, position, isBoundaryKnob);
    this.knobs.splice(index, 0, knob);

    if(index === 0) {
        this.startKnob = knob;
    } else if(arguments.length === 1 || isBoundaryKnob) {
        this.endKnob = knob;
    }

    if(!activate && arguments.length !== 1) {
        //We do not need ato add an additional pathpart for the endnode;
        this.getPathManager().addPathPart(index, position);
    }

    if(!activate) {
        this.transition.redraw();
    }
    return knob;
};

TransitionKnobManager.prototype.initKnob = function(knobIndex, position, isBoundaryKnob) {
    var that = this;
    var knobConfig = {
        radius:5,
        selectable: !isBoundaryKnob,
        fill:       isBoundaryKnob ? 'green' : 'silver'
    };
    var knob = new Knob(this.transition.diagram, position, knobConfig, this.transition.group);
    knob.transition = this.transition;
    var initialDrag = true;

    if(!isBoundaryKnob) {
        knob.draggable({
            dragAlignment : new DragAlignment(that.transition.diagram,
                function() { return [{source: [knob.position()], target: that.getJoiningOrientation(knob)}];}),
            dragMove : function() {
                //We just update boundary knobs if they are not in within multiselection
                if(!(that.transition.diagram.isMultiSelection() && that.isBoundaryIndex(knobIndex))) {
                    that.updateKnob(that.getIndexForKnob(knob), knob.position());
                    that.transition.update();
                }
            },
            dragEnd : function() {
                if(initialDrag) {
                    that.event.trigger('transition_docking_created', {'transition':that.transition.id, 'dockingIndex':knobIndex});
                    initialDrag = false;
                } else {
                    that.event.trigger('transition_docking_dropped', {'transition':that.transition.id, 'dockingIndex':knobIndex});
                }
            }
        });
    } else {
        knob.draggable({
            preventAlignment : true,
            dragMove : function() {
                //We just update boundary knobs if they are not in within multiselection
                if(!that.transition.diagram.isMultiSelection()) {
                    that.getPathManager().updatePart(that.getIndexForKnob(knob), knob.position());
                    that.transition.redraw();
                }
            },
            dragEnd : function() {
                //TODO: currently the getNodeByPosition function does return the first node found not the one with the highest index...
                var hoverNode = that.transition.diagram.getNodeByPosition(knob.position());
                if(knobIndex > 0) {
                    that.transition.setEndNode(hoverNode);
                } else {
                    that.transition.setStartNode(hoverNode);
                }
            }
        });
    }

    knob.on('deselect', function(evt) {
        if(that.transition.selected) {
            knob.inactiveStyle();
        } else {
            knob.hide();
        }
    });

    knob.on('remove', function() {
        that.removeKnob(knob);
    });

    //To prevent hiding the hoverknobs we adobt the transition hovering
    knob.hoverable({
        in : function() {
            that.transition.hover();
            if(!knob.isSelected()) {
                knob.fill('#9E9E9E');
            }
        },
        out : function() {
            that.transition.hoverOut();
        }
    });
    return knob;
};

TransitionKnobManager.isInitState = function() {
    return this.size() < 2;
}

TransitionKnobManager.prototype.updateStartKnob = function(position) {
    this.updateKnob(0, position);
};

TransitionKnobManager.prototype.updateEndKnob = function(position) {
    this.updateKnob(-1, position);
};

TransitionKnobManager.prototype.updateKnob = function(knobIndex, position) {
    knobIndex = object.getIndex(this.knobs, knobIndex);

    // Note the following is only neccessary for boundary knobs but won't affect other knobs since the given position
    // is the same as the current knob position after drag.
    this.knobs[knobIndex].moveTo(position.x, position.y);

    // update path
    this.getPathManager().updatePart(knobIndex, position);
};

TransitionKnobManager.prototype.removeKnob = function(knob) {
    if(!this.transition.removed) {
        var index = this.getIndexForKnob(knob);
        this.knobs.splice(index, 1);
        this.getPathManager().removePathPart(index);
        this.transition.update();
    }
};

TransitionKnobManager.prototype.size = function() {
    return this.knobs.length;
};

TransitionKnobManager.prototype.lastIndex = function() {
    return this.size() - 1;
};

TransitionKnobManager.prototype.hasInnerKnobs = function() {
    return this.knobs.length > 2;
};

TransitionKnobManager.prototype.remove = function() {
    object.each(this.knobs, function(index, value) {
        if(object.isDefined(value)) {
            value.remove();
        }
    });
};

TransitionKnobManager.prototype.removeDockingMarker = function() {
    this.transition.group.$().children('.docking').remove();
};

TransitionKnobManager.prototype.isBoundaryKnob = function(knob) {
    return this.isBoundaryIndex(this.getIndexForKnob(knob));
};

TransitionKnobManager.prototype.isBoundaryIndex = function(knobIndex) {
    return knobIndex === 0 || knobIndex === this.lastIndex();
};

TransitionKnobManager.prototype.getJoiningDockings = function(docking) {
    var index = this.getIndexForKnob(docking);
    return [this.knobs[index - 1], this.knobs[index + 1]];
};

TransitionKnobManager.prototype.getJoiningOrientation = function(knob) {
    var index = this.getIndexForKnob(knob);
    var result = [];
    if(index <= 1) { //start or second docking
        result.push(this.transition.dockingManager.startDocking.position());
    } else if(index !== 0){
        var orientation = this.knobs[index - 1].position();
        result.push({x : orientation.x, y : orientation.y});
    }

    if(index >= this.knobs.length -2) { //end or one before end docking
        result.push(this.transition.dockingManager.endDocking.position());
    } else {
        var orientation = this.knobs[index + 1].position();
        result.push({x : orientation.x, y : orientation.y});
    }

    return result;
};

TransitionKnobManager.prototype.getIndexForKnob = function(knob) {
    return this.knobs.indexOf(knob);
};

TransitionKnobManager.prototype.getKnobPositions = function() {
    var result = [];
    object.each(this.knobs, function(index, value) {
        result.push(value.position());
    });
    return result;
};

TransitionKnobManager.prototype.getStartKnob = function() {
    return this.getKnob(0);
};

TransitionKnobManager.prototype.getEndKnob = function() {
    return this.getKnob(-1);
};

TransitionKnobManager.prototype.start = function() {
    return this.getKnob(0).position();
};

TransitionKnobManager.prototype.end = function() {
    return this.getKnob(-1).position();
};

TransitionKnobManager.prototype.getKnob = function(index) {
    return object.valueByIndex(this.knobs, index);
};

TransitionKnobManager.prototype.hide = function() {
    object.each(this.knobs, function(index, knob) {
        if(!knob.isSelected()) {
            knob.hide();
        }
    });
};

TransitionKnobManager.prototype.inactiveStyle = function() {
    object.each(this.knobs, function(index, knob) {
        if(!knob.isSelected()) {
            knob.inactiveStyle();
        }
    });
};

TransitionKnobManager.prototype.ownsKnobNode = function(node) {
    var result = false;
    return node.root.$().parent().attr('id') === this.transition.group.$().attr('id');
};

TransitionKnobManager.prototype.getPosition = function(index) {
    if(index < this.size()) {
        return object.valueByIndex(this.knobs, index).position();
    }
};

TransitionKnobManager.prototype.getPathManager = function() {
    return this.transition.pathManager;
}

TransitionKnobManager.prototype.isInitState = function() {
    return !this.endKnob;
}

module.exports = TransitionKnobManager;
},{"../core/event":7,"../util/util":73,"./dragAlignment":18,"./knob":24}],42:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var xml = require('../util/xml');
var event = require('../core/event');
var Transition = require('./transition');

var AbstractManager = require('./abstractManager');

var EVT_TRANSITION_ADDED = "transition_added";
var EVT_TRANSITION_SELECTED = 'transition_selected';
var EVT_TRANSITION_DESELECTED = 'transition_deselected';
var EVT_TRANSITION_REMOVED = 'transition_removed';

var CMD_ADD = "transition_add";
var CMD_DEL = "transition_delete";
var CMD_DOC_CREATED = "transition_doc_created";
var CMD_DOC_DROPPED = "transition_doc_dropped";
var CMD_EDIT = "transition_edit";

var TransitionManager = function(diagram) {
    // Contains all nodes added to the diagram
    AbstractManager.call(this, diagram);

    this.transitions = {};
    this.diagram = diagram;
    event.listen('transition_delete', this.deleteTransitionListener, this);
    event.listen('transition_docking_created', this.transitionDockingCreatedListener, this);
    event.listen('transition_docking_dropped', this.transitionDockingDropListener, this);

    event.listen('transition_edit', this.editTransitionListener, this);

    this.command(CMD_ADD, this.importTransition, this.deleteTransition);
    this.command(CMD_DEL, this.deleteTransition, this.importTransition);
    this.command(CMD_DOC_CREATED, this.importTransition, this.deleteKnob);
    this.command(CMD_DOC_DROPPED, this.dropDocking, this.dropDocking);
    this.command(CMD_DOC_DROPPED, this.dropDocking, this.dropDocking);
    this.command(CMD_EDIT, this.editTransition, this.undoEdit);
};

util.inherits(TransitionManager, AbstractManager);

TransitionManager.prototype.editTransitionListener = function(evt) {
    var transition = this.getTransition(evt.data.transition);
    var key = evt.data.key;
    var oldValue = transition.additions.edit.getValue(key);
    this.exec(CMD_EDIT, [transition.id, key, evt.data.value], [transition.id, key, oldValue]);
};

TransitionManager.prototype.editTransition = function(transition, key, value) {
    transition = this.getTransition(transition);
    transition.additions.edit.setValue(key, value);
    event.trigger('transition_edited', transition);
};

TransitionManager.prototype.undoEdit = function(transition, key, value) {
    transition = this.getTransition(transition);
    transition.additions.edit.setValue(key, value);
    event.trigger('transition_edit_undo', transition);
};

TransitionManager.prototype.transitionDockingDropListener = function(evt) {
    if (evt.data) {
        var transition = evt.data.transition;
        var dockingIndex = evt.data.dockingIndex;
        var docking = this.getTransition(transition).knobManager.getKnob(dockingIndex);

        this.addCmd(CMD_DOC_DROPPED,
            [transition, dockingIndex, docking.node.root.dxSum, docking.node.root.dySum],
            [transition, dockingIndex, (-1 * docking.node.root.dxSum), (-1 * docking.node.root.dySum)]);
    }
};

TransitionManager.prototype.dropDocking = function(transition, dockingIndex, dxSum, dySum) {
    transition = this.getTransition(transition);
    if(transition) {
        var docking = transition.knobManager.getKnob(dockingIndex);
        docking.triggerDrag(dxSum, dySum);
    }
};

TransitionManager.prototype.transitionDockingCreatedListener = function(evt) {
    if (evt.data) {
        var transition = evt.data.transition;
        var dockingIndex = evt.data.dockingIndex;
        this.addCmd(CMD_DOC_CREATED, [this.getTransitionString(transition), transition], [transition, dockingIndex]);
    }
};

TransitionManager.prototype.deleteKnob = function(transition, dockingIndex) {
    transition = this.getTransition(transition);
    if(transition) {
        transition.knobManager.getKnob(dockingIndex).remove();
    }
};

TransitionManager.prototype.importTransition = function(transitionStr, transition) {
    if(transition) {
        transition = this.getTransition(transition)
        if(transition) {
            this.deleteTransition(transition.id);
        }
    }

    var transitionElement = this.diagram.import(transitionStr);
    this.activateTransition(transitionElement);
};

TransitionManager.prototype.activateTransition = function(toActivate) {
    if(object.isArray(toActivate)) {
        var result = [];
        var that = this;
        object.each(toActivate, function() {
            result.push(that.activateTransition($(this).get(0)));
        });
        return result;
    } else  { //toActivate is domElement
        return this.addTransition(new Transition(this.diagram, toActivate));
    }
};

TransitionManager.prototype.isDragTransition = function(transition) {
    return object.isDefined(this.dragTransition);
};

TransitionManager.prototype.startDragTransition = function(node, mouse) {
    mouse = mouse || node.getCenter();
    return this.dragTransition = new Transition(node, mouse);
};

TransitionManager.prototype.getDragTransition = function() {
    return this.dragTransition;
};

TransitionManager.prototype.endDragTransition = function() {
    this.addTransition(this.dragTransition);
    delete this.dragTransition;
};

TransitionManager.prototype.addTransition = function(transition) {
    var that = this;
    this.event.trigger(EVT_TRANSITION_ADDED, transition);
    transition.on('select', function() {
        that.event.trigger(EVT_TRANSITION_SELECTED, transition);
    }).on('deselect', function() {
        that.event.trigger(EVT_TRANSITION_DESELECTED, transition);
    }).on('remove', function() {
        that.event.trigger(EVT_TRANSITION_REMOVED, transition);
    });
    this.addCmd(CMD_ADD, [this.getTransitionString(transition)], [transition.id]);
    return this.transitions[transition.id] = transition;
};

TransitionManager.prototype.getTransitionString = function(transition) {
    transition = this.getTransition(transition);
    return xml.serializeToString(transition.instance());
};

TransitionManager.prototype.deleteTransitionListener = function(evt) {
    if(evt.data) {
        var transition = evt.data;
        this.exec(CMD_DEL, [transition.id], [this.getTransitionString(transition)]);
    }
};

TransitionManager.prototype.deleteTransition = function(id) {
    var transition = this.getTransition(id);
    if(transition) {
        delete this.transitions[id];
        transition.remove();
    }
};

TransitionManager.prototype.getTransition = function(id) {
    if(object.isString(id) && !isNaN(id)) {
        return this.transitions[parseInt(id)];
    } else if(!isNaN(id)) {
        return this.transitions[id];
    } else if(id instanceof Transition) {
        //We assume a node instance
        return id;
    } else {
        console.warn('getTransition call with no result for :'+id);
    }
};

module.exports = TransitionManager;
},{"../core/event":7,"../util/object":71,"../util/util":73,"../util/xml":74,"./abstractManager":11,"./transition":37}],43:[function(require,module,exports){
var util = require('../util/util');
var object = util.object;

var NODE_DISTANCE = 11;
var TRANSITION_DISTANCE = 10;
var DEF_TEXT_HEIGHT = 13;

var TransitionTextAddition = function(transition) {
    this.textNodes = [];
    this.transition = transition;
    this.diagram = this.transition.diagram;
};

/**
 * The update addition function rerenders all containing textnodes by means
 * of the current transition settings. This function is delegated by
 * the transition as addition call.
 */
TransitionTextAddition.prototype.update = function() {
    var that = this;
    object.each(this.textNodes, function(index, textSVG) {
        if(textSVG) {
            that.updateTextPosition(index);
        }
    });
};

TransitionTextAddition.prototype.getText = function(pos) {
    if(this.textNodes[pos]) {
        return this.textNodes[pos].$().text();
    }
};

/**
 * Sets the text for a given position. If the given text position is not
 * occupied yet we create a new textnode.
 */
TransitionTextAddition.prototype.setText = function(pos, text) {
    if(!this.textNodes[pos]) {
        var id = 'text'+pos+'_'+this.transition.id;
        var textNode = this.textNodes[pos] = this.diagram.svg.text(text, {id : id}).hanging(false);
        this.diagram.svg.addToGroup(this.transition.group, textNode);
    } else {
        this.textNodes[pos].content(text);
    }
    this.updateTextPosition(pos);
};

/**
 * Updates the textnode position and anchor for the given position by means of the current
 * transition settings.
 */
TransitionTextAddition.prototype.updateTextPosition = function(pos) {
    var position = this.getTextPosition(pos);

    //For some points the position cannot be determined mainly on the node corner
    if(position) {
        this.textNodes[pos].moveTo(position);
        this.setAnchor(pos);
    }
};

TransitionTextAddition.prototype.getTextPosition = function(pos) {
    var textPosition;

    var textHeight = this.getTextHeight(pos);

    if(isStartPos(pos) || isEndPos(pos)) {
        //Move along the transition in the right direction the index -1 searches the last transitionPart
        var index = isEndPos(pos) ? -1 : 1;
        var distance = isEndPos(pos) ? NODE_DISTANCE * -1 : NODE_DISTANCE;
        textPosition = this.transition.getPath().moveAlong(index, distance);

        switch(this.getLocation(pos)) {
            case 'left':
            case 'right':
                textPosition.y += (isTop(pos)) ? -TRANSITION_DISTANCE : TRANSITION_DISTANCE + (textHeight);
                break;
            case 'top':
            case 'bottom':
                textPosition.x += (isTop(pos)) ? TRANSITION_DISTANCE : -TRANSITION_DISTANCE;
                break;
        }
    } else {
        //Mid Position
        textPosition = this.transition.getPath().getCenter();
        textPosition.y += isTop(pos) ? TRANSITION_DISTANCE * -1 : TRANSITION_DISTANCE + textHeight;
    }

    return textPosition;
};

TransitionTextAddition.prototype.getTextHeight = function(pos) {
    return (this.textNodes[pos]) ? this.textNodes[pos].height() : DEF_TEXT_HEIGHT;
};

TransitionTextAddition.prototype.getAlignPosition = function(pos) {
    if(isStartPos(pos)) {
        return this.transition.start();
    } else if(isEndPos(pos)) {
        return this.transition.end();
    }
};

TransitionTextAddition.prototype.getLocation = function(pos) {
    if(isStartPos(pos)) {
        return this.transition.getStartLocation();
    } else if(isEndPos(pos)) {
        return this.transition.getEndLocation();
    }
};

/**
 * This function determines the text-anchor by means of the current
 * node location to assure the text is not overlapping other texts or the
 * node itself.
 */
TransitionTextAddition.prototype.setAnchor = function(pos) {
    var textSVG = this.textNodes[pos];
    if(!isMidPos(pos)) {
        switch(this.getLocation(pos)) {
            case 'left':
                textSVG.end();
                break;
            case 'right':
                textSVG.start();
                break;
            case 'top':
            case 'bottom':
                if(isBottom(pos)) {
                    textSVG.end();
                } else {
                    textSVG.start();
                }
                break;
        }
    } else {
        textSVG.middle();
    }
};

var isBottom = function(pos) {
    return !isTop(pos);
};

var isTop = function(pos) {
    return pos % 2 === 0;
};

var isStartPos = function(pos) {
    return pos < 2;
};

var isMidPos = function(pos) {
    return !isStartPos(pos) && !isEndPos(pos);
};

var isEndPos = function(pos) {
    return pos > 3;
};

module.exports = TransitionTextAddition;

},{"../util/util":73}],44:[function(require,module,exports){
var xml = require('../util/xml');
var object = require('../util/object');

var elementCache = {};

var create = function(element, attributes, text) {
    var $element = $(document.createElement(element));

    if(attributes) {
        $.each(attributes, function (key, value) {
            $element.attr(key, value);
        });
    }

    if(text) {
        $element.text(text);
    }
    return $element;
};

var query = function(selector, cache) {
    var result;
    if(cache) {
        result = $.qCache(selector);
    } else {
        result = $(selector);
    }
    return result;
};

var getJQueryNode = function(node) {
    if(!node) {
        return;
    }
    // The node is either a dom node or a selector
    if(object.isString(node)) {
        return query(node);
    } else if(node.getAttribute){
        var id = node.getAttribute('id');
        if(id) {
            return $.qCache('#'+node.getAttribute('id'), true);
        } else {
            return $(node);
        }
    } else if(node.jQuery) {
        return node;
    } else {
        // e.g. document, window...
        return $(node);
    }
};

var moveDown = function(node) {
    var $node = getJQueryNode(node);
    $node.before($node.next());
};

var moveUp = function(node) {
    var $node = getJQueryNode(node);
    $node.after($node.prev());
};

var insertAfterIndex = function(node, index) {
    var $node = getJQueryNode(node);
    $node.parent().children().eq(index).after($node);
};

var insertSVGAfter = function(container, element, text, insertAfter) {
    text = text || element.text;
    delete element.text;
    return addSVGElement(container,element,text,insertAfter);
};

var prependSVGElement = function(container, element, text) {
    text = text || element.text;
    delete element.text;
    return addSVGElement(container,element,true,text);
};

var appendSVGElement = function(container, element, text) {
    text = text || element.text;
    delete element.text;
    return addSVGElement(container,element,false,text);
};

var prependToRoot = function(element) {
    if(!element.root.hasChildNodes()) {
        element.instance(element.root.appendChild(element.instance()));
    } else {
        element.instance(element.root.insertBefore(element.instance(), element.root.childNodes[0]));
    }
};

var addSVGElement = function(container, element, prepend, text, insertAfter) {
    prepend = (object.isDefined(prepend))? prepend : false;
    // If only the container is given we assume its an SVGElement object with contained root node
    if(object.isDefined(container) && !object.isDefined(element)) {
        element = container;
        container = container.getRootNode();
    } else if(object.isString(container)) {
        container = query(container)[0];
    } else if(container.instance) {
        container = container.instance();
    }

    var instance;

    if(!element.instance || !object.isDefined(element.instance())) {
        instance = document.createElementNS("http://www.w3.org/2000/svg", element.tagName);
        $.each(element.attributes, function(key, value) {
            instance.setAttribute(key, value.toString());
        });
    } else {
        instance = element.instance();
    }

    if(object.isDefined(text)) {
        var txtNode = document.createTextNode(text);
        instance.appendChild(txtNode);
    }
    if(object.isDefined(insertAfter)) {
        //if the parents lastchild is the targetElement...
        if(container.lastchild == insertAfter) {
            //add the newElement after the target element.
            container.appendChild(instance);
        } else {
            // else the target has siblings, insert the new element between the target and it's next sibling.
            container.insertBefore(instance, insertAfter.nextSibling);
        }
    } else if(!prepend || !container.hasChildNodes() ) {
        instance = container.appendChild(instance);
    } else {
        instance = container.insertBefore(instance,container.childNodes[0]);
    }

    if(object.isFunction(element.instance)) {
        element.instance(instance);
    } else {
        element.instance = instance;
    }

    return element;
};

var importSVG = function(container, svgXML, prepend) {
    var $svgXML, name, attributes;

    if(svgXML.jquery) {
        $svgXML = svgXML;
    } else if(object.isString(svgXML)) {
        $svgXML = $(parseXML(svgXML.trim()));
        $svgXML = $($svgXML.get(0).documentElement);
    } else {
        $svgXML = $(svgXML);
    }

    if($svgXML.nodeName) {
        name = $svgXML.nodeName;
        attributes = getAttributes($svgXML);
    } else {
        name = $svgXML.get(0).tagName;
        attributes = getAttributes($svgXML.get(0));
    }

    //We create a dummy element object
    var element = {
        tagName : name,
        attributes : attributes,
        instance : function(inst) {
            if(object.isDefined(inst)) {
                this.instanceElement = inst;
            } else {
                return this.instanceElement;
            }
        }
    };

    if(!prepend) {
        appendSVGElement(container, element, _getChildText($svgXML));
    } else {
        prependSVGElement(container, element, _getChildText($svgXML));
    }

    $svgXML.children().each(function(index, child) {
        importSVG(element.instance(), child);
    });

    return element.instance();
};

var _getChildText = function(node) {
    if(!node.jquery) {
        node = $(node);
    }

    var childText = node.contents().filter(function(){
        return this.nodeType === 3;
    });

    if(object.isDefined(childText) && childText.length > 0) {
        return childText[0].nodeValue;
    }
};

var getAttributes = function(node) {
    var result = {};
    $(node.attributes).each(function() {
        result[this.nodeName] = this.nodeValue;
    });
    return result;
};

var findIncludeSelf = function(node, selector) {
    return $(node).find(selector).andSelf().filter(selector).get(0);
};

var parseNodeXML = function(node) {
    if(!node) {
        return;
    }
    return $.parseXML($(node).text());
};

var parseXML = function(str) {
    return xml.parseXML(str);
};

var parseNodeJSON = function(node) {
    return $.parseJSON($(node).text());
};

var getRawId = function(idSelector) {
    if(!object.isString(idSelector)) {
        return;
    }

    if(idSelector.charAt(0) === '#') {
        return idSelector.substring(1, idSelector.length);
    } else {
        return idSelector;
    }
};

var getIdSelector = function(rawId) {
    if(!object.isString(rawId)) {
        return;
    }

    if (rawId.charAt(0) !== '#') {
        return '#' + rawId;
    } else {
        return rawId;
    }
};

module.exports = {
    appendSVGElement : appendSVGElement,
    prependSVGElement : prependSVGElement,
    insertSVGAfter : insertSVGAfter,
    insertAfterIndex : insertAfterIndex,
    create : create,
    prependToRoot : prependToRoot,
    importSVG : importSVG,
    moveDown : moveDown,
    moveUp : moveUp,
    findIncludeSelf : findIncludeSelf,
    parseNodeXML : parseNodeXML,
    parseNodeJSON : parseNodeJSON,
    getAttributes : getAttributes,
    getRawId : getRawId,
    getIdSelector: getIdSelector
};
},{"../util/object":71,"../util/xml":74}],45:[function(require,module,exports){
var util = require('../util/util');
var object = util.object;
var dom = util.dom;

var Element = function(tagName, cfg, attributeSetter) {
    this.attributeSetter = attributeSetter || {};
    this.attributes = {};

    if(object.isObject(tagName)) {
        cfg = tagName;
        tagName = cfg.tagName;
        delete cfg.tagName;
    }

    this.tagName = tagName;

    if(object.isObject(cfg)) {
        if(cfg.children) {
            this.children = cfg.children;
            delete cfg.children;
        }

        this.single = cfg.single || false;
        delete cfg.single;

        //We assume all remaining cfg entries are attributes
        for(var attributeKey in cfg) {
            if(cfg.hasOwnProperty(attributeKey)) {
                this._setAttribute(attributeKey, cfg[attributeKey]);
            }
        }
    }
};

Element.prototype.instance = function(instance) {
    if(object.isDefined(instance)) {
        this.domInstance = instance;
        this.tagName = instance.tagName;
        this.loadAttributes(instance);
        return this;
    } else {
        return this.domInstance;
    }
};

/**
 * Loads all attributes from the dom instance into our attribute array except already existing attributes.
 * @param instance
 */
Element.prototype.loadAttributes = function(instance) {
    this.attributes = this.attributes || {};
    var attributes = dom.getAttributes(instance);
    for(var key in attributes) {
        if(attributes.hasOwnProperty(key) && !this.attributes[key]) {
            this._setAttribute(key, attributes[key], true);
        }
    }
};

Element.prototype.id = function(newId) {
    if(object.isString(newId)) {
        this._setAttribute('id',newId);
        return this;
    } else {
        return this.attr('id');
    }
};

Element.prototype.update = function() {
    for(attributeKey in this.attributeSetter) {
        if(this.attributeSetter.hasOwnProperty(attributeKey)) {
            this.updateAttribute(attributeKey);
        }
    }
};

Element.prototype.updateAttribute = function(key) {
    this._setAttribute(key, this.attributes[key]);
};

Element.prototype._setAttribute = function(key, value, prevDomSet) {
    // If first arg is object handle its properties as attributes
    if(object.isObject(key)) {
        for(var attribute in key) {
            if(object.isDefined(attribute) && key.hasOwnProperty(attribute)) {
                this._setAttribute(attribute, key[attribute]);
            }
        }
    } else {

        // Some elementtypes can transform specific types of attributes to special objects
        // which are able to render and set the values in a special way.
        if(!this.hasClass('noParse') && object.isString(value) && object.isDefined(this.attributeSetter[key])) {
            value = this.attributeSetter[key](value);
        }

        if(!object.isDefined(value) || value.length === 0) {
            return;
        }

        // Just transform stringlits values to arrays in case its a string list
        this.attributes[key] = value;

        // Directly set it to the SVG instance if already rendered
        if(this.domInstance && !prevDomSet) {
            var val = Element.getAttributeString(value);
            this.domInstance.setAttribute(key,val);
        }
    }
};

Element.prototype.hasClass = function(searchClass) {
    if(this.domInstance) {
        //Jquery hasclass does not work with svg elements
        var elementClass = ' '+ this.attr('class')+' ';
        return elementClass.indexOf(' '+searchClass+' ') > -1;
    }
};

Element.prototype.$ = function(selector) {
    if(!this.$domInstance && this.domInstance) {
        this.$domInstance = $(this.domInstance);
    }

    return (selector) ? this.$domInstance.find(selector) : this.$domInstance;
};

Element.getAttributeString = function(value) {
    var result = '';

    if(!object.isDefined(value)) {
        return '';
    }

    if(object.isArray(value)) {
        object.each(value, function(index, part) {
            result += (++index === value.length) ? part : part+' ';
        });
    } else {
        result = value.toString();
    }
    return result;
};

Element.getAttributeValueFromStringList = function(value) {
    if(object.isString(value) && value.indexOf(' ') > -1) {
        return value.split(/[\s]+/);
    } else {
        return value;
    }
};

Element.prototype.attrNumber = function(key, value) {
    var val = util.app.parseNumberString(this.attr(key, value));
    return (object.isDefined(value)) ? this : val;
};

Element.prototype.attr = function(attribute) {
    if(arguments.length > 1 && object.isDefined(arguments[1])) {
        //TODO: implement for mor thant 2
        var obj = {};
        obj[arguments[0]] = arguments[1];
        return this.attr(obj);
    } else if(object.isString(attribute)) {
        var result = this.attributes[attribute];
        if(!result && this.instance()) {
            result = this.attributes[attribute] =  this.$().attr(attribute);
        }
        return result;
    } else {
        this._setAttribute(attribute);
    }
    return this;
};

module.exports =  Element;

},{"../util/util":73}],46:[function(require,module,exports){
var object = require('../util/object');
var Vector = require('../util/math').Vector;
var math = require('../util/math');
var util = require("../util/util");

var AbstractPathDataType = function(type, absolute) {
    this.vector = new Vector();
    this.vector.add(type);
    this.absolute = absolute || true;
};

AbstractPathDataType.prototype.setAbsolute = function(absolute) {
    this.absolute = absolute || true;
    return this;
};

AbstractPathDataType.prototype.getType = function() {
    var type = this.value(0,0);
    return this.absolute ? type.toUpperCase() : type.toLowerCase();
};

AbstractPathDataType.prototype.value = function() {
    return this.vector.value(Array.prototype.slice.call(arguments));
};

AbstractPathDataType.prototype.setValue = function(pathArr, value) {
    return this.vector.setValue(pathArr, value);
};

AbstractPathDataType.prototype.insert = function(pathArr, values) {
    return this.vector.setValue(pathArr, values);
};

AbstractPathDataType.prototype.is = function(type) {
    return this.getType().toUpperCase() === type.toUpperCase();
};

AbstractPathDataType.prototype.to = function(pathArr, values) {
    //ABSTRACT
};

AbstractPathDataType.prototype.pointToString = function(p) {
    return p.x + ',' + p.y+' ';
};

AbstractPathDataType.prototype.getOrSet = function(index, value) {
    if(value) {
        this.setValue(index, value);
    } else {
        return this.value(index);
    }
}

/**
 * Vector = [['l'], {x:x, y:y}]
 */
var LineTo = function(p, absolute) {
    AbstractPathDataType.call(this, 'l', absolute);
    this.to(p);
};

util.inherits(LineTo, AbstractPathDataType);

LineTo.prototype.to = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(1,p);
};

LineTo.prototype.toString = function() {
    return this.getType()+this.pointToString(this.to());
};

LineTo.prototype.x = function(value) {
    if(value) {
        this.value(1).x = value
    }
    return this.value(1).x;
};

LineTo.prototype.y = function(value) {
    if(value) {
        this.value(1).y = value
    }
    return this.value(1).y;
};

LineTo.prototype.moveAlong = function(from, distance) {
    return math.Line.moveAlong(from, this.to(), distance);
};

var QBezier = function(controlP, toP, absolute) {
    AbstractPathDataType.call(this, 'l', absolute);
    this.control(controlP);
    this.to(toP);
};

util.inherits(QBezier, AbstractPathDataType);

QBezier.prototype.to = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(2,p);
};

QBezier.prototype.control = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(1,p);
};

QBezier.prototype.toString = function() {
    return this.getType()+this.pointToString(this.control())+this.pointToString(this.to());
};

var CBezier = function(controlP1, controlP2, toP, absolute) {
    AbstractPathDataType.call(this, 'c', absolute);
    this.control1(controlP1);
    this.control2(controlP2);
    this.to(toP);
};

util.inherits(CBezier, AbstractPathDataType);

CBezier.prototype.control = function(x,y) {
    return this.control1(x,y);
};

CBezier.prototype.control1 = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(1,p);
};

CBezier.prototype.control2 = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(2,p);
};

CBezier.prototype.to = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(3,p);
};

CBezier.prototype.toString = function() {
    return this.getType()+this.pointToString(this.control1())+this.pointToString(this.control2())+this.pointToString(this.to());
};

/**
 * calculates the nearest point of the bezier curve to the given position. since the CBezier does not know its start
 * point, we have to provide the from position as well as the search base position.
 * @param from
 * @param position
 * @returns {{point, location}|*}
 */
CBezier.prototype.getNearestPoint = function(from, position) {
    return math.bezier.nearestPointOnCurve(position, this.getCurve(from)).point;
};

CBezier.prototype.moveAlong = function(from, distance) {
    return math.bezier.moveAlong(this.getCurve(from), distance);
};

CBezier.prototype.getCurve = function(from) {
    return [from, this.control1(), this.control2(), this.to()];
}

var MoveTo = function(toP, absolute) {
    AbstractPathDataType.call(this, 'm', absolute);
    this.to(toP);
};

util.inherits(MoveTo, LineTo);

var Complete = function() {
    AbstractPathDataType.call(this, 'z');
};

util.inherits(Complete, AbstractPathDataType);

Complete.prototype.toString = function() {
    return this.getType();
};

var pathType = {
    z : function() { return new Complete() },
    m : function() { return new MoveTo(arguments[0]); },
    l : function() { return new LineTo(arguments[0]); },
    q : function() { return new QBezier(arguments[0], arguments[1]); },
    c : function() { return new CBezier(arguments[0], arguments[1],  arguments[2]); }
};

var PathData = function(def) {
    this.data = new Vector();
    if(object.isString(def)) {
        this.loadFromString(def);
    }
};

PathData.prototype.loadFromString = function(strVal) {
    var that = this;
    //'M100,100 Q200,200 300,300' --> ['M100,100 ', 'Q200,200 300,300']
    var definitions = strVal.split(/(?=[MmLlHhVvCcSsQqTtAaZz]+)/);
    //Each dType
    $.each(definitions, function(index, value) {
        var type = value.charAt(0);
        //'Q200,200 300,300 -> ['200,200', '300,300']
        var values = value.substring(1,value.length).trim().split(' ');
        //['200,200', '300,300'] -> [{x:200, y:200}, {x:300, y:300}]
        var points = [];
        $.each(values, function(i, coord) {
            var coordVals = coord.split(',');
            points.push(math.getPoint(parseFloat(coordVals[0]), parseFloat(coordVals[1])));
        });
        that.data.add(pathType[type.toLowerCase()].apply(undefined, points).setAbsolute((type == type.toUpperCase())));
    });
    return this;
};

PathData.prototype.getCorners = function() {
    var xMin, xMax, yMin, yMax;
    xMin = yMin = Number.POSITIVE_INFINITY;
    xMax = yMax = Number.NEGATIVE_INFINITY;

    this.data.each(function(index, pathPart) {
        if(pathPart.x && pathPart.y) {
            xMin = (xMin > pathPart.x()) ? pathPart.x() : xMin;
            yMin = (yMin > pathPart.y()) ? pathPart.y() : yMin;

            xMax = (xMax < pathPart.x()) ? pathPart.x() : xMax;
            yMax = (yMax < pathPart.y()) ? pathPart.y() : yMax;
        }
    });

    return [
        {x:xMin, y:yMin},
        {x:xMax, y:yMin},
        {x:xMax, y:yMax},
        {x:xMin, y:yMax}
    ];
};

PathData.prototype.getX = function() {
    return this.getCorners()[0].x;
};

PathData.prototype.getY = function() {
    return this.getCorners()[0].y;
};

PathData.prototype.polynoms = function() {
    var result = [];
    object.each(this.data.vectors, function(index, value) {
        if(value.to) {
            result.push(value.to());
        }
    });
    return result;
};

/**
 * Returns
 * @returns {Array}
 */
PathData.prototype.getPathParts = function() {
    var result = [];

    //We start at index 1 because the 0 index of the vector contains the pathpart type
    for(var i = 1; i <= this.length() - 1; i++) {
        result.push(this.getPathPart(i));
    }

    return result;
};

PathData.prototype.getPathPart = function(index) {
    var pathPart = this.value(index);
    return {
        start: this.value(index - 1).to(),
        end: pathPart.to(),
        value: pathPart
    };
};

PathData.prototype.moveAlong = function(index, distance, direction) {
    var pathPart = this.getPathPart(index);
    if(pathPart.value.moveAlong) {
        return pathPart.value.moveAlong(pathPart.start, distance, direction);
    } else {
        return math.Line.moveAlong(pathPart.start, pathPart.end, distance, direction);
    }
};

/**
 * Calculates the rough center of the path by calculating the total length of the pathparts (as direct lines) and moving
 * along those lines to the center (total length / 2). Note with this method we just get a exact result for simple
 * line paths. If the calculated center position is within a cubic bezier path part, we return the nearest point on the curve
 * to the calculated center.
 * @returns {*}
 */
PathData.prototype.getCenter = function() {
    var resultD = this.getDistance() / 2;
    var currentD = 0;
    var center;
    object.each(this.getPathParts(), function(index, part) {
        var lineD = math.Line.calcDistance(part.start, part.end);
        var nextD = currentD + lineD;
        if(nextD > resultD) {
            var diffD =  resultD - currentD;
            center = math.Line.moveAlong(part.start, part.end, diffD);

            //If we have a cubic bezier path part we calculate the nearest point on the curve
            if(part.value.is('c')) {
                center = part.value.getNearestPoint(part.start, center);
            }
            return false;
        }
        currentD = nextD;
    });
    return center;
};

PathData.prototype.getDistance = function() {
    var distance = 0;
    object.each(this.getPathParts(), function(index, part) {
        distance += math.Line.calcDistance(part.start, part.end);
    });
    return distance;
};

/**
 * Assuming there are only! cubic bezier curved path parts this function recalculates all control points of the curves
 * to smoothen the entire path.
 *
 * @param polynoms
 */
PathData.prototype.smoothen = function(polynoms) {
    if(!polynoms) {
        polynoms = this.polynoms();
    }

    var x = [];
    var y = [];

    object.each(polynoms, function(index, value) {
        x[index] = value.x;
        y[index] = value.y;
    });

    var px = math.bezier.calculateSmoothControlPoints(x);
    var py = math.bezier.calculateSmoothControlPoints(y);

    var that = this;
    object.each(px.p1, function(index, value) {
        that.value(index + 1).control1(px.p1[index], py.p1[index]);
        that.value(index + 1).control2(px.p2[index], py.p2[index]);
    });
    return this;
};

PathData.prototype.getLineByPathIndex = function(index, fromEnd) {
    var startIndex = (fromEnd)  ? (index + 1) * -1 : index;
    var endIndex =   (fromEnd)  ? (index + 2) * -1 : index + 1;
    var p1 = this.value(startIndex).to();
    var p2 = this.value(endIndex).to();
    return new math.Line(p1, p2);
};

PathData.prototype.getPathIndexForPosition = function(point) {

    if(this.length() === 2) {
        //If there is just the start and end docking we know the new index
        return 1;
    }

    var dockingIndex = 1;
    var candidate = [1,Number.POSITIVE_INFINITY ];

    object.each(this.getPathParts(), function(index, part) {
        //Sort out pathparts which are not within the boundary of start/end points with a little tolerance of 10px
        var p = new util.math.Point(point);
        if(p.isWithinXInterval(part.start, part.end, 10)) {
            var d;
            var line = new math.Line(part.start, part.end);

            if(!line.isVertical()) {
                d = Math.abs(line.calcFX(point.x).y - point.y)
            } else if(p.isWithinYInterval(part.start, part.end)) {
                //Since the point is within x (with tolerance) and y interval we calculate the x distance
                d = Math.abs(part.start.x - p.x);
            }

            if (candidate === undefined || candidate[1] > d) {
                //The pathPartindex is the arrayindex + 1 since we use the end index of the path as identity
                candidate[0] = index + 1;
                candidate[1] = d;
            }
        }
    });

    if (candidate) {
        return candidate[0];
    }
};

var _getDForVertical = function(part, point) {
    if(util.math.checkRange())
    var min = Math.min(part.start.y, part.end.y);
    var max = Math.max(part.start.y, part.end.y);
    if (point.y <= max && point.y >= min) {

    }
};

/*
 LinePathManager.prototype.getGradien = function(x,y) {
 var position = util.math.getPoint(x,y);
 var index = this.transition.getKnobIndexForPoint(position);
 var p1 = this.data.getDockingByIndex(index).position();
 var p2 = this.data.getDockingByIndex(index + 1).position();
 return util.math.Line.calcGradient(p1, p2);
 };

 LinePathManager.prototype.getGradientByIndex = function(index) {
 var p1 = this.data.getDockingByIndex(index).position();
 var p2 = this.data.getDockingByIndex(index + 1).position();
 return util.math.Line.calcGradient(p1, p2);
 };


 LinePathManager.prototype.getVectorByIndex = function(index, fromEnd) {
 var p1, p2;
 if(fromEnd) {
 p1 = this.data.getDockingByEndIndex(index + 1).position();
 p2 = this.data.getDockingByEndIndex(index).position();
 } else {
 p1 = this.data.getDockingByIndex(index).position();
 p2 = this.data.getDockingByIndex(index + 1).position();
 }
 return util.math.Line.calcNormalizedLineVector(p1, p2);
 };
 */

PathData.prototype.getY = function(value) {
    return this.getCorners()[0].y;
};

PathData.prototype.getRightX = function(value) {
    return this.getCorners()[1].x;
};

PathData.prototype.getBottomY = function(value) {
    return this.getCorners()[2].y;
};

PathData.prototype.setData = function(value) {
    if(object.isArray(value)) {
        this.data = value;
    }
};

PathData.prototype.clear = function() {
    this.data.clear();
    return this;
};

PathData.prototype.length = function() {
    return this.data.length();
};

PathData.prototype.value = function(index) {
    return this.data.value(index);
};

PathData.prototype.valueByType = function(index, type) {
    var count = 0;
    var result;

    object.each(this.data.vectors, function(i, value) {
       if(value.is(type) && count++ === index) {
           result = value;
           return false;
       }
    });

    return result;
}

PathData.prototype.start = function(p, absolute) {
    if(arguments.length === 0) {
        return this.value(0).to();
    }
    this.data.setValue(0, new MoveTo(p, absolute));
    return this;
};

PathData.prototype.end = function(value) {
    if(value) {
        return this.data.last().to(value);
    } else {
        return this.data.last().to();
    }
};

/**
 * TODO: refactor to setTo
 * @param index
 * @param value
 * @returns {PathData}
 */
PathData.prototype.setTo = function(index, value) {
    this.data.value(index).to(value);
    return this;
};

PathData.prototype.removePath = function(index) {
    this.data.remove(index);
    return this;
};

PathData.prototype.complete = function() {
    this.data.add(new Complete());
    return this;
};

PathData.prototype.line = function(x,y) {
    var p = math.getPoint(x,y);
    this.data.add(new LineTo(p, true));
    return this;
};

PathData.prototype.cBezier = function(c1, c2, to) {
    this.data.add(new CBezier(c1,c2, to, true));
    return this;
};

/**
 * TODO: Line to
 * @param index
 * @param value
 * @param absolute
 * @returns {PathData}
 */
PathData.prototype.insertLine = function(index, to, absolute) {
    this.data.insert(index, new LineTo(to,absolute));
    return this;
};

PathData.prototype.qBezier = function(controlP,toP) {
    this.data.add(new QBezier(controlP,toP, true));
    return this;
};

PathData.prototype.insertQBezier = function(index,c, to, absolute) {
    this.data.insert(index, new QBezier(to,absolute));
    return this;
};

PathData.prototype.insertCBezier = function(index, c1, c2, to, absolute) {
    this.data.insert(index, new CBezier(c1,c2, to,absolute));
    return this;
};

PathData.prototype.toString = function() {
    var result = '';
    var that = this;
    this.data.each(function(index, pathPart) {
       result += pathPart.toString();
    });
    return result.trim();
};

module.exports = PathData;
},{"../util/math":70,"../util/object":71,"../util/util":73}],47:[function(require,module,exports){
var DomElement = require('../dom/domElement');
var Style = require('./style');
var util = require('../util/util');
var dom = util.dom;
var object = util.object;

/*
 * Constructor for SVG Elements
 *
 * @param {type} name the element Name e.g. rect, circle, path...
 * @param {type} cfg attributes and additional configurations
 * @param {type} attributeSetter you can add additional attribute setter
 * for special attributes default attribute setter given by this impelementation
 * are transform and style setter
 */
var SVGElement = function(name, svg, cfg, attributeSetter) {
    this.attributeSetter = attributeSetter || {};
    this.attributeSetter.style = this.styleAttributeSetter;
    this.SVGElement = true;

    // If first attribute is not a string we assume a svg node constructor call.
    if(!object.isString(name)) {
        this.instance(name);
        cfg = dom.getAttributes(name);
        name = name.tagName;
    }

    this.svg = svg;
    this.root = svg.root || this;
    DomElement.call(this, name, cfg, this.attributeSetter);
};

util.inherits(SVGElement, DomElement);

SVGElement.prototype.styleAttributeSetter = function(trnasformationString) {
    return new Style(trnasformationString);
};

SVGElement.prototype.getRootNode = function() {
    return this.root.instance();
};

SVGElement.prototype.append = function(element) {
    var result;
    if(arguments.length > 1) {
        result = [];
        var that = this;
        object.each(arguments, function(index, val) {
            result.push(that.append(val));
        })
    } else if(arguments.length === 1) {
        result =  util.dom.appendSVGElement(this.instance(), element);
    }
    return result;
};

SVGElement.prototype.prepend = function(element) {
    var result;
    if(arguments.length > 1) {
        result = [];
        var that = this;
        object.each(arguments, function(index, val) {
            result.push(that.prepend(val));
        })
    } else if(arguments.length === 1) {
        result =  util.dom.prependSVGElement(this.instance(), arguments[0]);
    }
    return result;
};

SVGElement.prototype.remove = function() {
    this.$().remove();
};

SVGElement.prototype.firstChild = function() {
    return $.qCache().svg(this.$().children().first());
};

SVGElement.prototype.down = function() {
    dom.moveDown(this.instance());
};

SVGElement.prototype.up = function() {
    dom.moveUp(this.instance());
};

SVGElement.prototype.back = function() {
    dom.prependToRoot(this);
    return this;
};

/**
 * SVG Styles
 */

SVGElement.prototype.style = function(key, value) {
    if(!object.isDefined(value) && object.isString(key) && key.indexOf(':') <= 0
        && object.isDefined(this.attributes.style)) {
        //GETTER CALL
        return this.attributes.style.get(key);
    } else if(!object.isDefined(this.attributes.style) && object.isDefined(value)) {
        this.attributes.style = new Style(key, value);
    } else if(object.isDefined(value)) {
        this.attributes.style.set(key, value);
    } else {
        return;
    }
    this.updateAttribute('style');
    return this;
};

SVGElement.prototype.dala = function(key, value) {
    return this.attr('dala:'+key, value);
};

SVGElement.prototype.getBBox = function() {
    return this.instance().getBBox();
};

SVGElement.prototype.getBoundingClientRect = function() {
    return this.instance().getBoundingClientRect();
}

/**
 * SVG Eventhandling
 */

SVGElement.prototype.trigger = function(evt, args) {
    this.$().trigger(evt, args);
    return this;
};

SVGElement.prototype.on = function(evt, handler) {
    this.$().on(evt, handler);
    return this;
};

SVGElement.prototype.one = function(evt, handler) {
    this.$().one(evt, handler);
    return this;
};

SVGElement.prototype.off = function(evt) {
    this.$().off(evt);
    return this;
};

SVGElement.prototype.trigger = function(evt) {
    this.$().trigger(evt);
    return this;
};

SVGElement.prototype.toString = function() {
    return util.xml.serializeToString(this.instance());
};

module.exports = SVGElement;

},{"../dom/domElement":45,"../util/util":73,"./style":58}],48:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGEllipse = require('./ellipse');
var SVGShape = require('./genericShape');

var SVGCircle = function(svgRoot, cfg) {
    cfg = cfg || {};
    SVGShape.call(this, 'circle', svgRoot, cfg);
};

util.inherits(SVGCircle, SVGEllipse);

SVGCircle.prototype.r = function(value) {
    if((object.isBoolean(value) && value) || !object.isDefined(value)) {
        return this.attrNumber('r') + this.strokeWidth() / 2;
    } else if(object.isBoolean(value)) {
        return this.attrNumber('r');
    } else {
        this.attrNumber('r', value);
        return this;
    }
};

SVGCircle.prototype.height = function(value) {
    if(!object.isDefined(value) || object.isBoolean(value)) { //Getter
        return SVGCircle.super_.prototype.height.apply(this, [value]);
    } else { //Setter
        var v = value / 2;
        this.cy(v).cx(v).r(v);
        return this;
    }
};

SVGCircle.prototype.width = function(value) {
    return this.height(value);
};

SVGCircle.prototype.rx = function(value) {
    return this.r(value);
};

SVGCircle.prototype.ry = function(value) {
    return this.r(value);
};

SVGCircle.prototype.overlayCheck = function(position) {
    return new util.math.Circle(this.getCenter(), this.r()).overlays(position);
};

module.exports = SVGCircle;
},{"../util/object":71,"../util/util":73,"./ellipse":52,"./genericShape":53}],49:[function(require,module,exports){
var DragConfig = function() {
    this.hooks = {};
};

DragConfig.prototype.xOnly = function() {
    this.hooks.restrictionY = function(event, dx, dy) {
        return 0;
    };
    return this;
};

DragConfig.prototype.yOnly = function() {
    this.hooks.restrictionX = function(event, dx, dy) {
        return 0;
    };
    return this;
};

DragConfig.prototype.getScale = function(gsHook) {
    this.hooks.getScale = gsHook;
    return this;
};

DragConfig.prototype.dragMove = function(drmHook) {
    this.hooks.dragMove = drmHook;
    return this;
};

DragConfig.prototype.dragStart = function(drsHook) {
    this.hooks.dragStart = drsHook;
    return this;
};

DragConfig.prototype.dragEnd = function(dreHook) {
    this.hooks.dragEnd = dreHook;
    return this;
};

DragConfig.prototype.restrictionX = function() {
    return this.hooks.restrictionX;
};

DragConfig.prototype.restrictionY = function() {
    return this.hooks.restrictionY;
};

DragConfig.prototype.get = function() {
    return this.hooks;
};

module.exports = DragConfig;
},{}],50:[function(require,module,exports){
var SVGShape = require('./genericShape');
var util = require('../util/util');
var event = require('../core/event');

var object = util.object;
var dom = util.dom;

var ShiftDrag = function(cfg) {
    this.cfg = cfg;
    if(!cfg.restrictionX && !cfg.restrictionY) {
        this.init();
    } else {
        this.disable();
    }
};

ShiftDrag.prototype.init = function() {
    this.state = 'init';
    this.xShift = {
        shiftAlign : 0,
        unshiftAlign : 0
    };

    this.yShift = {
        shiftAlign : 0,
        unshiftAlign : 0
    };
};

ShiftDrag.prototype.disable = function() {
    this.state = 'disabled';
};

ShiftDrag.prototype.update = function(evt, dx ,dy) {
    var that = this;
    switch(this.state) {
        case 'init' :
            this.xShift.shiftAlign += dx;
            this.yShift.shiftAlign += dy;

            if(this.checkShiftHook(evt)) {
                if(Math.abs(this.xShift.shiftAlign) > Math.abs(this.yShift.shiftAlign)) {
                    this.restrictionX = undefined;
                    this.restrictionY = function(evt, dx ,dy) {
                        return that.shiftRestriction(that.yShift, dy);
                    };
                    this.state = 'shiftedX';
                } else {
                    this.restrictionY = undefined;
                    this.restrictionX = function(evt, dx , dy) {
                        return that.shiftRestriction(that.xShift, dx);
                    };
                    this.state = 'shiftedY';
                }
            }
            break;
        case 'shiftedX':
            if(!evt.shiftKey) {
                this.restrictionY = function(evt, dx, dy) {
                    return that.unShiftRestriction(that.yShift, dy);
                };
                this.state = 'init';
            }
            break;
        case 'shiftedY':
            if(!evt.shiftKey) {
                this.restrictionX = function(evt, dx ,dy) {
                    return that.unShiftRestriction(that.xShift, dx);
                };
                this.state = 'init';
            }
            break;
    }
};


ShiftDrag.prototype.shiftRestriction = function(shiftData, d) {
    //Update shifted d
    shiftData.unshiftAlign += d;
    //Align shift drag back to the start position
    var result = (Math.abs(shiftData.shiftAlign) > 0) ? shiftData.shiftAlign * -1 : 0;
    shiftData.shiftAlign = 0;
    return result;
};

ShiftDrag.prototype.unShiftRestriction = function(shiftData, d) {
    //Align shift drag back to the start position
    var result = shiftData.unshiftAlign + d;
    shiftData.unshiftAlign = 0;
    return result;
};

ShiftDrag.prototype.checkShiftHook = function(evt) {
    return evt.shiftKey && (Math.abs(this.xShift.shiftAlign) > 4 || Math.abs(this.yShift.shiftAlign) > 4);
};

//TODO: this would be more elegant to use the alignment align center to center.x if checkShiftHook

ShiftDrag.prototype.getRestrictionX = function() {
    return this.cfg.restrictionX || this.restrictionX;
};

ShiftDrag.prototype.getRestrictionY = function() {
    return this.cfg.restrictionY || this.restrictionY;
};

SVGShape.prototype.draggable = function(cfg, dragElement) {
    var cfg = cfg || {};

    if(!object.isDefined(dragElement)) {
        dragElement = this.instance();
    }

    var that = this;

    var dragMove = function(evt) {
        if(evt.preventDefault) {
            evt.preventDefault();
        }

        if(!evt.triggerEvent) {
            that.attr('pointer-events', 'none');
        }

        var actualdx = (object.isDefined(evt.dx)) ? evt.dx : evt.clientX - that.dragCurrentX;
        var actualdy = (object.isDefined(evt.dy)) ? evt.dy : evt.clientY - that.dragCurrentY;

        // DRAG BEFORE HOOK
        if(cfg.dragBeforeMove) {
            cfg.dragBeforeMove.apply(that, [evt, actualdx, actualdy, dragElement]);
        }

        // DRAG ALIGNMENT
        if(cfg.dragAlignment && !evt.triggerEvent) {
            var alignment = cfg.dragAlignment.check(actualdx, actualdy);
            actualdx = alignment.dx;
            actualdy = alignment.dy;
        }

        //Check for shiftDrag restriction, shiftDrag will only hook up if no other restriction is set.
        //Shiftdrag is not given for triggerdrags
        if(that.shiftDrag && !evt.triggerEvent) {
            that.shiftDrag.update(evt, actualdx, actualdy);
            var restrictionX = that.shiftDrag.getRestrictionX();
            var restrictionY = that.shiftDrag.getRestrictionY();
        }

        // DRAG RESTRICTION
        var dx = (restrictionX && !evt.triggerEvent) ? restrictionX.apply(that, [evt, actualdx, actualdy]) : actualdx;
        var dy = (restrictionY && !evt.triggerEvent) ? restrictionY.apply(that, [evt, actualdx, actualdy]) : actualdy;

        //TODO: somehow the scale should be determined in a more elegant way perhaps store it in svg instance...
        if(cfg.getScale && !evt.triggerEvent) {
            var scale = cfg.getScale();
            dx /= scale;
            dy /= scale;
        }

        // EXECUTE DRAG
        if(dx !== 0 || dy !== 0) {
            that.move(dx, dy);
        }

        var evtData = getMouseEventData(evt);
        // Keep track of current mouse position
        that.dragCurrentX = evtData.clientX;
        that.dragCurrentY = evtData.clientY;

        that.dxSum += dx;
        that.dySum += dy;

        // DRAG MOVE HOOK
        if(cfg.dragMove) {
            cfg.dragMove.apply(that, [evt, dx, dy, dragElement]);
        }
    };

    var dragEnd = function(evt) {
        evt.preventDefault();
        //Turn off drag events
        event.off(that.getRootNode(), 'mousemove');
        event.off(document, 'mouseup', dragEnd);

        if(cfg.dragAlignment) {
            cfg.dragAlignment.reset();
        }

        this.drag = false;

        if(cfg.cursor) {
            $('body').css('cursor','default');
        }

        // DRAG END HOOK
        if(cfg.dragEnd) {
            cfg.dragEnd.apply(that, [evt]);
        }

        that.attr('pointer-events', 'all');
    };

    if(dragElement) {
        var evtType = (cfg.once)? event.once : event.on;
        evtType(dragElement,'mousedown', function(e) {
            if(e.ctrlKey || !that.isVisible()) {
                return;
            }
            e.preventDefault();
            // We stop the event propagation to prevent the document mousedown handler to fire
            e.stopPropagation();

            initDragValues(that, e, cfg);

            // DRAG START HOOK
            if(cfg.dragStart) {
                cfg.dragStart.apply(that, [e]);
            }

            if(cfg.cursor) {
                $('body').css('cursor', cfg.cursor);
            }

            that.drag = true;
            event.on(that.getRootNode(), 'mousemove', dragMove);
            event.on(document, 'mouseup', dragEnd);
        });
    }

    //Simulates an drag start event
    this.initDrag = function() {
        $(dragElement).trigger('mousedown');
    };

    //For manual dragging a svg element the triggerEvent is used to identify this event was triggered manually
    //See Selectionmanager setNodeSelection dragMove handler
    this.triggerDrag = function(dx, dy) {
        dragMove.apply(this,[{dx:dx, dy:dy, triggerEvent:true}]);
    };

    return this;
};

var initDragValues = function(that, evt, cfg) {
    that.dxSum = 0;
    that.dySum = 0;
    that.shiftDrag = new ShiftDrag(cfg);
    var evtData = getMouseEventData(evt);
    that.dragCurrentX = evtData.clientX;
    that.dragCurrentY = evtData.clientY;

    that.drag = true;
};

var getMouseEventData = function(evt) {
    if(!evt.clientX) {
        return event.mouse();
    }
    return evt;
};
},{"../core/event":7,"../util/util":73,"./genericShape":53}],51:[function(require,module,exports){
var shapes = {}
shapes.svg = shapes.Svg = require('./svgRoot');
shapes.circle = shapes.Circle = require('./circle');
shapes.ellipse = shapes.Ellipse = require('./ellipse');
shapes.text = shapes.Text = require('./text');
shapes.tspan = shapes.TSpan = require('./tspan');
shapes.path = shapes.Path = require('./path');
shapes.rect = shapes.Rect = require('./rect');
shapes.g = shapes.Group = require('./group');
module.exports = shapes;
},{"./circle":48,"./ellipse":52,"./group":54,"./path":55,"./rect":57,"./svgRoot":61,"./text":62,"./tspan":64}],52:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./genericShape');

var SVGEllipse = function(svgRoot, cfg) {
    cfg = cfg || {};
    SVGShape.call(this, 'ellipse', svgRoot, cfg);
};

util.inherits(SVGEllipse, SVGShape);

SVGEllipse.prototype.x = function() {
    return this.cx() - this.rx();
};

SVGEllipse.prototype.height = function(value) {
    if(!object.isDefined(value) || object.isBoolean(value)) {
        return this.ry(value) * 2;
    } else {
        //When setting the height of an ellipse we move the center to not change the x/y
        var v = value / 2;
        this.cy(v).ry(v);
        return this;
    }
};

SVGEllipse.prototype.width = function(value) {
    if(!object.isDefined(value) || object.isBoolean(value)) {
        return this.rx(value) * 2;
    } else {
        //When setting the height of an ellipse we move the center to not change the x/y
        var v = value / 2;
        this.cx(v).rx(v);
        return this;
    }
};

SVGEllipse.prototype.x = function() {
    return this.cx() - this.rx();
};

SVGEllipse.prototype.y = function() {
    return this.cy() - this.ry();
};

SVGEllipse.prototype.rightX = function() {
    return this.cx() + this.rx();
};

SVGEllipse.prototype.getCenter = function() {
    return {
        x : this.cx(),
        y : this.cy()
    };
};

SVGEllipse.prototype.bottomY = function() {
    return this.cy() + this.ry();
};

SVGEllipse.prototype.cx = function(value) {
    if(!value) {
        return this.translatedX(this.attrNumber('cx'));
    } else {
        this.attr('cx', value);
        return this;
    }
};

SVGEllipse.prototype.cy = function(value) {
    if(!value) {
        return this.translatedY(this.attrNumber('cy'));
    } else {
        this.attr('cy', value);
        return this;
    }
};

SVGEllipse.prototype.rx = function(value) {
    if((!object.isDefined(value) || object.isBoolean(value) && value)) {
        return this.attrNumber('rx') + this.strokeWidth() / 2;
    } else if(object.isBoolean(value)) {
        return this.attrNumber('rx');
    } else {
        this.attrNumber('rx', value);
        return this;
    }
};

SVGEllipse.prototype.ry = function(value) {
    if((!object.isDefined(value) || object.isBoolean(value) && value)) {
        return this.attrNumber('ry') + this.strokeWidth() / 2;
    } else if(object.isBoolean(value)) {
        return this.attrNumber('ry');
    } else {
        this.attrNumber('ry', value);
        return this;
    }
};

SVGEllipse.prototype.overlayCheck = function(position) {
    return new util.math.Ellipse(this.getCenter(), this.rx(), this.ry()).overlays(position);
};

/*
SVGElement.prototype.overlayCheck = function(position) {

};*/

module.exports = SVGEllipse;
},{"../util/object":71,"../util/util":73,"./genericShape":53}],53:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var Transform = require('./transform');

var SVGElement = require('./SVGElement');

var SVGShape = function(name, svgRoot, cfg, attributeSetter) {
    cfg = cfg || {};
    this.attributeSetter = attributeSetter || {};
    this.attributeSetter.transform = this.transformationAttributeSetter;
    SVGElement.call(this, name, svgRoot, cfg, attributeSetter);
};

util.inherits(SVGShape, SVGElement);

SVGShape.prototype.transformationAttributeSetter = function(trnasformationString) {
    return new Transform(trnasformationString);
};

SVGShape.prototype.getTransformation = function() {
    if(!this.attributes.transform) {
        this.attributes.transform = new Transform();
    } else if(object.isString(this.attributes.transform)) {
        this.attributes.transform = new Transform(this.attributes.transform);
    }
    return this.attributes.transform;
};

SVGShape.prototype.scale = function(scale) {
    var result = this.getTransformation().scale(scale);

    if(result instanceof Transform) {
        // The trnaslate setter returns the Transform object so we reset thestyle
        // transform attribute in dom (setter was called)
        this.updateAttribute('transform');
        return this;
    } else {
        // The getter just returns the x,y values of the translate transformation
        return result;
    }
};

SVGShape.prototype.translate = function(x, y) {
    var result = this.getTransformation().translate(x,y);

    if(result instanceof Transform) {
        // The trnaslate setter returns the Transform object so we reset the
        // transform attribute in dom (setter was called)
        this.updateAttribute('transform');
        return this;
    } else {
        // The getter just returns the x,y values of the translate transformation
        return result;
    }
};

SVGShape.prototype.translated = function(position) {
    var translate = this.getTransformation().translate();
    return {
        x : translate.x + position.x,
        y : translate.y + position.y
    }
};

SVGShape.prototype.translatedX = function(px) {
    var translate = this.getTransformation().translate();
    px = (object.isDefined(px)) ? px : 0;
    return translate.x + px;
};

SVGShape.prototype.translatedY = function(py) {
    var translate = this.getTransformation().translate();
    py = (object.isDefined(py)) ? py : 0;
    return translate.y + py;
};

SVGShape.prototype.hasTransformation = function(transformation) {
    if(object.isDefined(this.attributes.transform)) {
        return (object.isDefined(this.attributes.transform[transformation]));
    }
};

SVGShape.prototype.fill = function(color) {
    return this.style('fill', color);
};

SVGShape.prototype.fillOpacity = function(opacity) {
    return this.style('fill-opacity', opacity);
};

SVGShape.prototype.strokeOpacity = function(opacity) {
    return this.style('stroke-opacity', opacity);
};

SVGShape.prototype.stroke = function(color, width) {
    if(width) {
        this.strokeWidth(width);
    }
    return this.style('stroke', color);

};

SVGShape.prototype.strokeDasharray = function(type) {
    if(!type) {
        return this.style('stroke-dasharray');
    }
    if(object.isString(type)) {
        this.style('stroke-dasharray', type);
    } else {

    }
};

SVGShape.prototype.strokeDashType = function(type) {
    if(!type) {
        switch(this.strokeDasharray()) {
            case "5,5":
                return 1;
            case "10,10":
                return 2;
            case "20,10,5,5,5,10":
                return 3;
            default:
                return 0;
        }
    } else {
        switch(type) {
            case '1':
            case 1:
                this.strokeDasharray("5,5");
                break;
            case '2':
            case 2:
                this.strokeDasharray("10,10");
                break;
            case '3':
            case 3:
                this.strokeDasharray("20,10,5,5,5,10");
                break;
            default:
                this.strokeDasharray("none");
                break;
        }
    }
};

SVGShape.prototype.strokeWidth = function(width) {
    return util.app.parseNumberString(this.style('stroke-width', width)) || 0;
};

SVGShape.prototype.isVisible = function() {
    return (!this.fillOpacity() || this.fillOpacity() > 0)
        && (!this.strokeOpacity() || this.strokeOpacity() > 0);
};

SVGShape.prototype.hide = function() {
    this.fillOpacity(0);
    this.strokeOpacity(0);
};

SVGShape.prototype.show = function(opacity) {
    opacity = opacity || 1;
    this.fillOpacity(opacity);
    this.strokeOpacity(opacity);
};

/**
 * Determines the location of a given position relative to the svg element.
 *      _t_
 *    |\   /|
 *  l |  c  | r
 *    |/___\|
 *       b
 * @param node
 * @param position
 * @returns {*}
 */
SVGShape.prototype.getRelativeLocation = function(position) {
    //First we check if the point lies direct on the boundary
    if(position.x === this.x()) {
        return 'left';
    } else if(position.y === this.y()) {
        return 'top';
    } else if(position.x === this.getRightX()) {
        return 'right';
    } else if(position.y === this.getBottomY()) {
        return 'bottom';
    }

    //If its not on the boundary we check the location by means of the line gradient
    var center = this.getCenter();
    var g = util.math.Line.calcGradient(center, position);
    if(position.y < center.y) { //position over elementcenter
        if (position.x >= center.x) { //position right (or eq) of elementcenter
            return (g > -1) ? 'right' : 'top';
        } else if (g < 1) {//position left and over of elementcenter
            return (g < 1) ? 'left' : 'top';
        }
    } else if(position.x >= center.x) { //position under (or eq) and right (or eq) of elementcenter
        return (g < 1) ? 'right' : 'bottom';
    } else { //position under and left of elementcenter
        return (g < -1) ? 'bottom' : 'left';
    }
};

SVGShape.prototype.x = function() {
    return this.translatedX(0);
};

SVGShape.prototype.y = function() {
    return this.translatedY(0);
};

SVGShape.prototype.position = function() {
    var that = this;
    return {
        x : that.x(),
        y : that.y()
    };
};

SVGShape.prototype.getCenter = function() {
    return {
        x: this.x() + Math.floor(this.width() / 2),
        y: this.y() + Math.floor(this.height() / 2)
    };
};

SVGShape.prototype.overlays = function() {
    var result = false;
    var that = this;
    object.each(arguments, function(index, position) {
        if(that.overlayCheck(position)) {
            result = true;
            return false; //TO break the each loop
        }
    });
    //console.log('result:'+result);
    return result;
};

/**
 * This is a default implementation for checking if a given position lies within the svgElement.
 * This can be overwritten by shapes like circles and ellipse..
 */
SVGShape.prototype.overlayCheck = function(position) {
    return position.x >= this.x() && position.x <= this.getRightX()
        && position.y >= this.y() && position.y <= this.getBottomY();
};

SVGShape.prototype.move = function(dx, dy) {
    var translate = this.translate();
    this.translate(translate.x + dx, translate.y + dy);
    return this;
};

SVGShape.prototype.moveTo = function(x, y) {
    var p = util.math.getPoint(x,y);

    var translate = this.translate();
    if(this.x() !== p.x || this.y() !== p.y) {
        //TODO: this does not consider x/y attribute settings
        this.translate(p);
    }
    return this;
};

SVGShape.prototype.moveX = function(x) {
    var translate = this.translate();
    if(translate.x !== x) {
        this.translate(x, translate.y);
    }
    return this;
};

SVGShape.prototype.moveY = function(y) {
    var translate = this.translate();
    if(translate.y !== y) {
        return this.translate(translate.x, y);
    }
    return this;
};

/**
 * Note: the implementation of getBBox differs between browsers some add the sroke-width and some do not add stroke-width
 */
SVGShape.prototype.height = function() {
    return this.getBBox().height;
};

SVGShape.prototype.width = function() {
    return this.getBBox().width;
};

SVGShape.prototype.getBottomY = function() {
    return this.y() + this.height();
};

SVGShape.prototype.getRightX = function() {
    return this.x() + this.width();
};

module.exports = SVGShape;
},{"../util/object":71,"../util/util":73,"./SVGElement":47,"./transform":63}],54:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./genericShape');

var SVGGroup = function(svgRoot, cfg) {
    cfg = cfg || {};
    SVGShape.call(this, 'g', svgRoot, cfg);
};

util.inherits(SVGGroup, SVGShape);

module.exports = SVGGroup;
},{"../util/object":71,"../util/util":73,"./genericShape":53}],55:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./genericShape');
var PathData = require('./pathData');

var SVGPath = function(svgRoot, cfg) {
    cfg = cfg || {};
    this.attributeSetter = { d : SVGPath.pathDataAttributeSetter};
    SVGShape.call(this, 'path', svgRoot, cfg, this.attributeSetter);
};

util.inherits(SVGPath, SVGShape);

SVGPath.pathDataAttributeSetter = function(pathDataString) {
    return new PathData(pathDataString);
};

SVGPath.prototype.x = function() {
    return this.d().getX();
};

SVGPath.prototype.y = function() {
    return this.d().getY();
};

SVGPath.prototype.d = function(pathData) {
    if(object.isString(pathData)) {
        this.attributes.d = new PathData(pathData);
        this.updateAttribute('d');
        return this;
    } else if(object.isDefined(pathData)) {
        this.attributes.d = pathData
        this.updateAttribute('d');
        return this;
    } else if(!object.isDefined(this.attributes.d)) {
        this.attributes.d = new PathData();
    }
    return this.attributes.d;
};

module.exports = SVGPath;
},{"../util/object":71,"../util/util":73,"./genericShape":53,"./pathData":56}],56:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"../util/math":70,"../util/object":71,"../util/util":73,"dup":46}],57:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./genericShape');

var SVGRect = function(svgRoot, cfg) {
    cfg = cfg || {};
    SVGShape.call(this, 'rect', svgRoot, cfg);
};

util.inherits(SVGRect, SVGShape);

SVGRect.prototype.y = function() {
    var y = this.attrNumber('y') || 0;
    return this.translatedY(y);
};

SVGRect.prototype.x = function() {
    var x = this.attrNumber('x') || 0;
    return this.translatedX(x);
};

SVGRect.prototype.height = function(value) {
    if((object.isBoolean(value) && !value)) {
        return this.attrNumber('height');
    } else if(!object.isDefined(value) || (object.isBoolean(value) && value)) {
        //TODO: note that the stroke is rendered on the center of the node border
        return this.attrNumber('height') + this.strokeWidth();
    } else {
        this.attr({height:value});
        return this;
    }
};

SVGRect.prototype.width = function(value) {
    if((object.isBoolean(value) && !value)) {
        return this.attrNumber('width');
    } else if(!object.isDefined(value) || (object.isBoolean(value) && value)) {
        return this.attrNumber('width') + this.strokeWidth();
    } else {
        this.attr({width:value});
        return this;
    }
};

//TODO: consider stroke-width ...
SVGRect.prototype.rightX = function() {
    return this.x() + this.width();
};

SVGRect.prototype.bottomY = function() {
    return this.y() + this.height();
};

SVGRect.prototype.overlayCheck = function(position) {
    return position.x >= this.x() && position.x <= this.rightX()
        && position.y >= this.y() && position.y <= this.bottomY();
};

module.exports = SVGRect;
},{"../util/object":71,"../util/util":73,"./genericShape":53}],58:[function(require,module,exports){
var object = require('../util/object');
var string = require('../util/string');

var REGEXP_PROPERTY_SUFFIX = ':[a-zA-Z0-9#,\.]*(;|$)';

var Style = function(key, value) {
    if(object.isString(key) && !object.isDefined(value)) {
        this.value = key;
    } else {
        this.set(key,value);
    }
};

Style.prototype.set = function(key, value) {
    if(object.isObject(key)) {
        object.each(key, function(objKey, val) {
            if(key.hasOwnProperty(objKey)) {
                this.set(objKey,val);
            }
        });
    } else if(object.isString(key) && object.isDefined(value)) {
        if(!object.isDefined(this.value)) {
            this.value = "";
        }

        if(this.value.indexOf(key+':') >= 0) {
            var regExp = new RegExp(key+REGEXP_PROPERTY_SUFFIX, 'gi');
            this.value = this.value.replace(regExp, this.createValueString(key,value));
        } else {
            this.value += (!string.endsWith(this.value,';') && this.value.length > 0) ? ';' + this.createValueString(key,value) : this.createValueString(key,value);
        }
    } else if(object.isString(key)) {
        this.value = key;
    }
};

Style.prototype.get = function(key) {
    var regExp = new RegExp(key+REGEXP_PROPERTY_SUFFIX, 'gi');
    var result = this.value.match(regExp);
    if(object.isArray(result)) {
        var value = result[0];
        var splitted = value.split(':');
        if(splitted.length > 1) {
            var result = splitted[1];
            return (string.endsWith(result, ';'))? result.substring(0,result.length -1) : result;
        }
    }
};

Style.prototype.createValueString = function(key, value) {
    return key+':'+value+';';
};

Style.prototype.toString = function() {
    return this.value;
};

module.exports = Style;

},{"../util/object":71,"../util/string":72}],59:[function(require,module,exports){
/**
 * This module contains functionality for creating and accessing SVG elements.
 * All SVG elements created with this module can be accessed by ID through the instance object.
 *
 * An SVG element created with this module can be seperated into multiple parts which can be managed speratly.
 * The 'root' part will be created by default. When creating a new svg part you can set it as default part, so all actions
 * like insertions will be executed on the default part if there is no other part as argument.
 */
var SVGGenericShape = require('./genericShape');
require('./draggable');
var shapes = require('./elements');
var util = require('../util/Util');

var dom = util.dom;
var object = util.object;

var NAMESPACE_SVG = 'http://www.w3.org/2000/svg';
var NAMESPACE_XLINK = 'http://www.w3.org/1999/xlink';

var instances = {};

/**
 * The constructor initializes a new SVG element within the given containerId.
 * The constructor accepts the containerId either as selector '#containerId' or as id string 'containerId'.
 *
 * The id of the nw SVG element will be the containerId with the suffix '_svg' -> 'containerId_svg'.
 *
 * Attributes of the new SVG elemnt can be set through the constructor argument 'cfg'.
 *
 * The SVG can be seperated in multiple parts so you can easily append elements to the different part.
 * The constructor creates a 'root' part as default.
 *
 * @param containerId
 * @param cfg
 * @constructor
 */
var SVG = function(containerId, cfg) {
    if(!(this instanceof SVG)) {
        return SVG.get(containerId);
    }

    cfg = cfg || {};

    //Get id from selector if its an selector
    this.containerId = dom.getRawId(containerId);
    this.$container = $.qCache('#'+this.containerId).get(0);

    if(!this.$container) {
        console.error('Attempt to initiate svg stage for invalid containerId: '+this.containerId);
        return;
    }

    this.svgId = this.containerId+'_svg';

    // Create SVG root element with given settings.
    this.root = new shapes.Svg(this, {id : this.svgId});

    cfg.height = cfg.height || '100%';
    cfg.width = cfg.width  || '100%';

    // Set cfg values as svg root attributes
    this.root.attr(cfg);

    // Append the svg root element to the containernode
    dom.appendSVGElement(this.$container, this.root);

    // The root part is the svg element itself
    this.svgParts = {'root':this.root};
    this.defaultPart = this.root;

    instances[this.svgId] = this;
};

/**
 * Returns the svg root domNode.
 * @returns {*} svg root domNode
 */
SVG.prototype.getRootNode = function() {
    return (this.root) ? this.root.instance() : undefined;
};

/**
 * Returns a cached jQuery object of the root node.
 * @returns {*}
 */
SVG.prototype.$ = function() {
    return $.qCache('#'+this.svgId);
};

/**
 * This is used for importing diagrams into the svg instance.
 * @param element
 */
SVG.prototype.setRoot = function(element) {
    var newId = dom.getAttributes(element)['id'];
    this.root.instance(element);
    this.root.attr({id : newId});
    instances[newId] = this;
};

/**
 * Returns the root element as SVGElement
 * @returns {SVGElement|exports|module.exports|*}
 */
SVG.prototype.getRoot = function() {
    return this.root;
};

/**
 * Returns the current defaultPart
 * @returns {SVGElement|exports|module.exports|*} current defaultPart
 */
SVG.prototype.getDefaultPart = function() {
    return this.defaultPart;
};

/**
 * Creates and returns a new svg part which is represented by a new group within the root.
 * The part id is composite of the svg root id and the partId.
 * By setting the isDefault argument as true the new part will be set as default part.
 * @param partId
 * @param isDefault
 * @returns {*}
 */
SVG.prototype.createPart = function(partId, isDefault) {
    //New parts are always added to the root part
    this.svgParts[partId] = this.g({id: this.svgId+'_'+partId, parentPart: 'root'});
    if(isDefault) {
        this.defaultPart = this.svgParts[partId];
    }
    return this.svgParts[partId];
};

SVG.prototype.part = function(id) {
    return this.svgParts[id];
};

/**
 * Adds an svg element to the given part.
 *
 * @param part
 * @param element
 */
SVG.prototype.addToPart = function(part, element) {
    this.addToGroup(this.svgParts[part], element);
};

/**
 * This function can be used to append or prepend elements with text to the svg root.
 *
 * @param element
 * @param prepend
 * @param text
 * @returns {*}
 */
SVG.prototype.addToRoot = function(element, prepend, text) {
    if(prepend) {
        return dom.prependSVGElement(this.getRoot(), element, text);
    } else {
        return dom.appendSVGElement(this.getRoot(), element, text);
    }
};

/**
 * This function can be used to append/prepend elements with text to a given (or default) svg part.
 *
 * @param element
 * @param part
 * @param prepend
 * @param text
 * @returns {*}
 */
SVG.prototype.add = function(element, part, prepend, text) {
    part = part || this.getDefaultPart();
    element.parent = part;
    if(prepend) {
        return dom.prependSVGElement(part, element, text);
    } else {
        return dom.appendSVGElement(part, element, text);
    }
};

/**
 * Imports an xml document to the given svg part.
 * @param elementXML
 * @param part
 * @returns {*}
 */
SVG.prototype.import = function(svgStr, part, prepend) {
    part = this.svgParts[part] || this.getDefaultPart();
    return dom.importSVG(part, svgStr, prepend);
};

/**
 * Adds and returns a newly created svg Rect with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.rect = function(cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Rect(this, cfg), part);
};

/**
 * Adds and returns a newly created svg Text with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.text = function(text, cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Text(this, cfg), part, false).content(text);
};

SVG.prototype.tspan = function(text, cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.TSpan(this, cfg), part, false).content(text);
};

/**
 * Adds and returns a newly created svg Circle with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.circle = function(cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Circle(this, cfg), part);
};

/**
 * Adds and returns a newly created svg Circle with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.ellipse = function(cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Ellipse(this, cfg), part);
};

/**
 * Adds and returns a newly created svg Group with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.g = function(cfg) {
    var cfg = cfg ||{};

    var parentPart = this.svgParts[cfg.parentPart] || this.getDefaultPart();

    delete cfg.part;

    var group = this.add(new shapes.Group(this, cfg), parentPart);

    if(arguments.length > 1) {
        for(var i = 1;i < arguments.length; i++) {
            console.log('addToGroup: '+group.attr('id')+' - '+ arguments[i].attr('id'));
            dom.appendSVGElement(group.instance(), arguments[i]);
        }
    }
    return group;
};

/**
 * Adds ands an svg element ot the given group.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.addToGroup = function(group, element) {
    var result;
    if(object.isArray(element)) {
        result = [];
        object.each(element, function(index, val) {
            result.push(dom.appendSVGElement(group.instance(), element));
        })
    } else {
        return dom.appendSVGElement(group.instance(), element);
    }
};

/**
 * Adds and returns a newly created svg Path with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.path = function(cfg, part) {
    var part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Path(this, cfg), part);
};

SVG.prototype.empty = function() {
    $(this.root.instance()).empty();
};

SVG.prototype.asString = function() {
    return this.root.toString();
};

/**
 * This function creates an SVGElement out of the given id selector element.
 * @param idSelector
 * @returns {SVGElement|exports|module.exports}
 */
SVG.get = function(idSelector) {
    var $node;

    if(!object.isString(idSelector)) {
        $node = $(idSelector);
    } else {
        $node = $.qCache(dom.getIdSelector(idSelector));
    }

    if(!$node) {
        console.warn('call SVG.get on a non existing node: '+idSelector);
        return;
    }

    var $svgRootNode = $($node.get(0).ownerSVGElement);

    if($svgRootNode.length) {
        var svgInstance = instances[$svgRootNode.attr('id')];
        return SVG._svgInstance($node, svgInstance);
    } else {
        console.warn('Call SVG.get on node with no svg root');
    }
};

SVG._svgInstance = function($node, svg) {
    var SVGShape = SVG.getShapeByName($node.get(0).nodeName);
    return (SVGShape) ? new SVGShape(svg).instance($node.get(0)) : new SVGGenericShape($node.get(0), svg);
};

SVG.getShapeByName = function(type) {
    var result = shapes[type.toLowerCase()];
    return result;
};

SVG.prototype.get = SVG.get;

module.exports = SVG;

},{"../util/Util":67,"./draggable":50,"./elements":51,"./genericShape":53}],60:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"../dom/domElement":45,"../util/util":73,"./style":58,"dup":47}],61:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGElement = require('./svgElement');

var NAMESPACE_SVG = 'http://www.w3.org/2000/svg';
var NAMESPACE_XLINK = 'http://www.w3.org/1999/xlink';
var SVG_VERSION = '1.1';

var SVGRoot = function(svg, cfg) {
    cfg = cfg || {};
    cfg['xmlns'] = NAMESPACE_SVG;
    cfg['xmlns:xlink'] = NAMESPACE_XLINK;
    cfg['version'] = SVG_VERSION;
    SVGElement.call(this, 'svg', svg, cfg);
};

util.inherits(SVGRoot, SVGElement);

SVGRoot.prototype.x = function(value) {
    return (value) ? this.attrNumber('x', value) : this.attrNumber('x') || 0 ;
};

SVGRoot.prototype.y = function(value) {
    return (value) ? this.attrNumber('y', value) : this.attrNumber('y') || 0 ;
};

SVGRoot.prototype.getCenter = function() {
    return {
        x: this.x() + Math.floor(this.width() / 2),
        y: this.y() + Math.floor(this.height() / 2)
    };
};

SVGRoot.prototype.height = function(value) {
    if(!value) {
        return this.$().height();
    } else {
        this.attr('height', value);
    }
};

SVGRoot.prototype.width = function(value) {
    if(!value) {
        return this.$().width();
    } else {
        this.attr('width', value);
    }
};

module.exports = SVGRoot;
},{"../util/object":71,"../util/util":73,"./svgElement":60}],62:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./genericShape');

var DEFAULT_FONT_SIZE = 11;
var DEFAULT_FONT_FAMILY = "Helvetica"; //Verdana, Arial, sans-serif ?
var DEFAULT_TEXT_ANCHOR = "start";
var DEFAULT_DOMINANT_BASELINE = "hanging";

var DEFAULT_SPAN_PADDING = 0;

var SVGText = function(svgRoot, cfg, attributeSetter) {
    cfg = cfg || {};
    cfg['font-family'] = cfg['font-size'] || DEFAULT_FONT_FAMILY;
    cfg['font-size'] = cfg['font-size'] || DEFAULT_FONT_SIZE;
    cfg['text-anchor'] = cfg['text-anchor'] || DEFAULT_TEXT_ANCHOR;
    cfg['dominant-baseline'] = cfg['dominant-baseline'] || DEFAULT_DOMINANT_BASELINE;

    this.spanPadding = cfg['padding'] || DEFAULT_SPAN_PADDING;

    SVGShape.call(this, 'text', svgRoot, cfg, attributeSetter);
    //TODO: Span / multi line text
};

util.inherits(SVGText, SVGShape);

SVGText.prototype.fontFamily = function(value) {
    return this.attr('font-family', value);
};

SVGText.prototype.padding = function(value) {
    if(object.isDefined(value)) {
        this.spanPadding = value;
        this.setSpanAttr('x', value);
    } else {
        return this.spanPadding;
    }
};

SVGText.prototype.fontFamily = function(value) {
    return this.attr('font-family', value);
};

SVGText.prototype.fontSize = function(value) {
    var result = this.attrNumber('font-size', value);
    if(value) {
        this.setSpanAttr('dy', value);
        return this;
    } else {
        return result;
    }
};

SVGText.prototype.setSpanAttr = function(key, value) {
    this.$().children('tspan').attr(key, value);
    return this;
};

SVGText.prototype.x = function(value) {
    return (object.isDefined(value)) ? this.attrNumber('x', value) : this.translatedX(this.attrNumber('x', value)) || 0 ;
};

SVGText.prototype.y = function(value) {
    return (object.isDefined(value)) ? this.attrNumber('y', value) : this.translatedY(this.attrNumber('y', value)) || 0 ;
};

SVGText.prototype.dx = function(value) {
    return this.attrNumber('dx', value);
};

SVGText.prototype.dy = function(value) {
    return this.attrNumber('dy', value);
};

SVGText.prototype.move = function(dx, dy) {
    SVGText.super_.prototype.move.apply(this, [dx, dy]);
    this.alignBackground();
};

SVGText.prototype.moveTo = function(x, y) {
    SVGText.super_.prototype.moveTo.apply(this, [x, y]);
    this.alignBackground();
};

SVGText.prototype.content = function(text) {
    if(!text) {
        return this.getText();
    }

    var that = this;
    var height;
    this.$().empty();
    $.each(text.split('\n'), function(index, value) {
        if(object.isDefined(value) && value.trim().length > 0) {
            var tSpan = that.svg.tspan(value).x(that.spanPadding);
            that.append(tSpan);
            if(index > 0) {
                tSpan.dy(height);
            } else {
                height = tSpan.height();
            }
        }
    });
    return this;
};

SVGText.prototype.getText = function() {
    var result = '';
    var $children = this.$().children('tspan');
    $children.each(function(index, value) {
        result += $(this).text();
        if(index != $children.length -1) {
            result += '\n';
        }
    });
    return result;
};

SVGText.prototype.switchAnchor = function() {
    switch(this.anchor()) {
        case 'start':
            this.end();
        case 'end':
            this.start();
    }
};

SVGText.prototype.getExtentOfChar = function(charNum) {
    return this.instance().getExtentOfChar(charNum);
};

SVGText.prototype.getCharHeight = function(charNum) {
    return this.getExtentOfChar(charNum).height;
};

SVGText.prototype.getCharDiff = function(charNum) {
    return this.height() - this.getCharHeight(charNum)
    this.getCharHeight(charNum) + this.getExtentOfChar(charNum).y;
};

SVGText.prototype.start = function() {
    return this.anchor('start');
};

SVGText.prototype.end = function() {
    return this.anchor('end');
};

SVGText.prototype.middle = function() {
    return this.anchor('middle');
};

SVGText.prototype.anchor = function(value) {
    return this.attr('text-anchor', value);
};

SVGText.prototype.tSpan = function(index) {
    return this.svg.get(this.$().children('tspan').get(index));
}

SVGText.prototype.hanging = function(hanging) {
    var hanging = object.isDefined(hanging) ? hanging : true;
    var value = hanging ? 'hanging' : 'baseline';
    this.attr('dominant-baseline', value);
    var firstSpan = this.tSpan(0);
    var dy = (hanging) ? 0 : firstSpan.height() + this.getBBox().y;
    firstSpan.dy(dy);
    return this;
};

/**
 * Note: the background won't align when the text is dragged. Perhaps add drag hook
 * @param color
 */
SVGText.prototype.background = function(color) {
    var svgBackground = this.getBackground();
    if(color) {
        if(!svgBackground) {
            svgBackground = this.svg.rect({'class':'textBackground'});
        }
        svgBackground.fill(color);
        svgBackground.$().after(this.$());
        this.alignBackground();
    } else if(svgBackground) {
        svgBackground.fill();
    }
    return this;
};

/**
 *  TODO: probably just works for hanging texts because of the offset...
 */
SVGText.prototype.alignBackground = function() {
    var svgBackground = this.getBackground();
    if(svgBackground) {
        var bgHeight = this.height() + this.getBBox().y; //remove text offset
        svgBackground.height(bgHeight).width(this.width()).translate(this.x(), this.y());
    }
};

SVGText.prototype.getBackground = function() {
    if(this.backgroundSVG) {
        return this.backgroundSVG;
    }

    var prev = this.$().prev();
    if(prev.length > 0) {
        var svgBack = this.svg.get(prev);
        return this.backgroundSVG = (svgBack.hasClass('textBackground')) ? svgBack : undefined;
    }
};

SVGText.prototype.dominantBaseline = function(value) {
    return this.attr('dominant-baseline', value);
};

module.exports = SVGText;
},{"../util/object":71,"../util/util":73,"./genericShape":53}],63:[function(require,module,exports){
var util = require('../util/util');
var object = util.object;
var DomElement = require('../dom/domElement');

var Transform = function(def) {
    if(typeof def !== 'undefined' ) {
        if(object.isString(def)) {
            this.setDefinitionFromString(def);
        } else {
            this.definition = def;
        }
    } else {
        this.definition = {};
    }
};

Transform.prototype.setDefinitionFromString = function(value) {
    if(!this.definition) {
        this.definition = {};
    }

    // extract 'translate(200 200) rotate(45 50 50)' to "translate" "200 200" " rotate" "45 50 50" ""
    var transformations = value.split(/[\(\)]+/);
    for(var i = 0;i < transformations.length; i += 2) {
        var transformation = transformations[i].trim();
        if(transformation.length > 0) {
            var values = DomElement.getAttributeValueFromStringList(transformations[i+1]);
            for(var i = 0; i < values.length; i++) {
                // We prefer integer values for calculations
                if(!isNaN(values[i])) {
                    values[i] = parseInt(values[i]);
                }
            }
            this.definition[transformation] = values;
        }
    }
};

Transform.prototype.toString = function() {
    var values = [];
    for(var key in this.definition) {
        if(this.definition.hasOwnProperty((key))) {
            // first we assamble all transformations in an array ['translate(30)','rotate(45 50 50)']
            var singleTransformation = key+'('+DomElement.getAttributeString(this.definition[key])+')';
            values.push(singleTransformation);
        }
    }
    // merge the transformations to one attributestring
    var valueStr = DomElement.getAttributeString(values);

    if(valueStr.length > 0) {
        return valueStr;
    } else {
        // if we don't have any transormations set we just return an empty string
        return '';
    }
};

Transform.prototype.hasTransformation = function(key) {
    return (typeof definition[key] !== 'undefined');
};

Transform.prototype.scale = function(s) {
    if(s) {
        this.definition.scale = s;
        return this;
    } else {
        return this.definition.scale;
    }
};

Transform.prototype.translate = function(x, y) {
    var p = util.math.getPoint(x,y);

    if(object.isDefined(p)) {
        this.definition.translate = [p.x, p.y];
        return this;
    } else {
        if(this.definition.translate) {
            return {
                x : this.definition.translate[0],
                y : this.definition.translate[1]
            };
        } else {
            return {
                x : 0,
                y : 0
            }
        }
    }
}

module.exports = Transform;
},{"../dom/domElement":45,"../util/util":73}],64:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./genericShape');
var SVGText = require('./text');

var DEFAULT_DOMINANT_BASELINE = 'inherit'

var SVGTSpan = function(svgRoot, cfg) {
    cfg = cfg || {};
    cfg['dominant-baseline'] = cfg['dominant-baseline'] || DEFAULT_DOMINANT_BASELINE;
    SVGShape.call(this, 'tspan', svgRoot, cfg);
};

util.inherits(SVGTSpan, SVGText);

SVGTSpan.prototype.content = function(value) {
    if(value) {
        this.$().text(value);
        return this;
    } else {
        return this.$().text();
    }
};

SVGTSpan.prototype.getBBox = function() {
    //some browser (e.g. firefox) does not implement the getBBox for tspan elements.
    return this.getBoundingClientRect();
};

module.exports = SVGTSpan;
},{"../util/object":71,"../util/util":73,"./genericShape":53,"./text":62}],65:[function(require,module,exports){
var dom = require('../dom/dom');
var object = require('../util/object');

EditPanel = function() {};

EditPanel.prototype.init = function(pageX, pageY, onclose) {
    var that = this;
    this.close();

    this.onclose = onclose;

    //Init Form
    this.$form = dom.create('form', {action : 'javascript:void(0);'})
        .on('submit', function() {
            that.close();
        });

    //Init Container
    this.$editDiv = dom.create('div', {id:'editPanel'})
        .offset({top: pageY, left: (pageX+5)})
        .css('position', 'absolute')
        .css('background-color', 'silver')
        .append(this.$form);

    //Append to body
    $('body').append(this.$editDiv);
    return this;
};

EditPanel.prototype.close = function() {
    if(this.onclose) {
        this.onclose.apply();
    }

    if(this.$editDiv) {
        this.$editDiv.remove();
    }
}

EditPanel.prototype.createTextEdit = function(pageX ,pageY, getter, setter) {
    var that = this;
    var $input = dom.create('input', {type:'text', value : getter()})
        .focus()
        .on('focus', function() {
            this.select();
        })
        .on('blur', function(evt) {
            that.close();
        })
        .on('change', function(evt) {
            setter($input.val());
        });

    this.init(pageX ,pageY);
    this.$form.append($input);
    $input.focus();
};

EditPanel.prototype.createTextAreaEdit = function(pageX ,pageY, getter, setter) {
    var that = this;
    var $input = dom.create('textarea')
        .val(getter())
        .on('change', function() {
            setter($input.val());
        })
        .on('blur', function(evt) {
            that.close();
        })
        .on('focus', function() {
            this.select();
        });

    this.init(pageX ,pageY);
    this.$form.append($input);
    $input.focus();
};

EditPanel.prototype.setTextAreaContent = function($textAreaNode, txtAreaContent) {
    $textAreaNode.empty();
    //TODO: we do not consider the text size for dy !
    var dy = 11;
    $.each(txtAreaContent.split('\n'), function(index, value) {
        if(object.isDefined(value) && value.trim().length > 0) {
            dom.appendSVGElement($textAreaNode.get(0), {
                name : 'tspan',
                attributes : {
                    dy : dy,
                    x : 2
                }
            }, value);
        }
    });
};

EditPanel.prototype.getTextAreaContent = function($textAreaNode) {
    var result = '';
    $textAreaNode.children().each(function() {
        result += $(this).text()+'\n';
    });
    return result;
};

module.exports = EditPanel;
},{"../dom/dom":44,"../util/object":71}],66:[function(require,module,exports){
var SVG = require('../svg/svg');
var queryCache = require('../core/cache');

$.fn.svg = function(selector) {
    if(selector) {
        return $(selector).svg();
    }

    if(this.length === 1) {
        return SVG.get(this);
    } else if(this.length > 1) {
        var result =  [];
        this.each(function() {
            result.push(SVG.get(this));
        })
        return result;
    }

    return this;
};

$.svg = $.fn.svg;

$.qCache = function(selector, preventCache) {
    if(selector) {
        return queryCache.$(selector, preventCache);
    } else {
        return queryCache;
    }
};

$.qUncache = function(selector) {
    return queryCache.remove(selector);
}

$.fn.growl = function(params) {
    var $root = this;

    // tooltip content and styling
    var $content = $(
        '<a class="icon-close" href="#"></a>'+
        '<h1 style="color: white; font-size: 12pt; font-weight: bold; padding-bottom: 5px;">' + params.title + '</h1>' +
        '<p style="margin: 0; padding: 5px 0 5px 0; font-size: 10pt;">' + params.text + '</p>');

    // add 'Close' button functionality
    var $close = $($content[0]);
    $close.click(function(e) {
        $root.uitooltip('close');
    });

    // prevent standard tooltip from closing
    $root.bind('focusout mouseleave', function(e) { e.preventDefault(); e.stopImmediatePropagation(); return false; });

    // build tooltip
    $root.uitooltip({
        content: function() { return $content; },
        items: $root.selector,
        tooltipClass: 'growl ' + params.growlClass,
        position: {
            my: 'right top',
            at: 'right-10 top+10'
        },
        close: function( event, ui ) {
            $root.uitooltip('destroy');
        }
    }).uitooltip('open');

    if(params.closeAfter) {
        setTimeout(function(){ $root.uitooltip('close'); }, params.closeAfter);
    }
};

if($.ui) {
    $.widget( "custom.iconselectmenu", $.ui.selectmenu, {
        _renderItem: function( ul, item ) {
            var li = $( "<li>", { text: item.label } );
            if ( item.disabled ) {
                li.addClass( "ui-state-disabled" );
            }
            $( "<span>", {
                style: item.element.attr( "data-style" ),
                "class": "ui-icon " + item.element.attr( "data-class" )
            })
                .appendTo( li );
            return li.appendTo( ul );
        }
    });
}

},{"../core/cache":2,"../svg/svg":59}],67:[function(require,module,exports){
var util = require("util");

module.exports = {
    object: require('./object'),
    string: require('./string'),
    dom: require('./../dom/dom'),
    app: require('./app'),
    math: require('./math'),
    xml : require('./xml'),
    inherits: util.inherits
}
},{"./../dom/dom":44,"./app":68,"./math":70,"./object":71,"./string":72,"./xml":74,"util":79}],68:[function(require,module,exports){
/**
 * This module serves as an wrapper for dom manipulation functionality. It is
 * highly prefered to use this module instead of jquery directly within other
 * modules.
 */
var object = require('./object');

var parseFeatureStrings = function(value, defaultVal) {
    var result = [];
    value = value.split(' ');
    object.each(value, function(index, feature) {
        result[index] = parseFeatureString(feature, defaultVal);
    });
    return result;
};

/**
 * parse a featurestinrg in the form of
 *  'featurename(30,30)' or 'featurename(30.4) or featurename
 *
 * The result is would be
 *      { type : 'featurename', value : [30,30] }
 *      { type : 'featurename', value : 30.4 }
 *      { type : 'featurename', value : undefined }
 * @param {type} feature
 * @returns {App_L6.parseFeatureString.result}
 */
var parseFeatureString = function(feature, defaultVal) {
    var result = {};
    if(feature.indexOf('(') > -1) {
        var splitted = feature.split('(');
        var value = splitted[1].substring(0, splitted[1].indexOf(')'));

        if(value.indexOf(',') > -1) { // multiple args
            value = value.split(',');
            object.each(value, function(index, v) {
                value[index] = parseNumberString(v);
            });
        } else { // single arg
            value = parseNumberString(value);
        }
        result.type = splitted[0];
        result.value = value;
    } else {
        result.type = feature;
        result.value = defaultVal;
    }
    return result;
};

var parseNumberString = function(value) {
    if(!object.isString(value)) {
        return value;
    }

    //Cut units 1.2em -> 1.2
    value = value.split(/(?=[a-z,A-Z]+)/)[0];

    if(!isNaN(value)) {
        if(value.indexOf('.') > -1) { //float
            value = parseFloat(value);
        } else { //int
            value = parseInt(value);
        }
    }
    return value;
};

var createFeatureString = function(feature, value) {
    var result = feature;

    if(object.isDefined(value)) {
        result += '(';
        if(object.isArray(value)) {
            object.each(value, function(index, value) {
                result += (index !== 0) ? ','+value : value;
            });
        } else {
            result += value;
        }
        result += ')';
    }
    return result;
};

var isMinDist = function(from, to, minDist) {
    return Math.abs(to.x - from.x) > minDist || Math.abs(to.y - from.y) > minDist;
};

module.exports = {
    parseFeatureString:parseFeatureString,
    createFeatureString:createFeatureString,
    parseFeatureStrings:parseFeatureStrings,
    parseNumberString : parseNumberString,
    isMinDist : isMinDist
};

},{"./object":71}],69:[function(require,module,exports){
/**
 * most Bezier helpter functions are taken from jsBezier library https://github.com/jsplumb/jsBezier/blob/master/js/0.6/jsBezier-0.6.js
 * check /libs/jsBezier.js for more functions if required.
 *
 *
 */

if (typeof Math.sgn == "undefined") {
    Math.sgn = function (x) {
        return x == 0 ? 0 : x > 0 ? 1 : -1;
    };
}

var Vectors = {
        subtract: function (v1, v2) {
            return {x: v1.x - v2.x, y: v1.y - v2.y};
        },
        dotProduct: function (v1, v2) {
            return (v1.x * v2.x) + (v1.y * v2.y);
        },
        square: function (v) {
            return Math.sqrt((v.x * v.x) + (v.y * v.y));
        },
        scale: function (v, s) {
            return {x: v.x * s, y: v.y * s};
        }
    },

    maxRecursion = 64,
    flatnessTolerance = Math.pow(2.0, -maxRecursion - 1);

/**
 * finds the nearest point on the curve to the given point.
 */
var _nearestPointOnCurve = function (point, curve) {
    var td = _distanceFromCurve(point, curve);
    return {point: _bezier(curve, curve.length - 1, td.location, null, null), location: td.location};
};

/**
 * Calculates the distance that the point lies from the curve.
 *
 * @param point a point in the form {x:567, y:3342}
 * @param curve a Bezier curve in the form [{x:..., y:...}, {x:..., y:...}, {x:..., y:...}, {x:..., y:...}].  note that this is currently
 * hardcoded to assume cubiz beziers, but would be better off supporting any degree.
 * @return a JS object literal containing location and distance, for example: {location:0.35, distance:10}.  Location is analogous to the location
 * argument you pass to the pointOnPath function: it is a ratio of distance travelled along the curve.  Distance is the distance in pixels from
 * the point to the curve.
 */
var _distanceFromCurve = function (point, curve) {
    var candidates = [],
        w = _convertToBezier(point, curve),
        degree = curve.length - 1, higherDegree = (2 * degree) - 1,
        numSolutions = _findRoots(w, higherDegree, candidates, 0),
        v = Vectors.subtract(point, curve[0]), dist = Vectors.square(v), t = 0.0;

    for (var i = 0; i < numSolutions; i++) {
        v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
        var newDist = Vectors.square(v);
        if (newDist < dist) {
            dist = newDist;
            t = candidates[i];
        }
    }
    v = Vectors.subtract(point, curve[degree]);
    newDist = Vectors.square(v);
    if (newDist < dist) {
        dist = newDist;
        t = 1.0;
    }
    return {location: t, distance: dist};
};

var _convertToBezier = function (point, curve) {
    var degree = curve.length - 1, higherDegree = (2 * degree) - 1,
        c = [], d = [], cdTable = [], w = [],
        z = [[1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0]];

    for (var i = 0; i <= degree; i++) c[i] = Vectors.subtract(curve[i], point);
    for (var i = 0; i <= degree - 1; i++) {
        d[i] = Vectors.subtract(curve[i + 1], curve[i]);
        d[i] = Vectors.scale(d[i], 3.0);
    }
    for (var row = 0; row <= degree - 1; row++) {
        for (var column = 0; column <= degree; column++) {
            if (!cdTable[row]) cdTable[row] = [];
            cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
        }
    }
    for (i = 0; i <= higherDegree; i++) {
        if (!w[i]) w[i] = [];
        w[i].y = 0.0;
        w[i].x = parseFloat(i) / higherDegree;
    }
    var n = degree, m = degree - 1;
    for (var k = 0; k <= n + m; k++) {
        var lb = Math.max(0, k - m),
            ub = Math.min(k, n);
        for (i = lb; i <= ub; i++) {
            j = k - i;
            w[i + j].y += cdTable[j][i] * z[j][i];
        }
    }
    return w;
};
/**
 * counts how many roots there are.
 */
var _findRoots = function (w, degree, t, depth) {
    var left = [], right = [],
        left_count, right_count,
        left_t = [], right_t = [];

    switch (_getCrossingCount(w, degree)) {
        case 0 :
        {
            return 0;
        }
        case 1 :
        {
            if (depth >= maxRecursion) {
                t[0] = (w[0].x + w[degree].x) / 2.0;
                return 1;
            }
            if (_isFlatEnough(w, degree)) {
                t[0] = _computeXIntercept(w, degree);
                return 1;
            }
            break;
        }
    }
    _bezier(w, degree, 0.5, left, right);
    left_count = _findRoots(left, degree, left_t, depth + 1);
    right_count = _findRoots(right, degree, right_t, depth + 1);
    for (var i = 0; i < left_count; i++) t[i] = left_t[i];
    for (var i = 0; i < right_count; i++) t[i + left_count] = right_t[i];
    return (left_count + right_count);
};
var _getCrossingCount = function (curve, degree) {
    var n_crossings = 0, sign, old_sign;
    sign = old_sign = Math.sgn(curve[0].y);
    for (var i = 1; i <= degree; i++) {
        sign = Math.sgn(curve[i].y);
        if (sign != old_sign) n_crossings++;
        old_sign = sign;
    }
    return n_crossings;
};
var _isFlatEnough = function (curve, degree) {
    var error,
        intercept_1, intercept_2, left_intercept, right_intercept,
        a, b, c, det, dInv, a1, b1, c1, a2, b2, c2;
    a = curve[0].y - curve[degree].y;
    b = curve[degree].x - curve[0].x;
    c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;

    var max_distance_above = max_distance_below = 0.0;

    for (var i = 1; i < degree; i++) {
        var value = a * curve[i].x + b * curve[i].y + c;
        if (value > max_distance_above)
            max_distance_above = value;
        else if (value < max_distance_below)
            max_distance_below = value;
    }

    a1 = 0.0;
    b1 = 1.0;
    c1 = 0.0;
    a2 = a;
    b2 = b;
    c2 = c - max_distance_above;
    det = a1 * b2 - a2 * b1;
    dInv = 1.0 / det;
    intercept_1 = (b1 * c2 - b2 * c1) * dInv;
    a2 = a;
    b2 = b;
    c2 = c - max_distance_below;
    det = a1 * b2 - a2 * b1;
    dInv = 1.0 / det;
    intercept_2 = (b1 * c2 - b2 * c1) * dInv;
    left_intercept = Math.min(intercept_1, intercept_2);
    right_intercept = Math.max(intercept_1, intercept_2);
    error = right_intercept - left_intercept;
    return (error < flatnessTolerance) ? 1 : 0;
};
var _computeXIntercept = function (curve, degree) {
    var XLK = 1.0, YLK = 0.0,
        XNM = curve[degree].x - curve[0].x, YNM = curve[degree].y - curve[0].y,
        XMK = curve[0].x - 0.0, YMK = curve[0].y - 0.0,
        det = XNM * YLK - YNM * XLK, detInv = 1.0 / det,
        S = (XNM * YMK - YNM * XMK) * detInv;
    return 0.0 + XLK * S;
};

var _bezier = function (curve, degree, t, left, right) {
    var temp = [[]];
    for (var j = 0; j <= degree; j++) temp[0][j] = curve[j];
    for (var i = 1; i <= degree; i++) {
        for (var j = 0; j <= degree - i; j++) {
            if (!temp[i]) temp[i] = [];
            if (!temp[i][j]) temp[i][j] = {};
            temp[i][j].x = (1.0 - t) * temp[i - 1][j].x + t * temp[i - 1][j + 1].x;
            temp[i][j].y = (1.0 - t) * temp[i - 1][j].y + t * temp[i - 1][j + 1].y;
        }
    }
    if (left != null)
        for (j = 0; j <= degree; j++) left[j] = temp[j][0];
    if (right != null)
        for (j = 0; j <= degree; j++) right[j] = temp[degree - j][j];

    return (temp[degree][0]);
};

var _curveFunctionCache = {};
var _getCurveFunctions = function (order) {
    var fns = _curveFunctionCache[order];
    if (!fns) {
        fns = [];
        var f_term = function () {
                return function (t) {
                    return Math.pow(t, order);
                };
            },
            l_term = function () {
                return function (t) {
                    return Math.pow((1 - t), order);
                };
            },
            c_term = function (c) {
                return function (t) {
                    return c;
                };
            },
            t_term = function () {
                return function (t) {
                    return t;
                };
            },
            one_minus_t_term = function () {
                return function (t) {
                    return 1 - t;
                };
            },
            _termFunc = function (terms) {
                return function (t) {
                    var p = 1;
                    for (var i = 0; i < terms.length; i++) p = p * terms[i](t);
                    return p;
                };
            };

        fns.push(new f_term());  // first is t to the power of the curve order
        for (var i = 1; i < order; i++) {
            var terms = [new c_term(order)];
            for (var j = 0; j < (order - i); j++) terms.push(new t_term());
            for (var j = 0; j < i; j++) terms.push(new one_minus_t_term());
            fns.push(new _termFunc(terms));
        }
        fns.push(new l_term());  // last is (1-t) to the power of the curve order

        _curveFunctionCache[order] = fns;
    }

    return fns;
};


/**
 * calculates a point on the curve, for a Bezier of arbitrary order.
 * @param curve an array of control points, eg [{x:10,y:20}, {x:50,y:50}, {x:100,y:100}, {x:120,y:100}].  For a cubic bezier this should have four points.
 * @param location a decimal indicating the distance along the curve the point should be located at.  this is the distance along the curve as it travels, taking the way it bends into account.  should be a number from 0 to 1, inclusive.
 */
var _pointOnPath = function (curve, location) {
    var cc = _getCurveFunctions(curve.length - 1),
        _x = 0, _y = 0;
    for (var i = 0; i < curve.length; i++) {
        _x = _x + (curve[i].x * cc[i](location));
        _y = _y + (curve[i].y * cc[i](location));
    }

    return {x: _x, y: _y};
};

var _dist = function (p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
};

var _isPoint = function (curve) {
    return curve[0].x == curve[1].x && curve[0].y == curve[1].y;
};

/**
 * finds the point that is 'distance' along the path from 'location'.  this method returns both the x,y location of the point and also
 * its 'location' (proportion of travel along the path); the method below - _pointAlongPathFrom - calls this method and just returns the
 * point.
 */
var _pointAlongPath = function (curve, location, distance) {

    if (_isPoint(curve)) {
        return {
            point: curve[0],
            location: location
        };
    }

    var prev = _pointOnPath(curve, location),
        tally = 0,
        curLoc = location,
        direction = distance > 0 ? 1 : -1,
        cur = null;

    while (tally < Math.abs(distance)) {
        curLoc += (0.005 * direction);
        cur = _pointOnPath(curve, curLoc);
        tally += _dist(cur, prev);
        prev = cur;
    }
    return {point: cur, location: curLoc};
};

var _length = function (curve) {
    if (_isPoint(curve)) return 0;

    var prev = _pointOnPath(curve, 0),
        tally = 0,
        curLoc = 0,
        direction = 1,
        cur = null;

    while (curLoc < 1) {
        curLoc += (0.005 * direction);
        cur = _pointOnPath(curve, curLoc);
        tally += _dist(cur, prev);
        prev = cur;
    }
    return tally;
};

/**
 * finds the point that is 'distance' along the path from 'location'.
 */
var _pointAlongPathFrom = function (curve, location, distance) {
    return _pointAlongPath(curve, location, distance).point;
};

/**
 * finds the location that is 'distance' along the path from 'location'.
 */
var _locationAlongPathFrom = function (curve, location, distance) {
    return _pointAlongPath(curve, location, distance).location;
};

/**
 * returns the gradient of the curve at the given location, which is a decimal between 0 and 1 inclusive.
 *
 * thanks // http://bimixual.org/AnimationLibrary/beziertangents.html
 */
var _gradientAtPoint = function (curve, location) {
    var p1 = _pointOnPath(curve, location),
        p2 = _pointOnPath(curve.slice(0, curve.length - 1), location),
        dy = p2.y - p1.y, dx = p2.x - p1.x;
    return dy == 0 ? Infinity : Math.atan(dy / dx);
};

/**
 returns the gradient of the curve at the point which is 'distance' from the given location.
 if this point is greater than location 1, the gradient at location 1 is returned.
 if this point is less than location 0, the gradient at location 0 is returned.
 */
var _gradientAtPointAlongPathFrom = function (curve, location, distance) {
    var p = _pointAlongPath(curve, location, distance);
    if (p.location > 1) p.location = 1;
    if (p.location < 0) p.location = 0;
    return _gradientAtPoint(curve, p.location);
};

/**
 * calculates a line that is 'length' pixels long, perpendicular to, and centered on, the path at 'distance' pixels from the given location.
 * if distance is not supplied, the perpendicular for the given location is computed (ie. we set distance to zero).
 */
var _perpendicularToPathAt = function (curve, location, length, distance) {
    distance = distance == null ? 0 : distance;
    var p = _pointAlongPath(curve, location, distance),
        m = _gradientAtPoint(curve, p.location),
        _theta2 = Math.atan(-1 / m),
        y = length / 2 * Math.sin(_theta2),
        x = length / 2 * Math.cos(_theta2);
    return [{x: p.point.x + x, y: p.point.y + y}, {x: p.point.x - x, y: p.point.y - y}];
};

var _calculateSmoothControlPoints = function(K) {
    var resultP1 = [];
    var resultP2 = [];
    var n = K.length-1;

    /*rhs vector init left most segment*/
    var a = [0];
    var b = [2];
    var c = [1];
    var r = [K[0] + 2 * K[1]];

    /*internal segments*/
    for(i = 1; i < n - 1; i++) {
        a[i] = 1;
        b[i] = 4;
        c[i] = 1;
        r[i] = 4 * K[i] + 2 * K[i+1];
    }

    /*right segment*/
    a[n-1] = 2;
    b[n-1] = 7;
    c[n-1] = 0;
    r[n-1] = 8 * K[n-1] + K[n];

    /*solves Ax=b with the Thomas algorithm*/
    for(i = 1; i < n; i++) {
        m = a[i] / b[i-1];
        b[i] = b[i] - m * c[i - 1];
        r[i] = r[i] - m * r[i-1];
    }

    resultP1[n-1] = r[n-1] / b[n-1];
    for (i = n - 2; i >= 0; --i) {
        resultP1[i] = (r[i] - c[i] * resultP1[i + 1]) / b[i];
    }

    /*we have p1, now compute p2*/
    for (i = 0; i < n - 1; i++) {
        resultP2[i] = 2 * K[i + 1] - resultP1[i + 1];
    }

    resultP2[n-1] = 0.5 * (K[n] + resultP1[n-1]);

    return {p1:resultP1, p2:resultP2};
};

/**
 * Moves a point along the given curve
 * @param curve
 * @param distance
 * @returns {*|{x, y}}
 */
var moveAlong = function(curve, distance) {
    // Somehow the pointAlongPath calculates in the wrong direction so we switch the bahaviour by setting
    // the location to 1 (end) for positive distances.
    // and negotiate the distance value.
    var location = distance > 0 ? 1 : 0;
    var distance = distance * -1;
    return _pointAlongPath(curve,location, distance).point;
};

module.exports = {
    nearestPointOnCurve : _nearestPointOnCurve,
    calculateSmoothControlPoints : _calculateSmoothControlPoints,
    moveAlong : moveAlong,
    length : _length
}


},{}],70:[function(require,module,exports){
var object = require('./object');
var bezier = require('./bezier');

var calcLineIntersection = function(pa1, pa2, pb1, pb2) {
    return new Line(pa1,pa2).calcLineIntercept(new Line(pb1,pb2));
};

var Point = function(x, y) {
    var p = getPoint(x,y);
    this.x = p.x;
    this.y = p.y;
};

Point.prototype.isWithinInterval = function(start, end, tolerance) {
    return isPointInInterval(this, start, end, tolerance);
};

Point.prototype.isWithinXInterval = function(start, end, tolerance) {
    return _inInterval(this, start, end, tolerance, 'x');
};

Point.prototype.isWithinYInterval = function(start, end, tolerance) {
    return _inInterval(this, start, end, tolerance, 'y');
};;

var isPointInInterval = function(point, start, end, tolerance) {
    return _inInterval(point, start, end, tolerance, 'x') && _isPointInInterval(point, start, end, tolerance, 'y');
};

var _inInterval = function(p, start, end, tolerance, dimension) {
    tolerance = tolerance || 0;
    var boundary = minMax(start[dimension], end[dimension]);
    boundary.min -= tolerance;
    boundary.max += tolerance;
    return (p[dimension] <= boundary.max && p[dimension] >= boundary.min);
};

var minMax = function(val1, val2) {
    return {
        min :  Math.min(val1, val2),
        max : Math.max(val1, val2)
    };
};

var Line = function(p1, p2) {
    //y = mx + t
    if(p1.x) {
        this.op1 = p1;
        this.op2 = p2;
        this.p1 = (p1.x <= p2.x)? p1 : p2;
        this.p2 = (p1.x > p2.x)? p1 : p2;
        this.m = this.calcGradient();
        this.t = this.calcYIntercept();
    } else {
        this.m = p1;
        this.t = p2;
    }
};

Line.prototype.calcYIntercept = function() {
    // y = m * x + t => t = -mx + y
    return (-1 * this.m * this.p1.x) + this.p1.y;
};

Line.prototype.getOrthogonal = function(p) {
    //
    var newM = -1 / this.m;
    var t = p.y - (newM * p.x);
    return new Line(newM,t);
};

Line.prototype.calcGradient = function() {
    return Line.calcGradient(this.p1, this.p2);
};

Line.prototype.calcNormalizedLineVector = function() {
    return Line.calcNormalizedLineVector(this.p1, this.p2);
};

Line.prototype.isLtR = function() {
    return this.op1.x < this.op2.x;
};

Line.prototype.isTtB = function() {
    return this.op1.y < this.op2.y;
};


Line.calcNormalizedLineVector = function(p1, p2) {
    var vector = {
        x : p2.x - p1.x,
        y : p2.y - p1.y
    };

    var length = Math.sqrt(vector.x*vector.x + vector.y*vector.y);

    vector.x = vector.x / length;
    vector.y = vector.y / length;
    return vector;
};

/*
 *  TODO: this is working if you provide start/end and distance (negative or positive) but not tested (and presumably not working)
 *  when given start/end dist and direction e.g move from start point -30 back.
 */
Line.moveAlong = function(p1,p2, dist, direction) {
    var vector = Line.calcNormalizedLineVector(p1,p2);

    //If there is no direction given we handle negative distances as direction -1 (from end to start)
    direction = direction || (dist < 0) ? -1 : 1;

    if(direction < 1) {
        dist = Line.calcDistance(p1,p2) + dist;
    }

    return {
        x : p1.x + vector.x * dist,
        y : p1.y + vector.y * dist
    };
};

Line.calcGradient = function(p1, p2) {
    return (p2.y - p1.y) / (p2.x - p1.x);
};

Line.prototype.calcFX = function(x) {
    var y = (this.m) * x + this.t;
    return {
        x : x,
        y : y
    };
};

Line.prototype.calcMidPoint = function() {
    return Line.calcMidPoint(this.p1, this.p2);
};

Line.calcMidPoint = function(p1, p2) {
    return {
        x : (p1.x+p2.x) / 2,
        y : (p1.y+p2.y) / 2
    };
};

Line.prototype.isVertical = function(x) {
    return !isFinite(this.m);
};

Line.prototype.isHorizontal = function(x) {
    return this.m === 0;
};

Line.prototype.calcLineIntercept = function(other) {
    //mx(1) + t(1) = mx(2) +t(2)
    var m = other.m + (-1 * this.m);
    var t = this.t + (-1 * other.t);
    var x = (m !== 0) ? t / m : t;
    return this.calcFX(x);
};

Line.calcDistance = function(p1, p2) {
    return Math.sqrt(Math.pow((p2.y - p1.y),2) + Math.pow((p2.x - p1.x),2));
}

var SimpleVector = function(x, y) {
    this.x = x;
    this.y = y;
};

SimpleVector.prototype.dot = function(that) {
    return this.x*that.x + this.y*that.y;
};

SimpleVector.fromPoints = function(p1, p2) {
    return new SimpleVector(
        p2.x - p1.x,
        p2.y - p1.y
    );
};

SimpleVector.prototype.subtract = function(that) {
    return new SimpleVector(this.x - that.x, this.y - that.y);
};

var Ellipse = function(cx, cy, rx, ry) {
    switch(arguments.length) {
        case 4:
            this.c = {x:cx,y:cy};
            this.rx = rx;
            this.ry = ry;
            break;
        case 3:
            this.c = cx;
            this.rx = cy;
            this.ry = rx;
            break;
    }
};

Ellipse.prototype.calcLineIntercept = function(p1,p2) {
    var result = [];

    if(arguments.length === 1) {
        p2 = p1.p2;
        p1 = p1.p1;
    }

    var origin = new SimpleVector(p1.x, p1.y);
    var dir = SimpleVector.fromPoints(p1, p2);
    var center = new SimpleVector(this.c.x, this.c.y);
    var diff = origin.subtract(center);
    var mDir = new SimpleVector(dir.x/(this.rx*this.rx),  dir.y/(this.ry*this.ry));
    var mDiff = new SimpleVector(diff.x/(this.rx*this.rx), diff.y/(this.ry*this.ry));

    var aDiff = dir.dot(mDir);
    var bDiff = dir.dot(mDiff);
    var cDiff = diff.dot(mDiff) - 1.0;
    var dDiff = bDiff*bDiff - aDiff*cDiff;

    if (dDiff > 0) {
        var root = Math.sqrt(dDiff);
        var tA  = (-bDiff - root) / aDiff;
        var tB  = (-bDiff + root) / aDiff;

        if (!((tA < 0 || 1 < tA) && (tB < 0 || 1 < tB))) {
            if (0 <= tA && tA <= 1) {
                result.push(lerp(p1, p2, tA));
            }
            if ( 0 <= tB && tB <= 1 ) {
                result.push(lerp(p1, p2, tB));
            }
        }
    } else {
        var t = -bDiff/aDiff;
        if (0 <= t && t <= 1) {
            result.push(lerp(p1. a2, t));
        }
    }

    return result;
};

Ellipse.prototype.overlays = function(p) {
    var bx = Math.pow((p.x - this.c.x), 2) / Math.pow(this.rx, 2);
    var by = Math.pow((p.y - this.c.y), 2) / Math.pow(this.ry, 2);
    return bx + by <= 1
};

var Circle = function(cx, cy, r) {
    if(arguments.length === 2) {
        this.c = cx;
        this.r = cy;
    } else {
        this.c = {x: cx, y : cy};
        this.r = r;
    }
};

Circle.prototype.overlays = function(p) {
    var bx = Math.pow((p.x - this.c.x), 2);
    var by = Math.pow((p.y - this.c.y), 2);
    return bx + by < Math.pow(this.r, 2);
};

Circle.prototype.calcLineIntercept = function(p1, p2) {
    var result = [];

    if(arguments.length === 1) {
        p2 = p1.p2;
        p1 = p1.p1;
    }

    var a = (p2.x - p1.x) * (p2.x - p1.x)
        + (p2.y - p1.y) * (p2.y - p1.y);
    var b  = 2 * ((p2.x - p1.x) * (p1.x - this.c.x)
        + (p2.y - p1.y) * (p1.y - this.c.y)   );
    var cc = this.c.x*this.c.x + this.c.y*this.c.y + p1.x*p1.x + p1.y*p1.y -
        2 * (this.c.x * p1.x + this.c.y * p1.y) - this.r*this.r;
    var deter = b*b - 4*a*cc;

    if(deter > 0) {
        var root  = Math.sqrt(deter);
        var tA = (-b + root) / (2*a);
        var tB = (-b - root) / (2*a);

        if (!((tA < 0 || tA > 1) && (tB < 0 || tB > 1))) {
            if (0 <= tA && tA <= 1) {
                result.push(lerp(p1, p2, tA));
            }

            if (0 <= tB && tB <= 1) {
                result.push(lerp(p1, p2, tB));
            }
        }
    }
    return result;
};

var lerp = function(a, b, t) {
    return {
        x : a.x + (b.x - a.x) * t,
        y : a.y + (b.y - a.y) * t
    };
};

var Vector = function() {
    this.vectors = [];
    var currentArr;
    for(var i = 0; i < arguments.length; i++) {
        if(object.isArray(arguments[i])) {
            if(currentArr) {
                this.add(currentArr);
                currentArr = undefined;
            }
            this.add(arguments[i]);
        } else {
            currentArr = currentArr || [];
            currentArr.push(arguments[i]);
        }
    };

    if(currentArr) {
        this.add(currentArr);
        delete currentArr;
    }
};

/**
 * Adds a vector value either by providing seperated arguments or an array of values
 */
Vector.prototype.add = function() {
    var value;
    if(arguments.length > 1) {
        value = [];
        for(var i = 0; i < arguments.length; i++) {
            value.push(arguments[i]);
        }
    } else if(arguments.length === 1) {
        value = arguments[0];
    }
    this.vectors.push(value);
};

Vector.prototype.value = function() {
    try {
        var path = object.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
        return getVectorValue(this.vectors, path);
    } catch(e) {
        console.error('get value vector failed - '+this.vectors+' args: '+arguments);
    }
};

Vector.prototype.clear = function() {
    this.vectors = [];
};

Vector.prototype.setValue = function(pathArr, value) {
    try {
        pathArr = !object.isArray(pathArr) ? [pathArr] : pathArr;
        var parentPath = pathArr.splice(0, pathArr.length -1);
        this.value(parentPath)[pathArr[pathArr.length -1]] = value;
    } catch(e) {
        console.error('set value vector failed - '+this.vectors+' args: '+arguments);
    }
};

Vector.prototype.insert = function(pathArr, value) {
    try {
        pathArr = !object.isArray(pathArr) ? [pathArr] : pathArr;
        var parentPath = pathArr.splice(0, pathArr.length -1);
        this.value(parentPath).splice(pathArr[pathArr.length -1], 0, value);
    } catch(e) {
        console.error('set value vector failed - '+this.vectors+' args: '+arguments);
    }
};

Vector.prototype.length = function() {
    return this.vectors.length;
}

Vector.prototype.remove = function(pathArr) {
    pathArr = !object.isArray(pathArr) ? [pathArr] : pathArr;
    var parentPath = pathArr.splice(0, pathArr.length -1);
    this.value(parentPath).splice(pathArr[pathArr.length -1], 1);
};

Vector.prototype.last = function() {
    return this.vectors[this.vectors.length -1];
};

Vector.prototype.each = function(handler) {
    object.each(this.vectors, function(index, value) {
        handler(index,value);
    });
};

/**
 * Note the indexes can be negative to retrieve values from the end of the vector e.g. -1 is the last
 * @param vectorArr
 * @param args
 * @returns {*}
 */
var getVectorValue = function(vectorArr, args) {
    if(!args) {
        return vectorArr;
    }else if(object.isArray(args)) {
        switch(args.length) {
            case 0:
                return vectorArr;
            case 1:
                return object.valueByIndex(vectorArr, args[0]);
            default:
                var index = args[0];
                return getVectorValue(vectorArr[index], args.splice(1));
        }
    } else {
        return object.valueByIndex(vectorArr, args);
    }
};

/**
 * Checks if the difference between source and target value is lower than the given range value
 */
var checkRangeDiff = function(source, target, range) {
    return isInDiffRange(target, source, range);
};

var isInDiffRange = function(p1, p2, range) {
    return Math.abs(p1 - p2) < range;
};

var getPoint = function(x, y) {
    var result;
    if(x && object.isDefined(x.x) && object.isDefined(x.y)) {
        result = x;
    } else if(!isNaN(x) && !isNaN(y)) {
        result = {
            x : x,
            y : y
        };
    } else if(object.isDefined(x) && object.isDefined(y)) {
        result = toPoint(x,y);
    }
    return result;
};

var toPoint = function(x,y) {
    x = (object.isString(x)) ? parseFloat(x) : x;
    y = (object.isString(y)) ? parseFloat(y) : y;

    return {x:x,y:y};
};

module.exports = {
    calcLineIntersection : calcLineIntersection,
    Line : Line,
    Circle : Circle,
    Ellipse : Ellipse,
    Vector : Vector,
    Point : Point,
    isPointInInterval : isPointInInterval,
    minMax : minMax,
    checkRangeDiff : checkRangeDiff,
    getPoint : getPoint,
    bezier : bezier
};
},{"./bezier":69,"./object":71}],71:[function(require,module,exports){
module.exports = {
    each: function() {
        return $.each(arguments[0], arguments[1], arguments[2]);
    },

    grep: function(arr, filter, invert) {
        return $.grep(arr, filter, invert);
    },

    isArray: function(obj) {
        return $.isArray(obj);
    },

    toArray : function(obj) {
        return $.map(obj, function(value, index) {
            return [value];
        });
    },

    removeFromArray: function(arr, item) {
        var index = arr.indexOf(item);
        if(index >= 0) {
            arr.splice(index, 1);
            return true;
        }
        return false;
    },

    sort: function(obj, sort) {
        var arr;
        if(!obj) {
            return;
        } else if(this.isArray(obj)) {
            arr = obj;
        } else if(this.isObject(obj)) {
            arr = $.map(obj, function (index, val) {
                return obj[val];
            });
        }

        return arr.sort(sort);
    },

    valueByIndex: function(arr, index) {
        var index = this.getIndex(arr,index);
        return arr[index];
    },

    getIndex: function(arr, index) {
        var result = index;
        // for negative indexes we return values counted from the other side so -1 is the last index
        // if the negative index is out of range we return the last index.
        if(index < 0) {
            result = arr.length + index;
            result = (result > arr.length -1 || result < 0) ? arr.length -1 : result;
        }
        return result;
    },

    isFunction: function(obj) {
        return Object.prototype.toString.call(obj) === '[object Function]';
    },

    isObject: function(obj) {
        return $.isPlainObject(obj);
    },

    isJQuery: function(obj) {
        return obj.jquery;
    },

    isString: function(obj) {
        return typeof obj === 'string';
    },

    isBoolean: function(obj) {
        return typeof obj === 'boolean';
    },

    isDefined: function(obj) {
        if(arguments.length > 1) {
            var result = true;
            var that = this;
            this.each(arguments, function(index, value) {
                if(!that.isDefined(value)) {
                    result = false;
                    return false;
                }
            });

            return result;
        }
        return typeof obj !== 'undefined';
    },

    merge: function(target, toMerge) {
        return $.merge(target, toMerge);
    },


    addValue: function(target, newVal) {
        if(isArray(newVal)) {
            merge(target);
        } else {
            target.push(newVal);
        }
    },

    extend: function(target, obj1, obj2) {
        return $.extend(target,obj1,obj2);
    },

    cloneArray: function(arr) {
        return arr.slice(0);
    },

    cloneObject: function(oldObject, deep) {
        deep = deep || false;
        return $.extend(deep, {}, oldObject);
    }
    
}
},{}],72:[function(require,module,exports){
var object = require('./object');

exports.endsWith = function(val, suffix) {
    if(!object.isDefined(val) || !object.isDefined(suffix)) {
        return false;
    }
    return val.indexOf(suffix, val.length - suffix.length) !== -1;
};

exports.startsWith = function(val, prefix) {
    if(!object.isDefined(val) || !object.isDefined(prefix)) {
        return false;
    }
    return val.indexOf(prefix) === 0;
};
},{"./object":71}],73:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"./../dom/dom":44,"./app":68,"./math":70,"./object":71,"./string":72,"./xml":74,"dup":67,"util":79}],74:[function(require,module,exports){
var string = require('./string');

var serializeToString = function(node) {
    var s = new XMLSerializer();
    node = (node.jQuery) ? node[0] : node;
    return s.serializeToString(node);
};

var parseXML = function(strData) {
    return $.parseXML(strData);
};

var format = function (xml) {
    var intend = -1;
    var result = '';
    xml = xml.replace(/(\r\n|\n|\r)/gm,"");
    var lastWasClose = false;
    var lastHadText = false;
    $.each(xml.split('<'), function(index, node) {
        node = node.trim();
        if(node) {
            if(node.indexOf('/') !== 0) {
                if(!lastWasClose) {
                    intend++;
                }

                lastHadText = !string.endsWith(node, '>');
                lastWasClose = string.endsWith(node, '/>');
            } else {
                if(!lastHadText) {
                    lastWasClose = true;
                    intend--;
                }
                lastHadText = !string.endsWith(node, '>');
            }

            var padding = '';
            for (var i = 0; i < intend; i++) {
                padding += '  ';
            }

            var text;
            if(lastHadText) {
                var splitted = node.split('>');
                node = splitted[0] + '>';
                text = splitted[1];
            }
            result += padding + '<'+node+'\r\n';

            if(text) {
                result += padding + '  ' + text+'\r\n';
            }

        }
    });
    return result;
};

module.exports = {
    serializeToString : serializeToString,
    parseXML : parseXML,
    format: format
};
},{"./string":72}],75:[function(require,module,exports){
(function (process,global){
/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 2.9.34
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};

},{}],2:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule.js");
var Queue = _dereq_("./queue.js");
var util = _dereq_("./util.js");

function Async() {
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule =
        schedule.isStatic ? schedule(this.drainQueues) : schedule;
}

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.enableTrampoline = function() {
    if (!this._trampolineEnabled) {
        this._trampolineEnabled = true;
        this._schedule = function(fn) {
            setTimeout(fn, 0);
        };
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._normalQueue.length() > 0;
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    if (schedule.isStatic) {
        schedule = function(fn) { setTimeout(fn, 0); };
    }
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype.invokeFirst = function (fn, receiver, arg) {
    this._normalQueue.unshift(fn, receiver, arg);
    this._queueTick();
};

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = new Async();
module.exports.firstLineError = firstLineError;

},{"./queue.js":28,"./schedule.js":31,"./util.js":38}],3:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (this._isPending()) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();

    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, ret._progress, ret, context);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 131072;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~131072);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 131072) === 131072;
};

Promise.bind = function (thisArg, value) {
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);

    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        maybePromise._then(function() {
            ret._resolveCallback(value);
        }, ret._reject, ret._progress, ret, null);
    } else {
        ret._resolveCallback(value);
    }
    return ret;
};
};

},{}],4:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise.js")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise.js":23}],5:[function(_dereq_,module,exports){
"use strict";
var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function(Promise) {
var util = _dereq_("./util.js");
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (!true) {
var makeMethodCaller = function (methodName) {
    return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
};

var makeGetter = function (propertyName) {
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
};

var getCompiled = function(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== "function") {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        }
    }
    return ret;
};

getMethodCaller = function(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
};

getGetter = function(name) {
    return getCompiled(name, makeGetter, getterCache);
};
}

function ensureMethod(obj, methodName) {
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj) + " has no method '" +
            util.toString(methodName) + "'";
        throw new Promise.TypeError(message);
    }
    return fn;
}

function caller(obj) {
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
    if (!true) {
        if (canEvaluate) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            }
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};

},{"./util.js":38}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var errors = _dereq_("./errors.js");
var async = _dereq_("./async.js");
var CancellationError = errors.CancellationError;

Promise.prototype._cancel = function (reason) {
    if (!this.isCancellable()) return this;
    var parent;
    var promiseToReject = this;
    while ((parent = promiseToReject._cancellationParent) !== undefined &&
        parent.isCancellable()) {
        promiseToReject = parent;
    }
    this._unsetCancellable();
    promiseToReject._target()._rejectCallback(reason, false, true);
};

Promise.prototype.cancel = function (reason) {
    if (!this.isCancellable()) return this;
    if (reason === undefined) reason = new CancellationError();
    async.invokeLater(this._cancel, this, reason);
    return this;
};

Promise.prototype.cancellable = function () {
    if (this._cancellable()) return this;
    async.enableTrampoline();
    this._setCancellable();
    this._cancellationParent = undefined;
    return this;
};

Promise.prototype.uncancellable = function () {
    var ret = this.then();
    ret._unsetCancellable();
    return ret;
};

Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
    var ret = this._then(didFulfill, didReject, didProgress,
                         undefined, undefined);

    ret._setCancellable();
    ret._cancellationParent = undefined;
    return ret;
};
};

},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var async = _dereq_("./async.js");
var util = _dereq_("./util.js");
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var warn;

function CapturedTrace(parent) {
    this._parent = parent;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.parent = function() {
    return this._parent;
};

CapturedTrace.prototype.hasParent = function() {
    return this._parent !== undefined;
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = CapturedTrace.parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = stackFramePattern.test(line) ||
            "    (No stack trace)" === line;
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0) {
        stack = stack.slice(i);
    }
    return stack;
}

CapturedTrace.parseStackAndMessage = function(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: cleanStack(stack)
    };
};

CapturedTrace.formatAndLogError = function(error, title) {
    if (typeof console !== "undefined") {
        var message;
        if (typeof error === "object" || typeof error === "function") {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof warn === "function") {
            warn(message);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
};

CapturedTrace.unhandledRejection = function (reason) {
    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
};

CapturedTrace.isSupported = function () {
    return typeof captureStackTrace === "function";
};

CapturedTrace.fireRejectionEvent =
function(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent(name, reason, promise);
    } catch (e) {
        globalEventFired = true;
        async.throwLater(e);
    }

    var domEventFired = false;
    if (fireDomEvent) {
        try {
            domEventFired = fireDomEvent(name.toLowerCase(), {
                reason: reason,
                promise: promise
            });
        } catch (e) {
            domEventFired = true;
            async.throwLater(e);
        }
    }

    if (!globalEventFired && !localEventFired && !domEventFired &&
        name === "unhandledRejection") {
        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
    }
};

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj.toString();
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}
CapturedTrace.setBounds = function(firstLineError, lastLineError) {
    if (!CapturedTrace.isSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit = Error.stackTraceLimit + 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit = Error.stackTraceLimit - 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit = Error.stackTraceLimit - 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

var fireDomEvent;
var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function(name, reason, promise) {
            if (name === "rejectionHandled") {
                return process.emit(name, promise);
            } else {
                return process.emit(name, reason, promise);
            }
        };
    } else {
        var customEventWorks = false;
        var anyEventWorks = true;
        try {
            var ev = new self.CustomEvent("test");
            customEventWorks = ev instanceof CustomEvent;
        } catch (e) {}
        if (!customEventWorks) {
            try {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                self.dispatchEvent(event);
            } catch (e) {
                anyEventWorks = false;
            }
        }
        if (anyEventWorks) {
            fireDomEvent = function(type, detail) {
                var event;
                if (customEventWorks) {
                    event = new self.CustomEvent(type, {
                        detail: detail,
                        bubbles: false,
                        cancelable: true
                    });
                } else if (self.dispatchEvent) {
                    event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, false, true, detail);
                }

                return event ? !self.dispatchEvent(event) : false;
            };
        }

        var toWindowMethodNameMap = {};
        toWindowMethodNameMap["unhandledRejection"] = ("on" +
            "unhandledRejection").toLowerCase();
        toWindowMethodNameMap["rejectionHandled"] = ("on" +
            "rejectionHandled").toLowerCase();

        return function(name, reason, promise) {
            var methodName = toWindowMethodNameMap[name];
            var method = self[methodName];
            if (!method) return false;
            if (name === "rejectionHandled") {
                method.call(self, promise);
            } else {
                method.call(self, reason, promise);
            }
            return true;
        };
    }
})();

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    warn = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        warn = function(message) {
            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        warn = function(message) {
            console.warn("%c" + message, "color: red");
        };
    }
}

return CapturedTrace;
};

},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util.js");
var errors = _dereq_("./errors.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var keys = _dereq_("./es5.js").keys;
var TypeError = errors.TypeError;

function CatchFilter(instances, callback, promise) {
    this._instances = instances;
    this._callback = callback;
    this._promise = promise;
}

function safePredicate(predicate, e) {
    var safeObject = {};
    var retfilter = tryCatch(predicate).call(safeObject, e);

    if (retfilter === errorObj) return retfilter;

    var safeKeys = keys(safeObject);
    if (safeKeys.length) {
        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
        return errorObj;
    }
    return retfilter;
}

CatchFilter.prototype.doFilter = function (e) {
    var cb = this._callback;
    var promise = this._promise;
    var boundTo = promise._boundValue();
    for (var i = 0, len = this._instances.length; i < len; ++i) {
        var item = this._instances[i];
        var itemIsErrorType = item === Error ||
            (item != null && item.prototype instanceof Error);

        if (itemIsErrorType && e instanceof item) {
            var ret = tryCatch(cb).call(boundTo, e);
            if (ret === errorObj) {
                NEXT_FILTER.e = ret.e;
                return NEXT_FILTER;
            }
            return ret;
        } else if (typeof item === "function" && !itemIsErrorType) {
            var shouldHandle = safePredicate(item, e);
            if (shouldHandle === errorObj) {
                e = errorObj.e;
                break;
            } else if (shouldHandle) {
                var ret = tryCatch(cb).call(boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            }
        }
    }
    NEXT_FILTER.e = e;
    return NEXT_FILTER;
};

return CatchFilter;
};

},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, CapturedTrace, isDebugging) {
var contextStack = [];
function Context() {
    this._trace = new CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (!isDebugging()) return;
    if (this._trace !== undefined) {
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (!isDebugging()) return;
    if (this._trace !== undefined) {
        contextStack.pop();
    }
};

function createContext() {
    if (isDebugging()) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}

Promise.prototype._peekContext = peekContext;
Promise.prototype._pushContext = Context.prototype._pushContext;
Promise.prototype._popContext = Context.prototype._popContext;

return createContext;
};

},{}],10:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, CapturedTrace) {
var getDomain = Promise._getDomain;
var async = _dereq_("./async.js");
var Warning = _dereq_("./errors.js").Warning;
var util = _dereq_("./util.js");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var debugging = false || (util.isNode &&
                    (!!process.env["BLUEBIRD_DEBUG"] ||
                     process.env["NODE_ENV"] === "development"));

if (debugging) {
    async.disableTrampolineIfNecessary();
}

Promise.prototype._ignoreRejections = function() {
    this._unsetRejectionIsUnhandled();
    this._bitField = this._bitField | 16777216;
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 16777216) !== 0) return;
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    CapturedTrace.fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._getCarriedStackTrace() || this._settledValue;
        this._setUnhandledRejectionIsNotified();
        CapturedTrace.fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 524288;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~524288);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 524288) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 2097152;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~2097152);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 2097152) > 0;
};

Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
    this._bitField = this._bitField | 1048576;
    this._fulfillmentHandler0 = capturedTrace;
};

Promise.prototype._isCarryingStackTrace = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._getCarriedStackTrace = function () {
    return this._isCarryingStackTrace()
        ? this._fulfillmentHandler0
        : undefined;
};

Promise.prototype._captureStackTrace = function () {
    if (debugging) {
        this._trace = new CapturedTrace(this._peekContext());
    }
    return this;
};

Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
    if (debugging && canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = CapturedTrace.parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
};

Promise.prototype._warn = function(message) {
    var warning = new Warning(message);
    var ctx = this._peekContext();
    if (ctx) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = CapturedTrace.parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }
    CapturedTrace.formatAndLogError(warning, "");
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                 : undefined;
};

Promise.longStackTraces = function () {
    if (async.haveItemsQueued() &&
        debugging === false
   ) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
    }
    debugging = CapturedTrace.isSupported();
    if (debugging) {
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return debugging && CapturedTrace.isSupported();
};

if (!CapturedTrace.isSupported()) {
    Promise.longStackTraces = function(){};
    debugging = false;
}

return function() {
    return debugging;
};
};

},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util.js");
var isPrimitive = util.isPrimitive;

module.exports = function(Promise) {
var returner = function () {
    return this;
};
var thrower = function () {
    throw this;
};
var returnUndefined = function() {};
var throwUndefined = function() {
    throw undefined;
};

var wrapper = function (value, action) {
    if (action === 1) {
        return function () {
            throw value;
        };
    } else if (action === 2) {
        return function () {
            return value;
        };
    }
};


Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value === undefined) return this.then(returnUndefined);

    if (isPrimitive(value)) {
        return this._then(
            wrapper(value, 2),
            undefined,
            undefined,
            undefined,
            undefined
       );
    }
    return this._then(returner, undefined, undefined, value, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    if (reason === undefined) return this.then(throwUndefined);

    if (isPrimitive(reason)) {
        return this._then(
            wrapper(reason, 1),
            undefined,
            undefined,
            undefined,
            undefined
       );
    }
    return this._then(thrower, undefined, undefined, reason, undefined);
};
};

},{"./util.js":38}],12:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;

Promise.prototype.each = function (fn) {
    return PromiseReduce(this, fn, null, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseReduce(promises, fn, null, INTERNAL);
};
};

},{}],13:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5.js");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util.js");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};

},{}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
var util = _dereq_("./util.js");
var isPrimitive = util.isPrimitive;
var thrower = util.thrower;

function returnThis() {
    return this;
}
function throwThis() {
    throw this;
}
function return$(r) {
    return function() {
        return r;
    };
}
function throw$(r) {
    return function() {
        throw r;
    };
}
function promisedFinally(ret, reasonOrValue, isFulfilled) {
    var then;
    if (isPrimitive(reasonOrValue)) {
        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
    } else {
        then = isFulfilled ? returnThis : throwThis;
    }
    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
}

function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundValue())
                    : handler();

    if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            return promisedFinally(maybePromise, reasonOrValue,
                                    promise.isFulfilled());
        }
    }

    if (promise.isRejected()) {
        NEXT_FILTER.e = reasonOrValue;
        return NEXT_FILTER;
    } else {
        return reasonOrValue;
    }
}

function tapHandler(value) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundValue(), value)
                    : handler(value);

    if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            return promisedFinally(maybePromise, value, true);
        }
    }
    return value;
}

Promise.prototype._passThroughHandler = function (handler, isFinally) {
    if (typeof handler !== "function") return this.then();

    var promiseAndHandler = {
        promise: this,
        handler: handler
    };

    return this._then(
            isFinally ? finallyHandler : tapHandler,
            isFinally ? finallyHandler : undefined, undefined,
            promiseAndHandler, undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThroughHandler(handler, true);
};

Promise.prototype.tap = function (handler) {
    return this._passThroughHandler(handler, false);
};
};

},{"./util.js":38}],17:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise) {
var errors = _dereq_("./errors.js");
var TypeError = errors.TypeError;
var util = _dereq_("./util.js");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    for (var i = 0; i < yieldHandlers.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
            traceParent._pushContext();
            var ret = Promise.reject(errorObj.e);
            traceParent._popContext();
            return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    var promise = this._promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === "function"
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
}

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._next(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    if (result === errorObj) {
        return this._promise._rejectCallback(result.e, false, true);
    }

    var value = result.value;
    if (result.done === true) {
        this._promise._resolveCallback(value);
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._throw(
                    new TypeError(
                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
                        "From coroutine:\u000a" +
                        this._stack.split("\n").slice(1, -7).join("\n")
                    )
                );
                return;
            }
        }
        maybePromise._then(
            this._next,
            this._throw,
            undefined,
            this,
            null
       );
    }
};

PromiseSpawn.prototype._throw = function (reason) {
    this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch(this._generator["throw"])
        .call(this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._next = function (value) {
    this._promise._pushContext();
    var result = tryCatch(this._generator.next).call(this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== "function") {
        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        spawn._generator = generator;
        spawn._next(undefined);
        return spawn.promise();
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};

},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
var util = _dereq_("./util.js");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var caller = function(count) {
        var values = [];
        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
        return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
    };
    var thenCallbacks = [];
    var callers = [undefined];
    for (var i = 1; i <= 5; ++i) {
        thenCallbacks.push(thenCallback(i));
        callers.push(caller(i));
    }

    var Holder = function(total, fn) {
        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
        this.fn = fn;
        this.total = total;
        this.now = 0;
    };

    Holder.prototype.callers = callers;
    Holder.prototype.checkFulfillment = function(promise) {
        var now = this.now;
        now++;
        var total = this.total;
        if (now >= total) {
            var handler = this.callers[total];
            promise._pushContext();
            var ret = tryCatch(handler)(this);
            promise._popContext();
            if (ret === errorObj) {
                promise._rejectCallback(ret.e, false, true);
            } else {
                promise._resolveCallback(ret);
            }
        } else {
            this.now = now;
        }
    };

    var reject = function (reason) {
        this._reject(reason);
    };
}
}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last < 6 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var holder = new Holder(last, fn);
                var callbacks = thenCallbacks;
                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        if (maybePromise._isPending()) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                        } else if (maybePromise._isFulfilled()) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else {
                            ret._reject(maybePromise._reason());
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }
                return ret;
            }
        }
    }
    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util.js":38}],19:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) {
var getDomain = Promise._getDomain;
var async = _dereq_("./async.js");
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var PENDING = {};
var EMPTY_ARRAY = [];

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    var domain = getDomain();
    this._callback = domain === null ? fn : domain.bind(fn);
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
    async.invoke(init, this, undefined);
}
util.inherits(MappingPromiseArray, PromiseArray);
function init() {this._init$(undefined, -2);}

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;
    if (values[index] === PENDING) {
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var callback = this._callback;
        var receiver = this._promise._boundValue();
        this._promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        this._promise._popContext();
        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                if (limit >= 1) this._inFlight++;
                values[index] = PENDING;
                return maybePromise._proxyPromiseArray(this, index);
            } else if (maybePromise._isFulfilled()) {
                ret = maybePromise._value();
            } else {
                return this._reject(maybePromise._reason());
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }

    }
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    var limit = typeof options === "object" && options !== null
        ? options.concurrency
        : 0;
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter);
}

Promise.prototype.map = function (fn, options) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

    return map(this, fn, options, null).promise();
};

Promise.map = function (promises, fn, options, _filter) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    return map(promises, fn, options, _filter).promise();
};


};

},{"./async.js":2,"./util.js":38}],20:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn, args, ctx) {
    if (typeof fn !== "function") {
        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value = util.isArray(args)
        ? tryCatch(fn).apply(ctx, args)
        : tryCatch(fn).call(ctx, args);
    ret._popContext();
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false, true);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util.js":38}],21:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var util = _dereq_("./util.js");
var async = _dereq_("./async.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret =
        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundValue();
    var ret = val === undefined
        ? tryCatch(nodeback).call(receiver, null)
        : tryCatch(nodeback).call(receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var target = promise._target();
        var newReason = target._getCarriedStackTrace();
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.asCallback =
Promise.prototype.nodeify = function (nodeback, options) {
    if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};

},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray) {
var util = _dereq_("./util.js");
var async = _dereq_("./async.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

Promise.prototype.progressed = function (handler) {
    return this._then(undefined, undefined, handler, undefined, undefined);
};

Promise.prototype._progress = function (progressValue) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._target()._progressUnchecked(progressValue);

};

Promise.prototype._progressHandlerAt = function (index) {
    return index === 0
        ? this._progressHandler0
        : this[(index << 2) + index - 5 + 2];
};

Promise.prototype._doProgressWith = function (progression) {
    var progressValue = progression.value;
    var handler = progression.handler;
    var promise = progression.promise;
    var receiver = progression.receiver;

    var ret = tryCatch(handler).call(receiver, progressValue);
    if (ret === errorObj) {
        if (ret.e != null &&
            ret.e.name !== "StopProgressPropagation") {
            var trace = util.canAttachTrace(ret.e)
                ? ret.e : new Error(util.toString(ret.e));
            promise._attachExtraTrace(trace);
            promise._progress(ret.e);
        }
    } else if (ret instanceof Promise) {
        ret._then(promise._progress, null, null, promise, undefined);
    } else {
        promise._progress(ret);
    }
};


Promise.prototype._progressUnchecked = function (progressValue) {
    var len = this._length();
    var progress = this._progress;
    for (var i = 0; i < len; i++) {
        var handler = this._progressHandlerAt(i);
        var promise = this._promiseAt(i);
        if (!(promise instanceof Promise)) {
            var receiver = this._receiverAt(i);
            if (typeof handler === "function") {
                handler.call(receiver, progressValue, promise);
            } else if (receiver instanceof PromiseArray &&
                       !receiver._isResolved()) {
                receiver._promiseProgressed(progressValue, promise);
            }
            continue;
        }

        if (typeof handler === "function") {
            async.invoke(this._doProgressWith, this, {
                handler: handler,
                promise: promise,
                receiver: this._receiverAt(i),
                value: progressValue
            });
        } else {
            async.invoke(progress, promise, progressValue);
        }
    }
};
};

},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
};
var reflect = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};

var util = _dereq_("./util.js");

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var async = _dereq_("./async.js");
var errors = _dereq_("./errors.js");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {e: null};
var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array.js")(Promise, INTERNAL,
                                    tryConvertToPromise, apiRejection);
var CapturedTrace = _dereq_("./captured_trace.js")();
var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
 /*jshint unused:false*/
var createContext =
    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
var PromiseResolver = _dereq_("./promise_resolver.js");
var nodebackForPromise = PromiseResolver._nodebackForPromise;
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function Promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
    }
    if (this.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._progressHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settledValue = undefined;
    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (typeof item === "function") {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(
                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        var catchFilter = new CatchFilter(catchInstances, fn, this);
        return this._then(undefined, catchFilter.doFilter, undefined,
            catchFilter, undefined);
    }
    return this._then(undefined, fn, undefined, undefined, undefined);
};

Promise.prototype.reflect = function () {
    return this._then(reflect, reflect, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject, didProgress) {
    if (isDebugging() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, didProgress,
        undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject, didProgress) {
    var promise = this._then(didFulfill, didReject, didProgress,
        undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (didFulfill, didReject) {
    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
};

Promise.prototype.isCancellable = function () {
    return !this.isResolved() &&
        this._cancellable();
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = function(fn) {
    var ret = new Promise(INTERNAL);
    var result = tryCatch(fn)(nodebackForPromise(ret));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true, true);
    }
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.defer = Promise.pending = function () {
    var promise = new Promise(INTERNAL);
    return new PromiseResolver(promise);
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        var val = ret;
        ret = new Promise(INTERNAL);
        ret._fulfillUnchecked(val);
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    var prev = async._schedule;
    async._schedule = fn;
    return prev;
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    didProgress,
    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

    if (!haveInternalData) {
        ret._propagateFrom(this, 4 | 1);
        ret._captureStackTrace();
    }

    var target = this._target();
    if (target !== this) {
        if (receiver === undefined) receiver = this._boundTo;
        if (!haveInternalData) ret._setIsMigrated();
    }

    var callbackIndex = target._addCallbacks(didFulfill,
                                             didReject,
                                             didProgress,
                                             ret,
                                             receiver,
                                             getDomain());

    if (target._isResolved() && !target._isSettlePromisesQueued()) {
        async.invoke(
            target._settlePromiseAtPostResolution, target, callbackIndex);
    }

    return ret;
};

Promise.prototype._settlePromiseAtPostResolution = function (index) {
    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
    this._settlePromiseAt(index);
};

Promise.prototype._length = function () {
    return this._bitField & 131071;
};

Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
    return (this._bitField & 939524096) > 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 536870912) === 536870912;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -131072) |
        (len & 131071);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 536870912;
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 33554432;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 33554432) > 0;
};

Promise.prototype._cancellable = function () {
    return (this._bitField & 67108864) > 0;
};

Promise.prototype._setCancellable = function () {
    this._bitField = this._bitField | 67108864;
};

Promise.prototype._unsetCancellable = function () {
    this._bitField = this._bitField & (~67108864);
};

Promise.prototype._setIsMigrated = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._unsetIsMigrated = function () {
    this._bitField = this._bitField & (~4194304);
};

Promise.prototype._isMigrated = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0
        ? this._receiver0
        : this[
            index * 5 - 5 + 4];
    if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return index === 0
        ? this._promise0
        : this[index * 5 - 5 + 3];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return index === 0
        ? this._fulfillmentHandler0
        : this[index * 5 - 5 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return index === 0
        ? this._rejectionHandler0
        : this[index * 5 - 5 + 1];
};

Promise.prototype._boundValue = function() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
};

Promise.prototype._migrateCallbacks = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var progress = follower._progressHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (promise instanceof Promise) promise._setIsMigrated();
    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    progress,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        if (receiver !== undefined) this._receiver0 = receiver;
        if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : domain.bind(fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : domain.bind(reject);
        }
        if (typeof progress === "function") {
            this._progressHandler0 =
                domain === null ? progress : domain.bind(progress);
        }
    } else {
        var base = index * 5 - 5;
        this[base + 3] = promise;
        this[base + 4] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : domain.bind(fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : domain.bind(reject);
        }
        if (typeof progress === "function") {
            this[base + 2] =
                domain === null ? progress : domain.bind(progress);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
    var index = this._length();

    if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
    }
    if (index === 0) {
        this._promise0 = promiseSlotValue;
        this._receiver0 = receiver;
    } else {
        var base = index * 5 - 5;
        this[base + 3] = promiseSlotValue;
        this[base + 4] = receiver;
    }
    this._setLength(index + 1);
};

Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
    this._setProxyHandlers(promiseArray, index);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false, true);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    var propagationFlags = 1 | (shouldBind ? 4 : 0);
    this._propagateFrom(maybePromise, propagationFlags);
    var promise = maybePromise._target();
    if (promise._isPending()) {
        var len = this._length();
        for (var i = 0; i < len; ++i) {
            promise._migrateCallbacks(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (promise._isFulfilled()) {
        this._fulfillUnchecked(promise._value());
    } else {
        this._rejectUnchecked(promise._reason(),
            promise._getCarriedStackTrace());
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
    if (!shouldNotMarkOriginatingFromRejection) {
        util.markAsOriginatingFromRejection(reason);
    }
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason, hasStack ? undefined : trace);
};

Promise.prototype._resolveFromResolver = function (resolver) {
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = tryCatch(resolver)(function(value) {
        if (promise === null) return;
        promise._resolveCallback(value);
        promise = null;
    }, function (reason) {
        if (promise === null) return;
        promise._rejectCallback(reason, synchronous);
        promise = null;
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined && r === errorObj && promise !== null) {
        promise._rejectCallback(r.e, true, true);
        promise = null;
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    if (promise._isRejected()) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY && !this._isRejected()) {
        x = tryCatch(handler).apply(this._boundValue(), value);
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    promise._popContext();

    if (x === errorObj || x === promise || x === NEXT_FILTER) {
        var err = x === promise ? makeSelfResolutionError() : x.e;
        promise._rejectCallback(err, false, true);
    } else {
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._cleanValues = function () {
    if (this._cancellable()) {
        this._cancellationParent = undefined;
    }
};

Promise.prototype._propagateFrom = function (parent, flags) {
    if ((flags & 1) > 0 && parent._cancellable()) {
        this._setCancellable();
        this._cancellationParent = parent;
    }
    if ((flags & 4) > 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
};

Promise.prototype._fulfill = function (value) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._fulfillUnchecked(value);
};

Promise.prototype._reject = function (reason, carriedStackTrace) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._rejectUnchecked(reason, carriedStackTrace);
};

Promise.prototype._settlePromiseAt = function (index) {
    var promise = this._promiseAt(index);
    var isPromise = promise instanceof Promise;

    if (isPromise && promise._isMigrated()) {
        promise._unsetIsMigrated();
        return async.invoke(this._settlePromiseAt, this, index);
    }
    var handler = this._isFulfilled()
        ? this._fulfillmentHandlerAt(index)
        : this._rejectionHandlerAt(index);

    var carriedStackTrace =
        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
    var value = this._settledValue;
    var receiver = this._receiverAt(index);
    this._clearCallbackDataAtIndex(index);

    if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof PromiseArray) {
        if (!receiver._isResolved()) {
            if (this._isFulfilled()) {
                receiver._promiseFulfilled(value, promise);
            }
            else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (this._isFulfilled()) {
            promise._fulfill(value);
        } else {
            promise._reject(value, carriedStackTrace);
        }
    }

    if (index >= 4 && (index & 31) === 4)
        async.invokeLater(this._setLength, this, 0);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    if (index === 0) {
        if (!this._isCarryingStackTrace()) {
            this._fulfillmentHandler0 = undefined;
        }
        this._rejectionHandler0 =
        this._progressHandler0 =
        this._receiver0 =
        this._promise0 = undefined;
    } else {
        var base = index * 5 - 5;
        this[base + 3] =
        this[base + 4] =
        this[base + 0] =
        this[base + 1] =
        this[base + 2] = undefined;
    }
};

Promise.prototype._isSettlePromisesQueued = function () {
    return (this._bitField &
            -1073741824) === -1073741824;
};

Promise.prototype._setSettlePromisesQueued = function () {
    this._bitField = this._bitField | -1073741824;
};

Promise.prototype._unsetSettlePromisesQueued = function () {
    this._bitField = this._bitField & (~-1073741824);
};

Promise.prototype._queueSettlePromises = function() {
    async.settlePromises(this);
    this._setSettlePromisesQueued();
};

Promise.prototype._fulfillUnchecked = function (value) {
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err, undefined);
    }
    this._setFulfilled();
    this._settledValue = value;
    this._cleanValues();

    if (this._length() > 0) {
        this._queueSettlePromises();
    }
};

Promise.prototype._rejectUncheckedCheckError = function (reason) {
    var trace = util.ensureErrorObject(reason);
    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
};

Promise.prototype._rejectUnchecked = function (reason, trace) {
    if (reason === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err);
    }
    this._setRejected();
    this._settledValue = reason;
    this._cleanValues();

    if (this._isFinal()) {
        async.throwLater(function(e) {
            if ("stack" in e) {
                async.invokeFirst(
                    CapturedTrace.unhandledRejection, undefined, e);
            }
            throw e;
        }, trace === undefined ? reason : trace);
        return;
    }

    if (trace !== undefined && trace !== reason) {
        this._setCarriedStackTrace(trace);
    }

    if (this._length() > 0) {
        this._queueSettlePromises();
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._settlePromises = function () {
    this._unsetSettlePromisesQueued();
    var len = this._length();
    for (var i = 0; i < len; i++) {
        this._settlePromiseAt(i);
    }
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

_dereq_("./progress.js")(Promise, PromiseArray);
_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
_dereq_("./direct_resolve.js")(Promise);
_dereq_("./synchronous_inspection.js")(Promise);
_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
Promise.Promise = Promise;
_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
_dereq_('./cancel.js')(Promise);
_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
_dereq_('./nodeify.js')(Promise);
_dereq_('./call_get.js')(Promise);
_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
_dereq_('./settle.js')(Promise, PromiseArray);
_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
_dereq_('./promisify.js')(Promise, INTERNAL);
_dereq_('./any.js')(Promise);
_dereq_('./each.js')(Promise, INTERNAL);
_dereq_('./timers.js')(Promise, INTERNAL);
_dereq_('./filter.js')(Promise, INTERNAL);
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._progressHandler0 = value;                                         
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
        p._settledValue = value;                                             
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
    return Promise;                                                          

};

},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection) {
var util = _dereq_("./util.js");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    var parent;
    if (values instanceof Promise) {
        parent = values;
        promise._propagateFrom(parent, 1 | 4);
    }
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        this._values = values;
        if (values._isFulfilled()) {
            values = values._value();
            if (!isArray(values)) {
                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                this.__hardReject__(err);
                return;
            }
        } else if (values._isPending()) {
            values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
            return;
        } else {
            this._reject(values._reason());
            return;
        }
    } else if (!isArray(values)) {
        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var promise = this._promise;
    for (var i = 0; i < len; ++i) {
        var isResolved = this._isResolved();
        var maybePromise = tryConvertToPromise(values[i], promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (isResolved) {
                maybePromise._ignoreRejections();
            } else if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise._isFulfilled()) {
                this._promiseFulfilled(maybePromise._value(), i);
            } else {
                this._promiseRejected(maybePromise._reason(), i);
            }
        } else if (!isResolved) {
            this._promiseFulfilled(maybePromise, i);
        }
    }
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype.__hardReject__ =
PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false, true);
};

PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
    this._promise._progress({
        index: index,
        value: progressValue
    });
};


PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

PromiseArray.prototype._promiseRejected = function (reason, index) {
    this._totalResolved++;
    this._reject(reason);
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util.js":38}],25:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util.js");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors.js");
var TimeoutError = errors.TimeoutError;
var OperationalError = errors.OperationalError;
var haveGetters = util.haveGetters;
var es5 = _dereq_("./es5.js");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise) {
    return function(err, value) {
        if (promise === null) return;

        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (arguments.length > 2) {
            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
            promise._fulfill(args);
        } else {
            promise._fulfill(value);
        }

        promise = null;
    };
}


var PromiseResolver;
if (!haveGetters) {
    PromiseResolver = function (promise) {
        this.promise = promise;
        this.asCallback = nodebackForPromise(promise);
        this.callback = this.asCallback;
    };
}
else {
    PromiseResolver = function (promise) {
        this.promise = promise;
    };
}
if (haveGetters) {
    var prop = {
        get: function() {
            return nodebackForPromise(this.promise);
        }
    };
    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
}

PromiseResolver._nodebackForPromise = nodebackForPromise;

PromiseResolver.prototype.toString = function () {
    return "[object PromiseResolver]";
};

PromiseResolver.prototype.resolve =
PromiseResolver.prototype.fulfill = function (value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._resolveCallback(value);
};

PromiseResolver.prototype.reject = function (reason) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._rejectCallback(reason);
};

PromiseResolver.prototype.progress = function (value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._progress(value);
};

PromiseResolver.prototype.cancel = function (err) {
    this.promise.cancel(err);
};

PromiseResolver.prototype.timeout = function () {
    this.reject(new TimeoutError("timeout"));
};

PromiseResolver.prototype.isResolved = function () {
    return this.promise.isResolved();
};

PromiseResolver.prototype.toJSON = function () {
    return this.promise.toJSON();
};

module.exports = PromiseResolver;

},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = _dereq_("./util.js");
var nodebackForPromise = _dereq_("./promise_resolver.js")
    ._nodebackForPromise;
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = _dereq_("./errors").TypeError;
var defaultSuffix = "Async";
var defaultPromisified = {__isPromisified__: true};
var noCopyProps = [
    "arity",    "length",
    "name",
    "arguments",
    "caller",
    "callee",
    "prototype",
    "__isPromisified__"
];
var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

var defaultFilter = function(name) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        name !== "constructor";
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, "\\$");
};

var makeNodePromisifiedEval;
if (!true) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i >= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, "_arg", "");
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), "_arg", "");
};

var parameterCount = function(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(", ");
        var comma = count > 0 ? ", " : "";
        var ret;
        if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
        } else {
            ret = receiver === undefined
                ? "ret = callback({{args}}, nodeback); break;\n"
                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        var ret = "";
        for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis
                                ? "ret = callback.apply(this, args);\n"
                                : "ret = callback.apply(receiver, args);\n"));
        return ret;
    }

    var getFunctionCode = typeof callback === "string"
                                ? ("this != null ? this['"+callback+"'] : fn")
                                : "fn";

    return new Function("Promise",
                        "fn",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "tryCatch",
                        "errorObj",
                        "notEnumerableProp",
                        "INTERNAL","'use strict';                            \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise);                      \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
        "
        .replace("Parameters", parameterDeclaration(newParameterCount))
        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
        .replace("[GetFunctionCode]", getFunctionCode))(
            Promise,
            fn,
            receiver,
            withAppended,
            maybeWrapAsError,
            nodebackForPromise,
            util.tryCatch,
            util.errorObj,
            util.notEnumerableProp,
            INTERNAL
        );
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === "string") {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        return promise;
    }
    util.notEnumerableProp(promisified, "__isPromisified__", true);
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i < len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        obj[promisifiedKey] = promisifier === makeNodePromisified
                ? makeNodePromisified(key, THIS, key, fn, suffix)
                : promisifier(fn, function() {
                    return makeNodePromisified(key, THIS, key, fn, suffix);
                });
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver) {
    return makeNodePromisified(callback, receiver, undefined, callback);
}

Promise.promisify = function (fn, receiver) {
    if (typeof fn !== "function") {
        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    if (isPromisified(fn)) {
        return fn;
    }
    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
    }
    options = Object(options);
    var suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier);
            promisifyAll(value, suffix, filter, promisifier);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier);
};
};


},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util.js");
var isObject = util.isObject;
var es5 = _dereq_("./es5.js");

function PropertiesPromiseArray(obj) {
    var keys = es5.keys(obj);
    var len = keys.length;
    var values = new Array(len * 2);
    for (var i = 0; i < len; ++i) {
        var key = keys[i];
        values[i] = obj[key];
        values[i + len] = key;
    }
    this.constructor$(values);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {
    this._init$(undefined, -3) ;
};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        var val = {};
        var keyOffset = this.length();
        for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
        }
        this._resolve(val);
    }
};

PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
    this._promise._progress({
        key: this._values[index + this.length()],
        value: value
    });
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len >> 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises);

    if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 4);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};

},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype._unshiftOne = function(value) {
    var capacity = this._capacity;
    this._checkCapacity(this.length() + 1);
    var front = this._front;
    var i = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = value;
    this._front = i;
    this._length = this.length() + 1;
};

Queue.prototype.unshift = function(fn, receiver, arg) {
    this._unshiftOne(arg);
    this._unshiftOne(receiver);
    this._unshiftOne(fn);
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],29:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var isArray = _dereq_("./util.js").isArray;

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else if (!isArray(promises)) {
        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 4 | 1);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];

        if (val === undefined && !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};

},{"./util.js":38}],30:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) {
var getDomain = Promise._getDomain;
var async = _dereq_("./async.js");
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
function ReductionPromiseArray(promises, fn, accum, _each) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    this._preservedValues = _each === INTERNAL ? [] : null;
    this._zerothIsAccum = (accum === undefined);
    this._gotAccum = false;
    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
    this._valuesPhase = undefined;
    var maybePromise = tryConvertToPromise(accum, this._promise);
    var rejected = false;
    var isPromise = maybePromise instanceof Promise;
    if (isPromise) {
        maybePromise = maybePromise._target();
        if (maybePromise._isPending()) {
            maybePromise._proxyPromiseArray(this, -1);
        } else if (maybePromise._isFulfilled()) {
            accum = maybePromise._value();
            this._gotAccum = true;
        } else {
            this._reject(maybePromise._reason());
            rejected = true;
        }
    }
    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
    var domain = getDomain();
    this._callback = domain === null ? fn : domain.bind(fn);
    this._accum = accum;
    if (!rejected) async.invoke(init, this, undefined);
}
function init() {
    this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._init = function () {};

ReductionPromiseArray.prototype._resolveEmptyArray = function () {
    if (this._gotAccum || this._zerothIsAccum) {
        this._resolve(this._preservedValues !== null
                        ? [] : this._accum);
    }
};

ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    values[index] = value;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var isEach = preservedValues !== null;
    var gotAccum = this._gotAccum;
    var valuesPhase = this._valuesPhase;
    var valuesPhaseIndex;
    if (!valuesPhase) {
        valuesPhase = this._valuesPhase = new Array(length);
        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
            valuesPhase[valuesPhaseIndex] = 0;
        }
    }
    valuesPhaseIndex = valuesPhase[index];

    if (index === 0 && this._zerothIsAccum) {
        this._accum = value;
        this._gotAccum = gotAccum = true;
        valuesPhase[index] = ((valuesPhaseIndex === 0)
            ? 1 : 2);
    } else if (index === -1) {
        this._accum = value;
        this._gotAccum = gotAccum = true;
    } else {
        if (valuesPhaseIndex === 0) {
            valuesPhase[index] = 1;
        } else {
            valuesPhase[index] = 2;
            this._accum = value;
        }
    }
    if (!gotAccum) return;

    var callback = this._callback;
    var receiver = this._promise._boundValue();
    var ret;

    for (var i = this._reducingIndex; i < length; ++i) {
        valuesPhaseIndex = valuesPhase[i];
        if (valuesPhaseIndex === 2) {
            this._reducingIndex = i + 1;
            continue;
        }
        if (valuesPhaseIndex !== 1) return;
        value = values[i];
        this._promise._pushContext();
        if (isEach) {
            preservedValues.push(value);
            ret = tryCatch(callback).call(receiver, value, i, length);
        }
        else {
            ret = tryCatch(callback)
                .call(receiver, this._accum, value, i, length);
        }
        this._promise._popContext();

        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                valuesPhase[i] = 4;
                return maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise._isFulfilled()) {
                ret = maybePromise._value();
            } else {
                return this._reject(maybePromise._reason());
            }
        }

        this._reducingIndex = i + 1;
        this._accum = ret;
    }

    this._resolve(isEach ? preservedValues : this._accum);
};

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};
};

},{"./async.js":2,"./util.js":38}],31:[function(_dereq_,module,exports){
"use strict";
var schedule;
var util = _dereq_("./util");
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
};
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            window.navigator.standalone)) {
    schedule = function(fn) {
        var div = document.createElement("div");
        var observer = new MutationObserver(fn);
        observer.observe(div, {attributes: true});
        return function() { div.classList.toggle("foo"); };
    };
    schedule.isStatic = true;
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{"./util":38}],32:[function(_dereq_,module,exports){
"use strict";
module.exports =
    function(Promise, PromiseArray) {
var PromiseInspection = Promise.PromiseInspection;
var util = _dereq_("./util.js");

function SettledPromiseArray(values) {
    this.constructor$(values);
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 268435456;
    ret._settledValue = value;
    this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 134217728;
    ret._settledValue = reason;
    this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return new SettledPromiseArray(this).promise();
};
};

},{"./util.js":38}],33:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = _dereq_("./util.js");
var RangeError = _dereq_("./errors.js").RangeError;
var AggregateError = _dereq_("./errors.js").AggregateError;
var isArray = util.isArray;


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &&
        isArrayResolved &&
        this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
    }

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
            e.push(this._values[i]);
        }
        this._reject(e);
    }
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = "Input array must contain at least " +
            this._howMany + " items but contains only " + count + " items";
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};

},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValue = promise._settledValue;
    }
    else {
        this._bitField = 0;
        this._settledValue = undefined;
    }
}

PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
    }
    return this._settledValue;
};

PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
    }
    return this._settledValue;
};

PromiseInspection.prototype.isFulfilled =
Promise.prototype._isFulfilled = function () {
    return (this._bitField & 268435456) > 0;
};

PromiseInspection.prototype.isRejected =
Promise.prototype._isRejected = function () {
    return (this._bitField & 134217728) > 0;
};

PromiseInspection.prototype.isPending =
Promise.prototype._isPending = function () {
    return (this._bitField & 402653184) === 0;
};

PromiseInspection.prototype.isResolved =
Promise.prototype._isResolved = function () {
    return (this._bitField & 402653184) > 0;
};

Promise.prototype.isPending = function() {
    return this._target()._isPending();
};

Promise.prototype.isRejected = function() {
    return this._target()._isRejected();
};

Promise.prototype.isFulfilled = function() {
    return this._target()._isFulfilled();
};

Promise.prototype.isResolved = function() {
    return this._target()._isResolved();
};

Promise.prototype._value = function() {
    return this._settledValue;
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue;
};

Promise.prototype.value = function() {
    var target = this._target();
    if (!target.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
    }
    return target._settledValue;
};

Promise.prototype.reason = function() {
    var target = this._target();
    if (!target.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
    }
    target._unsetRejectionIsUnhandled();
    return target._settledValue;
};


Promise.PromiseInspection = PromiseInspection;
};

},{}],35:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util.js");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) {
            return obj;
        }
        else if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise(INTERNAL);
            obj._then(
                ret._fulfillUnchecked,
                ret._rejectUncheckedCheckError,
                ret._progressUnchecked,
                ret,
                null
            );
            return ret;
        }
        var then = util.tryCatch(getThen)(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function getThen(obj) {
    return obj.then;
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    return hasProp.call(obj, "_promise0");
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x,
                                        resolveFromThenable,
                                        rejectFromThenable,
                                        progressFromThenable);
    synchronous = false;
    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolveFromThenable(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function rejectFromThenable(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }

    function progressFromThenable(value) {
        if (!promise) return;
        if (typeof promise._progress === "function") {
            promise._progress(value);
        }
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util.js":38}],36:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util.js");
var TimeoutError = Promise.TimeoutError;

var afterTimeout = function (promise, message) {
    if (!promise.isPending()) return;
    if (typeof message !== "string") {
        message = "operation timed out";
    }
    var err = new TimeoutError(message);
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._cancel(err);
};

var afterValue = function(value) { return delay(+this).thenReturn(value); };
var delay = Promise.delay = function (value, ms) {
    if (ms === undefined) {
        ms = value;
        value = undefined;
        var ret = new Promise(INTERNAL);
        setTimeout(function() { ret._fulfill(); }, ms);
        return ret;
    }
    ms = +ms;
    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
};

Promise.prototype.delay = function (ms) {
    return delay(this, ms);
};

function successClear(value) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    return value;
}

function failureClear(reason) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var ret = this.then().cancellable();
    ret._cancellationParent = this;
    var handle = setTimeout(function timeoutTimeout() {
        afterTimeout(ret, message);
    }, ms);
    return ret._then(successClear, failureClear, undefined, handle, undefined);
};

};

},{"./util.js":38}],37:[function(_dereq_,module,exports){
"use strict";
module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext) {
    var TypeError = _dereq_("./errors.js").TypeError;
    var inherits = _dereq_("./util.js").inherits;
    var PromiseInspection = Promise.PromiseInspection;

    function inspectionMapper(inspections) {
        var len = inspections.length;
        for (var i = 0; i < len; ++i) {
            var inspection = inspections[i];
            if (inspection.isRejected()) {
                return Promise.reject(inspection.error());
            }
            inspections[i] = inspection._settledValue;
        }
        return inspections;
    }

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable &&
            typeof thenable._isDisposable === "function" &&
            typeof thenable._getDisposer === "function" &&
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = Promise.defer();
        function iterator() {
            if (i >= len) return ret.resolve();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &&
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret.promise;
    }

    function disposerSuccess(value) {
        var inspection = new PromiseInspection();
        inspection._settledValue = value;
        inspection._bitField = 268435456;
        return dispose(this, inspection).thenReturn(value);
    }

    function disposerFail(reason) {
        var inspection = new PromiseInspection();
        inspection._settledValue = reason;
        inspection._bitField = 134217728;
        return dispose(this, inspection).thenThrow(reason);
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return null;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== null
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &&
                typeof d.resource === "function" &&
                typeof d.tryDispose === "function");
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection(
                        "you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        len--;
        var resources = new Array(len);
        for (var i = 0; i < len; ++i) {
            var resource = arguments[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var promise = Promise.settle(resources)
            .then(inspectionMapper)
            .then(function(vals) {
                promise._pushContext();
                var ret;
                try {
                    ret = fn.apply(undefined, vals);
                } finally {
                    promise._popContext();
                }
                return ret;
            })
            ._then(
                disposerSuccess, disposerFail, undefined, resources, undefined);
        resources.promise = promise;
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 262144;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 262144) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & (~262144);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};

},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5.js");
var canEvaluate = typeof navigator == "undefined";
var haveGetters = (function(){
    try {
        var o = {};
        es5.defineProperty(o, "f", {
            get: function () {
                return 3;
            }
        });
        return o.f === 3;
    }
    catch (e) {
        return false;
    }

})();

var errorObj = {e: {}};
var tryCatchTarget;
function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return !isPrimitive(value);
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function f() {}
    f.prototype = obj;
    var l = 8;
    while (l--) new f();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    haveGetters: haveGetters,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]"
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5.js":14}]},{},[4])(4)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":77}],76:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],77:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],78:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],79:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":78,"_process":77,"inherits":76}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnQvY2xpZW50LmRpYWdyYW0uanMiLCJjbGllbnQvY29yZS9jYWNoZS5qcyIsImNsaWVudC9jb3JlL2NsaWVudC5qcyIsImNsaWVudC9jb3JlL2NvbW1hbmQuanMiLCJjbGllbnQvY29yZS9jb21tYW5kTWFuYWdlci5qcyIsImNsaWVudC9jb3JlL2NvbmZpZy5qcyIsImNsaWVudC9jb3JlL2V2ZW50LmpzIiwiY2xpZW50L2NvcmUvc3ViRXZlbnQuanMiLCJjbGllbnQvZGlhZ3JhbS9Lbm9iLmpzIiwiY2xpZW50L2RpYWdyYW0vYWJzdHJhY3RFZGl0QWRkaXRpb24uanMiLCJjbGllbnQvZGlhZ3JhbS9hYnN0cmFjdE1hbmFnZXIuanMiLCJjbGllbnQvZGlhZ3JhbS9hYnN0cmFjdFBhdGhNYW5hZ2VyLmpzIiwiY2xpZW50L2RpYWdyYW0vYWRkaXRpb25zLmpzIiwiY2xpZW50L2RpYWdyYW0vYXBpLmpzIiwiY2xpZW50L2RpYWdyYW0vY3VydmVkUGF0aE1hbmFnZXIuanMiLCJjbGllbnQvZGlhZ3JhbS9kaWFncmFtLmpzIiwiY2xpZW50L2RpYWdyYW0vZG9ja2luZy5qcyIsImNsaWVudC9kaWFncmFtL2RyYWdBbGlnbm1lbnQuanMiLCJjbGllbnQvZGlhZ3JhbS9kcmFnZ2FibGUuanMiLCJjbGllbnQvZGlhZ3JhbS9lZGl0Tm9kZUFkZGl0aW9uLmpzIiwiY2xpZW50L2RpYWdyYW0vZWRpdFRyYW5zaXRpb25BZGRpdGlvbi5qcyIsImNsaWVudC9kaWFncmFtL2hlbHBlci5qcyIsImNsaWVudC9kaWFncmFtL2hvdmVyYWJsZS5qcyIsImNsaWVudC9kaWFncmFtL2tub2JNYW5hZ2VyLmpzIiwiY2xpZW50L2RpYWdyYW0va25vYlRlbXBsYXRlLmpzIiwiY2xpZW50L2RpYWdyYW0vbm9kZS5qcyIsImNsaWVudC9kaWFncmFtL25vZGVBZGRpdGlvbnMuanMiLCJjbGllbnQvZGlhZ3JhbS9ub2RlTWFuYWdlci5qcyIsImNsaWVudC9kaWFncmFtL3BhdGhNYW5hZ2VyRmFjdG9yeS5qcyIsImNsaWVudC9kaWFncmFtL3Jlc2l6ZS5qcyIsImNsaWVudC9kaWFncmFtL3Jlc2l6ZUFkZGl0aW9uLmpzIiwiY2xpZW50L2RpYWdyYW0vc2VsZWN0aW9uTWFuYWdlci5qcyIsImNsaWVudC9kaWFncmFtL3N0cmFpZ2h0UGF0aE1hbmFnZXIuanMiLCJjbGllbnQvZGlhZ3JhbS90ZW1wbGF0ZS5qcyIsImNsaWVudC9kaWFncmFtL3RlbXBsYXRlTWFuYWdlci5qcyIsImNsaWVudC9kaWFncmFtL3RyYW5zaXRpb24uanMiLCJjbGllbnQvZGlhZ3JhbS90cmFuc2l0aW9uQWRkaXRpb24uanMiLCJjbGllbnQvZGlhZ3JhbS90cmFuc2l0aW9uQWRkaXRpb25zLmpzIiwiY2xpZW50L2RpYWdyYW0vdHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLmpzIiwiY2xpZW50L2RpYWdyYW0vdHJhbnNpdGlvbktub2JNYW5hZ2VyLmpzIiwiY2xpZW50L2RpYWdyYW0vdHJhbnNpdGlvbk1hbmFnZXIuanMiLCJjbGllbnQvZGlhZ3JhbS90cmFuc2l0aW9uVGV4dEFkZGl0aW9uLmpzIiwiY2xpZW50L2RvbS9kb20uanMiLCJjbGllbnQvZG9tL2RvbUVsZW1lbnQuanMiLCJjbGllbnQvc3ZnL1BhdGhEYXRhLmpzIiwiY2xpZW50L3N2Zy9TVkdFbGVtZW50LmpzIiwiY2xpZW50L3N2Zy9jaXJjbGUuanMiLCJjbGllbnQvc3ZnL2RyYWdDb25maWcuanMiLCJjbGllbnQvc3ZnL2RyYWdnYWJsZS5qcyIsImNsaWVudC9zdmcvZWxlbWVudHMuanMiLCJjbGllbnQvc3ZnL2VsbGlwc2UuanMiLCJjbGllbnQvc3ZnL2dlbmVyaWNTaGFwZS5qcyIsImNsaWVudC9zdmcvZ3JvdXAuanMiLCJjbGllbnQvc3ZnL3BhdGguanMiLCJjbGllbnQvc3ZnL3JlY3QuanMiLCJjbGllbnQvc3ZnL3N0eWxlLmpzIiwiY2xpZW50L3N2Zy9zdmcuanMiLCJjbGllbnQvc3ZnL3N2Z1Jvb3QuanMiLCJjbGllbnQvc3ZnL3RleHQuanMiLCJjbGllbnQvc3ZnL3RyYW5zZm9ybS5qcyIsImNsaWVudC9zdmcvdHNwYW4uanMiLCJjbGllbnQvdWkvZWRpdFBhbmVsLmpzIiwiY2xpZW50L3VpL2pxdWVyeVBsdWdpbnMuanMiLCJjbGllbnQvdXRpbC9VdGlsLmpzIiwiY2xpZW50L3V0aWwvYXBwLmpzIiwiY2xpZW50L3V0aWwvYmV6aWVyLmpzIiwiY2xpZW50L3V0aWwvbWF0aC5qcyIsImNsaWVudC91dGlsL29iamVjdC5qcyIsImNsaWVudC91dGlsL3N0cmluZy5qcyIsImNsaWVudC91dGlsL3htbC5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9icm93c2VyL2JsdWViaXJkLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeHZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwicmVxdWlyZSgnLi91aS9qcXVlcnlQbHVnaW5zJyk7XG5yZXF1aXJlKCcuL3N2Zy9kcmFnZ2FibGUnKTtcblxuaWYoIXdpbmRvdy5kYWxhKSB7XG4gICAgZGFsYSA9IHt9O1xufVxuXG5kYWxhX2VudiA9IHdpbmRvdy5kYWxhX2VudiB8fCB7fTtcbmRhbGFfZW52LmluaXRpYWxfdGVtcGxhdGVzID0ge307XG5cbi8vVE9ETzogYmV0dGVyIG5hbWVzcGFjZSBoYW5kbGluZy4uLiBleHBvcnQgdG8gbW9kdWxlXG52YXIgZ2xvYmFsTW9kdWxlcyA9ICB7XG4gICAgJ3RlbXBsYXRlTWFuYWdlcic6IHJlcXVpcmUoJy4vZGlhZ3JhbS90ZW1wbGF0ZU1hbmFnZXInKVxufTtcblxuZGFsYS5yZXF1aXJlID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gZ2xvYmFsTW9kdWxlc1tpZF07XG59O1xuXG5cblxuaWYoIXdpbmRvdy5kYWxhLlNWRykge1xuICAgIHdpbmRvdy5kYWxhLlNWRyA9IHJlcXVpcmUoJy4vc3ZnL3N2ZycpO1xufVxuXG5pZighd2luZG93LmRhbGEuRGlhZ3JhbSkge1xuICAgIHdpbmRvdy5kYWxhLkRpYWdyYW0gPSByZXF1aXJlKCcuL2RpYWdyYW0vZGlhZ3JhbScpO1xufVxuXG4iLCJ2YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2RvbS9kb20nKTtcclxudmFyIHN0cmluZyA9IHJlcXVpcmUoJy4uL3V0aWwvc3RyaW5nJyk7XHJcblxyXG52YXIgQ2FjaGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucXVlcnlDYWNoZSA9IHt9O1xyXG4gICAgdGhpcy5zdmdDYWNoZSA9IHt9O1xyXG59O1xyXG5cclxuQ2FjaGUucHJvdG90eXBlLmNsZWFyQnlTdWZmaXggPSBmdW5jdGlvbihzdWZmaXgpIHtcclxuICAgIGZvcihrZXkgaW4gdGhpcy5xdWVyeUNhY2hlKSB7XHJcbiAgICAgICAgaWYodGhpcy5xdWVyeUNhY2hlLmhhc093blByb3BlcnR5KGtleSkgJiYgc3RyaW5nLmVuZHNXaXRoKGtleSwgc3VmZml4KSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5xdWVyeUNhY2hlW2tleV07XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmb3Ioa2V5IGluIHRoaXMuc3ZnQ2FjaGUpIHtcclxuICAgICAgICBpZih0aGlzLnN2Z0NhY2hlLmhhc093blByb3BlcnR5KGtleSkgJiYgc3RyaW5nLmVuZHNXaXRoKGtleSwgc3VmZml4KSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdmdDYWNoZVtrZXldO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5DYWNoZS5wcm90b3R5cGUuJCA9IGZ1bmN0aW9uKG9iaiwgcHJldmVudENhY2hlKSB7XHJcbiAgICBpZighb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMucXVlcnlDYWNoZVtvYmpdKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlDYWNoZVtvYmpdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuZ2V0Q2FjaGVTZXR0aW5ncyhvYmosIHRoaXMucXVlcnlDYWNoZSk7XHJcbiAgICByZXR1cm4gdGhpcy5jYWNoZUNoZWNrKHNldHRpbmdzLmtleSwgc2V0dGluZ3MuJG5vZGUsIHRoaXMucXVlcnlDYWNoZSwgcHJldmVudENhY2hlKTtcclxufTtcclxuXHJcbkNhY2hlLnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbihvYmosIHByZXZlbnRDYWNoZSkge1xyXG4gICAgaWYoIW9iaikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLnN2Z0NhY2hlW29ial0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdmdDYWNoZVtvYmpdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuZ2V0Q2FjaGVTZXR0aW5ncyhvYmosIHRoaXMuc3ZnQ2FjaGUpO1xyXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVDaGVjayhzZXR0aW5ncy5rZXksICQuc3ZnKHNldHRpbmdzLiRub2RlKSwgdGhpcy5zdmdDYWNoZSwgcHJldmVudENhY2hlKTtcclxufTtcclxuXHJcbkNhY2hlLnByb3RvdHlwZS5nZXRDYWNoZVNldHRpbmdzID0gZnVuY3Rpb24ob2JqLCBjYWNoZSkge1xyXG4gICAgdmFyIHNldHRpbmdzID0ge307XHJcblxyXG4gICAgaWYob2JqZWN0LmlzU3RyaW5nKG9iaikpe1xyXG4gICAgICAgIHNldHRpbmdzLiRub2RlID0gdGhpcy5xdWVyeUNhY2hlW29ial0gfHwgJChvYmopO1xyXG4gICAgICAgIHNldHRpbmdzLmtleSA9IG9iajtcclxuICAgIH0gZWxzZSBpZihvYmoualF1ZXJ5KSB7XHJcbiAgICAgICAgc2V0dGluZ3MuJG5vZGUgPSBvYmo7XHJcbiAgICAgICAgc2V0dGluZ3Mua2V5ID0gZG9tLmdldElkU2VsZWN0b3Iob2JqLmF0dHIoJ2lkJykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuJG5vZGUgPSAkKG9iaik7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmtleSA9IGRvbS5nZXRJZFNlbGVjdG9yKHNldHRpbmdzLiRub2RlLmF0dHIoJ2lkJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzZXR0aW5ncztcclxufVxyXG5cclxuQ2FjaGUucHJvdG90eXBlLmNhY2hlQ2hlY2sgPSBmdW5jdGlvbihrZXksIG9iaiwgY2FjaGUsIHByZXZlbnRDYWNoZSkge1xyXG4gICAgcHJldmVudENhY2hlID0gcHJldmVudENhY2hlIHx8IGZhbHNlO1xyXG4gICAgaWYoa2V5ICYmIG9iaikge1xyXG4gICAgICAgIHJldHVybiAoIXByZXZlbnRDYWNoZSkgPyBjYWNoZVtrZXldID0gb2JqIDogb2JqO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG59XHJcblxyXG5DYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZihvYmplY3QuaXNTdHJpbmcob2JqKSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXJ5Q2FjaGVbb2JqXTtcclxuICAgIH1cclxufTtcclxuXHJcbkNhY2hlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIG9iamVjdC5pc0RlZmluZWQocXVlcnlDYWNoW3NlbGVjdG9yXSk7XHJcbn07XHJcblxyXG5DYWNoZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IENhY2hlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDYWNoZSgpOyIsInZhciBldmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlsL3N0cmluZycpO1xyXG5cclxudmFyIFJlc3BvbnNlID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxufTtcclxuXHJcblJlc3BvbnNlLnByb3RvdHlwZS5pc0NvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YSAmJiAodGhpcy5kYXRhLnN0YXR1cyA9PT0gMCk7XHJcbn07XHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuc3RhdHVzICYmICh0aGlzLmRhdGEuc3RhdHVzID4gMCk7XHJcbn07XHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuZXJyb3I7XHJcbn07XHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0RXJyb3JDb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmVycm9yQ29kZTtcclxufTtcclxuXHJcblJlc3BvbnNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwieyBzdGF0dXM6IFwiK3RoaXMuZGF0YS5zdGF0dXMrXCIgZXJyb3I6IFwiK3RoaXMuZGF0YS5lcnJvcitcIiBkYXRhOiBcIit0aGlzLmRhdGEuZGF0YStcIiB9XCI7XHJcbn07XHJcblxyXG52YXIgY29uZmlnID0ge1xyXG4gICAgaG9zdCA6ICdsb2NhbGhvc3QnLFxyXG4gICAgcG9ydCA6IDMwMDBcclxufTtcclxuXHJcbnZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihjZmcsIHhocix0eXBlLGVycm9yVGhyb3duLCBlcnJvckNvZGUpIHtcclxuICAgIGVycm9yQ29kZSA9ICh4aHIpID8geGhyLnN0YXR1cyA6IHBhcnNlSW50KGVycm9yQ29kZSk7XHJcbiAgICBjb25zb2xlLndhcm4oXCJhamF4RXJyb3I6IFwiK3R5cGUrXCIgXCIrZXJyb3JUaHJvd24rXCIgLSBcIitlcnJvckNvZGUpO1xyXG5cclxuICAgIGlmKGNmZy5lcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNTdHJpbmcoY2ZnLmVycm9yTWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcignZXJyb3InLCBjZmcuZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9IGVsc2UgaWYob2JqZWN0LmlzT2JqZWN0KGNmZy5lcnJvck1lc3NhZ2UsIGVycm9yQ29kZSkpIHtcclxuICAgICAgICAgICAgdmFyIG1zZyA9IGNmZy5lcnJvck1lc3NhZ2VbZXJyb3JDb2RlXSB8fCBjZmcuZXJyb3JNZXNzYWdlWydkZWZhdWx0J107XHJcbiAgICAgICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQobXNnKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQudHJpZ2dlcignZXJyb3InLCBtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKGNmZy5lcnJvciAmJiBvYmplY3QuaXNGdW5jdGlvbihjZmcuZXJyb3IpKSB7XHJcbiAgICAgICAgLy8gXCJ0aW1lb3V0XCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiLCBcInBhcnNlcmVycm9yXCIgb3IgXCJhcHBsaWNhdGlvblwiXHJcbiAgICAgICAgY2ZnLmVycm9yKGVycm9yVGhyb3duLCBlcnJvckNvZGUsIHR5cGUpO1xyXG4gICAgfSBlbHNlIGlmKGNmZy5lcnJvcikge1xyXG4gICAgICAgIHZhciBtc2cgPSBjZmcuZXJyb3JbZXJyb3JDb2RlXSB8fCBjZmcuZXJyb3JbJ2RlZmF1bHQnXTtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKG1zZykpIHtcclxuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcignZXJyb3InLCBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZighY2ZnLmVycm9yICYmICFjZmcuZXJyb3JNZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmhhbmRsZWQgYWpheCBlcnJvcjogJytwYXRoK1wiIHR5cGVcIit0eXBlK1wiIGVycm9yOiBcIitlcnJvclRocm93bik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5waW5nKHNldHRpbmdzKTtcclxuICAgIH0sXHJcbiAgICBwaW5nOiBmdW5jdGlvbihzZXR0aW5ncykge1xyXG4gICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwgY29uZmlnO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICB1cmw6IFwiaHR0cDovL1wiK3NldHRpbmdzLmhvc3QrXCI6XCIrc2V0dGluZ3MucG9ydCtcIi9zZXJ2aWNlL3BpbmdcIixcclxuICAgICAgICAgICAgLy9jcm9zc0RvbWFpbjogdHJ1ZSxcclxuICAgICAgICAgICAgdHlwZSA6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHsncGluZyc6dHJ1ZX0sXHJcbiAgICAgICAgICAgIGFzeW5jIDogZmFsc2UsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcclxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgc3RhdHVzLCBtc2cpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgYWpheDogZnVuY3Rpb24ocGF0aCwgZGF0YSwgY2ZnKSB7XHJcbiAgICAgICAgdmFyIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgICAgICB2YXIgYXN5bmMgPSBjZmcuYXN5bmMgfHwgdHJ1ZTtcclxuICAgICAgICB2YXIgZGF0YVR5cGUgPSBjZmcuZGF0YVR5cGUgfHwgXCJqc29uXCI7XHJcblxyXG4gICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uKHhocix0eXBlLGVycm9yVGhyb3duLCBlcnJvckNvZGUpIHtcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGNmZywgeGhyLHR5cGUsZXJyb3JUaHJvd24sIGVycm9yQ29kZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VXcmFwcGVyID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlV3JhcHBlci5pc0Vycm9yKCkpIHsgLy9BcHBsaWNhdGlvbiBlcnJvcnNcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcih1bmRlZmluZWQsXCJhcHBsaWNhdGlvblwiLHJlc3BvbnNlV3JhcHBlci5nZXRFcnJvcigpLCByZXNwb25zZVdyYXBwZXIuZ2V0RXJyb3JDb2RlKCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoY2ZnLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGlmKG9iamVjdC5pc1N0cmluZyhjZmcuc3VjY2VzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC50cmlnZ2VyKCdpbmZvJywgY2ZnLnN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjZmcuc3VjY2VzcyhyZXNwb25zZVdyYXBwZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2ZnLnN1Y2Nlc3NNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC50cmlnZ2VyKCdpbmZvJywgY2ZnLnN1Y2Nlc3NNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICB1cmw6IHRoYXQuZ2V0VXJsKHBhdGgpLFxyXG4gICAgICAgICAgICAvL2Nyb3NzRG9tYWluOiB0cnVlLCAvL1RPRE86IHJlYWQgZnJvbSBjb25maWdcclxuICAgICAgICAgICAgdHlwZSA6IGNmZy50eXBlLFxyXG4gICAgICAgICAgICBwcm9jZXNzRGF0YSA6IGNmZy5wcm9jZXNzRGF0YSxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IGNmZy5jb250ZW50VHlwZSxcclxuICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgYXN5bmMgOiBhc3luYyxcclxuICAgICAgICAgICAgZGF0YVR5cGU6IGRhdGFUeXBlLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwb3N0OiBmdW5jdGlvbihwYXRoLCBkYXRhLCBjZmcpIHtcclxuICAgICAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICAgICAgY2ZnLnR5cGUgPSAnUE9TVCc7XHJcbiAgICAgICAgdGhpcy5hamF4KHBhdGgsIGRhdGEsIGNmZyk7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbihwYXRoLCBjZmcpIHtcclxuICAgICAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICAgICAgY2ZnLnR5cGUgPSAnR0VUJztcclxuICAgICAgICB0aGlzLmFqYXgocGF0aCwgY2ZnLmRhdGEsIGNmZyk7XHJcbiAgICB9LFxyXG4gICAgeG1sOiBmdW5jdGlvbihwYXRoLCBjZmcpIHtcclxuICAgICAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICAgICAgY2ZnLmRhdGFUeXBlID0gJ3htbCc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHBhdGgsY2ZnKTtcclxuICAgIH0sXHJcbiAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uKHBhdGgsIGNmZykge1xyXG4gICAgICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuICQuZ2V0U2NyaXB0KHBhdGgpXHJcbiAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uKHMsIFN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgaWYoY2ZnLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjZmcuc3VjY2VzcyhzLCBTdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5mYWlsKGZ1bmN0aW9uKHhociwgc2V0dGluZ3MsIGV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGNmZywgeGhyLCdlcnJvcicsZXhjZXB0aW9uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcmVzdEdldDogZnVuY3Rpb24ocGF0aCwgaWQsIGNmZykge1xyXG4gICAgICAgIHZhciBwYXRoID0gc3RyaW5nLmVuZHNXaXRoKHBhdGgsICcvJyk/IHBhdGgraWQgOiBwYXRoKycvJytpZDtcclxuICAgICAgICB0aGlzLmdldChwYXRoLCBjZmcpO1xyXG4gICAgfSxcclxuICAgIGdldFVybDogZnVuY3Rpb24oYWRkaXRpb24pIHtcclxuICAgICAgICB2YXIgdXJsID0gXCJodHRwOi8vXCIrY29uZmlnLmhvc3QrXCI6XCIrY29uZmlnLnBvcnQ7XHJcbiAgICAgICAgaWYoYWRkaXRpb24pIHtcclxuICAgICAgICAgICAgdXJsICs9IGFkZGl0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24oc2V0dGluZ3MpIHtcclxuICAgICAgICBjb25maWcgPSBzZXR0aW5ncztcclxuICAgIH0sXHJcbiAgICBnZXRTZXR0aW5nczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxufSIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG5cclxudmFyIENvbW1hbmRBY3Rpb24gPSBmdW5jdGlvbihjbGllbnQsIGFjdGlvbikge1xyXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XHJcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcclxufTtcclxuXHJcbkNvbW1hbmRBY3Rpb24ucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihhcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hY3Rpb24uYXBwbHkodGhpcy5jbGllbnQsIGFyZ3MpO1xyXG59O1xyXG5cclxudmFyIENvbW1hbmQgPSBmdW5jdGlvbihjbGllbnQsIGRvQWN0aW9uLCB1bmRvQWN0aW9uKSB7XHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vQ2FsbCB0aGUgZXhlYyBzZXR0ZXJcclxuICAgICAgICB0aGlzLmV4ZWMoY2xpZW50LGRvQWN0aW9uKTtcclxuICAgICAgICB0aGlzLnVuZG8oY2xpZW50LHVuZG9BY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG59O1xyXG5cclxuQ29tbWFuZC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGNsaWVudCwgYWN0aW9uLCBhcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hY3Rpb24oJ2RvJywgY2xpZW50LCBhY3Rpb24sIGFyZ3MpO1xyXG59O1xyXG5cclxuQ29tbWFuZC5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uKGNsaWVudCwgYWN0aW9uLCBhcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hY3Rpb24oJ3VuZG8nLCBjbGllbnQsIGFjdGlvbiwgYXJncyk7XHJcbn07XHJcblxyXG5Db21tYW5kLnByb3RvdHlwZS5pbnN0YW5jZSA9IGZ1bmN0aW9uKGRvQXJncywgdW5kb0FyZ3MpIHtcclxuICAgIHZhciBpbnN0YW5jZSA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzKTtcclxuXHJcbiAgICAvL0lmIGdpdmVuLCB3ZSBvdmVyd3JpdGUgdGhlIGFyZ3VtZW50IHNldHRpbmdzIGZvciB0aGUgYWN0aW9uc1xyXG4gICAgaWYoZG9BcmdzKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuZG9BcmdzID0gZG9BcmdzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHVuZG9BcmdzKSB7XHJcbiAgICAgICAgaW5zdGFuY2UudW5kb0FyZ3MgPSB1bmRvQXJncztcclxuICAgIH1cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBKdXN0IGEgaGVscGVyIHRvIHVuaWZ5IHRoZSBsb2dpYyBmb3IgZG9BY3Rpb24gYW5kIHVuZG9BY3Rpb24uXHJcbiAqXHJcbiAqIC0gaWYganVzdCB0aGUgdHlwZSBpcyBnaXZlbiB3ZSBhc3N1bWUgYWxsIG5lY2Vzc2FyeSBhY3Rpb24gZGF0YSBpcyBnaXZlbiBmb3IgdGhpcyB0eXBlIChkby91bmRvKSBhbmQgY2FsbCB0aGUgYWN0aW9uXHJcbiAqIC0gaWYgYSB0aGVyZSBpcyBhbm90aGVyIGFyZ3VtZW50IGJlc2lkZSB0aGUgdHlwZSB3ZSBhc3N1bWUgYW4gYXJncyBhcnJheSBhbmQgY2FsbCB0aGUgYWN0aW9uIHdpdGggdGhlIGdpdmVuIGFycmF5XHJcbiAqIC0gaWYgdGhlcmUgYXJlIG1vcmUgYXJncyBnaXZlbiwgd2UgYXNzdW1lIGEgc2V0dGVyIGNhbGwgdG8gc2V0IHRoZSBhY3Rpb24gZGF0YSAoZG8vdW5kbylcclxuICpcclxuICogQHBhcmFtIHR5cGUgZG8gb3IgdW5kb1xyXG4gKiBAcGFyYW0gY2xpZW50IGNsaWVudCBvYmplY3QgdXNlZCBhcyB0aGlzXHJcbiAqIEBwYXJhbSBhY3Rpb24gdGhlIGZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIGFyZ3MgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtDb21tYW5kfVxyXG4gKi9cclxuQ29tbWFuZC5wcm90b3R5cGUuYWN0aW9uID0gZnVuY3Rpb24odHlwZSwgY2xpZW50LCBhY3Rpb24sIGFyZ3MpIHtcclxuICAgIGlmKGFyZ3MpIHtcclxuICAgICAgICB0aGlzW3R5cGUgKyAnQXJncyddID0gYXJncztcclxuICAgIH1cclxuXHJcbiAgICBpZihjbGllbnQgJiYgYWN0aW9uKSB7XHJcbiAgICAgICAgdGhpc1t0eXBlICsgJ0FjdGlvbiddID0gbmV3IENvbW1hbmRBY3Rpb24oY2xpZW50LCBhY3Rpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL0V4ZWN1dGUgZWl0aGVyIHdpdGggYXJncyBzZXR0aW5ncyBmcm9tIHRoaXMgb3IgZnJvbSBhcmd1bWVudCBsaXN0XHJcbiAgICAgICAgdGhpc1t0eXBlICsgJ0FyZ3MnXSA9IGFyZ3VtZW50c1sxXSB8fCB0aGlzW3R5cGUgKyAnQXJncyddO1xyXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzW3R5cGUgKyAnQWN0aW9uJ107XHJcbiAgICAgICAgaWYoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXhlYyh0aGlzW3R5cGUgKyAnQXJncyddKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1hbmQ7XHJcblxyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpO1xyXG5cclxuLy9Db21tYW5kIGluc3RhbmNlcyBmb3IgZGlhZ3JhbXNcclxudmFyIGluc3RhbmNlcyA9IHt9O1xyXG5cclxudmFyIHN1YiA9IGZ1bmN0aW9uKHN1YklkLCB1cGRhdGVIYW5kbGVyKSB7XHJcbiAgICByZXR1cm4gaW5zdGFuY2VzW3N1YklkXSA9IG5ldyBDb21tYW5kTWFuYWdlcihzdWJJZCwgdXBkYXRlSGFuZGxlcik7XHJcbn07XHJcblxyXG52YXIgQ29tbWFuZE1hbmFnZXIgPSBmdW5jdGlvbihzdWJJZCwgdXBkYXRlSGFuZGxlcikge1xyXG4gICAgdGhpcy5zdWJJZCA9IHN1YklkO1xyXG4gICAgdGhpcy5jb21tYW5kcyA9IHt9O1xyXG4gICAgdGhpcy51bmRvQ29tbWFuZHMgPSBbXTtcclxuICAgIHRoaXMucmVkb0NvbW1hbmRzID0gW107XHJcbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXIgPSB1cGRhdGVIYW5kbGVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdlIGNhbiByZWdpc3RlciBhIG5ldyBjb21tYW5kIGZvciB0aGlzIGdpdmVuIGNvbW1hbmQgaW5zdGFuY2UgKG1vc3RseSBhIGNvbW1hbmQgZm9yIGEgc3BlY2lmaWMgZGlhZ3JhbSBpbnN0YW5jZSlcclxuICogd2hpY2ggaXMgaWRlbnRpZmllZCBieSBpdHMgc3RyaW5nIGlkLlxyXG4gKlxyXG4gKiBUaGUgY2xpZW50IGFuZCBhY3Rpb24gYXR0cmlidXRlIGZvciB0aGUgZG8gYW5kIHVuZG8gYWN0aW9uIHNob3VsZCBiZSBzZXQgZm9yIHRoZSBnaXZlbiBhY3Rpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gY21kSWQgc3RyaW5nIGlkXHJcbiAqIEBwYXJhbSBjbWQgY29tbWFuZCBpbnN0YW5jZVxyXG4gKi9cclxuQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oY21kSWQsIGNtZCkge1xyXG4gICAgdGhpcy5jb21tYW5kc1tjbWRJZF0gPSBjbWQ7XHJcbn07XHJcblxyXG5Db21tYW5kTWFuYWdlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGNtZElkLCBkb0FyZ3MsIHVuZG9BcmdzKSB7XHJcbiAgICB2YXIgY21kSW5zdGFuY2UgPSB0aGlzLmFkZChjbWRJZCwgZG9BcmdzLCB1bmRvQXJncyk7XHJcbiAgICBpZihjbWRJbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdFeGVjdXRlIGNvbW1hbmQgJytjbWRJbnN0YW5jZS5pZCk7XHJcbiAgICAgICAgcmV0dXJuIGNtZEluc3RhbmNlLmV4ZWMoKTtcclxuICAgIH1cclxufTtcclxuXHJcbkNvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjbWRJZCwgZG9BcmdzLCB1bmRvQXJncykge1xyXG4gICAgdmFyIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzW2NtZElkXTtcclxuICAgIGlmKGNvbW1hbmQpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZWQoY29tbWFuZCk7XHJcbiAgICAgICAgdmFyIGNtZEluc3RhbmNlID0gY29tbWFuZC5pbnN0YW5jZShkb0FyZ3MsdW5kb0FyZ3MpO1xyXG4gICAgICAgIGlmKGNtZEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNtZEluc3RhbmNlLmlkID0gY21kSWQrJ18nK0RhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGQgY29tbWFuZCAnK2NtZEluc3RhbmNlLmlkKTtcclxuICAgICAgICAgICAgdGhpcy51bmRvQ29tbWFuZHMucHVzaChjbWRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVkb0NvbW1hbmRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbWRJbnN0YW5jZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1VucmVnaXN0ZXJlZCBjb21tYW5kICcrY21kSWQrJyB3YXMgY2FsbGVkLicpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjb21tYW5kID0gdGhpcy51bmRvQ29tbWFuZHMucG9wKCk7XHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGNvbW1hbmQpICYmIG9iamVjdC5pc0RlZmluZWQoY29tbWFuZC51bmRvKSkge1xyXG4gICAgICAgIGNvbW1hbmQudW5kby5hcHBseShjb21tYW5kKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnVW5kbyBjb21tYW5kICcrY29tbWFuZC5pZCk7XHJcbiAgICAgICAgdGhpcy5yZWRvQ29tbWFuZHMucHVzaChjb21tYW5kKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZWQoY29tbWFuZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Db21tYW5kTWFuYWdlci5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNvbW1hbmQgPSB0aGlzLnJlZG9Db21tYW5kcy5wb3AoKTtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoY29tbWFuZCkgJiYgb2JqZWN0LmlzRGVmaW5lZChjb21tYW5kLmV4ZWMpKSB7XHJcbiAgICAgICAgY29tbWFuZC5leGVjLmFwcGx5KGNvbW1hbmQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWRvIGNvbW1hbmQgJytjb21tYW5kLmlkKTtcclxuICAgICAgICB0aGlzLnVuZG9Db21tYW5kcy5wdXNoKGNvbW1hbmQpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlZChjb21tYW5kKTtcclxuICAgIH1cclxufTtcclxuXHJcbkNvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24oY29tbWFuZCkge1xyXG4gICAgdGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKTtcclxuICAgIGlmKHRoaXMudXBkYXRlSGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlcihjb21tYW5kKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzdWIgOiBzdWJcclxufTtcclxuXHJcbiIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG5cclxudmFyIHZhbHVlcyA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICB2YWwgOiBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWwpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKGtleSkpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlc1trZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gKG9iamVjdC5pc0RlZmluZWQocmVzdWx0KSkgPyByZXN1bHQgOiBkZWZhdWx0VmFsO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGVidWcgOiBmdW5jdGlvbih2YWwpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNCb29sZWFuKHZhbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRWYWwoJ2RlYnVnJywgdmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsKCdkZWJ1ZycsIGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VmFsIDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQoa2V5KSAmJiBvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy52YWwoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlcGxhY2VDb25maWdWYWx1ZXMgOiBmdW5jdGlvbih0ZXh0LCBjb25maWcpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGV4dDtcclxuICAgICAgICBvYmplY3QuZWFjaChjb25maWcsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJ7XCIgKyBrZXkgKyBcIn1cIiwgXCJnXCIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZWdFeHAsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59OyIsInZhciBldmVudHMgPSB7fTtcclxuXHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29yZS9jb25maWcnKTtcclxudmFyIFN1YkV2ZW50ID0gcmVxdWlyZSgnLi9zdWJFdmVudCcpO1xyXG5cclxudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xyXG5cclxudmFyIGhhc0hhbmRsZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICByZXR1cm4gZXZlbnRzW3R5cGVdO1xyXG59O1xyXG5cclxubW91c2UgPSB7fTtcclxuXHJcbiQoZG9jdW1lbnQpLm9uKCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xyXG4gICAgbW91c2UgPSBlO1xyXG59KTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIG1vdXNlIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vdXNlO1xyXG4gICAgfSxcclxuICAgIGxpc3RlbjogIGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIsIG1vZHVsZSkge1xyXG4gICAgICAgIGlmKCFvYmplY3QuaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47b25jZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGV2ZW50Q29uZmlnID0ge1xyXG4gICAgICAgICAgICBoYW5kbGVyIDogaGFuZGxlcixcclxuICAgICAgICAgICAgbW9kdWxlIDogbW9kdWxlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYoIWV2ZW50c1t0eXBlXSkge1xyXG4gICAgICAgICAgICBldmVudHNbdHlwZV0gPSBbZXZlbnRDb25maWddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50c1t0eXBlXS5wdXNoKGV2ZW50Q29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVubGlzdGVuOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XHJcbiAgICAgICAgaWYoZXZlbnRzW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50c1t0eXBlXS5pbmRleE9mKGZ1bmMpO1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3ViOiBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJFdmVudChjb250ZXh0LCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tbWFuZDogZnVuY3Rpb24oY29tbWFuZCwgZXhlY3V0ZSkge1xyXG4gICAgICAgIGlmKGV4ZWN1dGUpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjb21tYW5kX2V4ZWN1dGUnLCBjb21tYW5kKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbW1hbmRfYWRkJywgY29tbWFuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbih0eXBlLCBkYXRhLCByb290RXZ0KSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gcm9vdEV2dCB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICBldmVudC50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgICAgIGlmKGhhc0hhbmRsZXIoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyQXJyID0gZXZlbnRzW2V2ZW50LnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LmVhY2goaGFuZGxlckFyciwgZnVuY3Rpb24oaW5kZXgsIGV2ZW50Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBldmVudENvbmZpZy5oYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlID0gZXZlbnRDb25maWcubW9kdWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihldmVudENvbmZpZy5tb2R1bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChldmVudENvbmZpZy5tb2R1bGUsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZFRleHQgPSAobW9kdWxlICYmIG1vZHVsZS5jb25zdHJ1Y3RvciAmJiBtb2R1bGUuY29uc3RydWN0b3IubmFtZSk/bW9kdWxlLmNvbnN0cnVjdG9yLm5hbWU6J3Vua25vd24nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtb2RUZXh0ID09PSAndW5rbm93bicgJiYgY29uZmlnLmRlYnVnKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0V2ZW50IGhhbmRsZXIgZXJyb3IgLSBtb2R1bGU6ICcrbW9kVGV4dCsnIGV2ZW50OiAnK2V2ZW50LnR5cGUsIGhhbmRsZXIsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFdmVudCBoYW5kbGVyIGVycm9yIC0gbW9kdWxlOiAnK21vZFRleHQrJyBldmVudDogJytldmVudC50eXBlLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcignZXJyb3InLCAnQW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBleGVjdXRpbmcgdGhlIGxhc3QgYWN0aW9uICEnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9XZSBqdXN0IHJlc29sdmUgaW4gYWxsIGNhc2VzIHNpbmNlIHRoZSBjYWxsZXIgb2YgdHJpZ2dlciBzaG91bGQgcmVtYWluIGluZGVwZW5kZW50IG9mIGhhbmRsZXIgbW9kdWxlc1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uOiBmdW5jdGlvbihub2RlLCBldmVudCwgc2VsZWN0b3IsIGRhdGEsIGhhbmRsZXIpIHtcclxuICAgICAgICAkKG5vZGUpLm9uKGV2ZW50LHNlbGVjdG9yLGRhdGEsIGhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvZmY6IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcikge1xyXG4gICAgICAgICQobm9kZSkub2ZmKGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcik7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uY2U6IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgaGFuZGxlcikge1xyXG4gICAgICAgICQobm9kZSkub25lKGV2ZW50LHNlbGVjdG9yLGRhdGEsIGhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmlnZ2VyRG9tOiBmdW5jdGlvbihub2RlLCBldmVudCkge1xyXG4gICAgICAgJChub2RlKS50cmlnZ2VyKGV2ZW50KTtcclxuICAgIH1cclxufTsiLCJ2YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxuXHJcbnZhciBTdWJFdmVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIGV2ZW50KSB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG59XHJcblxyXG5TdWJFdmVudC5wcm90b3R5cGUuZ2V0U3ViVHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRleHQrJzonK3R5cGU7XHJcbn1cclxuXHJcblN1YkV2ZW50LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyLCBtb2R1bGUpIHtcclxuICAgIC8vVE9ETzogaW1wbGVtZW50IGJ1YmJsZVxyXG4gICAgdGhpcy5ldmVudC5saXN0ZW4odGhpcy5nZXRTdWJUeXBlKHR5cGUpLCBoYW5kbGVyLCBtb2R1bGUpO1xyXG59O1xyXG5cclxuU3ViRXZlbnQucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24odHlwZSwgZnVuYykge1xyXG4gICAgdGhpcy5ldmVudC51bmxpc3Rlbih0aGlzLmdldFN1YlR5cGUodHlwZSksIGZ1bmMpO1xyXG59O1xyXG5cclxuU3ViRXZlbnQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCByb290RXZ0LCBwcmV2ZW50QnViYmxlKSB7XHJcbiAgICB0aGlzLmV2ZW50LnRyaWdnZXIodGhpcy5nZXRTdWJUeXBlKHR5cGUpLCBkYXRhLCByb290RXZ0KTtcclxuICAgIGlmKCFwcmV2ZW50QnViYmxlKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIHJvb3RFdnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU3ViRXZlbnQucHJvdG90eXBlLmNvbW1hbmQgPSBmdW5jdGlvbihjb21tYW5kLCBleGVjdXRlKSB7XHJcbiAgICB0aGlzLmV2ZW50LmNvbW1hbmQoY29tbWFuZCwgZXhlY3V0ZSk7XHJcbn07XHJcblxyXG5TdWJFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihub2RlLCBldmVudCwgc2VsZWN0b3IsIGRhdGEsIGhhbmRsZXIpIHtcclxuICAgIHRoaXMuZXZlbnQub24obm9kZSwgZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBoYW5kbGVyKTtcclxufTtcclxuXHJcblN1YkV2ZW50LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihub2RlLCBldmVudCwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcclxuICAgIHRoaXMuZXZlbnQub2ZmKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcik7XHJcbn07XHJcblxyXG5TdWJFdmVudC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgaGFuZGxlcikge1xyXG4gICAgdGhpcy5ldmVudC5vbmNlKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgaGFuZGxlcik7XHJcbn07XHJcblxyXG5TdWJFdmVudC5wcm90b3R5cGUudHJpZ2dlckRvbSA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50KSB7XHJcbiAgICB0aGlzLmV2ZW50LnRyaWdnZXJEb20obm9kZSxldmVudCk7XHJcbn1cclxuXHJcblN1YkV2ZW50LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IFN1YkV2ZW50KGNvbnRleHQsIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN1YkV2ZW50OyIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgYXBwID0gcmVxdWlyZSgnLi4vdXRpbC9hcHAnKTtcclxudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2RvbS9kb20nKTtcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL3N2Zy90cmFuc2Zvcm0nKTtcclxuXHJcbnZhciBERUZBVUxUX09QQUNJVFkgPSAwLjU7XHJcbnZhciBERUZBVUxUX0tOT0JfUkFESVVTID0gNTtcclxuXHJcbnZhciBLbm9iID0gZnVuY3Rpb24oZGlhZ3JhbSwgcCwgY2ZnLCBncm91cCkge1xyXG4gICAgdGhpcy5kaWFncmFtID0gZGlhZ3JhbTtcclxuICAgIHRoaXMuZXZlbnQgPSBkaWFncmFtLmV2ZW50O1xyXG4gICAgdGhpcy5ncm91cCA9IGdyb3VwO1xyXG4gICAgdGhpcy5pbml0KHAsIGNmZyk7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5jbGVhclJlbGF0aXZlT3JpZW50YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIGRlbGV0ZSB0aGlzLnJlbGF0aXZlUG9zaXRpb247XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlLnNlbGVjdGVkO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUucmVsYXRpdmVPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICBpZihwb3NpdGlvbikge1xyXG4gICAgICAgIHRoaXMucmVsYXRpdmVQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgeCA6IHBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgIHkgOiBwb3NpdGlvbi55XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnJlbGF0aXZlUG9zaXRpb247XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ocG9zaXRpb24sIGNmZykge1xyXG4gICAgdGhpcy5jb25maWcgPSBvYmplY3QuZXh0ZW5kKHtyYWRpdXMgOiBERUZBVUxUX0tOT0JfUkFESVVTfSwgY2ZnKTtcclxuICAgIHRoaXMubm9kZSA9IHRoaXMuZGlhZ3JhbS5jcmVhdGVLbm9iTm9kZShwb3NpdGlvbiwgdGhpcy5ncm91cCwgdGhpcy5jb25maWcpO1xyXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLm5vZGUuY29uZmlnO1xyXG4gICAgdGhpcy5yb290ID0gdGhpcy5ub2RlLnJvb3Q7XHJcbiAgICB0aGlzLm5vZGUua25vYiA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdmFyIHNlbGVjdCA9IGNmZy5zZWxlY3QgfHwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYWN0aXZlU3R5bGUoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIHZhciBkZXNlbGVjdCA9IGNmZy5kZXNlbGVjdCB8fCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5pbmFjdGl2ZVN0eWxlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgdGhpcy5vbignc2VsZWN0Jywgc2VsZWN0KS5vbignZGVzZWxlY3QnLCBkZXNlbGVjdCk7XHJcbiAgICB0aGlzLmV2ZW50LnRyaWdnZXIoJ2tub2JfYWRkZWQnLCB0aGlzKTtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLnggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGUueCgpO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUueSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZS55KCk7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDZW50ZXIoKTtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLmRyYWdnYWJsZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcclxuICAgIHRoaXMubm9kZS5kcmFnZ2FibGUoaGFuZGxlcik7XHJcbiAgICB0aGlzLnRyaWdnZXJEcmFnID0gZnVuY3Rpb24oZHgsZHkpIHtcclxuICAgICAgICB0aGlzLm5vZGUudHJpZ2dlckRyYWcoZHgsZHkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuaW5pdERyYWcgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRoaXMubm9kZS5pbml0RHJhZyhldnQpO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ub2RlLnJvb3QuaGlkZSgpO1xyXG4gICAgdGhpcy5ub2RlLnJvb3QuYXR0cigncicsIDApOyAvL1RPRE86IHBlcmhhcHMgbm90IHdhbnRlZCBmb3IgYWxsIGtub2IgdHlwZXMuXHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24ob3BhY2l0eSkge1xyXG4gICAgb3BhY2l0eSA9IG9wYWNpdHkgfHwgdGhpcy5jb25maWdbJ2ZpbGwtb3BjYWl0eSddIHx8IDE7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5zaG93KERFRkFVTFRfT1BBQ0lUWSk7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5hdHRyKCdyJywgdGhpcy5jb25maWdbJ3JhZGl1cyddKTtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICB0aGlzLm5vZGUudHJpZ2dlcignc2VsZWN0Jyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLm5vZGUudHJpZ2dlcignZGVzZWxlY3QnKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5maWxsKGNvbG9yKTtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5zdHJva2UoY29sb3IpO1xyXG4gICAgdGhpcy5ub2RlLnJvb3Quc3Ryb2tlV2lkdGgoMSk7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5hY3RpdmVTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5maWxsKHRoaXMuY29uZmlnWydmaWxsLWFjdGl2ZSddKTtcclxuICAgIHRoaXMuc2hvdygpO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaW5hY3RpdmVTdHlsZSgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5pbmFjdGl2ZVN0eWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmZpbGwodGhpcy5jb25maWdbJ2ZpbGwnXSk7XHJcbiAgICB0aGlzLnNob3coKTtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLmhvdmVyYWJsZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMubm9kZS5yb290LmhvdmVyYWJsZShoYW5kbGVyKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUub24gPSBmdW5jdGlvbihoYW5kbGVyLCBhcmdzKSB7XHJcbiAgICB0aGlzLm5vZGUub24oaGFuZGxlciwgYXJncyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ub2RlLnRyaWdnZXIoJ3JlbW92ZScpO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGR4LGR5KSB7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5tb3ZlKGR4LGR5KTtcclxuICAgIHRoaXMubm9kZS50cmlnZ2VyKCdtb3ZlJyBbZHgsZHldKTtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgdGhpcy5ub2RlLnJvb3QubW92ZVRvKHgseSk7XHJcbiAgICB0aGlzLm5vZGUudHJpZ2dlcignbW92ZVRvJywgW3gseV0pO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAnKCcrdGhpcy54KCkrJy8nK3RoaXMueSgpKycpJztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS25vYjsiLCJ2YXIgZG9tID0gcmVxdWlyZSgnLi4vZG9tL2RvbScpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIEVkaXRQYW5lbCA9IHJlcXVpcmUoJy4uL3VpL2VkaXRQYW5lbCcpO1xyXG5cclxudmFyIGVkaXRQYW5lbCA9IG5ldyBFZGl0UGFuZWwoKTtcclxuXHJcbnZhciBBYnN0cmFjdEVkaXRBZGRpdGlvbiA9IGZ1bmN0aW9uKGVkaXRhYmxlLCBlZGl0RnVuY3Rpb25zLCBjb25maWcpIHtcclxuICAgIHRoaXMuZWRpdGFibGUgPSBlZGl0YWJsZTtcclxuICAgIHRoaXMuZWRpdEZ1bmN0aW9ucyA9IGVkaXRGdW5jdGlvbnM7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMuaW5pdEVkaXRUcmlnZ2VyKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuaW5pdEVkaXRUcmlnZ2VyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLmNvbmZpZywgZnVuY3Rpb24oa2V5LCBlZGl0SXRlbSkge1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQoZWRpdEl0ZW0udHJpZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhhdC5hZGRFZGl0VGV4dFRyaWdnZXIoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkFic3RyYWN0RWRpdEFkZGl0aW9uLnByb3RvdHlwZS5hZGRFZGl0VHJpZ2dlciA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgc3dpdGNoKHR5cGUpIHtcclxuICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWRpdFRleHRUcmlnZ2VyKGtleSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLmFkZEVkaXRUZXh0VHJpZ2dlciA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgdmFyIGVkaXRJdGVtID0gdGhpcy5nZXRFZGl0SXRlbShrZXkpO1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIHZhciBzZWxlY3RvciA9IHRoaXMuZWRpdGFibGUuc2VsZWN0b3IoZWRpdEl0ZW0udHJpZ2dlcik7XHJcbiAgICAkKHNlbGVjdG9yKS5jc3MoJ2N1cnNvcicsICdwb2ludGVyJyk7XHJcblxyXG4gICAgLy9UT0RPOiBldnRsIG1vdmUgdGhpcyB0byB0ZXh0LmVkaXRhYmxlKCk7XHJcbiAgICB0aGlzLmVkaXRhYmxlLnJvb3QuJCgpLm9uKCdjbGljaycsIHNlbGVjdG9yLCAgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgaWYodGhhdC5pc1RyaWdnZXJBbGxvd2VkKCkpIHtcclxuICAgICAgICAgICAgc3dpdGNoKGVkaXRJdGVtLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICAgICAgICAgICAgICBlZGl0UGFuZWwuY3JlYXRlVGV4dEFyZWFFZGl0KGV2dC5wYWdlWCwgZXZ0LnBhZ2VZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmdldFZhbHVlKGtleSkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRWYWx1ZShrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgICAgICAgICBlZGl0UGFuZWwuY3JlYXRlVGV4dEVkaXQoZXZ0LnBhZ2VYLCBldnQucGFnZVksIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2V0VmFsdWUoa2V5KS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNldFZhbHVlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICB2YXIgZWRpdEl0ZW0gPSB0aGlzLmdldEVkaXRJdGVtKGtleSk7XHJcbiAgICB2YXIgZWRpdEZ1bmN0aW9uID0gdGhpcy5lZGl0RnVuY3Rpb25zW2VkaXRJdGVtLnR5cGVdO1xyXG4gICAgaWYoZWRpdEZ1bmN0aW9uICYmICFvYmplY3QuaXNTdHJpbmcoZWRpdEZ1bmN0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRGdW5jdGlvbnNbZWRpdEl0ZW0udHlwZV0uZ2V0LmNhbGwodGhpcywgZWRpdEl0ZW0sIGtleSk7XHJcbiAgICB9IGVsc2UgaWYoZWRpdEZ1bmN0aW9uICYmIG9iamVjdC5pc1N0cmluZyhlZGl0RnVuY3Rpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGUuZ2V0SW5uZXJTVkcoZWRpdEl0ZW0uYmluZClbZWRpdEZ1bmN0aW9uXSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgdmFyIGVkaXRJdGVtID0gdGhpcy5nZXRFZGl0SXRlbShrZXkpO1xyXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRWYWx1ZShrZXkpO1xyXG4gICAgdmFyIGVkaXRGdW5jdGlvbiA9IHRoaXMuZWRpdEZ1bmN0aW9uc1tlZGl0SXRlbS50eXBlXTtcclxuICAgIGlmKGVkaXRGdW5jdGlvbiAmJiAhb2JqZWN0LmlzU3RyaW5nKGVkaXRGdW5jdGlvbikpIHtcclxuICAgICAgICB0aGlzLmVkaXRGdW5jdGlvbnNbZWRpdEl0ZW0udHlwZV0uc2V0LmNhbGwodGhpcywgZWRpdEl0ZW0sIHZhbHVlKTtcclxuICAgICAgICB0aGlzLm9uU2V0VmFsdWUoZWRpdEl0ZW0sIHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZihlZGl0RnVuY3Rpb24gJiYgb2JqZWN0LmlzU3RyaW5nKGVkaXRGdW5jdGlvbikpIHtcclxuICAgICAgICB0aGlzLmVkaXRhYmxlLmdldElubmVyU1ZHKGVkaXRJdGVtLmJpbmQpW2VkaXRGdW5jdGlvbl0odmFsdWUpO1xyXG4gICAgICAgIHRoaXMub25TZXRWYWx1ZShlZGl0SXRlbSwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuZWRpdGFibGUuZXhlYykge1xyXG4gICAgICAgIHRoaXMuZWRpdGFibGUuZXhlYygnZWRpdCcsIFtrZXksIHZhbHVlLCBvbGRWYWx1ZV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGVpdGhlciByZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGVkaXRJdGVtIGZvciBub3JtYWwga2V5cyBsaWtlICd0aXRsZScsIG9yXHJcbiAqIGNyZWF0ZXMgYSBuZXcgZWRpdEl0ZW0gb3V0IG9mIGEgY29tYmluZWQga2V5IGxpa2UgJ3RpdGxlX3RleHQtc2l6ZScgd2l0aCBrZXkgdGl0bGUgYW5kIHR5cGUgdGV4dC1zaXplXHJcbiAqL1xyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuZ2V0RWRpdEl0ZW0gPSBmdW5jdGlvbihrZXkpIHtcclxuICAgIHZhciB0eXBlO1xyXG4gICAgdmFyIGVkaXRJdGVtO1xyXG4gICAgaWYoa2V5LmluZGV4T2YoJ18nKSA+IC0xKSB7XHJcbiAgICAgICAgdmFyIHNwbGl0dGVkID0ga2V5LnNwbGl0KCdfJyk7XHJcbiAgICAgICAgZWRpdEl0ZW0gPSBvYmplY3QuY2xvbmVPYmplY3QodGhpcy5jb25maWdbc3BsaXR0ZWRbMF1dKTtcclxuICAgICAgICBlZGl0SXRlbS50eXBlID0gc3BsaXR0ZWRbMV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVkaXRJdGVtID0gdGhpcy5jb25maWdba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBlZGl0SXRlbTtcclxufTtcclxuXHJcbkFic3RyYWN0RWRpdEFkZGl0aW9uLnByb3RvdHlwZS5pc1RyaWdnZXJBbGxvd2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gIXRoaXMubGFzdFNlbGVjdCB8fCAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdFNlbGVjdCA+IDIwMCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuc2V0VGV4dEFyZWFDb250ZW50ID0gZnVuY3Rpb24oJHRleHRBcmVhTm9kZSwgdHh0QXJlYUNvbnRlbnQpIHtcclxuICAgIHRoaXMuZWRpdGFibGUuZGlhZ3JhbS5zdmcuZ2V0KCR0ZXh0QXJlYU5vZGUpLmNvbnRlbnQodHh0QXJlYUNvbnRlbnQpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLmdldFRleHRBcmVhQ29udGVudCA9IGZ1bmN0aW9uKCR0ZXh0QXJlYU5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLmVkaXRhYmxlLmRpYWdyYW0uc3ZnLmdldCgkdGV4dEFyZWFOb2RlKS5jb250ZW50KCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmxhc3RTZWxlY3QgPSBEYXRlLm5vdygpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZWRpdFBhbmVsLmNsb3NlKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLm9uU2V0VmFsdWUgPSBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHsgfTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RFZGl0QWRkaXRpb247IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG52YXIgQ29tbWFuZCA9IHJlcXVpcmUoJy4uL2NvcmUvY29tbWFuZCcpO1xyXG5cclxudmFyIE1hbmFnZXIgPSBmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSBkaWFncmFtO1xyXG4gICAgdGhpcy5ldmVudCA9IGRpYWdyYW0uZXZlbnQ7XHJcbn07XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZS5jb21tYW5kID0gZnVuY3Rpb24oY21kSWQsIGRvQWN0aW9uLCB1bmRvQWN0aW9uKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0ucmVnaXN0ZXJDb21tYW5kKGNtZElkLCBuZXcgQ29tbWFuZCh0aGlzLCBkb0FjdGlvbiwgdW5kb0FjdGlvbikpO1xyXG59O1xyXG5cclxuTWFuYWdlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGNtZElkLCBkb0FyZ3MsIHVuZG9BcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLmV4ZWN1dGVDb21tYW5kKGNtZElkLCBkb0FyZ3MsIHVuZG9BcmdzKTtcclxufTtcclxuXHJcbk1hbmFnZXIucHJvdG90eXBlLmFkZENtZCA9IGZ1bmN0aW9uKGNtZElkLCBkb0FyZ3MsIHVuZG9BcmdzKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0uYWRkQ29tbWFuZChjbWRJZCwgZG9BcmdzLCB1bmRvQXJncyk7XHJcbn07XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbihldmVudElkLCBoYW5kbGVyKSB7XHJcbiAgICB0aGlzLmV2ZW50Lmxpc3RlbihldmVudElkLCBoYW5kbGVyLCB0aGlzKTtcclxufVxyXG5cclxuTWFuYWdlci5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlhZ3JhbS5nZXROb2RlQnlJZChpZCk7XHJcbn07XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uQnlJZCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLmdldFRyYW5zaXRpb25CeUlkKGlkKTtcclxufTtcclxuXHJcbk1hbmFnZXIucHJvdG90eXBlLmdldFNWRyA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICByZXR1cm4gJC5zdmcoaWQpO1xyXG59O1xyXG5cclxuTWFuYWdlci5wcm90b3R5cGUuZ2V0Tm9kZU1nciA9IGZ1bmN0aW9uKGNvbW1hbmQpIHtcclxuICAgIHJldHVybiB0aGlzLmRpYWdyYW0ubm9kZU1ncjtcclxufTtcclxuXHJcbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zaXRpb25NZ3IgPSBmdW5jdGlvbihjb21tYW5kKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLnRyYW5zaXRpb25NZ3I7XHJcbn07XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25NZ3IgPSBmdW5jdGlvbihjb21tYW5kKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLnNlbGVjdGlvbk1ncjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjsiLCJ2YXIgUGF0aERhdGEgPSByZXF1aXJlKCcuLi9zdmcvcGF0aERhdGEnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcblxyXG52YXIgQWJzdHJhY3RQYXRoTWFuYWdlciA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5wYXRoID0gIHRoaXMudHJhbnNpdGlvbi5nZXRMaW5lKCkuZCgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24ocGF0aERhdGFTdHIpIHtcclxuICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoRGF0YSgpLmxvYWRGcm9tU3RyaW5nKHBhdGhEYXRhU3RyKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLmRyYWdMaW5lID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIC8vIEluaXQgcGF0aCBpZiBubyBwYXRoIHdhcyBjcmVhdGVkIHlldFxyXG4gICAgaWYoIXRoaXMucGF0aCkge1xyXG4gICAgICAgIHRoaXMuX2luaXQocG9zaXRpb24pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGZ1bGwgcGF0aCBpZiB0aGUgcGF0aCBvbmx5IGNvbnNpc3Qgb2YgdGhlIHN0YXJ0IHBhdGggcGFydCB5ZXQgb3IgdXBkYXRlIHRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHBhdGhcclxuICAgIGlmKHRoaXMucGF0aC5sZW5ndGgoKSA9PT0gMSkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlKHBvc2l0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5wYXRoLmVuZChwb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoRGF0YSgpLnN0YXJ0KHBvc2l0aW9uKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVBhcnQgPSBmdW5jdGlvbihpbmRleCwgcG9zaXRpb24pIHtcclxuICAgIHRoaXMucGF0aC5zZXRUbyhpbmRleCwgcG9zaXRpb24pO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLmFkZFBhdGhQYXJ0ID0gZnVuY3Rpb24oaW5kZXgsIHBvc2l0aW9uKSB7XHJcbiAgICBpZighdGhpcy5wYXRoKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdChwb3NpdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYWRkKGluZGV4LHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlUGF0aFBhcnQgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgaWYodGhpcy5wYXRoKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoLnJlbW92ZVBhdGgoaW5kZXgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKG9sZCwgcG9zaXRpb25zKSB7XHJcbiAgICB0aGlzLl9pbml0KHBvc2l0aW9uc1swXSk7XHJcblxyXG4gICAgZm9yKHZhciBpICA9IDE7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLmFkZChpLCBwb3NpdGlvbnNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gICAgLy9XZSBzZXQgb3VyIGNyZWF0ZWQgcGF0aCBkYXRhIHRvIHRoZSBleGlzdGluZyBwYXRoLCBzaW5jZSB0aGUgdHJhbnNpdGlvbiBsaW5lIGFuZCBsaW5lYXJlYSBhcmUgZGVwZW5kZW50IG9uIHRoaXMgcGF0aCBpbnN0YW5jZVxyXG4gICAgb2xkLnBhdGguZGF0YSA9IHRoaXMucGF0aC5kYXRhO1xyXG4gICAgdGhpcy5wYXRoID0gb2xkLnBhdGg7XHJcblxyXG4gICAgdGhpcy50cmFuc2l0aW9uLnBhdGhNYW5hZ2VyID0gdGhpcztcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24ocG9zaXRpb24pIHsvKkFic3RyYWN0Ki99O1xyXG5BYnN0cmFjdFBhdGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihwb3NpdGlvbikgey8qQWJzdHJhY3QqL307XHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGluZGV4LCBwb3NpdGlvbikgey8qQWJzdHJhY3QqL307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0UGF0aE1hbmFnZXI7IiwidmFyIGFkZGl0aW9ucyA9IHt9O1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcblxyXG52YXIgQWRkaXRpb25GYWN0b3J5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmFkZGl0aW9ucyA9IHt9O1xyXG59O1xyXG5cclxuQWRkaXRpb25GYWN0b3J5LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGtleSwgYWRkaXRpb24pIHtcclxuICAgIHRoaXMuYWRkaXRpb25zW2tleV0gPSBhZGRpdGlvbjtcclxufTtcclxuXHJcbkFkZGl0aW9uRmFjdG9yeS5wcm90b3R5cGUuaW5pdEFkZGl0aW9uID0gZnVuY3Rpb24oa2V5LCBob3N0KSB7XHJcbiAgICBpZiAoIWhvc3QuYWRkaXRpb25zKSB7XHJcbiAgICAgICAgaG9zdC5hZGRpdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWRkaXRpb24gPSB0aGlzLmFkZGl0aW9uc1trZXldO1xyXG5cclxuICAgIGlmKGFkZGl0aW9uICYmIGhvc3QgJiYgX2NoZWNrQ29uZmlnUmVxdWlyZW1lbnQoYWRkaXRpb24sIGhvc3QsIGtleSkpIHtcclxuICAgICAgICBob3N0LmFkZGl0aW9uc1trZXldID0gbmV3IGFkZGl0aW9uKGhvc3QpO1xyXG4gICAgfSBlbHNlIGlmKCFhZGRpdGlvbil7XHJcbiAgICAgICAgZXZlbnQudHJpZ2dlcignd2FybicsICdUcmllZCB0byBpbml0aWF0ZSBhbiB1bmtub3duIGFkZGl0aW9uICcra2V5Kycgc29tZSBmdW5jdGlvbmFsaXR5IG1heSBub3QgYXZhaWxhYmxlLicpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIG5vZGVBZGRpdGlvbnMgPSBuZXcgQWRkaXRpb25GYWN0b3J5KCk7XHJcbnZhciB0cmFuc2l0aW9uQWRkaXRpb25zID0gbmV3IEFkZGl0aW9uRmFjdG9yeSgpO1xyXG5cclxudmFyIF9jaGVja0NvbmZpZ1JlcXVpcmVtZW50ID0gZnVuY3Rpb24oYWRkaXRpb24sIGhvc3QsIGtleSkge1xyXG4gICAgcmV0dXJuICFhZGRpdGlvbi5yZXF1aXJlQ29uZmlnIHx8IChhZGRpdGlvbi5yZXF1aXJlQ29uZmlnICYmIChob3N0LmNvbmZpZyAmJiBob3N0LmNvbmZpZ1trZXldKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHJlZ2lzdGVyTm9kZUFkZGl0aW9uIDogZnVuY3Rpb24oa2V5LCBhZGRpdGlvbikge25vZGVBZGRpdGlvbnMucmVnaXN0ZXIoa2V5LGFkZGl0aW9uKX0sXHJcbiAgICBpbml0Tm9kZUFkZGl0aW9uIDogZnVuY3Rpb24oa2V5LCBob3N0KSB7bm9kZUFkZGl0aW9ucy5pbml0QWRkaXRpb24oa2V5LCBob3N0KX0sXHJcbiAgICByZWdpc3RlclRyYW5zaXRpb25BZGRpdGlvbiA6IGZ1bmN0aW9uKGtleSwgYWRkaXRpb24pIHt0cmFuc2l0aW9uQWRkaXRpb25zLnJlZ2lzdGVyKGtleSxhZGRpdGlvbil9LFxyXG4gICAgaW5pdFRyYW5zaXRpb25BZGRpdGlvbiA6IGZ1bmN0aW9uKGtleSwgaG9zdCkge3RyYW5zaXRpb25BZGRpdGlvbnMuaW5pdEFkZGl0aW9uKGtleSwgaG9zdCl9XHJcbn07IiwidmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xyXG5cclxudmFyIERpYWdyYW1BUEkgPSBmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSBkaWFncmFtO1xyXG59O1xyXG5cclxuRGlhZ3JhbUFQSS5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uKHRtcGxJZCwgcG9zaXRpb24pIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB0aGF0LmxvYWRUZW1wbGF0ZSh0bXBsSWQpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoYXQuZGlhZ3JhbS5ub2RlTWdyLmNyZWF0ZU5vZGVDb21tYW5kKHRlbXBsYXRlLCBwb3NpdGlvbikpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxufTtcclxuXHJcbkRpYWdyYW1BUEkucHJvdG90eXBlLmdldFNlbGVjdGVkVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRtcGwsIHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLnNlbGVjdGlvbk1nci5zZWxlY3RlZFRyYW5zaXRpb247XHJcbn07XHJcblxyXG5EaWFncmFtQVBJLnByb3RvdHlwZS5sb2FkVGVtcGxhdGUgPSBmdW5jdGlvbih0bXBsKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdGhhdC5kaWFncmFtLnRlbXBsYXRlTWdyLmdldFRlbXBsYXRlKHRtcGwpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkRpYWdyYW1BUEkucHJvdG90eXBlLmdldFNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbih0bXBsLCBwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlhZ3JhbS5zZWxlY3Rpb25NZ3IuZ2V0U2VsZWN0ZWROb2RlcygpO1xyXG59O1xyXG5cclxuRGlhZ3JhbUFQSS5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlhZ3JhbS5ub2RlTWdyLmdldE5vZGUoaWQpO1xyXG59O1xyXG5cclxuRGlhZ3JhbUFQSS5wcm90b3R5cGUuY3JlYXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMikge1xyXG4gICAgcmV0dXJuIG5vZGUxLmFkZGl0aW9ucy50cmFuc2l0aW9uLnN0YXJ0TmV3VHJhbnNpdGlvbihub2RlMik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpYWdyYW1BUEk7IiwidmFyIEFic3RyYWN0UGF0aE1hbmFnZXIgPSByZXF1aXJlKCcuL2Fic3RyYWN0UGF0aE1hbmFnZXInKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxuXHJcbnZhciBDdXJ2ZWRQYXRoTWFuYWdlciA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIEFic3RyYWN0UGF0aE1hbmFnZXIuY2FsbCh0aGlzLCB0cmFuc2l0aW9uKTtcclxuICAgIHRoaXMudHlwZSA9IEN1cnZlZFBhdGhNYW5hZ2VyLnR5cGU7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKEN1cnZlZFBhdGhNYW5hZ2VyLCBBYnN0cmFjdFBhdGhNYW5hZ2VyKTtcclxuXHJcbkN1cnZlZFBhdGhNYW5hZ2VyLnR5cGUgPSAnY3VydmVkJztcclxuXHJcbkN1cnZlZFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgdGhpcy5wYXRoLmNCZXppZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIHBvc2l0aW9uKTtcclxufTtcclxuXHJcbkN1cnZlZFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpbmRleCwgcG9zaXRpb24pIHtcclxuICAgIHRoaXMucGF0aC5pbnNlcnRDQmV6aWVyKGluZGV4LHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwb3NpdGlvbik7XHJcbn07XHJcblxyXG5DdXJ2ZWRQYXRoTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnBhdGguc21vb3RoZW4oKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VydmVkUGF0aE1hbmFnZXI7XHJcbiIsIi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYW4gaW5zdGFuY2Ugb2YgYSBkaWFncmFtIGFuZCBpcyByZXNwb25zaWJsZSBmb3IgaW5pdGlhbGl6aW5nIGFuZFxyXG4gKiBidWlsZGluZyB0aGUgc3RhZ2UuIEZ1cnRoZXJtb3JlIGl0IGNvbnRhaW5zIGRpYWdyYW0gcmVsYXRlZCB1dGlsaXR5IGZ1bmN0aW9uYWxpdHkuXHJcbiAqXHJcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3Mgb2ZmZXJzIHRoZSBhY2Nlc3MgdG8gYWxsIG5vZGVzL3RyYW5zaXRpb25zIGFuZCB0ZW1wbGF0ZXMgb2YgdGhlXHJcbiAqIGRpYWdyYW0uXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gYmUgYWJsZSB0byBtYW5hZ2UgbXVsdGlwbGUgZGlhZ3JhbXMgd2l0aGluIG9uZVxyXG4gKiBhcHBsaWNhdGlvbiBpbnN0YW5jZS5cclxuICovXHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxudmFyIFNWRyA9IHJlcXVpcmUoJy4uL3N2Zy9zdmcnKTtcclxudmFyIFBhdGhEYXRhID0gcmVxdWlyZSgnLi4vc3ZnL3BhdGhEYXRhJyk7IC8vUmF0aGVyIGltcGxlbWVudCBzdmcuY3JlYXRlcGF0aCgpLnN0YXJ0KCkubGluZSgpLi4uXHJcbnZhciB0ZW1wbGF0ZU1hbmFnZXIgPSByZXF1aXJlKCcuL3RlbXBsYXRlTWFuYWdlcicpLmluaXQoKTtcclxudmFyIGNvbW1hbmRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vY29yZS9jb21tYW5kTWFuYWdlcicpO1xyXG52YXIgU2VsZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vc2VsZWN0aW9uTWFuYWdlcicpO1xyXG52YXIgTm9kZU1hbmFnZXIgPSByZXF1aXJlKCcuL25vZGVNYW5hZ2VyJyk7XHJcbnZhciBUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbk1hbmFnZXInKTtcclxudmFyIERpYWdyYW1BUEkgPSByZXF1aXJlKCcuL2FwaScpO1xyXG5cclxudmFyIEtub2JNYW5hZ2VyID0gcmVxdWlyZSgnLi9rbm9iTWFuYWdlcicpO1xyXG5yZXF1aXJlKCcuL2tub2JUZW1wbGF0ZScpO1xyXG52YXIgeG1sID0gcmVxdWlyZSgnLi4vdXRpbC94bWwnKTtcclxuXHJcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcclxuXHJcbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xyXG5cclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcblxyXG5cclxudmFyIENPTlRBSU5FUl9TRUxFQ1RPUiA9ICcjc3ZnU3RhZ2UnO1xyXG4vLyBDb250YWlucyB0aGUgcGFyZW50IGRvbSBub2RlIChkaXYpIG9mIHRoZSBTVkcgZWxlbWVudFxyXG52YXIgJENPTlRBSU5FUl9OT0RFID0gJChDT05UQUlORVJfU0VMRUNUT1IpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdG9yIGZvciBpbml0aWF0aW5nIGEgbmV3IGRpYWdyYW0gaW5zdGFuY2Ugd2l0aGluIHRoZSBjb250YWluZXJJRC5cclxuICpcclxuICogQHBhcmFtIHt0eXBlfSBjb250YWluZXJJRCBUaGUgcGFyZW50IG9mIHRoZSBuZXcgU1ZHIGRpYWdyYW1cclxuICogQHBhcmFtIHt0eXBlfSBjZmdcclxuICovXHJcbiB2YXIgRGlhZ3JhbSA9IGZ1bmN0aW9uKGNmZykge1xyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG5cclxuICAgIGlmKCFjZmcuaWQpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0NyZWF0ZWQgZGlhZ3JhbSB3aXRob3V0IGlkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51bmlxdWVJZHMgPSBbXTtcclxuXHJcbiAgICB0aGlzLmlkID0gY2ZnLmlkIHx8ICdub3Qgc3BlY2lmaWVkJztcclxuICAgIHRoaXMucHJvamVjdElkID0gY2ZnLnByb2plY3RJZCB8fCAnZGVmYXVsdCc7XHJcbiAgICB0aGlzLnRpdGxlID0gY2ZnLnRpdGxlIHx8ICduZXcnO1xyXG5cclxuICAgIC8vRGlhZ3JhbSBpbnRlcm4gZXZlbnQgY29udGV4dFxyXG4gICAgdGhpcy5ldmVudCA9IGV2ZW50LnN1Yih0aGlzLmlkKTtcclxuXHJcbiAgICBpZihjZmcuY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJChjZmcuY29udGFpbmVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJENPTlRBSU5FUl9OT0RFO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuY29tbWFuZE1nciA9IGNvbW1hbmRNYW5hZ2VyLnN1Yih0aGlzLmlkLCBmdW5jdGlvbihjbWQpIHtcclxuICAgICAgICB0aGF0LnRyaWdnZXJVcGRhdGUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhhbmRsZXMgdGhlIGxvYWRpbmcgYW5kIGNyZWF0aW9uIG9mIHRlbXBsYXRlc1xyXG4gICAgdGhpcy50ZW1wbGF0ZU1nciA9IHRlbXBsYXRlTWFuYWdlcjtcclxuICAgIC8vIFJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgbWFpbnRhaW5pbmcgbm9kZXNcclxuICAgIHRoaXMubm9kZU1nciA9IG5ldyBOb2RlTWFuYWdlcih0aGlzKTtcclxuICAgIC8vIFJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgbWFpbnRhaW5pbmcgdHJhbnNpdGlvbnNcclxuICAgIHRoaXMudHJhbnNpdGlvbk1nciA9IG5ldyBUcmFuc2l0aW9uTWFuYWdlcih0aGlzKTtcclxuICAgIC8vIFRoaXMgaGVscGVyIGNsYXNzIG1hbmFnZXMgdGhlIHNlbGVjdGlvbiBvZiBub2Rlcy90cmFuc2l0aW9uc1xyXG4gICAgdGhpcy5zZWxlY3Rpb25NZ3IgPSBuZXcgU2VsZWN0aW9uTWFuYWdlcih0aGlzKTtcclxuICAgIC8vIFJlc3BvbnNpYmxlIGZvciB0cmFja2luZyBhbmQgYWNjZXNzaW5nIGFsbCBkb2NraW5ncyBvbiB0aGUgZGlhZ3JhbVxyXG4gICAgdGhpcy5rbm9iTWdyID0gbmV3IEtub2JNYW5hZ2VyKHRoaXMpO1xyXG5cclxuICAgIC8vIEJ1aWxkIHRoZSBTVkcgc3RhZ2Ugd2l0aGluIHRoZSBjb250YWluZXJcclxuICAgIHRoaXMuc3ZnID0gbmV3IFNWRyh0aGlzLiRjb250YWluZXIuYXR0cignaWQnKSwge1wieG1sbnM6ZGFsYVwiIDogXCJodHRwOi8vd3d3LmRhbGEuY29tXCJ9KTtcclxuXHJcbiAgICAvLyBJbml0IHN0YWdlIHJlbGF0ZWQgYW5kIGtleSBldmVudHNcclxuICAgIHRoaXMuaW5pdEV2ZW50cygpO1xyXG5cclxuICAgIHRoaXMuc2NhbGUgPSAxO1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuaW5pdERlZnMoKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0Lm1haW5QYXJ0ID0gdGhhdC5zdmcuY3JlYXRlUGFydCgnbWFpbicsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGF0LmhlbHBlciA9IG5ldyBIZWxwZXIodGhpcyk7XHJcbiAgICAgICAgICAgIHRoYXQudHJpZ2dlcignaW5pdGlhbGl6ZWQnKTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGxvYWQgZGVmcyBpbml0aWFsaXNhdGlvbiBmYWlsZWQhJyk7XHJcbiAgICAgICAgfSk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZSA9IHtcclxuICAgIGdldCBhcGkgKCkge1xyXG4gICAgICAgIGlmKCF0aGlzLl9hcGkpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBpID0gbmV3IERpYWdyYW1BUEkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcGk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5nZXRSb290U1ZHID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdmcucm9vdDtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLnRyaWdnZXJVcGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudHJpZ2dlcignZGlhZ3JhbV91cGRhdGVkJywgdGhpcy5pZCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZU1nci5nZXROb2RlcyhmaWx0ZXIpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGV2dCwgYXJncykge1xyXG4gICAgLy9wZXJoYXBzIGFsc28gbGlzdGVuIHRvIGRpYWdyYW0gaW50ZXJuIGV2ZW50cyBub3Qgb25seSBkb20gZXZlbnRzLlxyXG4gICAgdGhpcy5zdmcucm9vdC50cmlnZ2VyKGV2dCwgYXJncyk7XHJcbiAgICB0aGlzLmV2ZW50LnRyaWdnZXIoZXZlbnQsIGFyZ3MpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldnQsIGhhbmRsZXIpIHtcclxuICAgIC8vcGVyaGFwcyBhbHNvIGxpc3RlbiB0byBkaWFncmFtIGludGVybiBldmVudHMgbm90IG9ubHkgZG9tIGV2ZW50cy5cclxuICAgIHRoaXMuc3ZnLnJvb3Qub24oZXZ0LCBoYW5kbGVyKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uKGV2dCwgaGFuZGxlcikge1xyXG4gICAgLy9wZXJoYXBzIGFsc28gbGlzdGVuIHRvIGRpYWdyYW0gaW50ZXJuIGV2ZW50cyBub3Qgb25seSBkb20gZXZlbnRzLlxyXG4gICAgdGhpcy5zdmcucm9vdC5vbmUoZXZ0LCBoYW5kbGVyKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdGhpcy5zdmcucm9vdC5vZmYoZXZ0KTtcclxufTtcclxuXHJcbi8qXHJcbiAqIEluaXRpYWxpemVzIFN0YWdlIE1vdXNlIGFuZCBLZXkgZXZlbnRzLlxyXG4gKi9cclxuRGlhZ3JhbS5wcm90b3R5cGUuaW5pdEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgLy8gRG91YmxlIGNsaWNrcyBvbiB0aGUgc3RhZ2UgYXJlYSB3aWxsIGNyZWF0ZSBuZXcgbm9kZXMgb2YgdGhlIHNlbGVjdGVkXHJcbiAgICAvLyB0ZW1wbGF0ZSB0eXBlLiBPbmx5IGlmIHdlIGRvIG5vdCBkYmNsaWNrIGFub3RoZXIgbm9kZSBpbiB0aGlzIGNhc2VcclxuICAgIC8vIHdlIHN0YXJ0IGEgdHJhbnNpdGlvbiBkcmFnLlxyXG4gICAgdGhpcy5vbignZGJsY2xpY2snLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZiAoIXRoYXQuc2VsZWN0aW9uTWdyLmlzRWxlbWVudEhvdmVyKCkpIHtcclxuICAgICAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKCdub2RlX2NyZWF0ZScsIHRoYXQudGVtcGxhdGVNZ3IuZ2V0U2VsZWN0ZWRUZW1wbGF0ZSgpLCBldnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhhdC5nZXRTdGFnZVBvc2l0aW9uKGV2dCk7XHJcblxyXG4gICAgICAgIGlmKGV2dC5jdHJsS2V5KSB7XHJcbiAgICAgICAgICAgIC8vTW92ZSBtYWluIHBhcnRcclxuICAgICAgICAgICAgdGhhdC5tYWluUGFydC5kcmFnZ2FibGUoe1xyXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2FsbC1zY3JvbGwnLFxyXG4gICAgICAgICAgICAgICAgZHJhZ01vdmU6IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmV2ZW50LnRyaWdnZXIoJ3ZpZXdwb3J0X3VwZGF0ZScsIHRoaXMucG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZHJhZ0VuZDogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmV2ZW50LnRyaWdnZXIoJ3ZpZXdwb3J0X3VwZGF0ZWQnLCB0aGlzLnBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlc3RyaWN0aW9uWDogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMueCgpICsgZHggPD0gMCk/IGR4IDogMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZXN0cmljdGlvblk6IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMueSgpICsgZHkgPD0gMCk/IGR5IDogMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXRTY2FsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGF0Lm1haW5QYXJ0LnRyaWdnZXIoJ21vdXNlZG93bicpOztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbk1nci5kcmFnU2VsZWN0aW9uU3RhcnQoZXZ0LCBzdGFydFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbignbW91c2V1cCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uTWdyLmRyYWdTZWxlY3Rpb25FbmQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGV2ZW50Lm9uKGRvY3VtZW50LCBcImRyYWdzdGFydFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUE9MWUxJTkVcIiB8fCBlLnRhcmdldC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUEFUSCcgfHwgZS50YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NJUkNMRScpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5wYXJ0ID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHJldHVybiB0aGlzLnN2Zy5wYXJ0KGlkKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmltcG9ydCA9IGZ1bmN0aW9uKHN2ZywgcGFydCwgcHJlcGVuZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3ZnLmltcG9ydChzdmcsIHBhcnQsIHByZXBlbmQpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUucGFydCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdmcucGFydChpZCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5pbml0RGVmcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHRoYXQudGVtcGxhdGVNZ3IuZ2V0VGVtcGxhdGUoJ2RlZnNfbWFya2VyJylcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRtcGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0bXBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wbC5jcmVhdGVOb2RlKHtkaWFncmFtSWQ6IHRoYXQuaWR9LCB0aGF0KS5pbml0KCdyb290JywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoJ0NvdWxkIGluaXRpYWxpemUgZGVmcyB0ZW1wbGF0ZSByZXN1bHQgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuY3JlYXRlS25vYk5vZGUgPSBmdW5jdGlvbihwLCBncm91cCwgY2ZnKSB7XHJcbiAgICByZXR1cm4gdGhpcy5rbm9iTWdyLmNyZWF0ZUtub2JOb2RlKHAsIGdyb3VwLCBjZmcpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUudW5pcXVlSWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBuZXdJZCA9IHRoaXMuY2hlY2tJZChEYXRlLm5vdygpICsgJycpO1xyXG4gICAgdGhpcy51bmlxdWVJZHMucHVzaChuZXdJZCk7XHJcbiAgICByZXR1cm4gbmV3SWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUHJldmVudCBkdXBsaWNhdGVzXHJcbiAqL1xyXG5EaWFncmFtLnByb3RvdHlwZS5jaGVja0lkID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHJldHVybiAoJC5pbkFycmF5KGlkLCB0aGlzLnVuaXF1ZUlkcykgPiAtMSkgPyB0aGlzLmNoZWNrSWQoJ3UnK2lkKSA6IGlkO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuZ2V0SG92ZXJOb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlTWdyLmhvdmVyTm9kZTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmlzTXVsdGlTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1nci5pc011bHRpU2VsZWN0aW9uKCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5pc1BvaW50ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiBvYmplY3QuaXNEZWZpbmVkKHZhbHVlLngpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUubmV3RGlhZ3JhbSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy9UT0RPOiB3ZSBzaG91bGQgdW5pZnkgdGhpcyB3aXRoIHRoZSBjb25zdHJ1Y3RvciBzdmcgY3JlYXRpb24gdGVjaG5pcXVlXHJcbiAgICB0aGlzLmxvYWREaWFncmFtKCc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB2ZXJzaW9uPVwiMS4xXCIgaWQ9XCJzdmdTdGFnZV9zdmdcIiB4bWxuczpkYWxhPVwiaHR0cDovL3d3dy5kYWxhLmNvbVwiIGhlaWdodD1cIjEwMCVcIiB3aWR0aD1cIjEwMCVcIj48L3N2Zz4nKTtcclxuICAgIHRoaXMuaW5pdERlZnMoKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmxvYWREaWFncmFtID0gZnVuY3Rpb24oc3ZnU3RyaW5nKSB7XHJcbiAgICAvL1RPRE86IHJhdGhlciBoYW5kbGUgdGhpcyBwZXIgZXZlbnRcclxuICAgIHRoaXMuc2VsZWN0aW9uTWdyLmNsZWFyKCk7XHJcbiAgICB0aGlzLm5vZGVNZ3IuY2xlYXIoKTtcclxuICAgIHRoaXMuJGNvbnRhaW5lci5lbXB0eSgpO1xyXG4gICAgdGhpcy5zdmcuc2V0Um9vdChkb20uaW1wb3J0U1ZHKHRoaXMuc3ZnLiRjb250YWluZXIsIHN2Z1N0cmluZykpO1xyXG4gICAgdGhpcy5hY3RpdmF0ZU5vZGVzKCk7XHJcbiAgICB0aGlzLmFjdGl2YXRlVHJhbnNpdGlvbnMoKTtcclxuICAgIHRoaXMuaW5pdEV2ZW50cygpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUudHJpZ2dlckRvY2tpbmdWaXNpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmtub2JNZ3IuaGlkZURvY2tpbmcpIHtcclxuICAgICAgICB0aGlzLmtub2JNZ3Iuc2hvd0tub2JzKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMua25vYk1nci5oaWRlS25vYnMoKTtcclxuICAgIH1cclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmFjdGl2YXRlTm9kZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICQoJy5lbGVtZW50X3Jvb3QnKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoYXQuYWN0aXZhdGVOb2RlKHRoaXMpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5hY3RpdmF0ZU5vZGUgPSBmdW5jdGlvbihkb21Ob2RlKSB7XHJcbiAgICB0aGlzLm5vZGVNZ3IuYWN0aXZhdGVCeURvbU5vZGUoZG9tTm9kZSk7XHJcbn07XHJcblxyXG4vL1RPRE86IG1vdmUgdG8gdHJhbnNpdGlvbm1nclxyXG5EaWFncmFtLnByb3RvdHlwZS5hY3RpdmF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25NZ3IuYWN0aXZhdGVUcmFuc2l0aW9uKCQoJy50cmFuc2l0aW9uJykpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbihub2RlSWQpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGVNZ3IuZ2V0Tm9kZShub2RlSWQpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkJ5SWQgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbk1nci5nZXROb2RlKGlkKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLnpvb21JbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zY2FsZSArPSAwLjE7XHJcbiAgICB0aGlzLnBhcnQoJ21haW4nKS5zY2FsZSh0aGlzLnNjYWxlKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLnpvb21PdXQgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKHRoaXMuc2NhbGUgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5zY2FsZSAtPSAwLjE7XHJcbiAgICAgICAgdGhpcy5wYXJ0KCdtYWluJykuc2NhbGUodGhpcy5zY2FsZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB0aGUgcmVsYXRpdmUgc3RhZ2UgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW5cclxuICogd2luZG93IHBvc2l0aW9uIGVpdGhlciBieSBwcm92aWRpbmcgdGhlIHggYW5kIHkgcG9zaXRpb24gb3IgYW4gZXZlbnRcclxuICogb2JqZWN0IHdpdGggZ2l2ZW4gcGFnZVggYW5kIHBhZ2VZIGF0dHJpYnV0ZXMgb3IgYW4gcG9pbnQgd2l0aCB4LHkgYXR0cmlidXRlcy5cclxuICpcclxuICogQHBhcmFtIHt0eXBlfSB4IGVpdGhlciBhbiBldmVudCBvYmplY3Qgd2l0aCBwYWdlWCwgcGFnZVkgb3IgYW4gcG9pbnQgd2l0aCB4LHlcclxuICogICAgICAgICAgICAgICAgIG9yIGp1c3QgdGhlIHBsYWluIHggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHt0eXBlfSB5IHRoZSB5IGNvb3JkaW5hdGUgaXMganVzdCBtYW5kYXRvcnkgaWYgdGhlIGZpc3JzdCBhcmcgaXMgdGhlIHBsYWluIHhcclxuICogQHJldHVybnMge0RpYWdyYW1fTDEzLkRpYWdyYW0ucHJvdG90eXBlLmdldFN0YWdlUG9zaXRpb24uRGlhZ3JhbUFub255bSQyfVxyXG4gKi9cclxuRGlhZ3JhbS5wcm90b3R5cGUuZ2V0U3RhZ2VQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoeC5wYWdlWCkpIHtcclxuICAgICAgICB5ID0geC5wYWdlWTtcclxuICAgICAgICB4ID0geC5wYWdlWDtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNEZWZpbmVkKHgueCkpIHtcclxuICAgICAgICB5ID0geC55O1xyXG4gICAgICAgIHggPSB4Lng7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0YWdlUG9zaXRpb24gPSB0aGlzLiRjb250YWluZXIub2Zmc2V0KCk7XHJcbiAgICB2YXIgdmlld1BvaW50QWxpZ25tZW50ID0gdGhpcy5tYWluUGFydC5wb3NpdGlvbigpO1xyXG5cclxuICAgIC8vVE9ETzogdmlld2JveCBhbGlnbmVtZW50ID9cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IHBhcnNlSW50KCh4ICAtIHN0YWdlUG9zaXRpb24ubGVmdCAtIHZpZXdQb2ludEFsaWdubWVudC54KSAvIHRoaXMuc2NhbGUpLFxyXG4gICAgICAgIHkgOiBwYXJzZUludCgoeSAgLSBzdGFnZVBvc2l0aW9uLnRvcCAtIHZpZXdQb2ludEFsaWdubWVudC55KSAvIHRoaXMuc2NhbGUpXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGdpdmVuIHBvc2l0aW9uIGlzIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiBhIGRpYWdyYW0gbm9kZS5cclxuICogVE9ETzogZWl0aGVyIHJldHVybiBhbGwgb3ZlcmxheSBub2RlcyBvciBqdXN0IHRoZSBvbmUgd2l0aCB0aGUgYmlnZ2VzdCBpbmRleC4uLlxyXG4gKiBAcGFyYW0ge3R5cGV9IHBvc2l0aW9uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuRGlhZ3JhbS5wcm90b3R5cGUuZ2V0Tm9kZUJ5UG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMubm9kZU1nci5ub2RlcywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheXMocG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuYXNTdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnN2Zy5hc1N0cmluZygpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUudW5kb0NvbW1hbmQgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuY29tbWFuZE1nci51bmRvKCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5yZWRvQ29tbWFuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jb21tYW5kTWdyLnJlZG8oKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLnJlZ2lzdGVyQ29tbWFuZCA9IGZ1bmN0aW9uKGNtZElkLCBjbWQpIHtcclxuICAgIHRoaXMuY29tbWFuZE1nci5yZWdpc3RlcihjbWRJZCwgY21kKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmV4ZWN1dGVDb21tYW5kID0gZnVuY3Rpb24oY21kSWQsIGRvQXJncywgdW5kb0FyZ3MpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNZ3IuZXhlYyhjbWRJZCwgZG9BcmdzLCB1bmRvQXJncyk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5hZGRDb21tYW5kID0gZnVuY3Rpb24oY21kSWQsIGRvQXJncywgdW5kb0FyZ3MpIHtcclxuICAgIHRoaXMuY29tbWFuZE1nci5hZGQoY21kSWQsIGRvQXJncywgdW5kb0FyZ3MpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaWFncmFtO1xyXG5cclxuIiwiLyoqXHJcbiAqIFRoaXMgdXRpbGl0eSBtb2R1bGUgcHJvdmllcyBidWlsZC1pbiBkb2NraW5nIHRlY2huaXF1ZXMgZm9yIHRyYW5zaXRpb25zIGFuZCBvdGhlclxyXG4gKiBkb2NrYWJsZSBlbGVtZW50cy4gVGhlIGRvY2tpbmcgdHlwZSBjYW4gYmUgY29uZmlndXJlZCB3aXRoaW4gdGhlIHRlbXBsYXRlXHJcbiAqIHdpdGggdGhlIGNvbmZpZyBrZXkgXCJkb2NraW5nVHlwZVwiLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKiAgPGNvbmZpZz5cclxuICogICAgICB7XHJcbiAqICAgICAgICAgIFwibm9kZUlEXCIgOiBcImVlcl9lbnRpdHlEZWZhdWx0XCIsXHJcbiAqICAgICAgICAgIFwiZG9ja2luZ1wiIDoge3R5cGU6ICdSRUNUJywgb3JpZW50YXRpb246J2NlbnRlcicsIC4uLn1cclxuICogICAgICAgICAgLi4uXHJcbiAqICAgICAgfVxyXG4gKiA8L2NvbmZpZz5cclxuICovXHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcbnZhciBtYXRoID0gdXRpbC5tYXRoO1xyXG5cclxudmFyIGNoZWNrT3JpZW50YXRpb25Cb3VuZGFyeSA9IGZ1bmN0aW9uKG5vZGUsIHApIHtcclxuICAgIHZhciBkb2NraW5nVHlwZSA9IChub2RlLmNvbmZpZy5kb2NraW5nICYmIG5vZGUuY29uZmlnLmRvY2tpbmcudHlwZSkgPyBub2RlLmNvbmZpZy5kb2NraW5nLnR5cGUgOiAnUkVDVCc7XHJcbiAgICBzd2l0Y2gobm9kZS5jb25maWcuZG9ja2luZy50eXBlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlICdDRU5URVInOlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgY2FzZSAnQ0lSQ0xFJzpcclxuICAgICAgICAgICAgcmV0dXJuIENJUkNMRV9CT1VOREFSWS5jYWxsKG5vZGUsIHApO1xyXG4gICAgICAgIGNhc2UgJ0VMTElQU0UnOlxyXG4gICAgICAgICAgICByZXR1cm4gRUxMSVBTRV9CT1VOREFSWS5jYWxsKG5vZGUsIHApO1xyXG4gICAgICAgIGNhc2UgJ1NRVUFSRSc6XHJcbiAgICAgICAgY2FzZSAnUkVDVCc6XHJcbiAgICAgICAgICAgIHJldHVybiBSRUNUX0JPVU5EQVJZLmNhbGwobm9kZSwgcCk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxudmFyIGNhbGN1bGF0ZURvY2tpbmdQb3NpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIG9yaWVudGF0aW9uT3V0LCBvcmllbnRhdGlvbkluKSB7XHJcbiAgICB2YXIgZG9ja2luZ1R5cGUgPSAobm9kZS5jb25maWcuZG9ja2luZyAmJiBub2RlLmNvbmZpZy5kb2NraW5nLnR5cGUpID8gbm9kZS5jb25maWcuZG9ja2luZy50eXBlIDogJ1JFQ1QnO1xyXG4gICAgc3dpdGNoKG5vZGUuY29uZmlnLmRvY2tpbmcudHlwZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgY2FzZSAnU0lNUExFJzpcclxuICAgICAgICAgICAgcmV0dXJuIFNJTVBMRS5jYWxsKG5vZGUsIG9yaWVudGF0aW9uT3V0LCBvcmllbnRhdGlvbkluKTtcclxuICAgICAgICBjYXNlICdDRU5URVInOlxyXG4gICAgICAgICAgICByZXR1cm4gQ0VOVEVSLmNhbGwobm9kZSwgb3JpZW50YXRpb25PdXQsIG9yaWVudGF0aW9uSW4pO1xyXG4gICAgICAgIGNhc2UgJ0NJUkNMRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBDSVJDTEUuY2FsbChub2RlLCBvcmllbnRhdGlvbk91dCwgb3JpZW50YXRpb25Jbik7XHJcbiAgICAgICAgY2FzZSAnRUxMSVBTRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBFTExJUFNFLmNhbGwobm9kZSwgb3JpZW50YXRpb25PdXQsIG9yaWVudGF0aW9uSW4pO1xyXG4gICAgICAgIGNhc2UgJ1NRVUFSRSc6XHJcbiAgICAgICAgY2FzZSAnUkVDVCc6XHJcbiAgICAgICAgICAgIHJldHVybiBSRUNULmNhbGwobm9kZSxvcmllbnRhdGlvbk91dCwgb3JpZW50YXRpb25Jbik7XHJcbiAgICAgICAgY2FzZSAnRlJFRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBGUkVFLmNhbGwobm9kZSxvcmllbnRhdGlvbk91dCwgb3JpZW50YXRpb25Jbik7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIENFTlRFUi5jYWxsKG5vZGUsIG9yaWVudGF0aW9uT3V0LCBvcmllbnRhdGlvbkluKTtcclxuXHJcbiAgICB9O1xyXG59O1xyXG5cclxudmFyIEZSRUUgPSBmdW5jdGlvbihwb3NpdGlvbiAsIG9yaWVudGF0aW9uSW4pIHtcclxuICAgIHJldHVybiBvcmllbnRhdGlvbkluO1xyXG59O1xyXG5cclxudmFyIEVMTElQU0UgPSBmdW5jdGlvbihwb3NpdGlvbiAsIG9yaWVudGF0aW9uSW4pIHtcclxuICAgIHZhciByeCA9IHRoaXMud2lkdGgoKSAvIDI7XHJcbiAgICB2YXIgcnkgPSB0aGlzLmhlaWdodCgpIC8gMjtcclxuICAgIHZhciBlbGxpcHNlID0gbmV3IG1hdGguRWxsaXBzZSh0aGlzLmdldENlbnRlcigpLCByeCwgcnkpO1xyXG4gICAgdmFyIHJlc3VsdCA9IGVsbGlwc2UuY2FsY0xpbmVJbnRlcmNlcHQocG9zaXRpb24sIG9yaWVudGF0aW9uSW4pO1xyXG5cclxuICAgIHJldHVybiAocmVzdWx0Lmxlbmd0aCA+IDApP3Jlc3VsdFswXTpvcmllbnRhdGlvbkluO1xyXG5cclxufTtcclxuXHJcbnZhciBFTExJUFNFX0JPVU5EQVJZID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHZhciByeCA9IHRoaXMud2lkdGgoKSAvIDI7XHJcbiAgICB2YXIgcnkgPSB0aGlzLmhlaWdodCgpIC8gMjtcclxuICAgIHJldHVybiBuZXcgbWF0aC5FbGxpcHNlKHRoaXMuZ2V0Q2VudGVyKCksIHJ4LCByeSkub3ZlcmxheXMocG9zaXRpb24pO1xyXG59O1xyXG5cclxudmFyIENJUkNMRSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBvcmllbnRhdGlvbkluKSB7XHJcbiAgICAvL05vdGUgdGhlIHN0cm9rZSBpcyBub3QgaW5jbHVkZWQgaW4gc29tZSBicm93c2Vycy4uLlxyXG4gICAgdmFyIHJhZGl1cyA9IHRoaXMud2lkdGgoKSAvIDI7XHJcbiAgICB2YXIgY2lyY2xlID0gbmV3IG1hdGguQ2lyY2xlKHRoaXMuZ2V0Q2VudGVyKCksIHJhZGl1cyk7XHJcbiAgICB2YXIgcmVzdWx0ID0gY2lyY2xlLmNhbGNMaW5lSW50ZXJjZXB0KHBvc2l0aW9uLCBvcmllbnRhdGlvbkluKTtcclxuXHJcbiAgICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPiAwKT9yZXN1bHRbMF06b3JpZW50YXRpb25JbjtcclxufTtcclxuXHJcbnZhciBDSVJDTEVfQk9VTkRBUlkgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICB2YXIgcmFkaXVzID0gdGhpcy53aWR0aCgpIC8gMjtcclxuICAgIHJldHVybiBuZXcgbWF0aC5DaXJjbGUodGhpcy5nZXRDZW50ZXIoKSwgcmFkaXVzKS5vdmVybGF5cyhwb3NpdGlvbik7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyB0ZWNobmlxdWUgdXNlcyB0aGUgY2VudGVyIG9mIHRoZSBub2RlIGFzIG9yaWVudGF0aW9uIHBvaW50IGFuZFxyXG4gKiByZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIG5vZGUgYm91bmRhcnkgYW5kIHRoZSBsaW5lIGZyb20gdGhlIG91dGVyXHJcbiAqIG9yaWVudGF0aW9uIHBvaW50IHRvIHRoZSBjZW50ZXIgb2YgdGhlIG5vZGUgYXMgcmVzdWx0LlxyXG4gKlxyXG4gKiBfX19fX19fX19fXHJcbiAqIHwgICAgICAgIHxcclxuICogfCAgICAgICAgfFxyXG4gKiB8ICAgIHggICB8PC0tLS0tLS0tLS0tLS0tLS14XHJcbiAqIHwgICAgICAgIHxcclxuICogfCAgICAgICAgfFxyXG4gKiAtLS0tLS0tLS0tXHJcbiAqXHJcbiAqIEBwYXJhbSB7dHlwZX0gcG9zaXRpb24gdGhlIG91dGVyIG9yaWVudGF0aW9uIHBvaW50XHJcbiAqIEByZXR1cm5zIHtEb2NraW5nVHlwZV9MMjBAY2FsbDtnZXRDZW50ZXJ9XHJcbiAqL1xyXG52YXIgUkVDVCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBvcmllbnRhdGlvbikge1xyXG4gICAgaWYodGhpcy5vdmVybGF5cyhwb3NpdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gb3JpZW50YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRyYW5zaXRpb24gPSBuZXcgbWF0aC5MaW5lKHBvc2l0aW9uLCBvcmllbnRhdGlvbik7XHJcblxyXG4gICAgaWYodGhpcy5pc1JpZ2h0T2YocG9zaXRpb24pKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zaXRpb24uY2FsY0ZYKHRoaXMueCgpKTtcclxuICAgICAgICBpZih0aGlzLm92ZXJsYXlzKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5pc0xlZnRPZihwb3NpdGlvbikpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNpdGlvbi5jYWxjRlgodGhpcy5nZXRSaWdodFgoKSk7XHJcbiAgICAgICAgaWYodGhpcy5vdmVybGF5cyhyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuaXNPdmVyKHBvc2l0aW9uKSkge1xyXG4gICAgICAgIHZhciBib3R0b21ZID0gdGhpcy5nZXRCb3R0b21ZKCk7XHJcblxyXG4gICAgICAgIGlmKHRyYW5zaXRpb24uaXNWZXJ0aWNhbCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7eDogb3JpZW50YXRpb24ueCwgeTogYm90dG9tWX07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihvcmllbnRhdGlvbi54ID09PSBwb3NpdGlvbi54KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7eDpvcmllbnRhdGlvbi54LCB5OmJvdHRvbVl9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYm90dG9tTGluZSA9IG5ldyBtYXRoLkxpbmUoe3g6MSx5OmJvdHRvbVl9LCB7eDoyLHk6Ym90dG9tWX0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2l0aW9uLmNhbGNMaW5lSW50ZXJjZXB0KGJvdHRvbUxpbmUpO1xyXG4gICAgICAgIC8vV2UgZXhwbGljaXRseSBzZXQgdGhpcyBiZWNhdXNlIG9mIHBvc3NpYmxlIGNhbGN1bGF0aW9uIGRldmlhdGlvbnNcclxuICAgICAgICByZXN1bHQueSA9IGJvdHRvbVk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYodHJhbnNpdGlvbi5pc0hvcml6b250YWwoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge3g6b3JpZW50YXRpb24ueCwgeTogdGhpcy55KCl9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYob3JpZW50YXRpb24ueCA9PT0gcG9zaXRpb24ueCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge3g6b3JpZW50YXRpb24ueCwgeTp0aGlzLnkoKX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0b3BMaW5lID0gbmV3IG1hdGguTGluZSh7eDoxLHk6dGhpcy55KCl9LCB7eDoyLHk6dGhpcy55KCl9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNpdGlvbi5jYWxjTGluZUludGVyY2VwdCh0b3BMaW5lKTtcclxuICAgICAgICAvL1dlIGV4cGxpY2l0bHkgc2V0IHRoaXMgYmVjYXVzZSBvZiBwb3NzaWJsZSBjYWxjdWxhdGlvbiBkZXZpYXRpb25zXHJcbiAgICAgICAgcmVzdWx0LnkgPSB0aGlzLnkoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIFJFQ1RfQk9VTkRBUlkgPSBmdW5jdGlvbihwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vdmVybFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgdGVjaG5pcXVlIGp1c3QgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBub2RlIGFzIHJlc3VsdC5cclxuICogTm90ZSB0aGF0IGxpbmUgd2lsbCBzdGFydCBvciBlbmQgd2l0aGluIHRoZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3R5cGV9IHBvc2l0aW9uXHJcbiAqIEByZXR1cm5zIHtEb2NraW5nVHlwZV9MMjAuQ0VOVEVSQGNhbGw7Z2V0Q2VudGVyfVxyXG4gKi9cclxudmFyIENFTlRFUiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXIoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHRlY2huaXF1ZSBwcm92aWRlcyA0IGRpZmZlcmVudCBkb2NraW5nIHBvaW50cyAodG9wL3JpZ2h0L2JvdHRvbS9sZWZ0KVxyXG4gKiBhbmQgcmV0dXJucyB0aGUgbW9zdCBzdWl0YWJsZSBkb2NraW5nIHBvaW50IGZvciB0aGUgZ2l2ZW4gb3V0ZXIgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7dHlwZX0gcG9zaXRpb25cclxuICovXHJcbnZhciBTSU1QTEUgPSBmdW5jdGlvbihwb3NpdGlvbiwgb3JpZW50YXRpb25Jbikge1xyXG4gICAgLy9UaGUgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBub2RlXHJcbiAgICBpZih0aGlzLm92ZXJsYXlzKHBvc2l0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBvcmllbnRhdGlvbkluO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuaXNMZWZ0T2YocG9zaXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5nZXRSaWdodFgoKSxcclxuICAgICAgICAgICAgeTogb3JpZW50YXRpb25Jbi55XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZih0aGlzLmlzUmlnaHRPZihwb3NpdGlvbikpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLnJvb3QueCgpLFxyXG4gICAgICAgICAgICB5OiBvcmllbnRhdGlvbkluLnlcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNPdmVyKHBvc2l0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IG9yaWVudGF0aW9uSW4ueCxcclxuICAgICAgICAgICAgeTogdGhpcy5nZXRCb3R0b21ZKClcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNVbmRlcihwb3NpdGlvbikpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBvcmllbnRhdGlvbkluLngsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucm9vdC55KClcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL1RoZSBwb3NpdGlvbiBpcyBub3Qgb3V0c2lkZSBvZiB0aGUgZWxlbWVudCBpdHNlbGZcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQ0VOVEVSIDogQ0VOVEVSICxcclxuICAgIFNJTVBMRSA6IFNJTVBMRSAsXHJcbiAgICBERUZBVUxUIDogQ0VOVEVSLFxyXG4gICAgY2FsY3VsYXRlRG9ja2luZ1Bvc2l0aW9uIDogY2FsY3VsYXRlRG9ja2luZ1Bvc2l0aW9uLFxyXG4gICAgY2hlY2tPcmllbnRhdGlvbkJvdW5kYXJ5IDogY2hlY2tPcmllbnRhdGlvbkJvdW5kYXJ5XHJcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvcmUvY29uZmlnJyk7XHJcblxyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBERUZfVE9MRVJBTkNFID0gMTA7XHJcblxyXG52YXIgQWxpZ25tZW50ID0gZnVuY3Rpb24odG9sZXJhbmNlLCBkaW1lbnNpb24pIHtcclxuICAgIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xyXG4gICAgdGhpcy50b2xlcmFuY2UgPSB0b2xlcmFuY2U7XHJcbiAgICB0aGlzLmFjdHVhbEQgPSAwO1xyXG59O1xyXG5cclxuQWxpZ25tZW50LnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKHNvdXJjZSwgc291cmNlSW5kZXhBcnIsdGFyZ2V0LCBkKSB7XHJcbiAgICBpZih0aGlzLmNoZWNrUmFuZ2Uoc291cmNlLCB0YXJnZXQsIGQpKSB7XHJcbiAgICAgICAgLy8gV2Uga2VlcCB0aGUgc291cmNlIHBvc2l0aW9uIGZvciB0aGUgcmVhbGlnbm1lbnRcclxuICAgICAgICBpZighdGhpcy53YXNBbGlnbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUluZGV4ID0gc291cmNlSW5kZXhBcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkIGJldHdlZW4gdGFyZ2V0IGFuZCBzb3VyY2UgYmVmb3JlIGRyYWdcclxuICAgICAgICB0aGlzLmQgPSAodGFyZ2V0W3RoaXMuZGltZW5zaW9uXSAtIChzb3VyY2VbdGhpcy5kaW1lbnNpb25dKSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgYWN0dWFsIGRyYWcgd2hpbGUgYmVlaW5nIGFsaWduZWQgZm9yIHRoZSByZWFsaWduXHJcbiAgICAgICAgdGhpcy5hY3R1YWxEICs9IGQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BbGlnbm1lbnQucHJvdG90eXBlLmNoZWNrUmFuZ2UgPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCwgZCkge1xyXG4gICAgLy9DaGVjayBpZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHNvdXJjZSAoYWZ0ZXIgZHJhZykgYW5kIHRhcmdldCBpcyB3aXRoaW4gdGhlIHRvbGVyYW5lXHJcbiAgICByZXR1cm4gdXRpbC5tYXRoLmNoZWNrUmFuZ2VEaWZmKHRhcmdldFt0aGlzLmRpbWVuc2lvbl0sIChzb3VyY2VbdGhpcy5kaW1lbnNpb25dICsgdGhpcy5hY3R1YWxEICsgZCksIHRoaXMudG9sZXJhbmNlKTtcclxufTtcclxuXHJcbkFsaWdubWVudC5wcm90b3R5cGUucmVhbGlnbiA9IGZ1bmN0aW9uKGFsaWduQ29uZmlnLCBkKSB7XHJcbiAgICAvLyBXZSBqdXN0IGhhdmUgdG8gY2FsY3VsYXRlIHRoZSByZWFsaWdubWVudCBpZiBhbiBhbGlnbm1lbnQgd2FzIHNldFxyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGlmKHRoaXMud2FzQWxpZ25lZCkge1xyXG4gICAgICAgIC8vTm93IHdlIHJldHJpZXZlIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBhbGlnbmVkIHNvdXJjZSBieSBvdXIgc291cmNlSW5kZXhcclxuICAgICAgICB2YXIgY3VycmVudFNvdXJjZVBvc2l0aW9uID0gYWxpZ25Db25maWdbdGhpcy5zb3VyY2VJbmRleFswXV0uc291cmNlW3RoaXMuc291cmNlSW5kZXhbMV1dO1xyXG4gICAgICAgIHJlc3VsdCA9ICh0aGlzLnNvdXJjZVt0aGlzLmRpbWVuc2lvbl0gKyB0aGlzLmFjdHVhbEQgKyBkKSAtIGN1cnJlbnRTb3VyY2VQb3NpdGlvblt0aGlzLmRpbWVuc2lvbl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IGQ7XHJcblxyXG4gICAgfVxyXG4gICAgdGhpcy5hY3R1YWxEID0gMDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5BbGlnbm1lbnQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oaW5pdGlhbGl6ZSkge1xyXG4gICAgaWYoIWluaXRpYWxpemUpIHtcclxuICAgICAgICB0aGlzLndhc0FsaWduZWQgPSB0aGlzLmlzQWxpZ25lZCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLndhc0FsaWduZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGUgdGhpcy50YXJnZXQ7XHJcbiAgICBkZWxldGUgdGhpcy5kO1xyXG59O1xyXG5cclxuQWxpZ25tZW50LnByb3RvdHlwZS5pc0FsaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBvYmplY3QuaXNEZWZpbmVkKHRoaXMudGFyZ2V0KTtcclxufTtcclxuXHJcbnZhciBEcmFnQWxpZ25tZW50ID0gZnVuY3Rpb24oZGlhZ3JhbSwgZ2V0Q29uZmlnLCB0b2xlcmFuY2UpIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IGRpYWdyYW07XHJcbiAgICB0aGlzLnRvbGVyYW5jZSA9IHRvbGVyYW5jZSB8fCBERUZfVE9MRVJBTkNFO1xyXG4gICAgdGhpcy5nZXRDb25maWcgPSBnZXRDb25maWc7XHJcbiAgICB0aGlzLmFsaWduWCA9IG5ldyBBbGlnbm1lbnQodGhpcy50b2xlcmFuY2UsICd4Jyk7XHJcbiAgICB0aGlzLmFsaWduWSA9IG5ldyBBbGlnbm1lbnQodGhpcy50b2xlcmFuY2UsICd5Jyk7XHJcbiAgICB0aGlzLmFjdHVhbERyYWcgPSB7eDowLCB5OjB9O1xyXG59O1xyXG5cclxuRHJhZ0FsaWdubWVudC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBpZihjb25maWcudmFsKCdkcmFnQWxpZ24nLCB0cnVlKSAmJiAhdGhpcy5kaWFncmFtLmlzTXVsdGlTZWxlY3Rpb24oKSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFsaWdubWVudHMgdG8gbm90aWZ5IGEgbmV3IHNlYXJjaCBsb29wXHJcbiAgICAgICAgdGhpcy5hbGlnblgucmVzZXQoKTtcclxuICAgICAgICB0aGlzLmFsaWduWS5yZXNldCgpO1xyXG5cclxuICAgICAgICB2YXIgYWxpZ25tZW50Q29uZmlnID0gdGhpcy5nZXRDb25maWcoZHgsIGR5KTtcclxuICAgICAgICBvYmplY3QuZWFjaChhbGlnbm1lbnRDb25maWcsIGZ1bmN0aW9uKGNvbmZpZ0luZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlQXJyID0gdmFsdWUuc291cmNlO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0QXJyID0gdmFsdWUudGFyZ2V0O1xyXG4gICAgICAgICAgICBvYmplY3QuZWFjaChzb3VyY2VBcnIsIGZ1bmN0aW9uKHNvdXJjZUluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jaGVja0FsaWdubWVudCh2YWx1ZSwgdGFyZ2V0QXJyLCBbY29uZmlnSW5kZXgsIHNvdXJjZUluZGV4XSwgZHgsIGR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGF0LmFsaWduWC5pc0FsaWduZWQoKSAmJiB0aGF0LmFsaWduWS5pc0FsaWduZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9Fc2NhcGUgdGhlIGVhY2ggbG9vcCBzaW5jZSB3ZSBmb3VuZCBib3RoIGFsaW5nbWVudHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBkeCA6ICh0aGlzLmFsaWduWC5pc0FsaWduZWQoKSkgPyB0aGlzLmFsaWduWC5kIDogdGhpcy5hbGlnblgucmVhbGlnbihhbGlnbm1lbnRDb25maWcsIGR4KSxcclxuICAgICAgICAgICAgZHkgOiAodGhpcy5hbGlnblkuaXNBbGlnbmVkKCkpID8gdGhpcy5hbGlnblkuZCA6IHRoaXMuYWxpZ25ZLnJlYWxpZ24oYWxpZ25tZW50Q29uZmlnLCBkeSlcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFsaWduWC5yZXNldCh0cnVlKTtcclxuICAgICAgICB0aGlzLmFsaWduWS5yZXNldCh0cnVlKTtcclxuICAgICAgICByZXN1bHQgPSB7ZHggOiBkeCwgZHkgOiBkeX07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbkRyYWdBbGlnbm1lbnQucHJvdG90eXBlLmNoZWNrQWxpZ25tZW50ID0gZnVuY3Rpb24oc291cmNlLCB0YXJnZXRzLCBzb3VyY2VJbmRleEFyciwgZHgsIGR5KSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBvYmplY3QuZWFjaCh0YXJnZXRzLCBmdW5jdGlvbihpbmRleCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgaWYoIXRoYXQuYWxpZ25YLmlzQWxpZ25lZCgpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYWxpZ25YLmNoZWNrKHNvdXJjZSxzb3VyY2VJbmRleEFyciwgdGFyZ2V0LCBkeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighdGhhdC5hbGlnblkuaXNBbGlnbmVkKCkpIHtcclxuICAgICAgICAgICAgdGhhdC5hbGlnblkuY2hlY2soc291cmNlLHNvdXJjZUluZGV4QXJyLCB0YXJnZXQsIGR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoYXQuYWxpZ25YLmlzQWxpZ25lZCgpICYmIHRoYXQuYWxpZ25ZLmlzQWxpZ25lZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9Fc2NhcGUgdGhlIGVhY2ggbG9vcCBzaW5jZSB3ZSBmb3VuZCBib3RoIGFsaW5nbWVudHNcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuRHJhZ0FsaWdubWVudC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuYWxpZ25YLnJlc2V0KHRydWUpO1xyXG4gICAgdGhpcy5hbGlnblkucmVzZXQodHJ1ZSk7XHJcbn07XHJcblxyXG5EcmFnQWxpZ25tZW50LnByb3RvdHlwZS5pc0FsaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmFsaWduWC5pc0FsaWduZWQgfHwgdGhpcy5hbGlnblkuaXNBbGlnbmVkKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERyYWdBbGlnbm1lbnQ7XHJcblxyXG4iLCJyZXF1aXJlKCcuLi9zdmcvZHJhZ2dhYmxlJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBEcmFnQWxpZ25tZW50ID0gcmVxdWlyZSgnLi9kcmFnQWxpZ25tZW50Jyk7XHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XHJcblxyXG52YXIgZG9tID0gdXRpbC5kb207XHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxuXHJcbnZhciBsYXN0RHJhZztcclxuXHJcbnZhciBEcmFnQ29udGV4dCA9IGZ1bmN0aW9uKG5vZGUsIGNmZykge1xyXG4gICAgdGhpcy5jZmcgPSBjZmcgfHwge307XHJcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgdGhpcy5keFN1bSA9IDA7XHJcbiAgICB0aGlzLmR5U3VtID0gMDtcclxufTtcclxuXHJcbkRyYWdDb250ZXh0LnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRoaXMuZHhTdW0gPSAwO1xyXG4gICAgdGhpcy5keVN1bSA9IDA7XHJcbiAgICB0aGlzLmZyb20gPSB0aGlzLm5vZGUucG9zaXRpb24oKTtcclxuICAgIGRlbGV0ZSB0aGlzLnRvO1xyXG4gICAgaWYodGhpcy5jZmcuZHJhZ1N0YXJ0KSB7XHJcbiAgICAgICAgdGhpcy5jZmcuZHJhZ1N0YXJ0KGV2dCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5EcmFnQ29udGV4dC5wcm90b3R5cGUud2FzTW92ZWQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHJldHVybiB0aGlzLmR4U3VtID4gMCB8fCB0aGlzLmR5U3VtID4gMDtcclxufTtcclxuXHJcbkRyYWdDb250ZXh0LnByb3RvdHlwZS5kcmFnTW92ZSA9IGZ1bmN0aW9uKGV2dCwgZHgsIGR5KSB7XHJcbiAgICB0aGlzLmR4U3VtICs9IGR4O1xyXG4gICAgdGhpcy5keVN1bSArPSBkeTtcclxuICAgIGlmKHRoaXMuY2ZnLmRyYWdNb3ZlKSB7XHJcbiAgICAgICAgdGhpcy5jZmcuZHJhZ01vdmUoZXZ0LCBkeCxkeSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5EcmFnQ29udGV4dC5wcm90b3R5cGUuZHJhZ0VuZCA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgaWYodGhpcy5keFN1bSAhPSAwIHx8IHRoaXMuZHlTdW0gIT0gMCkge1xyXG4gICAgICAgIHRoaXMudG8gPSB0aGlzLm5vZGUucG9zaXRpb24oKTtcclxuICAgICAgICBpZiAodGhpcy5jZmcuZHJhZ0VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNmZy5kcmFnRW5kKGV2dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuRHJhZ0NvbnRleHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGR4U3VtIDogdGhpcy5keFN1bSxcclxuICAgICAgICBkeVN1bSA6IHRoaXMuZHlTdW0sXHJcbiAgICAgICAgZnJvbSA6IHRoaXMuZnJvbSxcclxuICAgICAgICB0byA6IHRoaXMudG9cclxuICAgIH1cclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmRyYWdnYWJsZSA9IGZ1bmN0aW9uKGNmZykge1xyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5kcmFnQ29udGV4dCA9IG5ldyBEcmFnQ29udGV4dCh0aGlzLCBjZmcpO1xyXG5cclxuICAgIHZhciBkcmFnQ29uZmlnID0ge1xyXG4gICAgICAgIGN1cnNvcjogJ2FsbC1zY3JvbGwnLFxyXG4gICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHRoYXQuZHJhZ0NvbnRleHQuZHJhZ1N0YXJ0KGV2dCk7XHJcbiAgICAgICAgICAgIGxhc3REcmFnID0gdGhhdC5kcmFnQ29udGV4dDtcclxuICAgICAgICAgICAgdGhhdC5leGVjKCdkcmFnU3RhcnQnLCBbZXZ0XSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmFnTW92ZSA6IGZ1bmN0aW9uKGV2dCwgZHggLCBkeSkge1xyXG4gICAgICAgICAgICB0aGF0LmRyYWdDb250ZXh0LmRyYWdNb3ZlKGV2dCwgZHgsIGR5KTtcclxuICAgICAgICAgICAgLy90aGF0LmV4ZWMoJ2RyYWdNb3ZlJywgW2R4LGR5LCBldnRdKTtcclxuICAgICAgICAgICAgLy9XZSBza2lwIHRoZSB0aGUgZG9tRXZlbnQgZHJhZ01vdmUgaGVyZSBjYXVzZSBvZiBwZXJmb3JtYW5jZS4uLlxyXG4gICAgICAgICAgICB0aGF0LmV4ZWMoJ2RyYWdNb3ZlJywgW2R4LGR5LCBldnRdLCB0cnVlKTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmFnRW5kIDogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGlmKHRoYXQuZHJhZ0NvbnRleHQud2FzTW92ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5kcmFnQ29udGV4dC5kcmFnRW5kKGV2dCk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmV4ZWMoJ2RyYWdFbmQnLCBbZXZ0XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFNjYWxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuZGlhZ3JhbS5zY2FsZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc3RyaWN0aW9uWCA6IGNmZy5yZXN0cmljdGlvblgsXHJcbiAgICAgICAgcmVzdHJpY3Rpb25ZIDogY2ZnLnJlc3RyaWN0aW9uWSxcclxuICAgICAgICBjdXJzb3IgOiBjZmcuY3Vyc29yXHJcbiAgICB9O1xyXG5cclxuICAgIGlmKCFjZmcucHJldmVudEFsaWdubWVudCkge1xyXG4gICAgICAgIHZhciBkcmFnQWxpZ25tZW50O1xyXG4gICAgICAgIGlmKGNmZy5kcmFnQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIGRyYWdBbGlnbm1lbnQgPSAoY2ZnLmRyYWdBbGlnbm1lbnQgaW5zdGFuY2VvZiBEcmFnQWxpZ25tZW50KVxyXG4gICAgICAgICAgICAgICAgPyBjZmcuZHJhZ0FsaWdubWVudCA6IG5ldyBEcmFnQWxpZ25tZW50KHRoaXMuZGlhZ3JhbSwgY2ZnLmRyYWdBbGlnbm1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRyYWdBbGlnbm1lbnQgPSBuZXcgRHJhZ0FsaWdubWVudCh0aGF0LmRpYWdyYW0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxpZ25tZW50cyA9IHRoYXQuZ2V0VHJhbnNpdGlvbkFsaWdubWVudFRhcmdldHMoKTtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzLnB1c2goe3NvdXJjZTpbdGhhdC5nZXRDZW50ZXIoKV0sIHRhcmdldDp0aGF0LmdldE5vZGVBbGlnbm1lbnRUYXJnZXRzKCl9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxpZ25tZW50cztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcmFnQ29uZmlnLmRyYWdBbGlnbm1lbnQgPSBkcmFnQWxpZ25tZW50O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICB0aGlzLnJvb3QuZHJhZ2dhYmxlKGRyYWdDb25maWcsIHRoaXMuZ2V0RHJhZ0VsZW1lbnQoKSk7XHJcblxyXG4gICAgLy9TaW11bGF0ZXMgYW4gZHJhZyBzdGFydCBldmVudFxyXG4gICAgdGhpcy5pbml0RHJhZyA9IHRoaXMucm9vdC5pbml0RHJhZztcclxuXHJcbiAgICAvL0ZvciBtYW51YWwgZHJhZ2dpbmcgYSBzdmcgZWxlbWVudCB0aGUgdHJpZ2dlckV2ZW50IGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudCB3YXMgdHJpZ2dlcmVkIG1hbnVhbGx5XHJcbiAgICB0aGlzLnRyaWdnZXJEcmFnID0gdGhpcy5yb290LnRyaWdnZXJEcmFnO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkFsaWdubWVudFRhcmdldHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmFkZGl0aW9ucy50cmFuc2l0aW9uLmdldFRyYW5zaXRpb25BbGlnbm1lbnRUYXJnZXRzKCk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXROb2RlQWxpZ25tZW50VGFyZ2V0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIG9iamVjdC5lYWNoKHRoaXMuZGlhZ3JhbS5nZXROb2RlcygpLCBmdW5jdGlvbihrZXksIG5vZGUpIHtcclxuICAgICAgICBpZihub2RlLmlkICE9PSB0aGF0LmlkICYmICFub2RlLmtub2IpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5nZXRDZW50ZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmdldERyYWdFbGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvL1RPRE86IHdlIGhhdmUgdG8gdXNlIHRoZSBbY2xhc3N+PWJsYV0gc2VsZWN0b3Igc2luY2UgaWUsIGVkZ2UgKHdobyBlbHNlKSB0aHJvd2luZyBlcnJvcnMgZm9yIC5jbGFzcyBzZWxlY3RvcnMgaW4ganF1ZXJ5XHJcbiAgICAvL3RoaXMgbWF5IGNoYW5nZSBpbiBmb2xsb3dpbmcganFlcnkgdmVyc2lvbnMuXHJcbiAgICByZXR1cm4gZG9tLmZpbmRJbmNsdWRlU2VsZih0aGlzLmdldFJvb3RTVkcoKS5pbnN0YW5jZSgpLCAnW2NsYXNzfj0nK3RoaXMuZ2V0Tm9kZVNlbGVjdG9yKCdkcmFnUm91dGVfJykrJ10nKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgZ2V0TGFzdERyYWcgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbGFzdERyYWc7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBBYnN0cmFjdEVkaXRBZGRpdGlvbiA9IHJlcXVpcmUoJy4vYWJzdHJhY3RFZGl0QWRkaXRpb24nKTtcclxuXHJcbnZhciBlZGl0RnVuY3Rpb25zID0ge1xyXG4gICAgc3Ryb2tlIDogJ3N0cm9rZScsXHJcbiAgICAnc3Ryb2tlLXdpZHRoJyA6ICdzdHJva2VXaWR0aCcsXHJcbiAgICAnc3Ryb2tlLWRhc2gnIDogJ3N0cm9rZURhc2hUeXBlJyxcclxuICAgIGNvbG9yIDogJ2ZpbGwnLFxyXG4gICAgdGV4dCA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzLm5vZGUuZ2V0Tm9kZVNlbGVjdG9yKGVkaXRJdGVtLmJpbmQpKS50ZXh0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgJCh0aGlzLm5vZGUuZ2V0Tm9kZVNlbGVjdG9yKGVkaXRJdGVtLmJpbmQpKS50ZXh0KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGV4dGFyZWEgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dEFyZWFDb250ZW50KHRoaXMubm9kZS5nZXROb2RlU2VsZWN0b3IoZWRpdEl0ZW0uYmluZCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciAkZWRpdFNWR05vZGUgPSAkKHRoaXMubm9kZS5nZXROb2RlU2VsZWN0b3IoZWRpdEl0ZW0uYmluZCkpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFRleHRBcmVhQ29udGVudCgkZWRpdFNWR05vZGUsdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAndGV4dC1zaXplJyA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IHRoaXMubm9kZS5nZXRJbm5lclNWRyhlZGl0SXRlbS5iaW5kKS5zdHlsZSgnZm9udC1zaXplJyk7XHJcbiAgICAgICAgICAgIGlmKGRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLnN1YnN0cmluZygwLCBkZWZpbml0aW9uLmxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmdldElubmVyU1ZHKGVkaXRJdGVtLmJpbmQpLnN0eWxlKCdmb250LXNpemUnLCB2YWx1ZSsncHgnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgRWRpdE5vZGVBZGRpdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIEFic3RyYWN0RWRpdEFkZGl0aW9uLmNhbGwodGhpcywgbm9kZSwgZWRpdEZ1bmN0aW9ucywgbm9kZS5jb25maWcuZWRpdCk7XHJcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhFZGl0Tm9kZUFkZGl0aW9uLCBBYnN0cmFjdEVkaXRBZGRpdGlvbik7XHJcblxyXG5FZGl0Tm9kZUFkZGl0aW9uLnByb3RvdHlwZS5vblNldFZhbHVlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLm5vZGUuZXZlbnQudHJpZ2dlcignbm9kZV9lZGl0JywgdGhpcy5ub2RlKTtcclxufTtcclxuXHJcbkVkaXROb2RlQWRkaXRpb24ucmVxdWlyZUNvbmZpZyA9IHRydWU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVkaXROb2RlQWRkaXRpb247IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIEFic3RyYWN0RWRpdEFkZGl0aW9uID0gcmVxdWlyZSgnLi9hYnN0cmFjdEVkaXRBZGRpdGlvbicpO1xyXG5cclxudmFyIEVkaXRUcmFuc2l0aW9uQWRkaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICBBYnN0cmFjdEVkaXRBZGRpdGlvbi5jYWxsKHRoaXMsIHRyYW5zaXRpb24sIGVkaXRGdW5jdGlvbnMsIGNvbmZpZyk7XHJcbiAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhFZGl0VHJhbnNpdGlvbkFkZGl0aW9uLCBBYnN0cmFjdEVkaXRBZGRpdGlvbiApO1xyXG5cclxudmFyIGVkaXRGdW5jdGlvbnMgPSB7XHJcbiAgICBzdHJva2UgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5saW5lLnN0cm9rZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24oYmluZGluZywgdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uLmxpbmUuc3Ryb2tlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgJ3N0cm9rZS13aWR0aCcgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5zdHJva2VXaWR0aCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24oYmluZGluZywgdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uLnN0cm9rZVdpZHRoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgJ3N0cm9rZS1kYXNoJyA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLmxpbmUuc3Ryb2tlRGFzaFR5cGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGVkaXRJdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24ubGluZS5zdHJva2VEYXNoVHlwZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRleHQgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcy50cmFuc2l0aW9uLmdldFRyYW5zaXRpb25TZWxlY3RvcihlZGl0SXRlbS5iaW5kKSkudGV4dCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICQodGhpcy50cmFuc2l0aW9uLmdldFRyYW5zaXRpb25TZWxlY3RvcihlZGl0SXRlbS5iaW5kKSkudGV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRleHRhcmVhIDoge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKGVkaXRJdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRleHRBcmVhQ29udGVudCh0aGlzLnRyYW5zaXRpb24uZ2V0VHJhbnNpdGlvblNlbGVjdG9yKGVkaXRJdGVtLmJpbmQpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGVkaXRJdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgJGVkaXRTVkdOb2RlID0gJCh0aGlzLnRyYW5zaXRpb24uZ2V0VHJhbnNpdGlvblNlbGVjdG9yKGVkaXRJdGVtLmJpbmQpKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRUZXh0QXJlYUNvbnRlbnQoJGVkaXRTVkdOb2RlLHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgJ3RleHQtc2l6ZScgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSB0aGlzLnRyYW5zaXRpb24uZ2V0SW5uZXJTVkcoZWRpdEl0ZW0uYmluZCkuc3R5bGUoJ2ZvbnQtc2l6ZScpO1xyXG4gICAgICAgICAgICBpZihkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5zdWJzdHJpbmcoMCwgZGVmaW5pdGlvbi5sZW5ndGggLSAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbi5nZXRJbm5lclNWRyhlZGl0SXRlbS5iaW5kKS5zdHlsZSgnZm9udC1zaXplJywgdmFsdWUrJ3B4Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgICd0eXBlJyA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLnR5cGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGVkaXRJdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24udHlwZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbi5ncm91cC5kYWxhKCd0cmFuc2l0aW9uVHlwZScsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgJ3N0YXJ0TWFya2VyJyA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLnN0YXJ0TWFya2VyVmFsdWUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGVkaXRJdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24uc3RhcnRNYXJrZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAnZW5kTWFya2VyJyA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLmVuZE1hcmtlclZhbHVlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAnJztcclxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uLmVuZE1hcmtlcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGNvbmZpZyA9IHtcclxuICAgICd0ZXh0MCcgOiB7dHlwZSA6ICd0ZXh0JywgYmluZCA6ICd0ZXh0MCcsIHRyaWdnZXIgOiAndGV4dDAnfSxcclxuICAgICd0ZXh0MScgOiB7dHlwZSA6ICd0ZXh0JywgYmluZCA6ICd0ZXh0MScsIHRyaWdnZXIgOiAndGV4dDEnfSxcclxuICAgICd0ZXh0MicgOiB7dHlwZSA6ICd0ZXh0JywgYmluZCA6ICd0ZXh0MicsIHRyaWdnZXIgOiAndGV4dDInfSxcclxuICAgICd0ZXh0MycgOiB7dHlwZSA6ICd0ZXh0JywgYmluZCA6ICd0ZXh0MycsIHRyaWdnZXIgOiAndGV4dDMnfSxcclxuICAgICd0ZXh0NCcgOiB7dHlwZSA6ICd0ZXh0JywgYmluZCA6ICd0ZXh0NCcsIHRyaWdnZXIgOiAndGV4dDQnfSxcclxuICAgICd0ZXh0NScgOiB7dHlwZSA6ICd0ZXh0JywgYmluZCA6ICd0ZXh0NScsIHRyaWdnZXIgOiAndGV4dDUnfSxcclxuICAgICd0eXBlJyAgOiB7dHlwZSA6ICd0eXBlJywgYmluZCA6ICdsaW5lJ30sXHJcbiAgICAndHJhbnNpdGlvbicgOiB7IHR5cGUgOiAnc3Ryb2tlJywgYmluZCA6ICdsaW5lJ30sXHJcbiAgICAnc3RhcnRNYXJrZXInIDogeyB0eXBlIDogJ3N0YXJ0TWFya2VyJywgYmluZCA6ICdsaW5lJ30sXHJcbiAgICAnZW5kTWFya2VyJyA6IHsgdHlwZSA6ICdlbmRNYXJrZXInLCBiaW5kIDogJ2xpbmUnfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFZGl0VHJhbnNpdGlvbkFkZGl0aW9uOyIsInZhciBIZWxwZXIgPSBmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSBkaWFncmFtO1xyXG4gICAgdGhpcy5wb2ludHMgPSB7fTtcclxufTtcclxuXHJcbkhlbHBlci5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbihpZCwgcCwgY29sb3IsIHByZXZUZXh0KSB7XHJcbiAgICBjb2xvciA9IGNvbG9yIHx8ICdyZWQnO1xyXG4gICAgdmFyIHRleHQgPSBpZCsnKHg6JytwLnggKyAnIHk6JytwLnkrJyknO1xyXG4gICAgaWYoIXRoaXMucG9pbnRzW2lkXSkge1xyXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuZGlhZ3JhbS5zdmcuY2lyY2xlKHtcclxuICAgICAgICAgICAgcjoyLFxyXG4gICAgICAgICAgICBzdHlsZTonZmlsbDonK2NvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLmRpYWdyYW0uc3ZnLnRleHQodGV4dCk7XHJcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5kaWFncmFtLnN2Zy5nKHtpZDonaGVscGVyXycraWR9LCB0LCBwb2ludCk7XHJcbiAgICAgICAgdGhpcy5wb2ludHNbaWRdID0ge1xyXG4gICAgICAgICAgICBncm91cCA6IGdyb3VwLFxyXG4gICAgICAgICAgICB0ZXh0IDogdCxcclxuICAgICAgICAgICAgcG9pbnQgOiBwb2ludFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYocHJldlRleHQpIHtcclxuICAgICAgICAgICAgdC5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucG9pbnRzW2lkXS5wb2ludC5tb3ZlVG8ocCk7XHJcbiAgICB0aGlzLnBvaW50c1tpZF0udGV4dC4kKCkudGV4dCh0ZXh0KTtcclxuICAgIHRoaXMucG9pbnRzW2lkXS50ZXh0Lm1vdmVUbyhwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSGVscGVyO1xyXG4iLCJ2YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIFNWR1NoYXBlID0gcmVxdWlyZSgnLi4vc3ZnL2dlbmVyaWNTaGFwZScpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuaG92ZXJhYmxlID0gZnVuY3Rpb24oaGFuZGxlcikge1xyXG4gICAgaWYob2JqZWN0LmlzQm9vbGVhbihoYW5kbGVyKSkge1xyXG4gICAgICAgIHRoaXMuaG92ZXJGbGFnID0gaGFuZGxlcjtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuaG92ZXJGbGFnID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVyID0gaGFuZGxlciB8fCB7fTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICB0aGlzLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgaWYodGhhdC5ob3ZlckZsYWcpIHtcclxuICAgICAgICAgICAgdGhhdC5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcignZWxlbWVudF9ob3ZlckluJywgdGhhdCk7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmluKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmluLmFwcGx5KHRoYXQsIFtldnRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZih0aGF0LmhvdmVyRmxhZykge1xyXG4gICAgICAgICAgICB0aGF0LmhvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcignZWxlbWVudF9ob3Zlck91dCcsIHRoYXQpO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlci5vdXQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIub3V0LmFwcGx5KHRoYXQsIFtldnRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59OyIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG5cclxudmFyIEtub2JNYW5hZ2VyID0gZnVuY3Rpb24oZGlhZ3JhbSkge1xyXG4gICAgdGhpcy5rbm9icyA9IFtdO1xyXG4gICAgdGhpcy5oaWRlRG9ja2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5kaWFncmFtID0gZGlhZ3JhbTtcclxuICAgIHRoaXMudGVtcGxhdGVNZ3IgPSBkaWFncmFtLnRlbXBsYXRlTWdyO1xyXG4gICAgZGlhZ3JhbS5ldmVudC5saXN0ZW4oJ2tub2JfYWRkZWQnLCB0aGlzLmFkZEtub2JMaXN0ZW5lciwgdGhpcyk7XHJcbiAgICBkaWFncmFtLmV2ZW50Lmxpc3Rlbigna25vYl9kZWxldGUnLCB0aGlzLmRlbGV0ZUtub2JMaXN0ZW5lciwgdGhpcyk7XHJcbn07XHJcblxyXG5Lbm9iTWFuYWdlci5wcm90b3R5cGUuYWRkS25vYkxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBpZihldnQuZGF0YSkge1xyXG4gICAgICAgIHRoaXMua25vYnMucHVzaChldnQuZGF0YSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Lbm9iTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlS25vYk5vZGUgPSBmdW5jdGlvbihwLCBncm91cCwgY2ZnKSB7XHJcbiAgICB2YXIga25vYklkID0gdGhpcy5kaWFncmFtLnVuaXF1ZUlkKCk7XHJcbiAgICB2YXIgY29uZmlnID0gb2JqZWN0LmV4dGVuZCh7bm9kZV9pZDonZG9ja2luZ18nK2tub2JJZCwgeDogcC54LCB5OiBwLnksIHR5cGU6J2NpcmNsZSd9LCBjZmcpO1xyXG4gICAgdmFyIHRtcGxfaWQgPSAna25vYl8nK2NvbmZpZy50eXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB2YXIgbm9kZSA9IHRoaXMudGVtcGxhdGVNZ3IuZ2V0VGVtcGxhdGVTeW5jKHRtcGxfaWQpLmNyZWF0ZU5vZGUoY29uZmlnLCB0aGlzLmRpYWdyYW0pLmluaXQoKTtcclxuICAgIGlmKGdyb3VwKSB7XHJcbiAgICAgICAgdGhpcy5kaWFncmFtLnN2Zy5hZGRUb0dyb3VwKGdyb3VwLCBub2RlLnJvb3QpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Lbm9iTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlS25vYkxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGV2dC5kYXRhKSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMua25vYnMuaW5kZXhPZihldnQuZGF0YSk7XHJcbiAgICAgICAgaWYoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmtub2JzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2dC5kYXRhLnJlbW92ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuS25vYk1hbmFnZXIucHJvdG90eXBlLmhpZGVLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5oaWRlRG9ja2luZyA9IHRydWU7XHJcbiAgICB0aGlzLmV4ZWN1dGVPbkFsbEtub2JzKGZ1bmN0aW9uKGtub2IpIHtcclxuICAgICAgICBrbm9iLmhpZGUoKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuS25vYk1hbmFnZXIucHJvdG90eXBlLnNob3dLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5oaWRlRG9ja2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5leGVjdXRlT25BbGxLbm9icyhmdW5jdGlvbihrbm9iKSB7XHJcbiAgICAgICAga25vYi5zaG93KCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbktub2JNYW5hZ2VyLnByb3RvdHlwZS5leGVjdXRlT25BbGxLbm9icyA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMua25vYnMsIGZ1bmN0aW9uKGluZGV4LCBrbm9iKSB7XHJcbiAgICAgICAgZnVuYyhrbm9iKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtub2JNYW5hZ2VyO1xyXG4iLCJyZXF1aXJlKCcuL3RlbXBsYXRlJyk7XHJcbnJlcXVpcmUoJy4vbm9kZScpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxuXHJcbnZhciB0ZW1wbGF0ZU1nciA9IHJlcXVpcmUoJy4vdGVtcGxhdGVNYW5hZ2VyJyk7XHJcblxyXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcclxuICAgIGRvY2tpbmdUeXBlOiBcIkNFTlRFUlwiLFxyXG4gICAgZmlsbDogXCJzaWx2ZXJcIixcclxuICAgICdmaWxsLWFjdGl2ZSc6ICdncmVlbicsXHJcbiAgICAnZmlsbC1vcGFjaXR5JzogJzAuNScsXHJcbiAgICByYWRpdXM6IDUsXHJcbiAgICBzdHJva2U6ICcjN0M3QzdDJyxcclxuICAgICdzdHJva2Utd2lkdGgnOiAnMScsXHJcbiAgICAnY3NzQ2xhc3MnOiAna25vYicsXHJcbiAgICBwcmV2ZW50U2VsZWN0aW9uOiB0cnVlXHJcbn07XHJcblxyXG52YXIgY2lyY2xlQ29uZmlnID0gb2JqZWN0LmV4dGVuZCh7fSwgZGVmYXVsdENvbmZpZyxcclxuICAgIHtcclxuICAgICAgICByb290TmFtZTogJ2NpcmNsZScsXHJcbiAgICAgICAgc3ZnIDonPGNpcmNsZSBjeD1cIjBcIiBjeT1cIjBcIiByPVwie3JhZGl1c31cIiBpZD1cIntub2RlX2lkfVwiIGNsYXNzPVwie2Nzc0NsYXNzfVwiIHN0eWxlPVwic3Ryb2tlLXdpZHRoOntzdHJva2Utd2lkdGh9O3N0cm9rZTp7c3Ryb2tlfTtmaWxsOntmaWxsfTtmaWxsLW9wYWNpdHk6e2ZpbGwtb3BhY2l0eX07XCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKHt4fSB7eX0pXCI+PC9jaXJjbGU+J1xyXG4gICAgfSk7XHJcblxyXG50ZW1wbGF0ZU1nci5yZWdpc3RlclRlbXBsYXRlKCdrbm9iX2NpcmNsZScsIGNpcmNsZUNvbmZpZyk7XHJcblxyXG52YXIgcmVjdENvbmZpZyA9IG9iamVjdC5leHRlbmQoe30sIGRlZmF1bHRDb25maWcsXHJcbiAgICB7XHJcbiAgICAgICAgcm9vdE5hbWU6ICdyZWN0JyxcclxuICAgICAgICBzdmcgOic8cmVjdCB4PVwiMFwiIHk9XCIwXCIgaWQ9XCJ7bm9kZV9pZH1cIiBoZWlnaHQ9XCJ7c2l6ZX1cIiB3aWR0aD1cIntzaXplfVwiIGNsYXNzPVwie2Nzc0NsYXNzfVwiIHN0eWxlPVwic3Ryb2tlLXdpZHRoOntzdHJva2Utd2lkdGh9O3N0cm9rZTp7c3Ryb2tlfTtmaWxsOntmaWxsfTtmaWxsLW9wYWNpdHk6e2ZpbGwtb3BhY2l0eX07XCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKHt4fSB7eX0pXCI+PC9yZWN0PidcclxuICAgIH0pO1xyXG5cclxudGVtcGxhdGVNZ3IucmVnaXN0ZXJUZW1wbGF0ZSgna25vYl9yZWN0JywgcmVjdENvbmZpZyk7IiwiLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgbm9kZXMgb2YgYSBkaWFncmFtLiBFdmVyeSBub3RlIGhhcyBhIHVuaXF1ZSBJRCBhbmRcclxuICogYSB0ZW1wbGF0ZSBkZWZpbmluZyB0aGUgdHlwZSBvZiB0aGUgbm9kZS5cclxuICovXHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBkb2NraW5nVHlwZSA9IHJlcXVpcmUoJy4vZG9ja2luZycpO1xyXG52YXIgU1ZHID0gcmVxdWlyZSgnLi4vc3ZnL3N2ZycpO1xyXG52YXIgbm9kZUFkZGl0aW9ucyA9IHJlcXVpcmUoJy4vbm9kZUFkZGl0aW9ucycpO1xyXG5cclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcblxyXG4vKipcclxuICogVGhlIGNvbnN0cnVjdG9yIGRvZXMgbm90IHJlbmRlciBhIG5vZGUgdG8gdGhlIHN0YWdlLiBUbyByZW5kZXIgYSBub2RlXHJcbiAqIHRoZSBpbml0IG1ldGhvZCBoYXMgdG8gYmUgY2FsbGVkLlxyXG4gKi9cclxudmFyIE5vZGUgPSBmdW5jdGlvbih0bXBsLCBjb25maWcsIGRpYWdyYW0pIHtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgdGhpcy5kaWFncmFtID0gZGlhZ3JhbTtcclxuICAgIHRoaXMuaXNOb2RlID0gdHJ1ZTtcclxuICAgIHRoaXMuZXZlbnQgPSBkaWFncmFtLmV2ZW50O1xyXG4gICAgdGhpcy5pZCA9IGNvbmZpZy5ub2RlX2lkO1xyXG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRtcGw7XHJcbiAgICB0aGlzLnNlbGVjdGFibGUgPSBvYmplY3QuaXNEZWZpbmVkKHRoaXMuY29uZmlnLnNlbGVjdGFibGUpID8gdGhpcy5jb25maWcuc2VsZWN0YWJsZSA6IHRydWU7XHJcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIG5vZGUgdG8gdGhlIHN0YWdlIGFuZCBpbml0aWFsaXplcyBhbGwgZXZlbnQgaGFuZGxlcnNcclxuICogV2l0aCB0aGUgcGFydCBhcmd1bWVudCB3ZSBjYW4gaW1wb3J0IHRoZSBub2RlIHRvIGFub3RoZXIgc3ZnIHBhcnQgdGhhbiB0aGUgZGVmYXVsdCB3aGljaCBpcyB0aGUgbWFpbiBzdGFnZS5cclxuICogVGhpcyBpcyB1c2VkIGZvciBleGFtcGxlIGZvciB0aGUgZGVmcyAod2hpY2ggaXMgdGVjaG5pY2FsbHkgbm90IGEgcmVhbCBub2RlKVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Tm9kZV9MNy5Ob2RlLnByb3RvdHlwZX1cclxuICovXHJcbk5vZGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihwYXJ0LCBwcmVwZW5kKSB7XHJcbiAgICAvL0FERCBFbGVtZW50IHRvIHN0YWdlXHJcbiAgICB0aGlzLmRpYWdyYW0uaW1wb3J0KHRoaXMudGVtcGxhdGUuZ2V0U1ZHU3RyaW5nKHRoaXMuY29uZmlnKSwgcGFydCwgcHJlcGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZSgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZ2V0Q29ybmVycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHggPSB0aGlzLngoKTtcclxuICAgIHZhciB5ID0gdGhpcy55KCk7XHJcbiAgICB2YXIgYm90dG9teSA9IHRoaXMuZ2V0Qm90dG9tWSgpO1xyXG4gICAgdmFyIHJpZ2h0eCA9IHRoaXMuZ2V0UmlnaHRYKCk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHt4OngseTp5fSxcclxuICAgICAgICB7eDpyaWdodHgsIHk6eX0sXHJcbiAgICAgICAge3g6cmlnaHR4LCB5OmJvdHRvbXl9LFxyXG4gICAgICAgIHt4OngseTpib3R0b215fVxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBY3RpdmF0ZXMgdGhlIHRoZSBub2RlIGFuZCBoYW5kbGVyIGZ1bmN0aW9ucyBieSBtZWFucyBvZiB0aGUgZ2l2ZW4gY29uZmlnXHJcbiAqXHJcbiAqIEByZXR1cm5zIGl0c2VsZlxyXG4gKi9cclxuTm9kZS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihub2RlSUQpIHtcclxuXHJcbiAgICBpZihub2RlSUQpIHtcclxuICAgICAgICB0aGlzLmlkID0gdGhpcy5jb25maWcubm9kZV9pZCA9IG5vZGVJRDtcclxuICAgIH1cclxuXHJcbiAgICAvL05vdGU6IHRoZXJlIGFyZSBzb21lIHNwZWNpYWwgbm9kZSB0eXBlcyB3aXRob3V0IGFuIG5vZGVJZCBsaWtlIGRlZnMuXHJcbiAgICBpZih0aGlzLmlkKSB7XHJcbiAgICAgICAgLy9UaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBub2RlLCBpdHMgc3VwcG9zZWQgdG8gYmUgYSBncm91cCBub2RlIGluIG1vc3QgY2FzZXNcclxuICAgICAgICB0aGlzLnJvb3QgPSAkLnN2ZygnIycrdGhpcy5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgbm9kZUFkZGl0aW9ucy5pbml0KHRoaXMpO1xyXG5cclxuICAgIGlmKHRoaXMucm9vdCkge1xyXG4gICAgICAgIHRoaXMuaW5pdEV2ZW50RnVuY3Rpb25zKHRoaXMuY29uZmlnKTtcclxuICAgICAgICB0aGlzLnJvb3QuYXR0cih7J2RhbGE6dG1wbCcgOiB0aGlzLnRlbXBsYXRlLmlkfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5leGVjKCdhY3RpdmF0ZScpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5pbml0RXZlbnRGdW5jdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICBpZih0aGlzLnJvb3QuaG92ZXJhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5yb290LmhvdmVyYWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdGhhdC5leGVjKCdkYmNsaWNrJywgW2V2dF0sIHRydWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgaWYoIWV2dC5jdHJsS2V5ICYmIHRoYXQuaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB0aGF0LmV4ZWMoJ21vdXNlZG93bicsIFtldnRdLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYoIXRoYXQuc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5pc1Zpc2libGUoKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucm9vdC5oaWRlKCk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24ob3BhY2l0eSkge1xyXG4gICAgdGhpcy5yb290LnNob3cob3BhY2l0eSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC4kKCkuaW5kZXgoKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmZpcnN0Q2hpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vVE9ETzogdGhpcyBzaG91bGQgYmUgY2FjaGVkIHRvIHJlZHVjZSBkb20gY2FsbHMgIVxyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5maXJzdENoaWxkKCk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5tb3ZlVXAgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vV2Ugc3dpdGNoIFVQL0Rvd24gaGVyZSBiZWNhdXNlIHRoZSBmaXJzdCBub2RlIGluIHRoZSBkb20gdHJlZSBpcyB0aGVcclxuICAgIC8vbGFzdCBub2RlIChiYWNrKSBpbiB0aGUgc3ZnIHZpZXcuXHJcblxyXG4gICAgLy9UT0RPOiBhcyBjb21tYW5kIGV2ZW50ICFcclxuICAgIHRoaXMucm9vdC51cCgpO1xyXG4gICAgdGhpcy5leGVjKCdtb3ZlVXAnKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvL1dlIHN3aXRjaCBVUC9Eb3duIGhlcmUgYmVjYXVzZSB0aGUgZmlyc3Qgbm9kZSBpbiB0aGUgZG9tIHRyZWUgaXMgdGhlXHJcbiAgICAvL2xhc3Qgbm9kZSAoYmFjaykgaW4gdGhlIHN2ZyB2aWV3LlxyXG5cclxuICAgIC8vVE9ETzogYXMgY29tbWFuZCBldmVudCAhXHJcbiAgICB0aGlzLnJvb3QuZG93bigpO1xyXG4gICAgdGhpcy5leGVjKCdtb3ZlRG93bicpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmV4ZWMoJ3JlbW92ZScpO1xyXG4gICAgdGhpcy5yb290LnJlbW92ZSgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdGhpcy5yb290Lm1vdmVUbyh4LCB5KTtcclxuICAgIHRoaXMuZXhlYygnbW92ZVRvJyk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4IDogdGhpcy54KCksXHJcbiAgICAgICAgeSA6IHRoaXMueSgpXHJcbiAgICB9O1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZ2V0SW5uZXJTVkcgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIHJldHVybiAkLnFDYWNoZSgpLnN2Zyh0aGlzLmdldE5vZGVTZWxlY3RvcihwcmVmaXgpKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnVwZGF0ZUFkZGl0aW9ucyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHRoaXMuZXhlYygndXBkYXRlJyk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5hZGRPdXRnb2luZ1RyYW5zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkaXRpb25zLnRyYW5zaXRpb24uYWRkT3V0Z29pbmdUcmFuc2l0aW9uKHZhbHVlKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnJlbW92ZU91dGdvaW5nVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIHRoaXMuYWRkaXRpb25zLnRyYW5zaXRpb24ucmVtb3ZlT3V0Z29pbmdUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuYWRkSW5jb21pbmdUcmFuc2l0aW9uID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgdGhpcy5hZGRpdGlvbnMudHJhbnNpdGlvbi5hZGRJbmNvbWluZ1RyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5yZW1vdmVJbmNvbWluZ1RyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB0aGlzLmFkZGl0aW9ucy50cmFuc2l0aW9uLnJlbW92ZUluY29taW5nVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmdldFJvb3RTVkcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3Q7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5pbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZCh0aGlzLnJvb3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pbnN0YW5jZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuc2VsZWN0b3IgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIGlmKG9iamVjdC5pc0FycmF5KHByZWZpeCkpIHtcclxuICAgICAgICB2YXIgc3RyaW5nU2VsZWN0b3IgPSBbXTtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgb2JqZWN0LmVhY2gocHJlZml4LCBmdW5jdGlvbihpbmRleCwgdmFsKSB7XHJcbiAgICAgICAgICAgIHN0cmluZ1NlbGVjdG9yLnB1c2godGhhdC5zZWxlY3Rvcih2YWwpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc3RyaW5nU2VsZWN0b3Iuam9pbignLCAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZVNlbGVjdG9yKHByZWZpeCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXROb2RlU2VsZWN0b3IgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuXHJcbiAgICBpZighdXRpbC5zdHJpbmcuc3RhcnRzV2l0aChwcmVmaXgsICcjJykgJiYgIXV0aWwuc3RyaW5nLnN0YXJ0c1dpdGgocHJlZml4LCAnLicpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gJyMnK3ByZWZpeDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcHJlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1dGlsLnN0cmluZy5lbmRzV2l0aChwcmVmaXgsICdfJylcclxuICAgICAgICA/IHJlc3VsdCArIHRoaXMuaWRcclxuICAgICAgICA6IHJlc3VsdCArICdfJyArIHRoaXMuaWQ7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRSb290Tm9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5nZXRSb290Tm9kZSgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIHByZXZEb21FdmVudCkge1xyXG4gICAgYXJncyA9IGFyZ3MgfHwgdGhpcztcclxuICAgIHRoaXMuZXhlY3V0ZUFkZGl0aW9uKGZ1bmMsIGFyZ3MpO1xyXG4gICAgaWYodGhpcy5yb290ICYmICFwcmV2RG9tRXZlbnQpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoZnVuYywgYXJncyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5leGVjdXRlQWRkaXRpb24gPSBmdW5jdGlvbihmdW5jLCBhcmdzKSB7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLmFkZGl0aW9ucywgZnVuY3Rpb24oa2V5LCBhZGRpdGlvbikge1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQoYWRkaXRpb24pICYmIG9iamVjdC5pc0Z1bmN0aW9uKGFkZGl0aW9uW2Z1bmNdKSkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbltmdW5jXS5hcHBseShhZGRpdGlvbiwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzaGlmdGVkKSB7XHJcbiAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgIHRoaXMuZXhlYygnc2VsZWN0JywgW3NoaWZ0ZWRdKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmV4ZWMoJ2Rlc2VsZWN0Jyk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbihldnQsIGhhbmRsZXIpIHtcclxuICAgIHRoaXMucm9vdC4kKCkub25lKGV2dCwgaGFuZGxlcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZ0LCBoYW5kbGVyKSB7XHJcbiAgICB0aGlzLnJvb3QuJCgpLm9uKGV2dCwgaGFuZGxlcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihldnQsIGFyZ3MpIHtcclxuICAgIHRoaXMucm9vdC4kKCkudHJpZ2dlcihldnQsIGFyZ3MpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldnQsIGhhbmRsZXIpIHtcclxuICAgIHRoaXMucm9vdC4kKCkub2ZmKGV2dCwgaGFuZGxlcik7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5leHRyYWN0Tm9kZUlkID0gZnVuY3Rpb24ocmF3SWQpIHtcclxuICAgIHZhciBzcGxpdHRlZCA9IHJhd0lkLnNwbGl0KCdfJyk7XHJcbiAgICByZXR1cm4gc3BsaXR0ZWRbc3BsaXR0ZWQubGVuZ3RoIC0gMV07XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS54ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290LngoKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QueSgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290LmhlaWdodCgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3Qud2lkdGgoKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmdldFJpZ2h0WCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5nZXRSaWdodFgoKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmdldEJvdHRvbVkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0Qm90dG9tWSgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuaXNMZWZ0T2YgPSBmdW5jdGlvbihtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gbW91c2VQb3NpdGlvbi54ID4gKHRoaXMuZ2V0UmlnaHRYKCkpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuaXNSaWdodE9mID0gZnVuY3Rpb24obW91c2VQb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIG1vdXNlUG9zaXRpb24ueCA8ICh0aGlzLngoKSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5pc092ZXIgPSBmdW5jdGlvbihtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gbW91c2VQb3NpdGlvbi55ID4gKHRoaXMuZ2V0Qm90dG9tWSgpKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLm92ZXJsYXlzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290Lm92ZXJsYXlzLmFwcGx5KHRoaXMucm9vdCwgYXJndW1lbnRzKTtcclxuICAgIC8vcmV0dXJuIHRoaXMucm9vdC5vdmVybGF5Q2hlY2sobW91c2VQb3NpdGlvbik7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5pc1VuZGVyID0gZnVuY3Rpb24obW91c2VQb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIG1vdXNlUG9zaXRpb24ueSA8ICh0aGlzLmdldEJvdHRvbVkoKSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0Q2VudGVyKCk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRSZWxhdGl2ZUNlbnRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiB0aGlzLndpZHRoKCkgLyAyLFxyXG4gICAgICAgIHk6IHRoaXMuaGVpZ2h0KCkgLyAyXHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRSZWxhdGl2ZVBvc2l0aW9uID0gZnVuY3Rpb24ocGFnZVgscGFnZVkpIHtcclxuICAgIHZhciBwID0gdXRpbC5tYXRoLmdldFBvaW50KHBhZ2VYLHBhZ2VZKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogcC54IC0gdGhpcy54KCksXHJcbiAgICAgICAgeTogcC55IC0gdGhpcy55KClcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB0aGUgbG9jYXRpb24gb2YgYSBnaXZlbiBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgbm9kZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKiBAcGFyYW0gcG9zaXRpb25cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5Ob2RlLnByb3RvdHlwZS5nZXRSZWxhdGl2ZUxvY2F0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0UmVsYXRpdmVMb2NhdGlvbihwb3NpdGlvbik7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XHJcbiAgICBpZighb2JqZWN0LmlzRGVmaW5lZChyZWxhdGl2ZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeCA6IHRoaXMueCgpICsgcmVsYXRpdmUueCxcclxuICAgICAgICAgICAgeSA6IHRoaXMueSgpICsgcmVsYXRpdmUueVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7IiwidmFyIGFkZGl0aW9ucyA9IHJlcXVpcmUoJy4vYWRkaXRpb25zJyk7XHJcblxyXG4vL0luaXQgZGVmYXVsdCBhZGRpdGlvbnNcclxuYWRkaXRpb25zLnJlZ2lzdGVyTm9kZUFkZGl0aW9uKCdyZXNpemUnLCByZXF1aXJlKCcuL3Jlc2l6ZUFkZGl0aW9uJykpO1xyXG5hZGRpdGlvbnMucmVnaXN0ZXJOb2RlQWRkaXRpb24oJ2VkaXQnLCByZXF1aXJlKCcuL2VkaXROb2RlQWRkaXRpb24nKSk7XHJcbmFkZGl0aW9ucy5yZWdpc3Rlck5vZGVBZGRpdGlvbigndHJhbnNpdGlvbicsIHJlcXVpcmUoJy4vdHJhbnNpdGlvbkFkZGl0aW9uJykpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBpbml0IDogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIGFkZGl0aW9ucy5pbml0Tm9kZUFkZGl0aW9uKCd0cmFuc2l0aW9uJywgbm9kZSk7XHJcbiAgICAgICAgYWRkaXRpb25zLmluaXROb2RlQWRkaXRpb24oJ2VkaXQnLCBub2RlKTtcclxuICAgICAgICBhZGRpdGlvbnMuaW5pdE5vZGVBZGRpdGlvbigncmVzaXplJywgbm9kZSk7XHJcbiAgICB9XHJcbn0iLCJyZXF1aXJlKCcuL2RyYWdnYWJsZScpO1xyXG5yZXF1aXJlKCcuL2hvdmVyYWJsZScpO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIHhtbCA9IHJlcXVpcmUoJy4uL3V0aWwveG1sJyk7XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcclxudmFyIEFic3RyYWN0TWFuYWdlciA9IHJlcXVpcmUoJy4vYWJzdHJhY3RNYW5hZ2VyJyk7XHJcblxyXG52YXIgY2FjaGUgPSByZXF1aXJlKCcuLi9jb3JlL2NhY2hlJyk7XHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIGRvbSA9IHV0aWwuZG9tO1xyXG5cclxudmFyIEVWVF9DUkVBVEUgPSAnbm9kZV9jcmVhdGUnO1xyXG52YXIgRVZUX0RFTEVURSA9ICdub2RlX2RlbGV0ZSc7XHJcbnZhciBFVlRfQ09QWSA9ICdub2RlX2NvcHknO1xyXG5cclxudmFyIEVWVF9SRVNJWkVEID0gJ25vZGVfcmVzaXplZCc7XHJcbnZhciBFVlRfQURERUQgPSAnbm9kZV9hZGRlZCc7XHJcbnZhciBFVlRfU0VMRUNURUQgPSAnbm9kZV9zZWxlY3RlZCc7XHJcbnZhciBFVlRfREVTRUxFQ1RFRCA9ICdub2RlX2Rlc2VsZWN0ZWQnO1xyXG52YXIgRVZUX1JFTU9WRUQgPSAnbm9kZV9yZW1vdmVkJztcclxuXHJcbnZhciBDTURfQUREID0gJ25vZGVfYWRkJztcclxudmFyIENNRF9ERUxFVEUgPSAnbm9kZV9kZWxldGUnO1xyXG52YXIgQ01EX0NPUFkgPSAnbm9kZV9jb3B5JztcclxudmFyIENNRF9EUk9QID0gJ25vZGVfZHJvcCc7XHJcbnZhciBDTURfUkVTSVpFID0gJ25vZGVfcmVzaXplJztcclxudmFyIENNRF9FRElUID0gJ25vZGVfZWRpdCc7XHJcblxyXG52YXIgTm9kZU1hbmFnZXIgPSBmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICAvLyBDb250YWlucyBhbGwgbm9kZXMgYWRkZWQgdG8gdGhlIGRpYWdyYW1cclxuICAgIEFic3RyYWN0TWFuYWdlci5jYWxsKHRoaXMsIGRpYWdyYW0pO1xyXG4gICAgdGhpcy5ub2RlcyA9IHt9O1xyXG5cclxuICAgIHRoaXMuc2VsZWN0aW9uTWdyID0gZGlhZ3JhbS5zZWxlY3Rpb25NZ3I7XHJcbiAgICB0aGlzLnRlbXBsYXRlTWdyID0gZGlhZ3JhbS50ZW1wbGF0ZU1ncjtcclxuXHJcbiAgICB0aGlzLmxpc3RlbihFVlRfQ1JFQVRFLCB0aGlzLmNyZWF0ZU5vZGVMaXN0ZW5lcik7XHJcbiAgICB0aGlzLmxpc3RlbihFVlRfREVMRVRFLCB0aGlzLmRlbGV0ZU5vZGVMaXN0ZW5lcik7XHJcbiAgICB0aGlzLmxpc3RlbihFVlRfQ09QWSwgdGhpcy5jb3B5Tm9kZUxpc3RlbmVyKTtcclxuICAgIHRoaXMubGlzdGVuKEVWVF9SRVNJWkVELCB0aGlzLnJlc2l6ZU5vZGVMaXN0ZW5lcik7XHJcblxyXG4gICAgdGhpcy5jb21tYW5kKENNRF9BREQsIHRoaXMuY3JlYXRlTm9kZSwgdGhpcy5kZWxldGVOb2RlKTtcclxuICAgIHRoaXMuY29tbWFuZChDTURfREVMRVRFLCB0aGlzLmRlbGV0ZU5vZGUsIHRoaXMuaW1wb3J0Tm9kZSk7XHJcbiAgICB0aGlzLmNvbW1hbmQoQ01EX0NPUFksIHRoaXMuaW1wb3J0Tm9kZSwgdGhpcy5kZWxldGVOb2RlKTtcclxuICAgIHRoaXMuY29tbWFuZChDTURfRFJPUCwgdGhpcy5tb3ZlTm9kZSwgdGhpcy5tb3ZlTm9kZSk7XHJcbiAgICB0aGlzLmNvbW1hbmQoQ01EX1JFU0laRSwgdGhpcy5yZXNpemVOb2RlLCB0aGlzLnJlc2l6ZU5vZGUpO1xyXG4gICAgdGhpcy5jb21tYW5kKENNRF9FRElULCB0aGlzLmVkaXROb2RlLCB0aGlzLnVuZG9FZGl0KTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoTm9kZU1hbmFnZXIsIEFic3RyYWN0TWFuYWdlcik7XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlTm9kZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBzdGFnZVBvc2l0aW9uID0gdGhpcy5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICB0aGlzLmNyZWF0ZU5vZGVDb21tYW5kKGV2dC5kYXRhLCBzdGFnZVBvc2l0aW9uKTtcclxuICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgIGV2ZW50LnRyaWdnZXIoJ2Vycm9yJywgJ0Vycm9yIG9jY3VyZWQgd2hpbGUgY3JlYXRpbmcgbm9kZSAhJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlTm9kZUNvbW1hbmQgPSBmdW5jdGlvbih0bXBsLCBjb25maWcpIHtcclxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICBpZighdG1wbCkge1xyXG4gICAgICAgIGV2ZW50LnRyaWdnZXIoJ3dhcm4nLCAnQ291bGQgbm90IGNyZWF0ZSBOb2RlOiBObyB0ZW1wbGF0ZSBzZWxlY3RlZCEnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnLm5vZGVfaWQgPSB0aGlzLmRpYWdyYW0udW5pcXVlSWQoKTtcclxuICAgIGNvbmZpZy5kaWFncmFtSWQgPSB0aGlzLmRpYWdyYW0uaWQ7XHJcbiAgICByZXR1cm4gdGhpcy5leGVjKENNRF9BREQsIFt0bXBsLCBjb25maWddLCBbY29uZmlnLm5vZGVfaWRdKTtcclxufTtcclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24odG1wbCwgY29uZmlnKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB2YXIgbm9kZSA9IHRtcGwuY3JlYXRlTm9kZShjb25maWcsIHRoaXMuZGlhZ3JhbSkuaW5pdCgpO1xyXG4gICAgaWYoIWNvbmZpZy5wcmV2ZW50RHJhZykge1xyXG4gICAgICAgIG5vZGUuZHJhZ2dhYmxlKCk7XHJcbiAgICAgICAgbm9kZS5vbignc2VsZWN0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZXZlbnQudHJpZ2dlcihFVlRfU0VMRUNURUQsIG5vZGUpO1xyXG4gICAgICAgIH0pLm9uKCdkZXNlbGVjdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LmV2ZW50LnRyaWdnZXIoRVZUX0RFU0VMRUNURUQsIG5vZGUpO1xyXG4gICAgICAgIH0pLm9uKCdyZW1vdmUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKEVWVF9SRU1PVkVELCBub2RlKTtcclxuICAgICAgICB9KS5vbignZWRpdCcsIGZ1bmN0aW9uKGV2dCwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhhdC5hZGRDbWQoQ01EX0VESVQsIFtub2RlLmlkLCBrZXksIHZhbHVlXSwgW25vZGUuaWQsIGtleSwgb2xkVmFsdWVdKTtcclxuICAgICAgICB9KS5vbignZHJhZ0VuZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvL1dlIGp1c3QgYWRkIHRoZSBjb21tYW5kIHNpbmNlIHdlIGRvbid0IHdhbnQgdG8gZXhlY3V0ZSB0aGUgZHJhZyB0d2ljZVxyXG4gICAgICAgICAgICB0aGF0LmFkZENtZChDTURfRFJPUCxcclxuICAgICAgICAgICAgICAgIFtub2RlLmlkLCBub2RlLmRyYWdDb250ZXh0LmR4U3VtLCBub2RlLmRyYWdDb250ZXh0LmR5U3VtXSxcclxuICAgICAgICAgICAgICAgIFtub2RlLmlkLCAoLTEgKiBub2RlLmRyYWdDb250ZXh0LmR4U3VtKSwgKC0xICogbm9kZS5kcmFnQ29udGV4dC5keVN1bSldKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRoaXMuYWRkTm9kZShub2RlKTtcclxuICAgIHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICB0aGlzLm5vZGVzW25vZGUuaWRdID0gbm9kZTtcclxuICAgIHRoaXMuZXZlbnQudHJpZ2dlcihFVlRfQURERUQsIG5vZGUpO1xyXG59O1xyXG5cclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZUJ5RG9tTm9kZSA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcclxuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tLmdldEF0dHJpYnV0ZXMoZG9tTm9kZSk7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIHRtcGwgPSB0aGF0LnRlbXBsYXRlTWdyLmdldFRlbXBsYXRlKGF0dHJpYnV0ZXNbJ2RhbGE6dG1wbCddKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodG1wbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGF0LmFjdGl2YXRlKGF0dHJpYnV0ZXNbJ2lkJ10sIHRtcGwpKTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZWxlbWVudElkLCB0bXBsKSB7XHJcbiAgICB2YXIgbm9kZSA9IHRtcGwuY3JlYXRlTm9kZSh7fSwgdGhpcy5kaWFncmFtKVxyXG4gICAgICAgIC5hY3RpdmF0ZShlbGVtZW50SWQpXHJcbiAgICAgICAgLmRyYWdnYWJsZSgpO1xyXG5cclxuICAgIHRoaXMuYWRkTm9kZShub2RlKTtcclxuICAgIHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZU5vZGVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZShldnQuZGF0YSk7XHJcbiAgICAgICAgaWYobm9kZS5rbm9iKSB7XHJcbiAgICAgICAgICAgIC8vQ01EIGlzIGhhbmRsZWQgYnkgdHJhbnNpdGlvbk1nclxyXG4gICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZihub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWMoQ01EX0RFTEVURSwgW25vZGUuaWRdLCBbdGhpcy5nZXROb2RlQXNTdHJpbmcobm9kZSldKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICBldmVudC50cmlnZ2VyKCdlcnJvcicsICdDb3VsZCBub3QgZGVsZXRlIG5vZGUoJytub2RlLmlkKycpJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIG5vZGUgPSB0aGlzLmdldE5vZGUobm9kZSk7XHJcbiAgICBpZihub2RlKSB7XHJcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tub2RlLmlkXTtcclxuICAgICAgICBjYWNoZS5jbGVhckJ5U3VmZml4KG5vZGUuaWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2RlbGV0ZSBub2RlIHdhcyBjYWxsZWQgZm9yIHVua25vd24gbm9kZScpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmltcG9ydE5vZGUgPSBmdW5jdGlvbihub2RlU3RyLCBjZmcpIHtcclxuICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuXHJcbiAgICAvL0lmIHNldCB3ZSByZXBsYWNlIHRoZSBvbGQgbm9kZSBpZCB3aXRoIGEgbmV3IG9uZSBlLmcuIHdoZW4gd2UgY29weSBhIG5vZGVcclxuICAgIGlmKGNmZy5uZXdJZCAmJiBjZmcub2xkSWQpIHtcclxuICAgICAgICBub2RlU3RyID0gbm9kZVN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoY2ZnLm9sZElkLCAnZycpLCBjZmcubmV3SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vSW5zZXJ0IHRvIGRvbSBhbmQgYWN0aXZhdGUgdGhlIG5ldyBub2RlXHJcbiAgICB2YXIgdGFyZ2V0SW5zdGFuY2UgPSB0aGlzLmRpYWdyYW0uaW1wb3J0KG5vZGVTdHIpO1xyXG4gICAgdmFyIG5vZGUgPSB0aGlzLmRpYWdyYW0uYWN0aXZhdGVOb2RlKHRhcmdldEluc3RhbmNlKTtcclxuXHJcbiAgICAvL0lmIHNldCB3ZSBtb3ZlIHRoZSBuZXcgbm9kZSB0byBhIGdpdmVuIHBvc2l0aW9uXHJcbiAgICBpZihjZmcubW91c2UpIHtcclxuICAgICAgICB2YXIgc3RhZ2VQb3NpdGlvbiA9IHRoaXMuZGlhZ3JhbS5nZXRTdGFnZVBvc2l0aW9uKGNmZy5tb3VzZSk7XHJcbiAgICAgICAgbm9kZS5tb3ZlVG8oc3RhZ2VQb3NpdGlvbi54LCBzdGFnZVBvc2l0aW9uLnkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmdldE5vZGVBc1N0cmluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIG5vZGUgPSB0aGlzLmdldE5vZGUobm9kZSk7XHJcbiAgICByZXR1cm4geG1sLnNlcmlhbGl6ZVRvU3RyaW5nKG5vZGUuaW5zdGFuY2UoKSk7XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuY29weU5vZGVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZShldnQuZGF0YSk7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChub2RlKSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZVN0ciA9IHRoaXMuZ2V0Tm9kZUFzU3RyaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3Tm9kZUlkID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlYyhDTURfQ09QWSwgW25vZGVTdHIsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2UgOiBldnQubW91c2UsXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkSWQgOiBub2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0lkIDogbmV3Tm9kZUlkXHJcbiAgICAgICAgICAgICAgICB9XSwgW25ld05vZGVJZF0pO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgICBldmVudC50cmlnZ2VyKCdlcnJvcicsICdDb3VsZCBub3QgY29weSBub2RlICEnKTtcclxuICAgIH1cclxufTtcclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5tb3ZlTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGR4U3VtLCBkeVN1bSkge1xyXG4gICAgbm9kZSA9IHRoaXMuZ2V0Tm9kZShub2RlKTtcclxuICAgIGlmKG5vZGUpIHtcclxuICAgICAgICBub2RlLnRyaWdnZXJEcmFnKGR4U3VtLCBkeVN1bSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVE9ETzogbGlzdGVuIHRocm91Z2ggbm9kZSBldmVudCAhXHJcbiAqIEBwYXJhbSBldnRcclxuICovXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5yZXNpemVOb2RlTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBldnQuZGF0YTtcclxuICAgICAgICBpZihub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNpemVJbnN0YW5jZSA9IG5vZGUuYWRkaXRpb25zLnJlc2l6ZS5nZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRDbWQoQ01EX1JFU0laRSxcclxuICAgICAgICAgICAgICAgIFtub2RlLmlkLCByZXNpemVJbnN0YW5jZS5keCwgcmVzaXplSW5zdGFuY2UuZHksIHJlc2l6ZUluc3RhbmNlLmtub2JdLFxyXG4gICAgICAgICAgICAgICAgW25vZGUuaWQsICgtMSpyZXNpemVJbnN0YW5jZS5keCksICgtMSpyZXNpemVJbnN0YW5jZS5keSksIHJlc2l6ZUluc3RhbmNlLmtub2JdKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUucmVzaXplTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGR4LCBkeSwga25vYikge1xyXG4gICAgbm9kZSA9IHRoaXMuZ2V0Tm9kZShub2RlKTtcclxuICAgIGlmKG5vZGUpIHtcclxuICAgICAgICBub2RlLmFkZGl0aW9ucy5yZXNpemUuZ2V0KCkucmVzaXplKGR4LGR5LGtub2IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ3Jlc2l6ZU5vZGUgd2FzIGZvciB1bmtub3duIG5vZGUgOicrbm9kZS50b1N0cmluZygpKTtcclxuICAgIH1cclxufTtcclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhpZCkgJiYgIWlzTmFOKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3BhcnNlSW50KGlkKV07XHJcbiAgICB9IGVsc2UgaWYoIWlzTmFOKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2lkXTtcclxuICAgIH0gZWxzZSBpZihpZCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAvL1dlIGFzc3VtZSBhIG5vZGUgaW5zdGFuY2VcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignZ2V0Tm9kZSBjYWxsIHdpdGggbm8gcmVzdWx0IGZvciA6JytpZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcclxuICAgIGlmKCFmaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gb2JqZWN0LnRvQXJyYXkodGhpcy5ub2Rlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBvYmplY3QuZWFjaCh0aGlzLm5vZGVzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmKGZpbHRlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoW3ZhbHVlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuZWRpdE5vZGUgPSBmdW5jdGlvbihub2RlLCBlZGl0S2V5LCBuZXdWYWx1ZSkge1xyXG4gICAgbm9kZSA9IHRoaXMuZ2V0Tm9kZShub2RlKTtcclxuICAgIG5vZGUuYWRkaXRpb25zLmVkaXQuc2V0VmFsdWUoZWRpdEtleSwgbmV3VmFsdWUpO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLnVuZG9FZGl0ID0gZnVuY3Rpb24obm9kZSwgZWRpdEtleSwgbmV3VmFsdWUpIHtcclxuICAgIG5vZGUgPSB0aGlzLmdldE5vZGUobm9kZSk7XHJcbiAgICBub2RlLmFkZGl0aW9ucy5lZGl0LnNldFZhbHVlKGVkaXRLZXksIG5ld1ZhbHVlKTtcclxufTtcclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ub2RlcyA9IHt9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlTWFuYWdlcjsiLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29yZS9jb25maWcnKTtcclxudmFyIEN1cnZlUGF0aE1hbmFnZXIgPSByZXF1aXJlKCcuL2N1cnZlZFBhdGhNYW5hZ2VyJyk7XHJcbnZhciBTdHJhaWdodFBhdGhNYW5hZ2VyID0gcmVxdWlyZSgnLi9zdHJhaWdodFBhdGhNYW5hZ2VyJyk7XHJcbnZhciBwYXRoTWFuYWdlciA9IHt9O1xyXG5cclxudmFyIHJlZ2lzdGVyID0gICBmdW5jdGlvbihjb25zdHJ1Y3Rvcikge1xyXG4gICAgcGF0aE1hbmFnZXJbY29uc3RydWN0b3IudHlwZV0gPSBjb25zdHJ1Y3RvcjtcclxufTtcclxuXHJcbnJlZ2lzdGVyKEN1cnZlUGF0aE1hbmFnZXIpO1xyXG5yZWdpc3RlcihTdHJhaWdodFBhdGhNYW5hZ2VyKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gIHtcclxuICAgIHJlZ2lzdGVyIDogcmVnaXN0ZXIsXHJcbiAgICBnZXQgOiBmdW5jdGlvbih0cmFuc2l0aW9uLCBpZCkge1xyXG4gICAgICAgIGlkID0gaWQgfHwgY29uZmlnLnZhbCgndHJhbnNpdGlvbl90eXBlJywgU3RyYWlnaHRQYXRoTWFuYWdlci50eXBlKTtcclxuICAgICAgICBpZihwYXRoTWFuYWdlcltpZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXRoTWFuYWdlcltpZF0odHJhbnNpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxudmFyIENvbW1hbmQgPSByZXF1aXJlKCcuLi9jb3JlL2NvbW1hbmQnKTtcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL3N2Zy90cmFuc2Zvcm0nKTtcclxudmFyIFNWRyA9IHJlcXVpcmUoJy4uL3N2Zy9zdmcnKTtcclxudmFyIERyYWdDb25maWcgPSByZXF1aXJlKCcuLi9zdmcvZHJhZ0NvbmZpZycpO1xyXG52YXIgS25vYiA9IHJlcXVpcmUoJy4va25vYicpO1xyXG5cclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcblxyXG4vLyBVc2VkIHRvIGlkZW50aWZ5IHRoZSBkaWZmZXJlbnQga25vYnMgZnJvbSBub3J0aCB3ZXN0IGNsb2Nrd2lzZVxyXG52YXIgS05PQl9OVyA9IDA7XHJcbnZhciBLTk9CX04gPSAxO1xyXG52YXIgS05PQl9ORSA9IDI7XHJcbnZhciBLTk9CX0UgPSAzO1xyXG52YXIgS05PQl9TRSA9IDQ7XHJcbnZhciBLTk9CX1MgPSA1O1xyXG52YXIgS05PQl9TVyA9IDY7XHJcbnZhciBLTk9CX1cgPSA3O1xyXG5cclxuXHJcbi8vIHNwZWNpZmllcyB0aGUgc3BhY2UgYmV0d2VlbiBub2RlIGFuZCByZXNpemUga25vYlxyXG52YXIgRElGID0gMztcclxuXHJcbi8vIHNwZWNpZmllcyB0aGUgc2l6ZSBvZiBhIGtub2JcclxudmFyIFNJWkUgPSA1O1xyXG5cclxuLy8gdXNlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBrbm9ic1xyXG52YXIgRElGX1JFTCA9IERJRiArIFNJWkU7XHJcblxyXG52YXIgUmVzaXplID0gZnVuY3Rpb24obm9kZSwgZGlhZ3JhbSkge1xyXG4gICAgdGhpcy5kaWFncmFtID0gZGlhZ3JhbTtcclxuICAgIHRoaXMuZXZlbnQgPSBkaWFncmFtLmV2ZW50O1xyXG4gICAgdGhpcy5rbm9icyA9IFtdO1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIHRoaXMuY29uZmlnID0gdGhpcy5ub2RlLnRlbXBsYXRlLmNvbmZpZy5yZXNpemU7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVuZGVycyB0aGUga25vYnMgYXJvdW5kIHRoZSBub2RlLlxyXG4gKi9cclxuUmVzaXplLnByb3RvdHlwZS5hY3RpdmF0ZUtub2JzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5jYWxjdWxhdGVLbm9iUG9zaXRpb24oKTtcclxuXHJcbiAgICB2YXIgdHJhbnNsWCA9IHRoaXMubm9kZS54KCkgLSBESUZfUkVMO1xyXG4gICAgdmFyIHRyYW5zbFkgPSB0aGlzLm5vZGUueSgpIC0gRElGX1JFTDtcclxuICAgIHRoaXMuZ3JvdXAgPSB0aGlzLmRpYWdyYW0uc3ZnLmcoe30pLnRyYW5zbGF0ZSh0cmFuc2xYLCB0cmFuc2xZKTtcclxuXHJcbiAgICAvL0luaXRpYWxpemUgdGhlIGRpZmZlcmVudCBrbm9icyB3aXRoIGRpZmZlcmVudCBkcmFnIHJlc3RyaWNpdG9uc1xyXG4gICAgdGhpcy5jcmVhdGVLbm9iKEtOT0JfTlcscG9zaXRpb25zW0tOT0JfTlddLG5ldyBEcmFnQ29uZmlnKCkpO1xyXG4gICAgdGhpcy5jcmVhdGVLbm9iKEtOT0JfTiwgcG9zaXRpb25zW0tOT0JfTl0sbmV3IERyYWdDb25maWcoKS55T25seSgpKTtcclxuICAgIHRoaXMuY3JlYXRlS25vYihLTk9CX05FLHBvc2l0aW9uc1tLTk9CX05FXSxuZXcgRHJhZ0NvbmZpZygpKTtcclxuICAgIHRoaXMuY3JlYXRlS25vYihLTk9CX0UsIHBvc2l0aW9uc1tLTk9CX0VdLG5ldyBEcmFnQ29uZmlnKCkueE9ubHkoKSk7XHJcbiAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9TRSxwb3NpdGlvbnNbS05PQl9TRV0sbmV3IERyYWdDb25maWcoKSk7XHJcbiAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9TLCBwb3NpdGlvbnNbS05PQl9TXSwgbmV3IERyYWdDb25maWcoKS55T25seSgpKTtcclxuICAgIHRoaXMuY3JlYXRlS25vYihLTk9CX1NXLHBvc2l0aW9uc1tLTk9CX1NXXSxuZXcgRHJhZ0NvbmZpZygpKTtcclxuICAgIHRoaXMuY3JlYXRlS25vYihLTk9CX1csIHBvc2l0aW9uc1tLTk9CX1ddLG5ldyBEcmFnQ29uZmlnKCkueE9ubHkoKSk7XHJcblxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGEga25vYiB0byB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIGNvbmZpZ3VyZXMgdGhlIGRyYWcgYW5kIGhvdmVyXHJcbiAqIGxvZ2ljLiBUaGUgdG90YWwgZHJhZyBhbW91bnQgb2Ygb25lIGRyYWcgaXMgY2FuIGJlIGFjZXNzZWQgdGhyb3VnaFxyXG4gKiB0aGlzLmR4IGFuZCB0aGlzLmR5LlxyXG4gKi9cclxuUmVzaXplLnByb3RvdHlwZS5jcmVhdGVLbm9iID0gZnVuY3Rpb24oa25vYiwgcCwgZHJhZ0NmZykge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgLy8gSW5pdGlhbGl6ZSBkcmFnbG9naWNcclxuICAgIHZhciBkcmFnSG9vayA9IGRyYWdDZmdcclxuICAgICAgICAuZHJhZ1N0YXJ0KGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICB0aGF0LmR4ID0gMDtcclxuICAgICAgICAgICAgdGhhdC5keSA9IDA7XHJcbiAgICAgICAgICAgIHRoYXQuZHJhZ0tub2IgPSBrbm9iO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmRyYWdNb3ZlKGZ1bmN0aW9uKGV2dCwgZHgsIGR5KSB7XHJcbiAgICAgICAgICAgIC8vV2Uga2VlcCB0cmFjayBvZiB0aGUgdG90YWwgZHJhZyBtb3ZlbWVudFxyXG4gICAgICAgICAgICB0aGF0LmR4ICs9IGR4O1xyXG4gICAgICAgICAgICB0aGF0LmR5ICs9IGR5O1xyXG4gICAgICAgICAgICB0aGF0LnJlc2l6ZShkeCxkeSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZHJhZ0VuZChmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKCdub2RlX3Jlc2l6ZWQnLCB0aGF0Lm5vZGUpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmdldFNjYWxlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5kaWFncmFtLnNjYWxlO1xyXG4gICAgICAgIH0pLmdldCgpO1xyXG5cclxuICAgIGRyYWdIb29rLnByZXZlbnRBbGlnbm1lbnQgPSB0cnVlO1xyXG5cclxuICAgIC8vIFJlbmRlciB0aGUga25vYiBvbiBzdGFnZVxyXG4gICAgdGhpcy5rbm9ic1trbm9iXSA9IG5ldyBLbm9iKHRoaXMuZGlhZ3JhbSwgcCwge3R5cGU6J3JlY3QnLCBmaWxsOidibGFjaycsIHN0cm9rZTonbm9uZScsIHNlbGVjdGFibGU6ZmFsc2UsICdzdHJva2Utd2lkdGgnOjAsIHNpemU6U0laRSwgJ2ZpbGwtb3BhY2l0eSc6MX0sIHRoaXMuZ3JvdXApXHJcbiAgICAgICAgLmRyYWdnYWJsZShkcmFnSG9vaykuaG92ZXJhYmxlKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBhbGwgc3ZnIGVsZW1lbnRzIHBhcnRpY2lwYXRpbmcgaW4gdGhlIHJlc2l6ZSBwcm9jZXNzLCB3aGljaFxyXG4gKiBhcmUgY29uZmlndXJlZCBpbiB0aGUgcmVzaXplIGNvbmZpZyBiaW5kIGF0dHJpYnV0ZVxyXG4gKi9cclxuUmVzaXplLnByb3RvdHlwZS5nZXRSZXNpemVFbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5jb25maWcsIGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzdmdTZWxlY3RvciA9IHRoYXQubm9kZS5nZXROb2RlU2VsZWN0b3IodmFsdWUuYmluZCk7XHJcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9ICQucUNhY2hlKCkuc3ZnKHN2Z1NlbGVjdG9yKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSByZXNpemUgbG9naWNcclxuICovXHJcblJlc2l6ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlc2l6ZSgwLDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc2l6ZXMgdGhlIG5vZGUgYnkgYXBwbHlpbmcgdGhlIGNvbmZpZ3VyZWQgcmVzaXplIGxvZ2ljIHRvIHRoZSBpbm5lclxyXG4gKiBzdmcgZWxlbWVudHMgb2YgdGhlIG5vZGVzLiBUaGUgZHggYW5kIGR5IHZhbHVlcyBzcGVjaWZpZSB0aGUgcmVzaXplXHJcbiAqIGFtb3VudCBvZiB0aGUgeC0gYW5kIHktYXhpcy4gQWZ0ZXIgdGhlIGFjdHVhbCByZXNpemUgcHJvY2VzcyB0aGUga25vYnNcclxuICogYXJlIGFsaWduZWQgdG8gdGhlIG5ldyBub2RlIGRpbWVuc2lvbi5cclxuICovXHJcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICB0aGlzLnVwZGF0ZU5vZGVzKGR4LGR5KTtcclxuICAgIHRoaXMudXBkYXRlS25vYnModHJ1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpZ25zIGEgc2luZ2xlIGtub2IgdG8gdGhlXHJcbiAqIEBwYXJhbSB7dHlwZX0gcmVzaXplS25vYlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuUmVzaXplLnByb3RvdHlwZS51cGRhdGVLbm9icyA9IGZ1bmN0aW9uKHJlc2l6ZUtub2IpIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQodGhpcy5ncm91cCkpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKHJlc2l6ZUtub2IpICYmIHJlc2l6ZUtub2IpIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuY2FsY3VsYXRlS25vYlBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmtub2JzW0tOT0JfTlddLm1vdmVUbyhwb3NpdGlvbnNbS05PQl9OV10pO1xyXG4gICAgICAgICAgICB0aGlzLmtub2JzW0tOT0JfTl0ubW92ZVRvKHBvc2l0aW9uc1tLTk9CX05dKTtcclxuICAgICAgICAgICAgdGhpcy5rbm9ic1tLTk9CX05FXS5tb3ZlVG8ocG9zaXRpb25zW0tOT0JfTkVdKTtcclxuICAgICAgICAgICAgdGhpcy5rbm9ic1tLTk9CX0VdLm1vdmVUbyhwb3NpdGlvbnNbS05PQl9FXSk7XHJcbiAgICAgICAgICAgIHRoaXMua25vYnNbS05PQl9TRV0ubW92ZVRvKHBvc2l0aW9uc1tLTk9CX1NFXSk7XHJcbiAgICAgICAgICAgIHRoaXMua25vYnNbS05PQl9TXS5tb3ZlVG8ocG9zaXRpb25zW0tOT0JfU10pO1xyXG4gICAgICAgICAgICB0aGlzLmtub2JzW0tOT0JfU1ddLm1vdmVUbyhwb3NpdGlvbnNbS05PQl9TV10pO1xyXG4gICAgICAgICAgICB0aGlzLmtub2JzW0tOT0JfV10ubW92ZVRvKHBvc2l0aW9uc1tLTk9CX1ddKTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmV4ZWMoJ3Jlc2l6ZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgdGhlIGZsYWcgaXMgbm90IHNldCB3ZSBqdXN0IGRvIGFuIHVwZGF0ZSBwcm9iYWJseSBmcm9tIHNpbXBsZSBub2RlIGRyYWcvZHJvcFxyXG4gICAgICAgICAgICB2YXIgdHJhbnNsWCA9IHRoaXMubm9kZS5yb290LmdldFRyYW5zZm9ybWF0aW9uKCkudHJhbnNsYXRlKCkueCAtIERJRl9SRUw7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2xZID0gdGhpcy5ub2RlLnJvb3QuZ2V0VHJhbnNmb3JtYXRpb24oKS50cmFuc2xhdGUoKS55IC0gRElGX1JFTDtcclxuICAgICAgICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGUodHJhbnNsWCwgdHJhbnNsWSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuUmVzaXplLnByb3RvdHlwZS5jYWxjdWxhdGVLbm9iUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByaWdodFggPSBTSVpFICsgKERJRioyKSArIHRoaXMubm9kZS53aWR0aCgpO1xyXG4gICAgdmFyIGNlbnRlclggPSByaWdodFggLyAyO1xyXG4gICAgdmFyIGJvdHRvbVkgPSBTSVpFICsgKERJRioyKSArIHRoaXMubm9kZS5oZWlnaHQoKTtcclxuICAgIHZhciBjZW50ZXJZID0gYm90dG9tWSAvIDI7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgcmVzdWx0W0tOT0JfTlddID0ge3g6MCwgeTowfTtcclxuICAgIHJlc3VsdFtLTk9CX05dID0ge3g6Y2VudGVyWCwgeTowfTtcclxuICAgIHJlc3VsdFtLTk9CX05FXSA9IHt4OnJpZ2h0WCwgeTowfTtcclxuICAgIHJlc3VsdFtLTk9CX0VdID0ge3g6cmlnaHRYLCB5OmNlbnRlcll9O1xyXG4gICAgcmVzdWx0W0tOT0JfU0VdID0ge3g6cmlnaHRYLCB5OmJvdHRvbVl9O1xyXG4gICAgcmVzdWx0W0tOT0JfU10gPSB7eDpjZW50ZXJYLCB5OmJvdHRvbVl9O1xyXG4gICAgcmVzdWx0W0tOT0JfU1ddID0ge3g6MCwgeTpib3R0b21ZfTtcclxuICAgIHJlc3VsdFtLTk9CX1ddID0ge3g6MCwgeTpjZW50ZXJZfTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG59O1xyXG5cclxuUmVzaXplLnByb3RvdHlwZS5yZW1vdmVLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZCh0aGlzLmdyb3VwKSkge1xyXG4gICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgdGhpcy5ncm91cDtcclxufTtcclxuXHJcblJlc2l6ZS5wcm90b3R5cGUudXBkYXRlTm9kZXMgPSBmdW5jdGlvbihkeCxkeSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgaWYoIW9iamVjdC5pc0RlZmluZWQodGhpcy5yZXNpemVFbGVtZW50cykpIHtcclxuICAgICAgICB0aGlzLnJlc2l6ZUVsZW1lbnRzID0gdGhpcy5nZXRSZXNpemVFbGVtZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIG9iamVjdC5lYWNoKHRoaXMucmVzaXplRWxlbWVudHMsIGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XHJcbiAgICAgICAgdGhhdC51cGRhdGVOb2RlKGluZGV4LGVsZW1lbnQsZHgsZHkpO1xyXG4gICAgfSkgO1xyXG59O1xyXG5cclxuUmVzaXplLnByb3RvdHlwZS51cGRhdGVOb2RlID0gZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQsIGR4LCBkeSkge1xyXG4gICAgZHggPSAoIW9iamVjdC5pc0RlZmluZWQoZHgpKT8gMCA6IGR4O1xyXG4gICAgZHkgPSAoIW9iamVjdC5pc0RlZmluZWQoZHkpKT8gMCA6IGR5O1xyXG5cclxuICAgIHZhciBlbGVtZW50Q29uZmlnID0gdGhpcy5jb25maWdbaW5kZXhdO1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChlbGVtZW50Q29uZmlnLnZhbHVlKSkge1xyXG4gICAgICAgIGlmKGVsZW1lbnRDb25maWcudmFsdWVbMF0udHlwZSAhPT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICB0aGlzLnNldFJlc2l6ZShlbGVtZW50LCBlbGVtZW50Q29uZmlnLCBlbGVtZW50Q29uZmlnLnZhbHVlWzBdLCBkeCwgJ3dpZHRoJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vV2UganVzdCBzZXQgb25lIGRpbWVuc2lvbiBmb3IgYSBjaXJjbGVcclxuICAgICAgICBpZihlbGVtZW50Q29uZmlnLnZhbHVlWzBdLnR5cGUgIT09ICdjaXJjbGUnIHx8IHRoaXMuZHJhZ0tub2IgPT09IEtOT0JfUyB8fCB0aGlzLmRyYWdLbm9iID09PSBLTk9CX04pIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRSZXNpemUoZWxlbWVudCxlbGVtZW50Q29uZmlnLCBlbGVtZW50Q29uZmlnLnZhbHVlWzFdLCBkeSwgJ2hlaWdodCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGVsZW1lbnRDb25maWcubWluKSkge1xyXG4gICAgICAgIHRoaXMuYWxpZ25WYWx1ZUxpbWl0KGVsZW1lbnQsIGVsZW1lbnRDb25maWcubWluWzBdLCAnd2lkdGgnLCAnbWluJyk7XHJcbiAgICAgICAgdGhpcy5hbGlnblZhbHVlTGltaXQoZWxlbWVudCwgZWxlbWVudENvbmZpZy5taW5bMV0sICdoZWlnaHQnLCAnbWluJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChlbGVtZW50Q29uZmlnLm1heCkpIHtcclxuICAgICAgICB0aGlzLmFsaWduVmFsdWVMaW1pdChlbGVtZW50LCBlbGVtZW50Q29uZmlnLm1heFswXSwgJ3dpZHRoJywgJ21heCcpO1xyXG4gICAgICAgIHRoaXMuYWxpZ25WYWx1ZUxpbWl0KGVsZW1lbnQsIGVsZW1lbnRDb25maWcubWF4WzFdLCAnaGVpZ2h0JywgJ21heCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoZWxlbWVudENvbmZpZy5wb3NpdGlvbikpIHtcclxuICAgICAgICB0aGlzLmFsaWduUG9zaXRpb24oZWxlbWVudCwgZWxlbWVudENvbmZpZyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5SZXNpemUucHJvdG90eXBlLnNldFJlc2l6ZSA9IGZ1bmN0aW9uKHN2Z0VsZW1lbnQsIGVsZW1lbnRDb25maWcsIHNldHRpbmcsIGQsIGRpbWVuc2lvbikge1xyXG4gICAgc3dpdGNoKHNldHRpbmcudHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XHJcbiAgICAgICAgY2FzZSAnbm9uZSc6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcclxuICAgICAgICAgICAgdmFyIG5ld1kgPSBwYXJzZUludChzdmdFbGVtZW50LmF0dHIoJ3kyJykpICsgZDtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5hdHRyKCd5MicsIG5ld1kpO1xyXG4gICAgICAgIGNhc2UgJ3BhcmVudCc6XHJcbiAgICAgICAgICAgIC8vV2UgY291bGQgY2hlY2sgdGhlIHJlc2l6ZSBzZXR0aW5ncyBvZiB0aGUgcGFyZW50IGlmIHRoaXMgaXMgc3RhdGljXHJcbiAgICAgICAgICAgIC8vd2UgZG8gbm90IGhhdmUgdG8gY2hhbmdlIGFueXRoaW5nIHdoZW4gcmVzaXppbmcuXHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnRbZGltZW5zaW9uXSgxKTtcclxuXHJcbiAgICAgICAgICAgIC8vR2V0IHRoZSBkaW1lbnNpb24gZnJvbSBwYXJlbnQgbm9kZVxyXG4gICAgICAgICAgICB2YXIgcGFyZW50VmFsID0gc3ZnRWxlbWVudC4kKCkucGFyZW50KCkuZ2V0KDApLmdldEJCb3goKVtkaW1lbnNpb25dO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50W2RpbWVuc2lvbl0ocGFyZW50VmFsICsgc2V0dGluZy52YWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50VmFsID0gc3ZnRWxlbWVudFtkaW1lbnNpb25dKGZhbHNlKSA7XHJcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IChjdXJyZW50VmFsICsgZCk7XHJcbiAgICAgICAgICAgIGlmKG5ld1ZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc3ZnRWxlbWVudFtkaW1lbnNpb25dKChjdXJyZW50VmFsICsgZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUmVzaXplLnByb3RvdHlwZS5hbGlnblZhbHVlTGltaXQgPSBmdW5jdGlvbihzdmdFbGVtZW50LCBzZXR0aW5nLCBkaW1lbnNpb24sIHR5cGUpIHtcclxuICAgIHZhciB2YWx1ZSA9IHNldHRpbmcudHlwZTtcclxuICAgIHZhciBsaW1pdDtcclxuXHJcbiAgICBpZih2YWx1ZSA9PT0gJ3BhcmVudCcpIHtcclxuICAgICAgICBsaW1pdCA9IHN2Z0VsZW1lbnQuJCgpLnBhcmVudCgpWzBdLmdldEJCb3goKVtkaW1lbnNpb25dO1xyXG4gICAgfSBlbHNlIGlmKCFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICBsaW1pdCA9IHBhcnNlSW50KHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZih1dGlsLnN0cmluZy5zdGFydHNXaXRoKHZhbHVlLCAnIycpKSB7XHJcbiAgICAgICAgbGltaXQgPSAkLnFDYWNoZSh0aGlzLm5vZGUuZ2V0Tm9kZVNlbGVjdG9yKHZhbHVlKSlbMF0uZ2V0QkJveCgpW2RpbWVuc2lvbl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHNldHRpbmcudmFsdWUpKSB7XHJcbiAgICAgICAgbGltaXQgKz0gc2V0dGluZy52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3VycmVudFZhbCA9IHN2Z0VsZW1lbnRbZGltZW5zaW9uXShmYWxzZSlcclxuICAgIGlmKCh0eXBlID09PSAnbWluJyAmJiBjdXJyZW50VmFsIDwgbGltaXQpIHx8ICh0eXBlID09PSAnbWF4JyAmJiBjdXJyZW50VmFsID4gbGltaXQpKSB7XHJcbiAgICAgICAgc3ZnRWxlbWVudFtkaW1lbnNpb25dKGxpbWl0KTtcclxuICAgIH1cclxufTtcclxuXHJcblJlc2l6ZS5wcm90b3R5cGUuYWxpZ25Qb3NpdGlvbiA9IGZ1bmN0aW9uKHN2Z0VsZW1lbnQsIGVsZW1lbnRDb25maWcpIHtcclxuICAgIC8vdmFyIHNldHRpbmcgPSBlbGVtZW50Q29uZmlnLlxyXG4gICAgLy9UT0RPOiBzZXQgYWxpZ25FbGVtZW50IGlkIGluIGNvbmZpZyAhXHJcbiAgICB2YXIgeCA9IHRoaXMuZ2V0QWxpZ25lZFBvc2l0aW9uKHN2Z0VsZW1lbnQsZWxlbWVudENvbmZpZy5wb3NpdGlvblswXSwgZWxlbWVudENvbmZpZy5hbGlnbnRvLCAnd2lkdGgnICwgJ3gnKTtcclxuICAgIHZhciB5ID0gdGhpcy5nZXRBbGlnbmVkUG9zaXRpb24oc3ZnRWxlbWVudCxlbGVtZW50Q29uZmlnLnBvc2l0aW9uWzFdLCBlbGVtZW50Q29uZmlnLmFsaWdudG8sICdoZWlnaHQnLCAneScpO1xyXG5cclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoeCkpIHtcclxuICAgICAgICBzdmdFbGVtZW50Lm1vdmVYKHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoeSkpIHtcclxuICAgICAgICBzdmdFbGVtZW50Lm1vdmVZKHkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUmVzaXplLnByb3RvdHlwZS5nZXRBbGlnbmVkUG9zaXRpb24gPSBmdW5jdGlvbihzdmdFbGVtZW50LCBzZXR0aW5ncywgYWxpZ250bywgZGltZW5zaW9uLCBkaW1lbnNpb25Db29yZCkge1xyXG4gICAgc3dpdGNoKHNldHRpbmdzLnR5cGUpIHtcclxuICAgICAgICBjYXNlICdub25lJzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgICAgdmFyIGFsaWduU1ZHID0gdGhpcy5nZXRBbGlnbkVsZW1lbnQoYWxpZ250bywgc3ZnRWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQoYWxpZ25TVkcpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ25WYWwgPSBhbGlnblNWRy5nZXRDZW50ZXIoKVtkaW1lbnNpb25Db29yZF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxpZ25WYWwgLSAoc3ZnRWxlbWVudFtkaW1lbnNpb25dKCkgLyAyKSAtIHNldHRpbmdzLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gKGFsaWduVmFsIC0gc3ZnRWxlbWVudFtkaW1lbnNpb25dKCkpIC8gMiArIHNldHRpbmdzLnZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdyZWxhdGl2ZSc6XHJcbiAgICAgICAgICAgIHZhciAkcHJldk5vZGUgPSBzdmdFbGVtZW50LiQoKS5wcmV2KCk7XHJcbiAgICAgICAgICAgIGlmKCRwcmV2Tm9kZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2U1ZHID0gJC5xQ2FjaGUoKS5zdmcoJHByZXZOb2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsID0gcHJldlNWR1tkaW1lbnNpb25dKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldkNvb3JkID0gcHJldlNWR1tkaW1lbnNpb25Db29yZF0oKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAocHJldkNvb3JkICsgcHJldlZhbCkgKyBzZXR0aW5ncy52YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vTm8gcHJldiBzaWJsaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgIHZhciBhbGlnblNWRyA9IHRoaXMuZ2V0QWxpZ25FbGVtZW50KGFsaWdudG8sIHN2Z0VsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKGFsaWduU1ZHKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFsaWduVmFsID0gKHNldHRpbmdzLnR5cGUgPT09ICdyaWdodCcpPyBhbGlnblNWRy5nZXRSaWdodFgoKTphbGlnblNWRy5nZXRCb3R0b21ZKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFsaWduVmFsIC0gc3ZnRWxlbWVudFtkaW1lbnNpb25dKCkpIC0gc2V0dGluZ3MudmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgIH1cclxufTtcclxuXHJcblJlc2l6ZS5wcm90b3R5cGUuZ2V0QWxpZ25FbGVtZW50ID0gZnVuY3Rpb24oYWxpZ250bywgc3ZnRWxlbWVudCkge1xyXG4gICAgdmFyIGVsZW1lbnRUb0FsaWduO1xyXG4gICAgLy9UaGUgYWxpZ250byBzZXR0aW5nIGNhbiBiZSB0aGUgcGFyZW50LSwgcm9vdC0gb3IgYW4gZXhwbGljaXQgZWxlbWVudCBkZWZhdWx0IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIGVsZW1lbnRcclxuICAgIGlmKCFhbGlnbnRvIHx8IGFsaWdudG8gPT09ICdwcmV2Jykge1xyXG4gICAgICAgIGVsZW1lbnRUb0FsaWduID0gJC5xQ2FjaGUoKS5zdmcoc3ZnRWxlbWVudC4kKCkucHJldigpKTtcclxuICAgIH1lbHNlIGlmKCFhbGlnbnRvIHx8IGFsaWdudG8gPT09ICdwYXJlbnQnKSB7XHJcbiAgICAgICAgZWxlbWVudFRvQWxpZ24gPSAkLnFDYWNoZSgpLnN2ZyhzdmdFbGVtZW50LiQoKS5wYXJlbnQoKSk7O1xyXG4gICAgfSBlbHNlIGlmKGFsaWdudG8gPT09ICdyb290Jykge1xyXG4gICAgICAgIGVsZW1lbnRUb0FsaWduID0gdGhpcy5ub2RlLnJvb3Q7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZW1lbnRUb0FsaWduID0gJC5xQ2FjaGUuc3ZnKHRoaXMubm9kZS5nZXROb2RlU2VsZWN0b3IoYWxpZ250bykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCFlbGVtZW50VG9BbGlnbikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGRldGVybWluZSBhbGlnbnRvIGVsZW1lbnQgXCInK2FsaWdudG8rJ1wiIGZvciBub2RlICcrdGhpcy5ub2RlLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudFRvQWxpZ247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2l6ZTtcclxuIiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBSZXNpemUgPSByZXF1aXJlKCcuL3Jlc2l6ZScpO1xyXG5cclxudmFyIFJlc2l6ZUFkZGl0aW9uID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIHRoaXMucmVzaXplID0gbmV3IFJlc2l6ZSh0aGlzLm5vZGUsIHRoaXMubm9kZS5kaWFncmFtKTtcclxufTtcclxuXHJcblJlc2l6ZUFkZGl0aW9uLnByb3RvdHlwZS5yZXNpemVOb2RlID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICAvL1RoaXMgaXMgdGhlIGFwaSB3YXkgdG8gcmVzaXplIGEgbm9kZSB3ZSBpbWl0YXRlIHRoZSBkcmFnZXZlbnQuXHJcbiAgICB0aGlzLnJlc2l6ZS51cGRhdGVOb2RlcyhkeCxkeSk7XHJcbiAgICB0aGlzLnJlc2l6ZS5kcmFnS25vYiA9IDQ7IC8vV2Ugc2V0IHRoZSBLTk9CX1NFIGtub2IgYXMgZHJhZ0tub2IgZm9yIHRoZSByZWRvIGNvbW1hbmRcclxuICAgIHRoaXMucmVzaXplLmR4ID0gZHg7XHJcbiAgICB0aGlzLnJlc2l6ZS5keSA9IGR5O1xyXG4gICAgdGhpcy5ub2RlLmV2ZW50LnRyaWdnZXIoJ25vZGVfcmVzaXplZCcsIHRoaXMubm9kZSk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlc2l6ZS5hY3RpdmF0ZUtub2JzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVzaXplLnJlbW92ZUtub2JzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRlc2VsZWN0KCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuZHJhZ01vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVzaXplLnVwZGF0ZUtub2JzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuZWRpdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZXNpemUudXBkYXRlKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvL1RPRE86IFRocm91Z2ggRVZFTlRTICFcclxuICAgIHRoaXMucmVzaXplLnVwZGF0ZUtub2JzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVzaXplLnVwZGF0ZU5vZGVzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXNpemU7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5yZXF1aXJlQ29uZmlnID0gdHJ1ZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzaXplQWRkaXRpb247IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG52YXIgUGF0aERhdGEgPSByZXF1aXJlKCcuLi9zdmcvUGF0aERhdGEnKTtcclxuXHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIGRvbSA9IHV0aWwuZG9tO1xyXG5cclxudmFyIFNlbGVjdGlvbk1hbmFnZXIgPSBmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSBkaWFncmFtO1xyXG4gICAgdGhpcy5ldmVudCA9IGRpYWdyYW0uZXZlbnQ7XHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXMgPSBbXTtcclxuICAgIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9ucyA9IFtdO1xyXG4gICAgdGhpcy5jb3B5Tm9kZXMgPSBbXTtcclxuICAgIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uO1xyXG4gICAgdGhpcy5ob3ZlckVsZW1lbnQ7XHJcblxyXG4gICAgZXZlbnQubGlzdGVuKCdrZXlfdXBfcHJlc3MnLCB0aGlzLnVwTGlzdGVuZXIsIHRoaXMpO1xyXG4gICAgZXZlbnQubGlzdGVuKCdrZXlfZG93bl9wcmVzcycsIHRoaXMuZG93bkxpc3RlbmVyLCB0aGlzKTtcclxuICAgIGV2ZW50Lmxpc3Rlbigna2V5X2NvcHlfcHJlc3MnLCB0aGlzLmNvcHlMaXN0ZW5lciwgdGhpcyk7XHJcbiAgICBldmVudC5saXN0ZW4oJ2tleV9wYXN0ZV9wcmVzcycsIHRoaXMucGFzdGVMaXN0ZW5lciwgdGhpcyk7XHJcbiAgICBldmVudC5saXN0ZW4oJ2tleV9kZWxfcHJlc3MnLCB0aGlzLmRlbGV0ZUxpc3RlbmVyLCB0aGlzKTtcclxuICAgIGV2ZW50Lmxpc3RlbigndGFiX2FjdGl2YXRlZCcsIHRoaXMuY2xlYXIsIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuZXZlbnQubGlzdGVuKCd0cmFuc2l0aW9uX2FkZGVkJywgdGhpcy50cmFuc2l0aW9uQWRkZWRMaXN0ZW5lciwgdGhpcyk7XHJcbiAgICB0aGlzLmV2ZW50Lmxpc3Rlbignbm9kZV9hZGRlZCcsIHRoaXMubm9kZUFkZGVkTGlzdGVuZXIsIHRoaXMpO1xyXG4gICAgdGhpcy5ldmVudC5saXN0ZW4oJ2tub2JfYWRkZWQnLCB0aGlzLmtub2JBZGRlZExpc3RlbmVyLCB0aGlzKTtcclxuXHJcbiAgICAvL1RoZXNlIGFyZSBjdXJyZW50bHkgZ2xvYmFsIGV2ZW50cyBub3QgZGlhZ3JhbSBjb250ZXh0IGV2ZW50c1xyXG4gICAgZXZlbnQubGlzdGVuKCdlbGVtZW50X2hvdmVySW4nLCB0aGlzLmhvdmVySW5FbGVtZW50TGlzdGVuZXIsIHRoaXMpO1xyXG4gICAgZXZlbnQubGlzdGVuKCdlbGVtZW50X2hvdmVyT3V0JywgdGhpcy5ob3Zlck91dEVsZW1lbnRMaXN0ZW5lciwgdGhpcyk7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTZWxlY3RlZE5vZGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZE5vZGVzLnNsaWNlKCk7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5rbm9iQWRkZWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdmFyIGtub2IgPSBldnQuZGF0YTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuYWRkTm9kZUV2ZW50cyhrbm9iLm5vZGUpO1xyXG4gICAgaWYoa25vYi5ub2RlLnNlbGVjdGFibGUpIHtcclxuICAgICAgICBrbm9iLm5vZGUub24oJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoYXQuZHJhZ1NlbGVjdGlvbiB8fCBldnQuc2hpZnRLZXkgJiYga25vYi50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa25vYi50cmFuc2l0aW9uLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga25vYi50cmFuc2l0aW9uLmRlc2VsZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWtub2IudHJhbnNpdGlvbi5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtub2IudHJhbnNpdGlvbi5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubm9kZUFkZGVkTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRoaXMuYWRkTm9kZUV2ZW50cyhldnQuZGF0YSk7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGROb2RlRXZlbnRzID0gZnVuY3Rpb24obm9kZSwgc2hpZnRlZCkge1xyXG4gICAgaWYobm9kZS5zZWxlY3RhYmxlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG5vZGUub24oJ3NlbGVjdCcsIGZ1bmN0aW9uIChldnQsIHNoaWZ0ZWQpIHtcclxuICAgICAgICAgICAgdGhhdC5zZXROb2RlU2VsZWN0aW9uKG5vZGUsIHNoaWZ0ZWQpO1xyXG4gICAgICAgIH0pLm9uKCdkZXNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhhdC5yZW1vdmVTZWxlY3RlZE5vZGUobm9kZSk7XHJcbiAgICAgICAgfSkub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhhdC5yZW1vdmVTZWxlY3RlZE5vZGUobm9kZSk7XHJcbiAgICAgICAgfSkuc2VsZWN0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnRyYW5zaXRpb25BZGRlZExpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB2YXIgdHJhbnNpdGlvbiA9IGV2dC5kYXRhO1xyXG4gICAgdHJhbnNpdGlvbi5vbignc2VsZWN0JywgZnVuY3Rpb24oZXZ0LCBzaGlmdGVkKSB7XHJcbiAgICAgICAgdGhhdC5zZXRUcmFuc2l0aW9uU2VsZWN0aW9uKHRyYW5zaXRpb24pO1xyXG4gICAgfSkub24oJ2Rlc2VsZWN0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhhdC5yZW1vdmVTZWxlY3RlZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbiAgICB9KS5vbigncmVtb3ZlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhhdC5yZW1vdmVTZWxlY3RlZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbiAgICB9KS5zZWxlY3QoZXZ0LnNoaWZ0S2V5KTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvcHlMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdGhpcy5jb3B5Tm9kZXMgPSBvYmplY3QuY2xvbmVBcnJheSh0aGlzLnNlbGVjdGVkTm9kZXMpO1xyXG5cclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBhc3RlTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5jb3B5Tm9kZXMsIGZ1bmN0aW9uKGluZGV4LCBub2RlKSB7XHJcbiAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKCdub2RlX2NvcHknLCBub2RlLCBldnQpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cExpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBpZihldnQuY3RybEtleSkge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIG9iamVjdC5lYWNoKHRoaXMuc2VsZWN0ZWROb2RlcywgZnVuY3Rpb24oaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5tb3ZlVXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZG93bkxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBpZihldnQuY3RybEtleSkge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIG9iamVjdC5lYWNoKHRoaXMuc2VsZWN0ZWROb2RlcywgZnVuY3Rpb24oaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5tb3ZlRG93bigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ob3ZlckluRWxlbWVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB0aGlzLmhvdmVyRWxlbWVudCA9IGV2dC5kYXRhO1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaG92ZXJPdXRFbGVtZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGRlbGV0ZSB0aGlzLmhvdmVyRWxlbWVudDtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZWRUcmFuc2l0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoZXZ0LmRhdGEpKSB7XHJcbiAgICAgICAgaWYoZXZ0LmRhdGEgPT09IHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVkTm9kZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGV2dC5kYXRhKSkge1xyXG4gICAgICAgIC8vUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIHNlbGVjdGlvblxyXG4gICAgICAgIG9iamVjdC5yZW1vdmVGcm9tQXJyYXkodGhpcy5zZWxlY3RlZE5vZGVzLCBldnQuZGF0YSk7XHJcblxyXG4gICAgICAgIC8vQ2hlY2sgaWYgd2UgaGF2ZSB0byByZW1vdmUgdGhlIGhvdmVyRWxlbWVudCB0b29cclxuICAgICAgICBpZihldnQuZGF0YS5yb290ID09PSB0aGlzLmhvdmVyRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmhvdmVyT3V0RWxlbWVudExpc3RlbmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRoaXMuZGVsZXRlU2VsZWN0aW9uTm9kZXMoKTtcclxuXHJcbiAgICAvL1JlbW92ZSBzZWxlY3RlZCB0cmFuc2l0aW9uXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uKSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnQudHJpZ2dlcigndHJhbnNpdGlvbl9kZWxldGUnLCB0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xlYXIoKTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGlvbk5vZGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYXJyQ2xvbmUgPSB0aGlzLnNlbGVjdGVkTm9kZXMuc2xpY2UoMCk7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBvYmplY3QuZWFjaChhcnJDbG9uZSwgZnVuY3Rpb24oaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZXZlbnQudHJpZ2dlcignbm9kZV9kZWxldGUnLCBub2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL0lmIHRoZXJlIGlzIGEgdW5kZWZpbmVkIHZhbHVlIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGVzLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnRyYW5zaXRpb25DcmVhdGVkTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uID0gZXZ0LmRhdGE7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5pc0VsZW1lbnRIb3ZlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG9iamVjdC5pc0RlZmluZWQodGhpcy5ob3ZlckVsZW1lbnQpO1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VHJhbnNpdGlvblNlbGVjdGlvbiA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIC8vV2UgZG8gbm90IGNhbGwgdGhpcy5jbGVhciBiZWNhdXNlIHdlIHdvdWxkIGhpZGUgdGhlIGVkaXQgZmllbGRzIHRyb3VnaCB0aGUgdHJpZ2dlcmVkIGV2ZW50XHJcbiAgICB0aGlzLmNsZWFyTm9kZXMoZnVuY3Rpb24obm9kZSkge3JldHVybiAhdHJhbnNpdGlvbi5vd25zS25vYk5vZGUobm9kZSl9KTtcclxuICAgIGlmKHRyYW5zaXRpb24gIT09IHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhclRyYW5zaXRpb24oKTtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXROb2RlU2VsZWN0aW9uID0gZnVuY3Rpb24oc2VsZWN0ZWROb2RlLCBzaGlmdGVkKSB7XHJcbiAgICAvL3NvbWUgdGVtcGxhdGVzIG9yIG5vZGVzIGFyZSBzaG91bGQgbm90IGFmZmVjdCB0aGUgc2VsZWN0aW9uIChlLmcuIHJlc2l6ZSBrbm9icylcclxuICAgIGlmKCFzZWxlY3RlZE5vZGUuc2VsZWN0YWJsZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH07XHJcblxyXG4gICAgaWYoIXRoaXMuY29udGFpbnNOb2RlKHNlbGVjdGVkTm9kZSkpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8vQ2xlYXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlmIG5vdCBzaGlmdGVkIG9yIGRyYWdTZWxlY3Rpb25cclxuICAgICAgICBpZighc2hpZnRlZCAmJiAhdGhpcy5kcmFnU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJOb2RlcyhmdW5jdGlvbihub2RlKSB7cmV0dXJuIHNlbGVjdGVkTm9kZS5pZCAhPT0gbm9kZS5pZH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRlbXBsYXRlID0gc2VsZWN0ZWROb2RlLnRlbXBsYXRlO1xyXG4gICAgICAgIHRoaXMuYWRkU2VsZWN0ZWROb2RlKHNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgdGhpcy5jbGVhclRyYW5zaXRpb24oc2VsZWN0ZWROb2RlLCBvYmplY3QuaXNEZWZpbmVkKHRoaXMuZHJhZ1NlbGVjdGlvbikpO1xyXG5cclxuICAgICAgICAvL1RyaWdnZXIgZHJhZyBmb3IgYWxsIHNlbGVjdGVkIG5vZGVzIGlmIG9uZSBzZWxlY3Rpb24gaXMgZHJhZ2dlZFxyXG4gICAgICAgIC8vV2UgdXNlIGFkZGl0b24gc3R5bGUgaW5zdGVhZCBvZiBvbiBldmVudCBmb3IgYSBwZXJmb3JtYW5jZSBnYWluIChvbi5kcmFnTW92ZSBpcyBkZWFjdGl2YXRlZCBzZWUgZHJhZ2dhYmxlLmpzKVxyXG4gICAgICAgIC8vV2UgZG9uJ3QgaGF2ZSB0byByZW1vdmUgdGhpcyBhZGRpdGlvbiBhZnRlciByZXNlbGVjdCBiZWNhdXNlIG9ubHkgc2VsZWN0ZWQgbm9kZXMgY2FuIGJlIGRyYWdnZWQgYW55d2F5cy5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgc2VsZWN0ZWROb2RlLmFkZGl0aW9uc1snbXVsdGlTZWxlY3Rpb25EcmFnJ10gPSB7XHJcbiAgICAgICAgICAgIGRyYWdNb3ZlIDogZnVuY3Rpb24oZHgsZHksIGV2dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFldnQudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVhY2godGhhdC5zZWxlY3RlZE5vZGVzLCBmdW5jdGlvbiAoaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5pZCAhPT0gbm9kZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmlnZ2VyRHJhZyhkeCwgZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYoc2hpZnRlZCAmJiAhdGhpcy5kcmFnU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTZWxlY3RlZE5vZGUoc2VsZWN0ZWROb2RlKTtcclxuICAgIH1cclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRyYWdTZWxlY3Rpb25TdGFydCA9IGZ1bmN0aW9uKGV2dCwgc3RhcnRQb3NpdGlvbikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgLy8gSU5JVCBkcmFnIHNlbGVjdGlvblxyXG4gICAgaWYgKCF0aGlzLmlzRWxlbWVudEhvdmVyKCkpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5kaWFncmFtLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFnZVBvc2l0aW9uID0gdGhhdC5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICAgICAgaWYgKCF0aGF0LmRyYWdTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdGlvbiA9IHRoYXQuZGlhZ3JhbS5zdmcucGF0aCh7c3R5bGU6ICdzdHJva2U6Z3JheTtzdHJva2Utd2lkdGg6MXB4O3N0cm9rZS1kYXNoYXJyYXk6NSw1O2ZpbGw6bm9uZTsnfSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmRyYWdTZWxlY3Rpb24uZCgpLnN0YXJ0KHN0YXJ0UG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmxpbmUoc3RhcnRQb3NpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAubGluZShzdGFnZVBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5saW5lKHN0YWdlUG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL01vdmUgc2VsZWN0aW9uIGF3YXkgZnJvbSBtb3VzZSBwb2ludGVyXHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ25lZE1vdXNlWCA9IHN0YWdlUG9zaXRpb24ueCAtIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ25lZE1vdXNlWSA9IHN0YWdlUG9zaXRpb24ueSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9VcGRhdGUgcGF0aGRhdGFcclxuICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdGlvbi5kKCkuY2xlYXIoKS5zdGFydChzdGFydFBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5saW5lKHt4OiBzdGFydFBvc2l0aW9uLngsIHk6IGFsaWduZWRNb3VzZVl9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5saW5lKHt4OiBhbGlnbmVkTW91c2VYLCB5OiBhbGlnbmVkTW91c2VZfSlcclxuICAgICAgICAgICAgICAgICAgICAubGluZSh7eDogYWxpZ25lZE1vdXNlWCwgeTogc3RhcnRQb3NpdGlvbi55fSlcclxuICAgICAgICAgICAgICAgICAgICAuY29tcGxldGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGZvciBob3ZlcmVkIGVsZW1lbnRzIHRvIHNlbGVjdFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0LmVhY2godGhhdC5kaWFncmFtLm5vZGVNZ3Iubm9kZXMsIGZ1bmN0aW9uIChpZCwgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdChub2RlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG9iamVjdC5lYWNoKHRoYXQuZGlhZ3JhbS5rbm9iTWdyLmtub2JzLCBmdW5jdGlvbihpZCwga25vYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdChrbm9iLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVHJpZ2dlciBhdHRyaWJ1dGUgdXBkYXRlXHJcbiAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdGlvbi51cGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kcmFnU2VsZWN0ID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYoIW5vZGUuc2VsZWN0YWJsZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmKHRoaXMuZHJhZ1NlbGVjdGlvbi5vdmVybGF5cyhub2RlLmdldENlbnRlcigpKSkge1xyXG4gICAgICAgIGlmKCFub2RlLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc2VsZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmKG5vZGUuc2VsZWN0ZWQpIHtcclxuICAgICAgICBub2RlLmRlc2VsZWN0KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kcmFnU2VsZWN0aW9uRW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0ub2ZmKCdtb3VzZW1vdmUnKTtcclxuICAgIGlmKHRoaXMuZHJhZ1NlbGVjdGlvbikge1xyXG4gICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbi5yZW1vdmUoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5kcmFnU2VsZWN0aW9uO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGp1c3QgYWRkcyBuZXcgbm9kZXMgdG8gdGhlIHNlbGVjdGlvbiBpZiBpdCBoYXZlIG5vdCBiZWVuXHJcbiAqIGFkZGVkIHlldCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIHJlc3RyaWN0aW9ucy5cclxuICpcclxuICogQWxsIHNlbGVjdGVkIHRyYW5zaXRpb25zIGFyZSBkZXNlbGVjdGVkIHNpbmNlIHRoZSBtaXhlZCBzZWxlY3Rpb25cclxuICogaXMgbm90IGltcGxlbWVudGVkIHlldC5cclxuICpcclxuICogQHBhcmFtIHt0eXBlfSBzZWxlY3RlZE5vZGVcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZFNlbGVjdGVkTm9kZSA9IGZ1bmN0aW9uKHNlbGVjdGVkTm9kZSkge1xyXG4gICAgdGhpcy5zZWxlY3RlZE5vZGVzLnB1c2goc2VsZWN0ZWROb2RlKTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVNlbGVjdGVkVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIGlmKHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uID09PSB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlU2VsZWN0ZWROb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5zZWxlY3RlZE5vZGVzLmluZGV4T2Yobm9kZSk7XHJcbiAgICBpZihpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb250YWluc05vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZE5vZGVzLmluZGV4T2Yobm9kZSkgPiAtMTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmNsZWFyTm9kZXMoKTtcclxuICAgIHRoaXMuY2xlYXJUcmFuc2l0aW9uKCk7XHJcbiAgICB0aGlzLmV2ZW50LnRyaWdnZXIoJ3NlbGVjdGlvbl9jbGVhcicpO1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJOb2RlcyA9IGZ1bmN0aW9uKGZpbHRlcikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgZmlsdGVyID0gZmlsdGVyIHx8IGZ1bmN0aW9uKCkge3JldHVybiB0cnVlO307XHJcbiAgICAvL1dlIGNsb25lIHRoZSBhcnJheSBzaW5jZSB0aGUgb3JpZ2luYWwgYXJyYXkgY2FuIGJlIG1hbmlwdWxhdGVkIHdoaWxlIGRlc2VsZWN0aW9uLlxyXG4gICAgdmFyIHNlbGVjdGVkTm9kZXNBcnIgPSBvYmplY3QuY2xvbmVBcnJheSh0aGlzLnNlbGVjdGVkTm9kZXMpO1xyXG4gICAgb2JqZWN0LmVhY2goc2VsZWN0ZWROb2Rlc0FyciwgZnVuY3Rpb24oaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICBpZihub2RlLnNlbGVjdGFibGUgJiYgZmlsdGVyKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuZGVzZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGZvcmNlKSB7XHJcbiAgICBpZighdGhpcy5zZWxlY3RlZFRyYW5zaXRpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZihmb3JjZSB8fCAhbm9kZSAgfHwgIW5vZGUua25vYiB8fCAhdGhpcy5zZWxlY3RlZFRyYW5zaXRpb25Pd25zS25vYk5vZGUobm9kZSkpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbi5kZXNlbGVjdCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VsZWN0ZWRUcmFuc2l0aW9uT3duc0tub2JOb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uICYmIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uLm93bnNLbm9iTm9kZShub2RlKTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmlzTXVsdGlTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICBjb3VudCArPSB0aGlzLnNlbGVjdGVkTm9kZXMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGNvdW50ID4gMTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0aW9uTWFuYWdlcjtcclxuIiwiLyoqXHJcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBwYXRoIG1hbmFnZXJcclxuICogQHR5cGUge1BhdGhEYXRhfGV4cG9ydHN8bW9kdWxlLmV4cG9ydHN9XHJcbiAqL1xyXG52YXIgQWJzdHJhY3RQYXRoTWFuYWdlciA9IHJlcXVpcmUoJy4vYWJzdHJhY3RQYXRoTWFuYWdlcicpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG5cclxudmFyIExpbmVQYXRoTWFuYWdlciA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIEFic3RyYWN0UGF0aE1hbmFnZXIuY2FsbCh0aGlzLCB0cmFuc2l0aW9uKTtcclxuICAgIHRoaXMudHlwZSA9IExpbmVQYXRoTWFuYWdlci50eXBlO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhMaW5lUGF0aE1hbmFnZXIsIEFic3RyYWN0UGF0aE1hbmFnZXIpO1xyXG5cclxuTGluZVBhdGhNYW5hZ2VyLnR5cGUgPSAnc3RyYWlnaHQnO1xyXG5cclxuTGluZVBhdGhNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgdGhpcy5wYXRoLmxpbmUocG9zaXRpb24pO1xyXG59O1xyXG5cclxuTGluZVBhdGhNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpbmRleCwgcG9zaXRpb24pIHtcclxuICAgIHRoaXMucGF0aC5pbnNlcnRMaW5lKGluZGV4LCBwb3NpdGlvbik7XHJcbn07XHJcblxyXG5MaW5lUGF0aE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7LyogTm90aGluZyB0byBkbyBoZXJlICovfTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZVBhdGhNYW5hZ2VyO1xyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgeG1sID0gcmVxdWlyZSgnLi4vdXRpbC94bWwnKTtcclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvcmUvY29uZmlnJyk7XHJcblxyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxuXHJcbnZhciBUZW1wbGF0ZSA9IGZ1bmN0aW9uKGlkLCBjZmcpIHtcclxuICAgIHRoaXMuY29uZmlnID0gY2ZnIHx8IHt9O1xyXG5cclxuICAgIGlmKHRoaXMuY29uZmlnLmZyb21Eb20pIHsgLy9Mb2FkIHRtcGwgZnJvbSBkb20gc2NyaXB0IG5vZGVcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy50bXBsWE1MID0gZG9tLnBhcnNlTm9kZVhNTCgkLnFDYWNoZSgnIycraWQpKTtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNTdHJpbmcoaWQpKSB7IC8vUmVtb3RlIHRtcGwgaXMgaW5pdGlhbGl6ZWQgbGF0ZXIgKGFmdGVyIGxvYWRpbmcgeG1sKVxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnRtcGxYTUwgPSAodGhpcy5jb25maWcuc3ZnKSA/IHhtbC5wYXJzZVhNTCh0aGlzLmNvbmZpZy5zdmcpIDogdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIHsgLy9pZCBpcyB0ZW1wbGF0ZVhNTFxyXG4gICAgICAgIHRoaXMudG1wbFhNTCA9IGlkO1xyXG4gICAgICAgIHRoaXMuaWQgPSAkKHRoaXMudG1wbFhNTCkuYXR0cignaWQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvL1JlbW90ZSB0ZW1wbGF0ZXMgYXJlIGluaXRpYWxpemVkIGxhdGVyO1xyXG4gICAgaWYodGhpcy50bXBsWE1MKSB7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZCh0aGlzLmNvbmZpZykpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKHRoaXMuY29uZmlnLnJlc2l6ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0UmVzaXplQ29uZmlnKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih0bXBsWE1MKSB7XHJcbiAgICB0aGlzLmNvbmZpZy5yb290TmFtZSA9IHRoaXMuY29uZmlnLnJvb3ROYW1lIHx8ICdnJztcclxuXHJcbiAgICBpZih0bXBsWE1MKSB7XHJcbiAgICAgICAgdGhpcy50bXBsWE1MID0gdG1wbFhNTDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN2ZyA9IHhtbC5zZXJpYWxpemVUb1N0cmluZygkKHRoaXMudG1wbFhNTCkuZmluZCh0aGlzLmNvbmZpZy5yb290TmFtZSlbMF0pO1xyXG59O1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlLmlzSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAhIXRoaXMuc3ZnO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVzaXplIGFkZGl0aW9uIGFsbG93cyB0byBjb25maWd1cmUgYSByZXNpemUgYmVoYXZpb3VyIGZvciBzdmcgZWxlbWVudHNcclxuICogYnkgbWVhbnMgb2YgZGVmaW5pbmcgdGhlIGxvZ2ljIGZvciBjaGFuZ2VzIG9mIHggKHdpZHRoKSBhbmQgeSAoaGVpZ2h0KVxyXG4gKiBpbiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqIGUuZy46XHJcbiAqXHJcbiAqIHBhcmVudCg1KSBkZWZhdWx0XHJcbiAqXHJcbiAqIHdoZXJlIHRoZSB4IHZhbHVlIGlzXHJcbiAqIEBwYXJhbSB7dHlwZX0gcmVzaXplQ29uZmlnXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5UZW1wbGF0ZS5wcm90b3R5cGUuaW5pdFJlc2l6ZUNvbmZpZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5jb25maWcucmVzaXplLCBmdW5jdGlvbihpbmRleCwgcmVzaXplSXRlbSkge1xyXG4gICAgICAgIC8vIEhlcmUgd2UganVzdCBwYXJzZSB0aGUgcmF3IHN0cmluZyB0byBhbiBhcnJheSBvZiBmZWF0dXJlIHNldHRpbmdzXHJcbiAgICAgICAgdGhhdC5zZXR1cFNldHRpbmdzKGluZGV4LCByZXNpemVJdGVtLCAndmFsdWUnKTtcclxuICAgICAgICB0aGF0LnNldHVwU2V0dGluZ3MoaW5kZXgsIHJlc2l6ZUl0ZW0sICdwb3NpdGlvbicpO1xyXG4gICAgICAgIHRoYXQuc2V0dXBTZXR0aW5ncyhpbmRleCwgcmVzaXplSXRlbSwgJ21heCcpO1xyXG4gICAgICAgIHRoYXQuc2V0dXBTZXR0aW5ncyhpbmRleCwgcmVzaXplSXRlbSwgJ21pbicpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UZW1wbGF0ZS5wcm90b3R5cGUuc2V0dXBTZXR0aW5ncyA9IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBzZXR0aW5nKSB7XHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGl0ZW1bc2V0dGluZ10pKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHV0aWwuYXBwLnBhcnNlRmVhdHVyZVN0cmluZ3MoaXRlbVtzZXR0aW5nXSwgMCk7XHJcblxyXG4gICAgICAgIC8vSWYgdGhlciBpcyBqdXN0IG9uZSB2YWx1ZSBnaXZlbiB3ZSB1c2UgaXQgZm9yIGJvdGggeCBhbmQgeVxyXG4gICAgICAgIGlmKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgdmFsdWVzWzFdID0gdmFsdWVzWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcucmVzaXplW2luZGV4XVtzZXR0aW5nXSA9IHZhbHVlcztcclxuICAgIH1cclxufTtcclxuXHJcblRlbXBsYXRlLnByb3RvdHlwZS5yZXNpemFibGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBvYmplY3QuaXNEZWZpbmVkKHRoaXMuY29uZmlnLnJlc2l6ZSk7XHJcbn07XHJcblxyXG5UZW1wbGF0ZS5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uKGNvbmZpZywgZGlhZ3JhbSkge1xyXG4gICAgdmFyIHJlc3VsdENvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKGNvbmZpZyk7XHJcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgcmVzdWx0Q29uZmlnLCBkaWFncmFtKTtcclxufTtcclxuXHJcblRlbXBsYXRlLnByb3RvdHlwZS5nZXRTVkdTdHJpbmcgPSBmdW5jdGlvbihjZmcpIHtcclxuICAgIHJldHVybiBjb25maWcucmVwbGFjZUNvbmZpZ1ZhbHVlcyh0aGlzLnN2ZywgY2ZnKTtcclxufTtcclxuXHJcblRlbXBsYXRlLnByb3RvdHlwZS5nZXRTVkdYTUwgPSBmdW5jdGlvbihjZmcpIHtcclxuICAgIHJldHVybiBkb20ucGFyc2VYTUwoZ2V0U1ZHU3RyaW5nKGNmZykpO1xyXG59O1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlLmdldEZ1bmN0aW9ucyA9IGZ1bmN0aW9uKGNmZykge1xyXG4gICAgaWYodGhpcy5mdW5jdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjb25maWcucmVwbGFjZUNvbmZpZ1ZhbHVlcyh0aGlzLmZ1bmN0aW9ucywgY2ZnKTtcclxuICAgIH1cclxufTtcclxuXHJcblRlbXBsYXRlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbihjZmcpIHtcclxuICAgIHJldHVybiBvYmplY3QuZXh0ZW5kKHt9LCB0aGlzLmNvbmZpZywgY2ZnKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGVtcGxhdGU7IiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG52YXIgY2xpZW50ID0gcmVxdWlyZSgnLi4vY29yZS9jbGllbnQnKTtcclxuXHJcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcclxuXHJcbnZhciBQQVRIX1BBTkVMUyA9ICcvdGVtcGxhdGUvcGFuZWwnO1xyXG52YXIgUEFUSF9URU1QTEFURVMgPSAnL3RlbXBsYXRlcyc7XHJcblxyXG52YXIgRVZFTlRfUEFORUxfTE9BREVEID0gJ3RlbXBsYXRlX3BhbmVsX2xvYWRlZCc7XHJcblxyXG52YXIgcGFuZWxzID0ge307XHJcbnZhciB0ZW1wbGF0ZXMgPSB7fTtcclxudmFyIHNlbGVjdGVkVGVtcGxhdGU7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgbGlzdGVuZXJzIGFuZCBsb2FkcyB0aGUgaW5pdGlhbCB0ZW1wbGF0ZSBwYW5lbHMgc2V0IGluIGRhbGFfZW52LmluaXRpYWxfdGVtcGxhdGVzIGFycmF5LlxyXG4gKi9cclxudmFyIGluaXQgPSBmdW5jdGlvbigpIHtcclxuICAgIGV2ZW50Lmxpc3Rlbignbm9kZV9zZWxlY3RlZCcsIG5vZGVTZWxlY3Rpb25MaXN0ZW5lcik7XHJcbiAgICBldmVudC5saXN0ZW4oJ3RlbXBsYXRlX3NlbGVjdCcsIHRlbXBsYXRlU2VsZWN0TGlzdGVuZXIpO1xyXG5cclxuICAgIGlmKGRhbGFfZW52LmluaXRpYWxfdGVtcGxhdGVzICYmIGRhbGFfZW52LmluaXRpYWxfdGVtcGxhdGVzLnBhbmVscykge1xyXG4gICAgICAgICQuZWFjaChkYWxhX2Vudi5pbml0aWFsX3RlbXBsYXRlcy5wYW5lbHMsIGZ1bmN0aW9uKGluZGV4LCBwYW5lbElkKSB7XHJcbiAgICAgICAgICAgIF9sb2FkUGFuZWwocGFuZWxJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgbm9kZVNlbGVjdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBfc2V0U2VsZWN0ZWRUZW1wbGF0ZShldnQuZGF0YS50ZW1wbGF0ZSk7XHJcbn07XHJcblxyXG52YXIgdGVtcGxhdGVTZWxlY3RMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgaWYoZXZ0LmRhdGEpIHtcclxuICAgICAgICBfc2V0U2VsZWN0ZWRUZW1wbGF0ZShldnQuZGF0YSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgX3NldFNlbGVjdGVkVGVtcGxhdGUgPSBmdW5jdGlvbih0bXBsSWQpIHtcclxuICAgIGlmKCFvYmplY3QuaXNEZWZpbmVkKHRtcGxJZCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbnN0YW5jZTtcclxuXHJcbiAgICBpZighb2JqZWN0LmlzU3RyaW5nKHRtcGxJZCkpIHtcclxuICAgICAgICBpZighdG1wbElkLmNvbmZpZy5wcmV2ZW50U2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkVGVtcGxhdGUgPSB0bXBsSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBnZXRUZW1wbGF0ZSh0bXBsSWQpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29uZmlnLnByZXZlbnRTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFRlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bHQgbm90IGRldGVybWluZSB0ZW1wbGF0ZTogJyt0bXBsSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3Igd2hpbGUgZGV0ZXJtaW5pbmcgdGVtcGxhdGU6ICcrdG1wbElkKycgLSAnK2Vycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB0ZW1wbGF0ZWluc3RhbmNlLCB0aGUgdGVtcGxhdGUgd2lsbCBiZSBsb2FkZWQgYW5kIGluaXRpYWxpemVkIGlmIG5vdCBsb2FkZWQgeWV0LlxyXG4gKlxyXG4gKiBAcGFyYW0gdG1wbElkXHJcbiAqIEBwYXJhbSB0bXBsUm9vdEVsXHJcbiAqIEByZXR1cm5zIHtibHVlYmlyZHxleHBvcnRzfG1vZHVsZS5leHBvcnRzfVxyXG4gKi9cclxudmFyIGdldFRlbXBsYXRlID0gZnVuY3Rpb24odG1wbElkKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIHBhbmVsSWQgPSB0bXBsSWQuc3Vic3RyaW5nKDAsIHRtcGxJZC5pbmRleE9mKCdfJykpO1xyXG4gICAgICAgIGlmKHRlbXBsYXRlc1t0bXBsSWRdKSB7IC8vVGVtcGxhdGUgaXMgbG9hZGVkXHJcbiAgICAgICAgICAgIHZhciB0bXBsID0gdGVtcGxhdGVzW3RtcGxJZF07XHJcbiAgICAgICAgICAgIGlmKCF0bXBsLmlzSW5pdGlhbGl6ZWQoKSkgeyAvL1RlbXBsYXRlIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQgc28gbG9hZCBzdmdcclxuICAgICAgICAgICAgICAgIF9sb2FkUmVtb3RlVGVtcGxhdGVTVkdhc1hNTCh0bXBsSWQsIHBhbmVsSWQpLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodG1wbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUodGVtcGxhdGVzW3RtcGxJZF0pO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vVGVtcGxhdGUgbm90IGxvYWRlZCB5ZXRcclxuICAgICAgICAgICAgdmFyIHBhbmVsSWQgPSB0bXBsSWQuc3Vic3RyaW5nKDAsIHRtcGxJZC5pbmRleE9mKCdfJykpO1xyXG4gICAgICAgICAgICBpZihwYW5lbElkKSB7IC8vTG9hZCBhbmQgaW5pdGlhbGl6ZSB0ZW1wbGF0ZVxyXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBoZXJlIHdlIGhhdmUgdG8gY29uc2lkZXIgb3RoZXIgbG9hZGluZyBtZWNoYW5pc20gYXMgZG9tIGxvYWRpbmcgLyBicm93c2VyIGNhY2hlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICBfbG9hZFJlbW90ZVRlbXBsYXRlKHBhbmVsSWQsIHRtcGxJZCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0ZW1wbGF0ZXNbdG1wbElkXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfY3JlYXRlVGVtcGxhdGUodG1wbElkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNpbXBseSByZXR1cm5zIGEgdGVtcGxhdGUgaWYgaXRzIGFscmVhZHkgbG9hZGVkLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlbXBsYXRlcyB3aGljaCBhcmUgcmVnaXN0ZXJlZFxyXG4gKiBvbiBzdGFydHVwIGFuZCBhbHJlYWR5IGxvYWRlZC5cclxuICpcclxuICogQHBhcmFtIHRtcGxJZFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbnZhciBnZXRUZW1wbGF0ZVN5bmMgPSBmdW5jdGlvbih0bXBsSWQpIHtcclxuICAgIHJldHVybiB0ZW1wbGF0ZXNbdG1wbElkXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhIHBhbmVsIGRlZmluaXRpb24gZnJvbSB0aGUgc2VydmVyLiBXaGVuIGxvYWRlZCB0aGUgcGFuZWwgd2lsbCByZWdpc3RlciBpdHNlbGYgdG8gdGhlIHRlbXBsYXRlTWFuYWdlci5cclxuICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYSBQcm9taXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGFuZWxJZFxyXG4gKiBAcmV0dXJucyB7Ymx1ZWJpcmR8ZXhwb3J0c3xtb2R1bGUuZXhwb3J0c31cclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBfbG9hZFBhbmVsID0gZnVuY3Rpb24ocGFuZWxJZCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGNsaWVudC5nZXRTY3JpcHQoUEFUSF9URU1QTEFURVMrJy8nK3BhbmVsSWQrJy8nK3BhbmVsSWQrJy5qcycsIHtcclxuICAgICAgICAgICAgc3VjY2VzcyA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvciA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA6IHtcclxuICAgICAgICAgICAgICAgIDQwNDogJ0NvdWxkIG5vdCBsb2FkIHBhbmVsICcrcGFuZWxJZCsnIGZpbGUgd2FzIG5vdCBmb3VuZCBvbiB0aGUgc2VydmVyICEnLFxyXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiAnQ291bGQgbm90IGxvYWQgcGFuZWwgJytwYW5lbElkKycgc29tZXRoaW5nIHdlbnQgd3JvbmcgISdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTG9hZHMgYSByZW1vdGUgdGFtcGxhdGUgZnJvbSB0aGUgc2VydmVyLiBXaGVuIGxvYWRlZCB0aGUgdGVtcGxhdGUgd2lsbCByZWdpc3RlciBpdHNlbGYgdG8gdGhlIHRlbXBsYXRlTWFuYWdlclxyXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBQcm9taXNlIHdpdGhvdXQgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcGFuZWxJZFxyXG4gKiBAcGFyYW0gdG1wbElkXHJcbiAqIEByZXR1cm5zIHtibHVlYmlyZHxleHBvcnRzfG1vZHVsZS5leHBvcnRzfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIF9sb2FkUmVtb3RlVGVtcGxhdGUgPSBmdW5jdGlvbihwYW5lbElkLCB0bXBsSWQsIGZldGNoU1ZHKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgY2xpZW50LmdldFNjcmlwdChQQVRIX1RFTVBMQVRFUysnLycrcGFuZWxJZCsnLycrdG1wbElkKycuanMnLCB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoZmV0Y2hTVkcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgX2xvYWRSZW1vdGVUZW1wbGF0ZVNWR2FzWE1MKHRtcGxJZCwgcGFuZWxJZCkudGhlbihyZXNvbHZlLHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yTXNnKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JNc2cpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgOiB7XHJcbiAgICAgICAgICAgICAgICA0MDQ6ICdDb3VsZCBub3QgbG9hZCB0ZW1wbGF0ZSBcIicrdG1wbElkKydcIiBmaWxlIHdhcyBub3QgZm91bmQgb24gdGhlIHNlcnZlciAhJyxcclxuICAgICAgICAgICAgICAgICdkZWZhdWx0JzogJ0NvdWxkIG5vdCBsb2FkIHRlbXBsYXRlIFwiJyt0bXBsSWQrJ1wiIHNvbWV0aGluZyB3ZW50IHdyb25nICEnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIHRlbXBsYXRlIGJ5IGNyZWF0aW5nIGEgbmV3IFRlbXBsYXRlIGluc3RhbmNlIG91dCBvZiB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0gdGVtcGxhdGVJZFxyXG4gKiBAcGFyYW0gcGFuZWxJZFxyXG4gKiBAcGFyYW0gY29uZmlnXHJcbiAqL1xyXG52YXIgcmVnaXN0ZXJUZW1wbGF0ZSA9IGZ1bmN0aW9uKHRlbXBsYXRlSWQsIGNvbmZpZykge1xyXG4gICAgX2FkZFRlbXBsYXRlKG5ldyBUZW1wbGF0ZSh0ZW1wbGF0ZUlkLCBjb25maWcpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2FkcyB0aGUgdGVtcGxhdGUgc3ZnIGFzIHhtbCBkb2N1bWVudCBmb3IgdGhlIGdpdmVuIHRtcGxJZC5cclxuICogQHBhcmFtIHRtcGxJZFxyXG4gKiBAcGFyYW0gcGFuZWxJZFxyXG4gKiBAcmV0dXJucyB7Ymx1ZWJpcmR8ZXhwb3J0c3xtb2R1bGUuZXhwb3J0c31cclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBfbG9hZFJlbW90ZVRlbXBsYXRlU1ZHYXNYTUwgPSBmdW5jdGlvbih0bXBsSWQsIHBhbmVsSWQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBjbGllbnQueG1sKCcvdGVtcGxhdGVzLycrcGFuZWxJZCsnLycrdG1wbElkKycuc3ZnJywge1xyXG4gICAgICAgICAgICBzdWNjZXNzIDogZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIF9pbml0VGVtcGxhdGUodG1wbElkLCByZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yIDogZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlIDogIHtcclxuICAgICAgICAgICAgICAgIDQwNDogJ0NvdWxkIG5vdCBsb2FkIHRlbXBsYXRlIFwiJyt0bXBsSWQrJ1wiIGZpbGUgd2FzIG5vdCBmb3VuZCBvbiB0aGUgc2VydmVyICEnLFxyXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiAnQ291bGQgbm90IGxvYWQgdGVtcGxhdGUgXCInK3RtcGxJZCsnXCIgc29tZXRoaW5nIHdlbnQgd3JvbmcgISdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG59O1xyXG5cclxudmFyIF9pbml0VGVtcGxhdGUgPSBmdW5jdGlvbih0bXBsSWQsIHN2Z1hNTCkge1xyXG4gICAgdGVtcGxhdGVzW3RtcGxJZF0uaW5pdChzdmdYTUwpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIG5ldyBwYW5lbC5cclxuICogQHBhcmFtIGNmZ1xyXG4gKi9cclxudmFyIHJlZ2lzdGVyUGFuZWwgPSBmdW5jdGlvbihjZmcpIHtcclxuICBpZihjZmcuaWQpIHtcclxuICAgICAgcGFuZWxzW2NmZy5pZF0gPSBjZmc7XHJcbiAgICAgIGV2ZW50LnRyaWdnZXIoRVZFTlRfUEFORUxfTE9BREVELCBjZmcpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBfY3JlYXRlVGVtcGxhdGUgPSBmdW5jdGlvbih0bXBsSWQsIHRtcGxSb290RWwpIHtcclxuICAgIHJldHVybiBfYWRkVGVtcGxhdGUobmV3IFRlbXBsYXRlKHRtcGxJZCwgdHJ1ZSwgdG1wbFJvb3RFbCkpO1xyXG59O1xyXG5cclxudmFyIF9hZGRUZW1wbGF0ZSA9IGZ1bmN0aW9uKHRtcGwpIHtcclxuICAgIHRlbXBsYXRlc1t0bXBsLmlkXSA9IHRtcGw7XHJcbiAgICByZXR1cm4gdG1wbDtcclxufTtcclxuXHJcbnZhciBnZXRTZWxlY3RlZFRlbXBsYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gc2VsZWN0ZWRUZW1wbGF0ZTtcclxufTtcclxuXHJcbnZhciBnZXRQYW5lbCA9IGZ1bmN0aW9uKHBhbmVsSWQpIHtcclxuICAgIHJldHVybiBwYW5lbHNbcGFuZWxJZF07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcmVnaXN0ZXJQYW5lbCA6IHJlZ2lzdGVyUGFuZWwsXHJcbiAgICByZWdpc3RlclRlbXBsYXRlIDogcmVnaXN0ZXJUZW1wbGF0ZSxcclxuICAgIGdldFBhbmVsOiBnZXRQYW5lbCxcclxuICAgIGdldFRlbXBsYXRlOiBnZXRUZW1wbGF0ZSxcclxuICAgIGdldFRlbXBsYXRlU3luYyA6IGdldFRlbXBsYXRlU3luYyxcclxuICAgIGdldFNlbGVjdGVkVGVtcGxhdGU6IGdldFNlbGVjdGVkVGVtcGxhdGUsXHJcbiAgICBpbml0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaW5pdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb3JlL2NvbmZpZycpO1xyXG5cclxudmFyIFRyYW5zaXRpb25Lbm9iTWFuYWdlciA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbktub2JNYW5hZ2VyJyk7XHJcbnZhciBUcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIgPSByZXF1aXJlKCcuL3RyYW5zaXRpb25Eb2NraW5nTWFuYWdlcicpO1xyXG52YXIgVHJhbnNpdGlvblBhdGhNYW5hZ2VyID0gcmVxdWlyZSgnLi9jdXJ2ZWRQYXRoTWFuYWdlcicpO1xyXG52YXIgdHJhbnNpdGlvbkFkZGl0aW9ucyA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbkFkZGl0aW9ucycpO1xyXG5cclxudmFyIHBhdGhNYW5hZ2VyRmFjdG9yeSA9IHJlcXVpcmUoJy4vcGF0aE1hbmFnZXJGYWN0b3J5Jyk7XHJcblxyXG52YXIgU1RZTEVfVFJBTlNJVElPTl9BQ1RJVkUgPSBcInN0cm9rZTpibHVlO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtcIjtcclxudmFyIFNUWUxFX1RSQU5TSVRJT05fSU5BQ1RJVkUgPSBcInN0cm9rZTpibGFjaztzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7XCI7XHJcbnZhciBTVFlMRV9BUkVBID0gXCJzdHJva2U6Z3JleTtzdHJva2Utb3BhY2l0eTowLjA7c3Ryb2tlLXdpZHRoOjExO2ZpbGw6bm9uZTtcIjtcclxuXHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIGRvbSA9IHV0aWwuZG9tO1xyXG5cclxudmFyIFRyYW5zaXRpb24gPSBmdW5jdGlvbihub2RlLCBzdGFydFBvc2l0aW9uKSB7XHJcbiAgICBpZihub2RlLmlzTm9kZSkge1xyXG4gICAgICAgIHRoaXMuZGlhZ3JhbSA9IG5vZGUuZGlhZ3JhbTtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gdGhpcy5kaWFncmFtLmV2ZW50O1xyXG4gICAgICAgIHRoaXMuc3ZnID0gdGhpcy5kaWFncmFtLnN2ZztcclxuICAgICAgICB0aGlzLmluaXQobm9kZSwgc3RhcnRQb3NpdGlvbik7XHJcbiAgICB9IGVsc2UgeyAvL25vZGUgPSBkaWFncmFtLCBzdGFydFBvc2l0aW9uID0gZG9tR3JvdXAgb2YgdHJhbnNpdGlvblxyXG4gICAgICAgIHRoaXMuZGlhZ3JhbSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHRoaXMuZGlhZ3JhbS5ldmVudDtcclxuICAgICAgICB0aGlzLnN2ZyA9IHRoaXMuZGlhZ3JhbS5zdmc7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZShzdGFydFBvc2l0aW9uKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnBhdGhNYW5hZ2VyLnBhdGg7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKHZhbHVlICYmIHZhbHVlICE9PSB0aGlzLnBhdGhNYW5hZ2VyLnR5cGUpIHtcclxuICAgICAgICB2YXIgbmV3UGF0aE1hbmFnZXIgPSBwYXRoTWFuYWdlckZhY3RvcnkuZ2V0KHRoaXMsIHZhbHVlKTtcclxuICAgICAgICBpZihuZXdQYXRoTWFuYWdlcikge1xyXG4gICAgICAgICAgICBuZXdQYXRoTWFuYWdlci5yZXBsYWNlKHRoaXMucGF0aE1hbmFnZXIsIHRoaXMua25vYk1hbmFnZXIuZ2V0S25vYlBvc2l0aW9ucygpKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGhNYW5hZ2VyLnR5cGU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGRvbUdyb3VwKSB7XHJcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmdyb3VwID0gJC5zdmcoZG9tR3JvdXApO1xyXG4gICAgdGhpcy5pZCA9IHRoaXMuZ3JvdXAuYXR0cignaWQnKTtcclxuXHJcbiAgICB0cmFuc2l0aW9uQWRkaXRpb25zLmluaXQodGhpcyk7XHJcblxyXG4gICAgLy9SZW1vdmUgYWxsIGV4aXN0aW5nIGtub2JzIChleGNlcHQgb3JpZW50YXRpb24ga25vYnMpXHJcbiAgICB0aGlzLmdyb3VwLiQoKS5jaGlsZHJlbignLmtub2InKS5yZW1vdmUoKTtcclxuXHJcbiAgICAvL0dldCBsaW5lIGFuZCBsaW5lYXJlYSBmcm9tIGRvbVxyXG4gICAgdGhpcy5saW5lID0gdGhpcy5nZXRMaW5lKCk7XHJcbiAgICB0aGlzLmxpbmVBcmVhID0gdGhpcy5nZXRMaW5lQXJlYSgpO1xyXG4gICAgdGhpcy5saW5lQXJlYS5kKHRoaXMubGluZS5kKCkpO1xyXG5cclxuICAgIC8vSW5pdCBNYW5hZ2VyXHJcbiAgICB0aGlzLmRvY2tpbmdNYW5hZ2VyID0gbmV3IFRyYW5zaXRpb25Eb2NraW5nTWFuYWdlcih0aGlzKS5hY3RpdmF0ZSgpO1xyXG4gICAgdGhpcy5wYXRoTWFuYWdlciA9IHBhdGhNYW5hZ2VyRmFjdG9yeS5nZXQodGhpcywgdGhpcy5ncm91cC5kYWxhKCd0cmFuc2l0aW9uVHlwZScpKS5hY3RpdmF0ZSgpO1xyXG4gICAgdGhpcy5rbm9iTWFuYWdlciA9IG5ldyBUcmFuc2l0aW9uS25vYk1hbmFnZXIodGhpcykuYWN0aXZhdGUoKTtcclxuICAgIHRoaXMuaW5pdEV2ZW50cygpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRMaW5lID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZighdGhpcy5saW5lICYmIHRoaXMuZ3JvdXApIHtcclxuICAgICAgICB0aGlzLmxpbmUgPSB0aGlzLmdldElubmVyU1ZHKCdsaW5lJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5saW5lO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0TGluZUFyZWEgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKCF0aGlzLmxpbmVBcmVhICYmIHRoaXMuZ3JvdXApIHtcclxuICAgICAgICB0aGlzLmxpbmVBcmVhID0gdGhpcy5nZXRJbm5lclNWRygnbGluZUFyZWEnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmxpbmVBcmVhO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIGEgbmV3IHRyYW5zaXRpb24gYnkgY3JlYXRpbmcgdGhlIHN2ZyBub2RlcyBhbmQgc3RhcnRkb2NraW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7dHlwZX0gbW91c2VcclxuICovXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihub2RlLCBtb3VzZSkge1xyXG4gICAgLy9UT0RPOiB1c2VyIFVVSUQubmV3IG9yIHNvbWV0aGluZ1xyXG4gICAgdGhpcy5pZCA9IHRoaXMuZGlhZ3JhbS51bmlxdWVJZCgpO1xyXG4gICAgLy9Jbml0aWFsaXplcyB0aGUgdHJhbnNpdGlvbiBncm91cCBjb250YWluZXJcclxuICAgIHRoaXMuaW5pdFNWR0dyb3VwKCk7XHJcblxyXG4gICAgdHJhbnNpdGlvbkFkZGl0aW9ucy5pbml0KHRoaXMpO1xyXG5cclxuICAgIC8vSW5pdGlhbGl6ZSB0aGUgdHJhbnNpdGlvbiBkb2NraW5nIG1lY2hhbmlzbSAoc3RhcnQvZW5kKSBkb2NraW5nIHRvIG5vZGVzLlxyXG4gICAgdGhpcy5kb2NraW5nTWFuYWdlciA9IG5ldyBUcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIodGhpcywgbm9kZSwgbW91c2UpO1xyXG4gICAgLy9Jbml0aWFsaXplIHRoZSBwYXRoIGNyZWF0b3Igd2hpY2ggY3JlYXRlcyB0aGUgcGF0aCB3aXRoIHRoZSBoZWxwIG9mIHRoZSBrbm9icyBhbmQgYSBnaXZlbiB0cmFuc2l0aW9udHlwZS5cclxuICAgIHRoaXMucGF0aE1hbmFnZXIgPSBwYXRoTWFuYWdlckZhY3RvcnkuZ2V0KHRoaXMpO1xyXG4gICAgdGhpcy5ncm91cC5kYWxhKCd0cmFuc2l0aW9uVHlwZScsIHRoaXMucGF0aE1hbmFnZXIudHlwZSk7XHJcblxyXG4gICAgLy9Jbml0aWFsaXplIHRoZSB0cmFuc2l0aW9uIGtub2IgbWVjaGFuaXNtIGZvciAoc3RhcnQvZW5kKSBhbmQgaW5uZXIga25vYnMgZm9yIG1hbmlwdWxhdGluZyB0cmFuc2l0aW9uc1xyXG4gICAgdGhpcy5rbm9iTWFuYWdlciA9IG5ldyBUcmFuc2l0aW9uS25vYk1hbmFnZXIodGhpcyk7XHJcblxyXG4gICAgLy9DYWxjdWxhdGUgc3RhcnQgcG9zaXRpb24gZm9yIG91dGVyIG9yaWVudGF0aW9uIChtb3VzZSBwb3NpdGlvbilcclxuICAgIHZhciBzdGFydERvY2tpbmdQb3NpdGlvbiA9IHRoaXMuZG9ja2luZ01hbmFnZXIuY2FsY3VsYXRlU3RhcnQobW91c2UpO1xyXG5cclxuICAgIC8vSW5pdCBrbm9iIGZvciBzdGFydFBvc2l0aW9uXHJcbiAgICB0aGlzLmV4ZWMoJ3NldFN0YXJ0Tm9kZScsIFtub2RlXSk7XHJcblxyXG4gICAgLy9DcmVhdGUgU1ZHIEVsZW1lbnRzIGluIGRvbSBhbmQgdHJhbnNpdGlvbiBldmVudHNcclxuICAgIHRoaXMuaW5pdFRyYW5zaXRpb25TVkcoKTtcclxuICAgIHRoaXMuaW5pdEV2ZW50cygpO1xyXG4gICAgdGhpcy51cGRhdGUobW91c2UpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5pbml0U1ZHR3JvdXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucm9vdCA9IHRoaXMuZ3JvdXAgPSB0aGlzLnN2Zy5nKHtcImNsYXNzXCI6J3RyYW5zaXRpb24nLCAneG1sbnM6ZGFsYSc6XCJodHRwOi8vd3d3LmRhbGEuY29tXCIsIGlkIDogdGhpcy5pZH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0U3RhcnRBbGlnbm1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSB7c291cmNlOlt0aGlzLmRvY2tpbmdNYW5hZ2VyLnN0YXJ0RG9ja2luZy5wb3NpdGlvbigpXX07XHJcbiAgICBpZighdGhpcy5rbm9iTWFuYWdlci5oYXNJbm5lcktub2JzKCkpIHtcclxuICAgICAgICByZXN1bHQudGFyZ2V0ID0gW3RoaXMuZG9ja2luZ01hbmFnZXIuZW5kRG9ja2luZy5wb3NpdGlvbigpXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0LnRhcmdldCA9IFt0aGlzLmtub2JNYW5hZ2VyLmdldEtub2IoMSkucG9zaXRpb24oKV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0RW5kQWxpZ25tZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge3NvdXJjZTpbdGhpcy5kb2NraW5nTWFuYWdlci5lbmREb2NraW5nLnBvc2l0aW9uKCldfTtcclxuICAgIGlmKCF0aGlzLmtub2JNYW5hZ2VyLmhhc0lubmVyS25vYnMoKSkge1xyXG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBbdGhpcy5kb2NraW5nTWFuYWdlci5zdGFydERvY2tpbmcucG9zaXRpb24oKV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBbdGhpcy5rbm9iTWFuYWdlci5nZXRLbm9iKC0yKS5wb3NpdGlvbigpXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMua25vYk1hbmFnZXIuc3RhcnQoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMua25vYk1hbmFnZXIuZW5kKCk7XHJcbn07XHJcblxyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0U3RhcnRMb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9ja2luZ01hbmFnZXIuc3RhcnROb2RlLmdldFJlbGF0aXZlTG9jYXRpb24odGhpcy5zdGFydCgpKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmdldEVuZExvY2F0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2NraW5nTWFuYWdlci5lbmROb2RlLmdldFJlbGF0aXZlTG9jYXRpb24odGhpcy5lbmQoKSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5kcmFnU3RhcnRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgdGhpcy5kb2NraW5nTWFuYWdlci5kcmFnU3RhcnRPcmllbnRhdGlvbihkeCwgZHkpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZHJhZ0VuZE9yaWVudGF0aW9uID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICB0aGlzLmRvY2tpbmdNYW5hZ2VyLmRyYWdFbmRPcmllbnRhdGlvbihkeCwgZHkpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuc3Ryb2tlV2lkdGggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubGluZS5zdHJva2VXaWR0aCh2YWx1ZSk7XHJcbiAgICBpZih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubGluZUFyZWEuc3Ryb2tlV2lkdGgodmFsdWUgKyAxMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0SW5uZXJTVkcgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIHJldHVybiAkLnN2Zyh0aGlzLmdldFRyYW5zaXRpb25TZWxlY3RvcihwcmVmaXgpKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmluaXRUcmFuc2l0aW9uU1ZHID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aE1hbmFnZXIucGF0aDtcclxuXHJcbiAgICAvL05vdGUgd2Ugc2hhcmUgdGhlIHBhdGggYmV0d2VlbiBsaW5lIGFuZCBsaW5lQXJlYSBhbiB1cGRhdGVcclxuICAgIHRoaXMubGluZSA9IHRoaXMuc3ZnLnBhdGgoe1xyXG4gICAgICAgIGQgOiBwYXRoLFxyXG4gICAgICAgIGlkIDogJ2xpbmVfJyt0aGlzLmlkLFxyXG4gICAgICAgIHN0eWxlICA6IFNUWUxFX1RSQU5TSVRJT05fQUNUSVZFXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmxpbmVBcmVhID0gdGhpcy5zdmcucGF0aCh7XHJcbiAgICAgICAgZCA6IHBhdGgsXHJcbiAgICAgICAgaWQ6ICdsaW5lQXJlYV8nK3RoaXMuaWQsXHJcbiAgICAgICAgc3R5bGUgIDogU1RZTEVfQVJFQVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy9UT0RPOiBtYWtlIHRoaXMgY29uZmlndXJhYmxlIGluIG5vZGUgdGVtcGxhdGUgb3Igc29tZXRoaW5nICEhIVxyXG4gICAgdGhpcy5lbmRNYXJrZXIoJ3RyaWFuZ2xlZmlsbCcpO1xyXG5cclxuICAgIHRoaXMuZ3JvdXAucHJlcGVuZCh0aGlzLmxpbmVBcmVhLCB0aGlzLmxpbmUpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuaW5pdEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5saW5lQXJlYS5ob3ZlcmFibGUoe1xyXG4gICAgICAgIGluOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5ob3ZlcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5ob3Zlck91dCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgaWYoIXRoYXQuc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkcmFnSW5pdGlhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGF0LmRpYWdyYW0uZ2V0U3RhZ2VQb3NpdGlvbihldnQucGFnZVgsIGV2dC5wYWdlWSk7XHJcbiAgICAgICAgdmFyIGtub2JJbmRleCA9IHRoYXQuZ2V0UGF0aCgpLmdldFBhdGhJbmRleEZvclBvc2l0aW9uKHN0YXJ0UG9zaXRpb24pO1xyXG5cclxuICAgICAgICBpZiAoa25vYkluZGV4KSB7XHJcbiAgICAgICAgICAgIGV2ZW50Lm9uY2UoZG9jdW1lbnQsIFwibW91c2V1cFwiLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuZGlhZ3JhbS5vZmYoJ21vdXNlbW92ZScpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhhdC5kaWFncmFtLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW92ZVBvc2l0aW9uID0gdGhhdC5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1dlIGp1c3Qgc3RhcnQgdGhlIGRyYWcgZXZlbnQgaW4gY2FzZSB3ZSBtb3ZlIG1vcmUgdGhhbnQgNXB4IGF3YXlcclxuICAgICAgICAgICAgICAgIGlmKCFkcmFnSW5pdGlhdGVkICYmIHV0aWwuYXBwLmlzTWluRGlzdChzdGFydFBvc2l0aW9uLCBtb3ZlUG9zaXRpb24sIDUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtub2IgPSB0aGF0Lmtub2JNYW5hZ2VyLmFkZEtub2Ioc3RhcnRQb3NpdGlvbiwga25vYkluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBrbm9iLmluaXREcmFnKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBkcmFnSW5pdGlhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5vd25zS25vYk5vZGUgPSBmdW5jdGlvbihrbm9iTm9kZSkge1xyXG4gICAgcmV0dXJuIHRoaXMua25vYk1hbmFnZXIub3duc0tub2JOb2RlKGtub2JOb2RlKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG1vdXNlKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUVuZChtb3VzZSk7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXJ0KG1vdXNlKTtcclxuICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICB0aGlzLmV4ZWMoJ3VwZGF0ZScsW10sIHRydWUpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmxpbmUgJiYgdGhpcy5saW5lQXJlYSkge1xyXG4gICAgICAgIHRoaXMubGluZS51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLmxpbmVBcmVhLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUudXBkYXRlU3RhcnQgPSBmdW5jdGlvbihtb3VzZSkge1xyXG4gICAgdmFyIG91dGVyT3JpZW50YXRpb24gPSBtb3VzZSB8fCB0aGlzLmtub2JNYW5hZ2VyLmdldFBvc2l0aW9uKDEpO1xyXG4gICAgdGhpcy5rbm9iTWFuYWdlci51cGRhdGVTdGFydEtub2IodGhpcy5kb2NraW5nTWFuYWdlci5jYWxjdWxhdGVTdGFydChvdXRlck9yaWVudGF0aW9uKSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS51cGRhdGVFbmQgPSBmdW5jdGlvbihtb3VzZSkge1xyXG4gICAgaWYodGhpcy5pc0luaXRTdGF0ZSgpKSB7XHJcbiAgICAgICAgbW91c2UgPSB0aGlzLmFsaWduRW5kUG9zaXRpb25Gb3JNb3VzZShtb3VzZSk7XHJcbiAgICAgICAgdGhpcy5wYXRoTWFuYWdlci5kcmFnTGluZShtb3VzZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBvdXRlck9yaWVudGF0aW9uID0gdGhpcy5rbm9iTWFuYWdlci5nZXRQb3NpdGlvbigtMik7XHJcbiAgICAgICAgdGhpcy5rbm9iTWFuYWdlci51cGRhdGVFbmRLbm9iKHRoaXMuZG9ja2luZ01hbmFnZXIuY2FsY3VsYXRlRW5kKG91dGVyT3JpZW50YXRpb24pKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmlzSW5pdFN0YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZG9ja2luZ01hbmFnZXIuZW5kTm9kZTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmFsaWduRW5kUG9zaXRpb25Gb3JNb3VzZSA9IGZ1bmN0aW9uKG1vdXNlKSB7XHJcbiAgICAvL1RoaXMgcHJldmVudHMgdGhlIGxpbmUgcmVuZGVyaW5nIHRvIG92ZXJsYXAgdGhlIGV4YWN0IG1vdXNlIHBvc2l0aW9uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHggOiAodGhpcy5rbm9iTWFuYWdlci5zdGFydEtub2IueCgpIDwgbW91c2UueCkgPyBtb3VzZS54IC0gMSA6IG1vdXNlLnggKyAxLFxyXG4gICAgICAgIHkgOiAodGhpcy5rbm9iTWFuYWdlci5zdGFydEtub2IueSgpIDwgbW91c2UueSkgPyBtb3VzZS55IC0gMSA6IG1vdXNlLnkgKyAxXHJcbiAgICB9O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuc2V0U3RhcnROb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdGhpcy5leGVjKCdzZXRTdGFydE5vZGUnLCBbbm9kZV0pO1xyXG4gICAgaWYoIXRoaXMuaXNJbml0U3RhdGUoKSkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEb21Qb3NpdGlvbigpO1xyXG4gICAgfVxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnNldEVuZE5vZGUgPSBmdW5jdGlvbihub2RlLCBtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLmV4ZWMoJ3NldEVuZE5vZGUnLCBbbm9kZSwgbW91c2VQb3NpdGlvbl0pO1xyXG4gICAgdGhpcy5jaGVja0RvbVBvc2l0aW9uKCk7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuY2hlY2tEb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG1heE5vZGVJbmRleCA9IE1hdGgubWF4KHRoaXMuZG9ja2luZ01hbmFnZXIuc3RhcnROb2RlLmluZGV4KCksIHRoaXMuZG9ja2luZ01hbmFnZXIuZW5kTm9kZS5pbmRleCgpKTtcclxuICAgIHZhciB0cmFuc2l0aW9uSW5kZXggPSB0aGlzLmluZGV4KCk7XHJcblxyXG4gICAgaWYodHJhbnNpdGlvbkluZGV4IDwgbWF4Tm9kZUluZGV4KSB7XHJcbiAgICAgICAgZG9tLmluc2VydEFmdGVySW5kZXgodGhpcy5ncm91cC5pbnN0YW5jZSgpLCBtYXhOb2RlSW5kZXgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5ncm91cC5yZW1vdmUoKTtcclxuICAgIHRoaXMuZG9ja2luZ01hbmFnZXIucmVtb3ZlKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogTmVlZGVkIGJ5IEludGVyZmFjZSBlZGl0YWJsZSAvLyBTZWUgYWJzdHJhY3RFZGl0QWRkaXRpb25cclxuICovXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihmdW5jLCBhcmdzLCBwcmV2RG9tRXZlbnQpIHtcclxuICAgIHRoaXMuZXhlY3V0ZUFkZGl0aW9uKGZ1bmMsIGFyZ3MpO1xyXG4gICAgaWYoIXByZXZEb21FdmVudCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihmdW5jLCBhcmdzKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmV4ZWN1dGVBZGRpdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMuYWRkaXRpb25zLCBmdW5jdGlvbihrZXksIGFkZGl0aW9uKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChhZGRpdGlvbikgJiYgb2JqZWN0LmlzRnVuY3Rpb24oYWRkaXRpb25bZnVuY10pKSB7XHJcbiAgICAgICAgICAgIGFkZGl0aW9uW2Z1bmNdLmFwcGx5KGFkZGl0aW9uLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ncm91cC4kKCkuaW5kZXgoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmluc3RhbmNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAuaW5zdGFuY2UoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmVuZE1hcmtlciA9IGZ1bmN0aW9uKG1hcmtlcikge1xyXG4gICAgcmV0dXJuIHRoaXMubWFya2VyKCdlbmQnLCBtYXJrZXIpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZW5kTWFya2VyVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1hcmtlclZhbHVlKCdlbmQnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnN0YXJ0TWFya2VyID0gZnVuY3Rpb24obWFya2VyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIoJ3N0YXJ0JywgbWFya2VyKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnN0YXJ0TWFya2VyVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1hcmtlclZhbHVlKCdzdGFydCcpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUubWFya2VyID0gZnVuY3Rpb24odHlwZSwgbWFya2VyKSB7XHJcbiAgICB2YXIga2V5ID0gJ21hcmtlci0nK3R5cGU7XHJcbiAgICBpZih1dGlsLm9iamVjdC5pc0RlZmluZWQobWFya2VyKSkge1xyXG4gICAgICAgIHRoaXMubGluZS5hdHRyKGtleSwgdGhpcy5nZXRNYXJrZXJWYWx1ZVN0cmluZyhtYXJrZXIpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIG1hcmtlclN0ciA9IHRoaXMubGluZS5hdHRyKGtleSk7XHJcbiAgICAgICAgaWYobWFya2VyU3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJTdHIuc3Vic3RyaW5nKDUsIG1hcmtlclN0ci5sZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5zZWxlY3RvciA9IGZ1bmN0aW9uKHByZWZpeCkge1xyXG4gICAgdmFyIHN0cmluZ1NlbGVjdG9yO1xyXG4gICAgaWYob2JqZWN0LmlzQXJyYXkocHJlZml4KSkge1xyXG4gICAgICAgIHN0cmluZ1NlbGVjdG9yID0gW107XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG9iamVjdC5lYWNoKHByZWZpeCwgZnVuY3Rpb24oaW5kZXgsIHZhbCkge1xyXG4gICAgICAgICAgICBzdHJpbmdTZWxlY3Rvci5wdXNoKHRoYXQuc2VsZWN0b3IodmFsKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RyaW5nU2VsZWN0b3IgPSBzdHJpbmdTZWxlY3Rvci5qb2luKCcsICcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzdHJpbmdTZWxlY3RvciA9IHByZWZpeDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldFRyYW5zaXRpb25TZWxlY3RvcihzdHJpbmdTZWxlY3Rvcik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uU2VsZWN0b3IgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuXHJcbiAgICBpZighdXRpbC5zdHJpbmcuc3RhcnRzV2l0aChwcmVmaXgsICcjJykgJiYgIXV0aWwuc3RyaW5nLnN0YXJ0c1dpdGgocHJlZml4LCAnLicpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gJyMnK3ByZWZpeDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcHJlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1dGlsLnN0cmluZy5lbmRzV2l0aChwcmVmaXgsICdfJylcclxuICAgICAgICA/IHJlc3VsdCArIHRoaXMuaWRcclxuICAgICAgICA6IHJlc3VsdCArICdfJyArIHRoaXMuaWQ7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5tYXJrZXJWYWx1ZSA9IGZ1bmN0aW9uKHR5cGUsIG1hcmtlcikge1xyXG4gICAgdmFyIG1hcmtlclN0cmluZyA9IHRoaXMubWFya2VyKHR5cGUsIG1hcmtlcik7XHJcbiAgICBpZihtYXJrZXJTdHJpbmcpIHsgLy8gdHJpYW5nbGVfc18xMjMxMjQyMyAtLT4gdHJpYW5nbGVfc1xyXG4gICAgICAgIHJldHVybiBtYXJrZXJTdHJpbmcuc3Vic3RyaW5nKDAsIG1hcmtlclN0cmluZy5sZW5ndGggLSB0aGlzLmRpYWdyYW0uaWQubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0TWFya2VyVmFsdWVTdHJpbmcgPSBmdW5jdGlvbihtYXJrZXJJZCkge1xyXG4gICAgbWFya2VySWQgPSAodXRpbC5zdHJpbmcuZW5kc1dpdGgobWFya2VySWQsIHRoaXMuZGlhZ3JhbS5pZCkpID8gbWFya2VySWQgOiBtYXJrZXJJZCArICdfJyArIHRoaXMuZGlhZ3JhbS5pZDtcclxuICAgIHJldHVybiAndXJsKCMnICsgbWFya2VySWQgKyAnKSc7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5hY3RpdmVTdHlsZSgpO1xyXG4gICAgdGhpcy5leGVjKCdzZWxlY3QnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmhvdmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmV4ZWMoJ2hvdmVyJyk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5ob3Zlck91dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5leGVjKCdob3Zlck91dCcpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuYWN0aXZlU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubGluZS5hdHRyKHtzdHlsZTpTVFlMRV9UUkFOU0lUSU9OX0FDVElWRX0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaW5hY3RpdmVTdHlsZSgpO1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5leGVjKCdkZXNlbGVjdCcpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuaW5hY3RpdmVTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5saW5lLmF0dHIoe3N0eWxlOlNUWUxFX1RSQU5TSVRJT05fSU5BQ1RJVkV9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZ0LCBoYW5kbGVyKSB7XHJcbiAgICB0aGlzLmxpbmVBcmVhLm9uKGV2dCwgaGFuZGxlcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmKHRoaXMubGluZUFyZWEpIHtcclxuICAgICAgICB0aGlzLmxpbmVBcmVhLnRyaWdnZXIoZXZ0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB0aGlzLmxpbmVBcmVhLm9mZihldnQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zaXRpb247IiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxudmFyIFRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3RyYW5zaXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgdHJhbnNpdGlvbmFkZGl0aW9uIGZvciBub2RlcyBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIHVwZGF0aW5nL3JlbmRlcmluZyB0aGUgaW5jb21pbmcgYW5kIG91dGdvaW5nXHJcbiAqIHRyYW5zaXRpb25zIG9mIGEgbm9kZS5cclxuICpcclxuICogQHBhcmFtIG5vZGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgVHJhbnNpdGlvbkFkZGl0aW9uID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIHRoaXMuZXZlbnQgPSBub2RlLmV2ZW50O1xyXG4gICAgdGhpcy5kaWFncmFtID0gdGhpcy5ub2RlLmRpYWdyYW07XHJcbiAgICB0aGlzLnRyYW5zaXRpb25NZ3IgPSB0aGlzLmRpYWdyYW0udHJhbnNpdGlvbk1ncjtcclxuICAgIHRoaXMub3V0Z29pbmdUcmFuc2l0aW9ucyA9IFtdO1xyXG4gICAgdGhpcy5pbmNvbWluZ1RyYW5zaXRpb25zID0gW107XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLmRyYWdNb3ZlID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICB0aGlzLnVwZGF0ZU9yaWVudGF0aW9ucyhkeCAsZHkpO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUudXBkYXRlT3JpZW50YXRpb25zID0gZnVuY3Rpb24oZHggLGR5KSB7XHJcbiAgICB0aGlzLmV4ZWN1dGVPbk91dGdvaW5nVHJhbnNpdGlvbnMoZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgICAgIHRyYW5zaXRpb24uZHJhZ1N0YXJ0T3JpZW50YXRpb24oZHgsZHkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5leGVjdXRlT25JbmNvbWluZ1RyYW5zaXRpb25zKGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgICAgICB0cmFuc2l0aW9uLmRyYWdFbmRPcmllbnRhdGlvbihkeCxkeSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZXhlY3V0ZU9uQWxsVHJhbnNpdGlvbnMoZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgICAgIHRyYW5zaXRpb24udXBkYXRlKCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmV4ZWN1dGVPbkFsbFRyYW5zaXRpb25zKGZ1bmN0aW9uKCB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbi5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5tb3ZlVXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZXhlY3V0ZU9uQWxsVHJhbnNpdGlvbnMoZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgICAgIHRyYW5zaXRpb24uY2hlY2tEb21Qb3NpdGlvbigpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTm9kZSBkYmNsaWNrIHRyaWdnZXJzIHRoZSBjcmVhdGlvbiBvZiBhIHRyYW5zaXRpb24uXHJcbiAqL1xyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLmRiY2xpY2sgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRoaXMuc3RhcnROZXdUcmFuc2l0aW9uKHVuZGVmaW5lZCwgdGhpcy5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZ0KSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBzdGFydHMgYSBuZXcgdHJhbnNpdGlvbiBlaXRoZXIgYnkgcHJvdmlkaW5nIGEgZW5kTm9kZSBvciBieSB1c2luZyB0aGUgdHJhbnNpdGlvbmRyYWdcclxuICogQHBhcmFtIGVuZE5vZGVcclxuICovXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuc3RhcnROZXdUcmFuc2l0aW9uID0gZnVuY3Rpb24oZW5kTm9kZSwgbW91c2UpIHtcclxuICAgIGlmKHRoaXMudHJhbnNpdGlvbk1nci5pc0RyYWdUcmFuc2l0aW9uKCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaWFncmFtLnRyYW5zaXRpb25NZ3IuZ2V0RHJhZ1RyYW5zaXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbk1nci5zdGFydERyYWdUcmFuc2l0aW9uKHRoaXMubm9kZSwgbW91c2UpO1xyXG5cclxuICAgIGlmKCFlbmROb2RlKSB7XHJcbiAgICAgICAgLy9JZiBubyBlbmROb2RlIHdhcyBwcm92aWRlZCB3ZSBzdGFydCB0aGUgbW91c2UgbGlzdGVuZXIgZm9yIHRoZSB0cmFuc2l0aW9uZHJhZ1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBldmVudC5vbih0aGlzLmRpYWdyYW0uc3ZnLmdldFJvb3ROb2RlKCksIFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbkRyYWcoZXZlbnQsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL0lmIGFuIGVuZE5vZGUgd2FzIHByb3ZpZGVkIHdlIGltaXRhdGUgdGhlIHRyYW5zaXRpb25kcmFnIGFuZCBzZXQgdGhlIGVuZE5vZGVcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb25EcmFnKGVuZE5vZGUuZ2V0Q2VudGVyKCkpO1xyXG4gICAgICAgIGVuZE5vZGUuYWRkaXRpb25zLnRyYW5zaXRpb24uZW5kVHJhbnNpdGlvbkRyYWcoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhbnNpdGlvbjtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbkRyYWcgPSBmdW5jdGlvbihtb3VzZSwgaXNFdnQpIHtcclxuICAgIG1vdXNlID0gKGlzRXZ0KT8gdGhpcy5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24obW91c2UpIDogbW91c2U7XHJcbiAgICAvL1VwZGF0ZSB0aGUgY3VycmVudCBkcmFnVHJhbnNpdGlvblxyXG4gICAgdGhpcy50cmFuc2l0aW9uTWdyLmdldERyYWdUcmFuc2l0aW9uKCkudXBkYXRlKG1vdXNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb2RlIG1vdXNlZG93biBlbmRzIGEgdHJhbnNpdGlvbkRyYWcgZXZlbiAoaWYgdGhlcmUgaXMgb25lKSBhbmQgc2V0cyB0aGlzIG5vZGUgYXMgZW5kbm9kZVxyXG4gKi9cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbihldnQpIHtcclxuICAgIC8vIFN0b3AgdHJhbnNpdGlvbiBkcmFnIGV2ZW50IGFuZCBzZXQgZW5kIG5vZGVcclxuICAgIGlmKHRoaXMudHJhbnNpdGlvbk1nci5pc0RyYWdUcmFuc2l0aW9uKCkpIHtcclxuICAgICAgICB0aGlzLmVuZFRyYW5zaXRpb25EcmFnKGV2dCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLmVuZFRyYW5zaXRpb25EcmFnID0gZnVuY3Rpb24obW91c2VFdnQpIHtcclxuICAgIG1vdXNlRXZ0ID0gbW91c2VFdnQgfHwgdGhpcy5ub2RlLmdldENlbnRlcigpO1xyXG4gICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25NZ3IuZ2V0RHJhZ1RyYW5zaXRpb24oKTtcclxuICAgIHRyYW5zaXRpb24uc2V0RW5kTm9kZSh0aGlzLm5vZGUsIHRoaXMuZGlhZ3JhbS5nZXRTdGFnZVBvc2l0aW9uKG1vdXNlRXZ0KSk7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25NZ3IuZW5kRHJhZ1RyYW5zaXRpb24oKTtcclxuICAgIGV2ZW50Lm9mZih0aGlzLmRpYWdyYW0uc3ZnLmdldFJvb3ROb2RlKCksICdtb3VzZW1vdmUnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuYWRkT3V0Z29pbmdUcmFuc2l0aW9uID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgdGhpcy5vdXRnb2luZ1RyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvbjtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUudW5kb2NrU3RhcnQgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB0aGlzLmVkZ2VEb2NraW5nRHJhZ0xpc3RlbmVyKHRyYW5zaXRpb24sICdTdGFydCcpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS51bmRvY2tFbmQgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB0aGlzLmVkZ2VEb2NraW5nRHJhZ0xpc3RlbmVyKHRyYW5zaXRpb24sICdFbmQnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUudW5kb2NrRWRnZURvY2tpbmcgPSBmdW5jdGlvbih0cmFuc2l0aW9uLCBkb2NraW5nVHlwZSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgLy9XZSB3YWl0IHRpbGwgdGhlIGRyYWcgZXZlbnQgc3RvcHMgKG1vdXNldXApXHJcbiAgICBldmVudC5vbmNlKHRoaXMuZGlhZ3JhbS5zdmcuZ2V0Um9vdE5vZGUoKSwgXCJtb3VzZXVwXCIsIGZ1bmN0aW9uKG1vdXNlVXBFdmVudCkge1xyXG4gICAgICAgIHZhciBtb3VzZSA9IHRoYXQuZGlhZ3JhbS5nZXRTdGFnZVBvc2l0aW9uKG1vdXNlVXBFdmVudCk7XHJcbiAgICAgICAgdmFyIGhvdmVyTm9kZSA9IHRoYXQuZGlhZ3JhbS5vdmVybGF5c05vZGUobW91c2UpO1xyXG4gICAgICAgIGlmKGhvdmVyTm9kZSAhPT0gdHJhbnNpdGlvblsnZ2V0Jytkb2NraW5nVHlwZSsnTm9kZSddKCkpIHtcclxuICAgICAgICAgICAgLy9JZiB3ZSBhcmUgaG92ZXJpbmcgYW5vdGhlciBub2RlIHdlIHN3YXAgc3RhcnQvZW5kIG5vZGVcclxuICAgICAgICAgICAgdHJhbnNpdGlvblsnc2V0Jytkb2NraW5nVHlwZSsnTm9kZSddKGhvdmVyTm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGhvdmVyTm9kZSA9PT0gdHJhbnNpdGlvblsnZ2V0Jytkb2NraW5nVHlwZSsnTm9kZSddKCkpe1xyXG4gICAgICAgICAgICAvL0lmIHdlIGFyZSBob3ZlcmluZyB0aGUgc2FtZSBub2RlIHdlIHNldCBhIHJlbGF0aXZlIGRvY2tpbmdcclxuICAgICAgICAgICAgdHJhbnNpdGlvblsnc2V0UmVsYXRpdmUnK2RvY2tpbmdUeXBlKydLbm9iJ10obW91c2UueCwgbW91c2UueSk7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24udXBkYXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9Nb3VzZSBpcyBob3ZlcmluZyBlbXB0eSBzcGFjZVxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5leGVjdXRlT25BbGxUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcclxuICAgIHRoaXMuZXhlY3V0ZU9uT3V0Z29pbmdUcmFuc2l0aW9ucyhoYW5kbGVyKTtcclxuICAgIHRoaXMuZXhlY3V0ZU9uSW5jb21pbmdUcmFuc2l0aW9ucyhoYW5kbGVyKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuZXhlY3V0ZU9uT3V0Z29pbmdUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMub3V0Z29pbmdUcmFuc2l0aW9ucywgZnVuY3Rpb24oaW5kZXgsIHRyYW5zaXRpb24pIHtcclxuICAgICAgICBpZih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIodHJhbnNpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLmV4ZWN1dGVPbkluY29taW5nVHJhbnNpdGlvbnMgPSBmdW5jdGlvbihoYW5kbGVyKSB7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLmluY29taW5nVHJhbnNpdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgaWYodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBoYW5kbGVyKHRyYW5zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uQWxpZ25tZW50VGFyZ2V0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5vdXRnb2luZ1RyYW5zaXRpb25zLCBmdW5jdGlvbihpbmRleCwgdHJhbnNpdGlvbikge1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQodHJhbnNpdGlvbikpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHJhbnNpdGlvbi5nZXRTdGFydEFsaWdubWVudCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLmluY29taW5nVHJhbnNpdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKG9iamVjdC5pc0RlZmluZWQodHJhbnNpdGlvbikpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHJhbnNpdGlvbi5nZXRFbmRBbGlnbm1lbnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5yZW1vdmVPdXRnb2luZ1RyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLm91dGdvaW5nVHJhbnNpdGlvbnMuaW5kZXhPZih0cmFuc2l0aW9uKTtcclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICB0aGlzLm91dGdvaW5nVHJhbnNpdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuYWRkSW5jb21pbmdUcmFuc2l0aW9uID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgdGhpcy5pbmNvbWluZ1RyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLnJlbW92ZUluY29taW5nVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuaW5jb21pbmdUcmFuc2l0aW9ucy5pbmRleE9mKHRyYW5zaXRpb24pO1xyXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHRoaXMuaW5jb21pbmdUcmFuc2l0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnJlcXVpcmVDb25maWcgPSBmYWxzZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbkFkZGl0aW9uO1xyXG5cclxuIiwidmFyIGFkZGl0aW9ucyA9IHJlcXVpcmUoJy4vYWRkaXRpb25zJyk7XHJcblxyXG4vL0luaXQgZGVmYXVsdCBhZGRpdGlvbnNcclxuYWRkaXRpb25zLnJlZ2lzdGVyVHJhbnNpdGlvbkFkZGl0aW9uKCd0ZXh0JywgcmVxdWlyZSgnLi90cmFuc2l0aW9uVGV4dEFkZGl0aW9uJykpO1xyXG5hZGRpdGlvbnMucmVnaXN0ZXJUcmFuc2l0aW9uQWRkaXRpb24oJ2VkaXQnLCByZXF1aXJlKCcuL2VkaXRUcmFuc2l0aW9uQWRkaXRpb24nKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGluaXQgOiBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgYWRkaXRpb25zLmluaXRUcmFuc2l0aW9uQWRkaXRpb24oJ3RleHQnLCB0cmFuc2l0aW9uKTtcclxuICAgICAgICBhZGRpdGlvbnMuaW5pdFRyYW5zaXRpb25BZGRpdGlvbignZWRpdCcsIHRyYW5zaXRpb24pO1xyXG4gICAgfVxyXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBLbm9iID0gcmVxdWlyZSgnLi9Lbm9iJyk7XHJcbnZhciBkb2NraW5nVHlwZSA9IHJlcXVpcmUoJy4vZG9ja2luZycpO1xyXG5cclxudmFyIFRyYW5zaXRpb25Eb2NraW5nID0gZnVuY3Rpb24oZG9ja2luZ01hbmFnZXIsIG5vZGUsIG1vdXNlLCB0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IGRvY2tpbmdNYW5hZ2VyLnRyYW5zaXRpb247XHJcbiAgICAgICAgdGhpcy5kb2NraW5nTWFuYWdlciA9IGRvY2tpbmdNYW5hZ2VyO1xyXG4gICAgICAgIGlmKCFub2RlLmtub2IpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0T3JpZW50YXRpb24obW91c2UpO1xyXG4gICAgICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nLnByb3RvdHlwZS5pbml0T3JpZW50YXRpb24gPSBmdW5jdGlvbihzdGFydFBvc2l0aW9uKSB7XHJcbiAgICB2YXIgb3JpZW50YXRpb25Qb3NpdGlvbiA9IF9nZXRTdGFydE9yaWVudGF0aW9uUG9zaXRpb24odGhpcy5ub2RlLCBzdGFydFBvc2l0aW9uKTtcclxuICAgIHRoaXMua25vYiA9IG5ldyBLbm9iKHRoaXMudHJhbnNpdGlvbi5kaWFncmFtLCBvcmllbnRhdGlvblBvc2l0aW9uLCB7J2Nzc0NsYXNzJzonb3JpZW50YXRpb25Lbm9iJywgJ2ZpbGwtYWN0aXZlJzonb3JhbmdlJywgZmlsbDonb3JhbmdlJywgc2VsZWN0YWJsZTpmYWxzZX0sIHRoaXMudHJhbnNpdGlvbi5ncm91cCk7XHJcbiAgICB0aGlzLmluaXRLbm9iRXZlbnRzKCk7XHJcbn07XHJcblxyXG52YXIgX2dldFN0YXJ0T3JpZW50YXRpb25Qb3NpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIG1vdXNlKSB7XHJcbiAgICB2YXIgb3JpZW50YXRpb25UeXBlID0gKG5vZGUuY29uZmlnLmRvY2tpbmcgJiYgbm9kZS5jb25maWcuZG9ja2luZy5vcmllbnRhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5vZGUuY29uZmlnLmRvY2tpbmcub3JpZW50YXRpb24gOiAnY2VudGVyJztcclxuICAgIHN3aXRjaChvcmllbnRhdGlvblR5cGUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgIGNhc2UgJ0ZSRUUnOlxyXG4gICAgICAgICAgICByZXR1cm4gbW91c2U7XHJcbiAgICAgICAgY2FzZSAgJ0NFTlRFUic6XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0Q2VudGVyKCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmcucHJvdG90eXBlLmluaXRLbm9iRXZlbnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGlzLmtub2IuZHJhZ2dhYmxlKHtcclxuICAgICAgICByZXN0cmljdGlvblggOiBmdW5jdGlvbihldnQsIGR4LCBkeSkge1xyXG4gICAgICAgICAgICB2YXIgZHJhZ0NlbnRlciA9IHRoYXQua25vYi5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICBkcmFnQ2VudGVyLnggKz0gZHg7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGF0Lm5vZGUub3ZlcmxheXMoZHJhZ0NlbnRlcikgPyBkeCA6IDA7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIChkb2NraW5nVHlwZS5jaGVja09yaWVudGF0aW9uQm91bmRhcnkodGhhdC5ub2RlLCBkcmFnQ2VudGVyKSkgPyBkeCA6IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXN0cmljdGlvblkgOiBmdW5jdGlvbihldnQsIGR4LCBkeSkge1xyXG4gICAgICAgICAgICB2YXIgZHJhZ0NlbnRlciA9IHRoYXQua25vYi5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICBkcmFnQ2VudGVyLnkgKz0gZHk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGF0Lm5vZGUub3ZlcmxheXMoZHJhZ0NlbnRlcikgPyBkeSA6IDA7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIChkb2NraW5nVHlwZS5jaGVja09yaWVudGF0aW9uQm91bmRhcnkodGhhdC5ub2RlLCBkcmFnQ2VudGVyKSkgPyBkeSA6IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmFnQWxpZ25tZW50IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vV2UgYWxpZ24gb3VyIGtub2IgY2VudGVyIHRvIHRoZSBub2RlIGNlbnRlciBhbmQgYWxzbyB0byBvdXIgdHJhbnNpdGlvbiBhbGlnbm1lbnQgcG9pbnRcclxuICAgICAgICAgICAgdmFyIGFsaWdubWVudCA9ICh0aGF0LnR5cGUgPT09ICdzdGFydCcpXHJcbiAgICAgICAgICAgICAgICA/IHRoYXQudHJhbnNpdGlvbi5nZXRTdGFydEFsaWdubWVudCgpIDogdGhhdC50cmFuc2l0aW9uLmdldEVuZEFsaWdubWVudCgpO1xyXG4gICAgICAgICAgICBhbGlnbm1lbnQudGFyZ2V0LnB1c2godGhhdC5ub2RlLmdldENlbnRlcigpKTtcclxuICAgICAgICAgICAgcmV0dXJuIFthbGlnbm1lbnRdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhZ01vdmUgOiBmdW5jdGlvbihldnQsIGR4ICxkeSkge1xyXG4gICAgICAgICAgICB0aGF0LnRyYW5zaXRpb24udXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZy5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKHRoaXMua25vYikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtub2IucG9zaXRpb24oKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDZW50ZXIoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nLnByb3RvdHlwZS50cmlnZ2VyRHJhZyA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgaWYodGhpcy5rbm9iKSB7XHJcbiAgICAgICAgdGhpcy5rbm9iLnRyaWdnZXJEcmFnKGR4LCBkeSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZy5wcm90b3R5cGUuY2FsY3VsYXRlRG9ja2luZ1Bvc2l0aW9uID0gZnVuY3Rpb24ob3V0ZXJPcmllbnRhdGlvbikge1xyXG4gICAgaWYodGhpcy5ub2RlLmtub2IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldENlbnRlcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvY2tpbmdUeXBlLmNhbGN1bGF0ZURvY2tpbmdQb3NpdGlvbih0aGlzLm5vZGUsIG91dGVyT3JpZW50YXRpb24sIHRoaXMucG9zaXRpb24oKSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZy5wcm90b3R5cGUuaW5hY3RpdmVTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5rbm9iKSB7XHJcbiAgICAgICAgdGhpcy5rbm9iLmluYWN0aXZlU3R5bGUoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmtub2IpIHtcclxuICAgICAgICB0aGlzLmtub2IuaGlkZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5rbm9iKSB7XHJcbiAgICAgICAgdGhpcy5rbm9iLnJlbW92ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIFRyYW5zaXRpb25Eb2NraW5nTWFuYWdlciA9IGZ1bmN0aW9uKHRyYW5zaXRpb24sIHN0YXJ0Tm9kZSwgbW91c2UpIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IHRyYW5zaXRpb24uZGlhZ3JhbTtcclxuICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcblxyXG4gICAgaWYoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGFydE5vZGUoc3RhcnROb2RlLCBtb3VzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy50cmFuc2l0aW9uLmFkZGl0aW9uc1snZG9ja2luZ01hbmFnZXInXSA9IHtcclxuICAgICAgICBzZXRFbmROb2RlIDogZnVuY3Rpb24obm9kZSwgbW91c2VQb3NpdGlvbikge1xyXG4gICAgICAgICAgICB0aGF0LnNldEVuZE5vZGUobm9kZSwgbW91c2VQb3NpdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTdGFydE5vZGUgOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2V0U3RhcnROb2RlKG5vZGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VsZWN0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuaW5hY3RpdmVTdHlsZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzZWxlY3QgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5oaWRlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBob3ZlciA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LmluYWN0aXZlU3R5bGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhvdmVyT3V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGF0LnRyYW5zaXRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY3VycmVudE9yaWVudGF0aW9uTm9kZXMgPSB0aGlzLnRyYW5zaXRpb24uZ3JvdXAuJCgpLmNoaWxkcmVuKCcub3JpZW50YXRpb25Lbm9iJyk7XHJcbiAgICB0aGlzLnNldFN0YXJ0Tm9kZSh0aGlzLmRpYWdyYW0uZ2V0Tm9kZUJ5SWQodGhpcy5nZXRTdGFydE5vZGVGZWF0dXJlKCkpKTtcclxuICAgIHRoaXMuc2V0RW5kTm9kZSh0aGlzLmRpYWdyYW0uZ2V0Tm9kZUJ5SWQodGhpcy5nZXRFbmROb2RlRmVhdHVyZSgpKSk7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAkLmVhY2goY3VycmVudE9yaWVudGF0aW9uTm9kZXMsIGZ1bmN0aW9uKGluZGV4LCBvcmllbnRhdGlvbk5vZGUpIHtcclxuICAgICAgICB2YXIgc3ZnTm9kZSA9ICQuc3ZnKG9yaWVudGF0aW9uTm9kZSk7XHJcbiAgICAgICAgaWYodGhhdC5zdGFydE5vZGUub3ZlcmxheXMoc3ZnTm9kZS5wb3NpdGlvbigpKSkge1xyXG4gICAgICAgICAgICB0aGF0LnN0YXJ0RG9ja2luZy5rbm9iLm1vdmVUbyhzdmdOb2RlLnBvc2l0aW9uKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGF0LmVuZE5vZGUub3ZlcmxheXMoc3ZnTm9kZS5wb3NpdGlvbigpKSkge1xyXG4gICAgICAgICAgICB0aGF0LmVuZERvY2tpbmcua25vYi5tb3ZlVG8oc3ZnTm9kZS5wb3NpdGlvbigpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RldGVjdGVkIG9yaWVudGF0aW9uIGtub2Igbm90IGhvdmVyaW5nIGEgc3RhcnQvZW5kIG5vZGUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN2Z05vZGUucmVtb3ZlKCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5zZXRTdGFydE5vZGUgPSBmdW5jdGlvbihub2RlLCBtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICBpZih0aGlzLnN0YXJ0Tm9kZSAmJiB0aGlzLnN0YXJ0Tm9kZS5pZCA9PT0gbm9kZS5pZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSBpZih0aGlzLnN0YXJ0Tm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhcnROb2RlLnJlbW92ZU91dGdvaW5nVHJhbnNpdGlvbih0aGlzLnRyYW5zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuc3RhcnREb2NraW5nKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydERvY2tpbmcucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGFydE5vZGUgPSBub2RlO1xyXG4gICAgdGhpcy5zdGFydE5vZGUuYWRkT3V0Z29pbmdUcmFuc2l0aW9uKHRoaXMudHJhbnNpdGlvbik7XHJcbiAgICB0aGlzLnN0YXJ0RG9ja2luZyA9IG5ldyBUcmFuc2l0aW9uRG9ja2luZyh0aGlzLCBub2RlLCBtb3VzZVBvc2l0aW9uLCAnc3RhcnQnKTtcclxuICAgIHRoaXMuc2V0U3RhcnROb2RlRmVhdHVyZSgpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGFydE5vZGVGZWF0dXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLmdyb3VwLmRhbGEoJ3N0YXJ0Jyk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLnNldFN0YXJ0Tm9kZUZlYXR1cmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudHJhbnNpdGlvbi5ncm91cC5kYWxhKCdzdGFydCcsIHRoaXMuc3RhcnROb2RlLmlkKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nTWFuYWdlci5wcm90b3R5cGUuY2FsY3VsYXRlU3RhcnQgPSBmdW5jdGlvbihvdXRlck9yaWVudGF0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGFydERvY2tpbmcuY2FsY3VsYXRlRG9ja2luZ1Bvc2l0aW9uKG91dGVyT3JpZW50YXRpb24pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5kcmFnU3RhcnRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKGR4LGR5KSB7XHJcbiAgICB0aGlzLnN0YXJ0RG9ja2luZy50cmlnZ2VyRHJhZyhkeCxkeSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLnNldEVuZE5vZGUgPSBmdW5jdGlvbihub2RlLCBtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICBpZih0aGlzLmVuZE5vZGUpIHtcclxuICAgICAgICB0aGlzLmVuZE5vZGUucmVtb3ZlSW5jb21pbmdUcmFuc2l0aW9uKHRoaXMudHJhbnNpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5lbmREb2NraW5nKSB7XHJcbiAgICAgICAgdGhpcy5lbmREb2NraW5nLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZW5kTm9kZSA9IG5vZGU7XHJcbiAgICB0aGlzLmVuZE5vZGUuYWRkSW5jb21pbmdUcmFuc2l0aW9uKHRoaXMudHJhbnNpdGlvbik7XHJcbiAgICB0aGlzLmVuZERvY2tpbmcgPSBuZXcgVHJhbnNpdGlvbkRvY2tpbmcodGhpcywgbm9kZSwgbW91c2VQb3NpdGlvbiwgJ2VuZCcpO1xyXG4gICAgdGhpcy5zZXRFbmROb2RlRmVhdHVyZSgpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5kcmFnRW5kT3JpZW50YXRpb24gPSBmdW5jdGlvbihkeCxkeSkge1xyXG4gICAgdGhpcy5lbmREb2NraW5nLnRyaWdnZXJEcmFnKGR4LGR5KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nTWFuYWdlci5wcm90b3R5cGUuY2FsY3VsYXRlRW5kID0gZnVuY3Rpb24ob3V0ZXJPcmllbnRhdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuZW5kRG9ja2luZy5jYWxjdWxhdGVEb2NraW5nUG9zaXRpb24ob3V0ZXJPcmllbnRhdGlvbik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmdldEVuZE5vZGVGZWF0dXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLmdyb3VwLmRhbGEoJ2VuZCcpO1xyXG59O1xyXG5cclxuXHJcblRyYW5zaXRpb25Eb2NraW5nTWFuYWdlci5wcm90b3R5cGUuc2V0RW5kTm9kZUZlYXR1cmUgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKHRoaXMuZW5kTm9kZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbi5ncm91cC5kYWxhKCdlbmQnLCB0aGlzLmVuZE5vZGUuaWQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5pbmFjdGl2ZVN0eWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnN0YXJ0RG9ja2luZy5pbmFjdGl2ZVN0eWxlKCk7XHJcbiAgICBpZih0aGlzLmVuZERvY2tpbmcpIHtcclxuICAgICAgICB0aGlzLmVuZERvY2tpbmcuaW5hY3RpdmVTdHlsZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnN0YXJ0RG9ja2luZy5oaWRlKCk7XHJcbiAgICBpZih0aGlzLmVuZERvY2tpbmcpIHtcclxuICAgICAgICB0aGlzLmVuZERvY2tpbmcuaGlkZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKHRoaXMuc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vZGUucmVtb3ZlT3V0Z29pbmdUcmFuc2l0aW9uKHRoaXMudHJhbnNpdGlvbik7XHJcbiAgICAgICAgdGhpcy5zdGFydERvY2tpbmcucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5lbmROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5lbmROb2RlLnJlbW92ZUluY29taW5nVHJhbnNpdGlvbih0aGlzLnRyYW5zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuZW5kRG9ja2luZy5yZW1vdmUoKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyOyIsIi8qKlxyXG4gKiBUaGlzIG1vZHVsZSBtYW5hZ2VzIHRoZSB0cmFuc2l0aW9uIGRhdGEgbGlrZSBrbm9icyBhbmQgcGF0aGRhdGEuXHJcbiAqXHJcbiAqL1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgS25vYiA9IHJlcXVpcmUoJy4va25vYicpO1xyXG52YXIgRHJhZ0FsaWdubWVudCA9IHJlcXVpcmUoJy4vZHJhZ0FsaWdubWVudCcpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcblxyXG52YXIgZG9tID0gdXRpbC5kb207XHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxuXHJcbnZhciBUcmFuc2l0aW9uS25vYk1hbmFnZXIgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xyXG4gICAgdGhpcy5kb2NraW5nTWFuYWdlciA9IHRyYW5zaXRpb24uZG9ja2luZ01hbmFnZXI7XHJcbiAgICB0aGlzLmV2ZW50ID0gdHJhbnNpdGlvbi5ldmVudDtcclxuICAgIHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMudHJhbnNpdGlvbi5hZGRpdGlvbnNbJ2tub2JNYW5hZ2VyJ10gPSB7XHJcbiAgICAgICAgc2V0RW5kTm9kZSA6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGtub2IgPSAodGhhdC5pc0luaXRTdGF0ZSgpKSA/IHRoYXQuYWRkS25vYihub2RlLmdldENlbnRlcigpKSA6IHRoYXQuZ2V0RW5kS25vYigpO1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS5rbm9iKSB7XHJcbiAgICAgICAgICAgICAgICBrbm9iLmhvdmVyYWJsZShmYWxzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrbm9iLmhvdmVyYWJsZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0U3RhcnROb2RlIDogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICB2YXIga25vYiA9ICh0aGF0LmlzSW5pdFN0YXRlKCkpID8gdGhhdC5hZGRLbm9iKG5vZGUuZ2V0Q2VudGVyKCksIDApIDogdGhhdC5nZXRTdGFydEtub2IoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKG5vZGUua25vYikge1xyXG4gICAgICAgICAgICAgICAga25vYi5ob3ZlcmFibGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAga25vYi5ob3ZlcmFibGUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlbGVjdCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LmluYWN0aXZlU3R5bGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc2VsZWN0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG92ZXIgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5pbmFjdGl2ZVN0eWxlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBob3Zlck91dCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZighdGhhdC50cmFuc2l0aW9uLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmtub2JzID0gW107XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcG9seW5vbXMgPSB0aGlzLnRyYW5zaXRpb24uZ2V0TGluZSgpLmQoKS5wb2x5bm9tcygpO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBvbHlub21zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHRvID0gcG9seW5vbXNbaV07XHJcbiAgICAgICAgdGhpcy5hZGRLbm9iKHRvLCBpLCB0cnVlLCAoaSA9PT0gMCB8fCBpID09PSBwb2x5bm9tcy5sZW5ndGggLSAxKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuYWRkS25vYiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCwgYWN0aXZhdGUsIGlzQm91bmRhcnlLbm9iKSB7XHJcbiAgICB2YXIgaW5kZXggPSBpbmRleCB8fCB0aGlzLnNpemUoKTtcclxuICAgIHZhciBpc0JvdW5kYXJ5S25vYiA9ICghYWN0aXZhdGUpPyB0aGlzLmlzSW5pdFN0YXRlKCkgOiBpc0JvdW5kYXJ5S25vYjtcclxuICAgIHZhciBrbm9iID0gdGhpcy5pbml0S25vYihpbmRleCwgcG9zaXRpb24sIGlzQm91bmRhcnlLbm9iKTtcclxuICAgIHRoaXMua25vYnMuc3BsaWNlKGluZGV4LCAwLCBrbm9iKTtcclxuXHJcbiAgICBpZihpbmRleCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnRLbm9iID0ga25vYjtcclxuICAgIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IGlzQm91bmRhcnlLbm9iKSB7XHJcbiAgICAgICAgdGhpcy5lbmRLbm9iID0ga25vYjtcclxuICAgIH1cclxuXHJcbiAgICBpZighYWN0aXZhdGUgJiYgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgIC8vV2UgZG8gbm90IG5lZWQgYXRvIGFkZCBhbiBhZGRpdGlvbmFsIHBhdGhwYXJ0IGZvciB0aGUgZW5kbm9kZTtcclxuICAgICAgICB0aGlzLmdldFBhdGhNYW5hZ2VyKCkuYWRkUGF0aFBhcnQoaW5kZXgsIHBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZighYWN0aXZhdGUpIHtcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb24ucmVkcmF3KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga25vYjtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuaW5pdEtub2IgPSBmdW5jdGlvbihrbm9iSW5kZXgsIHBvc2l0aW9uLCBpc0JvdW5kYXJ5S25vYikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdmFyIGtub2JDb25maWcgPSB7XHJcbiAgICAgICAgcmFkaXVzOjUsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogIWlzQm91bmRhcnlLbm9iLFxyXG4gICAgICAgIGZpbGw6ICAgICAgIGlzQm91bmRhcnlLbm9iID8gJ2dyZWVuJyA6ICdzaWx2ZXInXHJcbiAgICB9O1xyXG4gICAgdmFyIGtub2IgPSBuZXcgS25vYih0aGlzLnRyYW5zaXRpb24uZGlhZ3JhbSwgcG9zaXRpb24sIGtub2JDb25maWcsIHRoaXMudHJhbnNpdGlvbi5ncm91cCk7XHJcbiAgICBrbm9iLnRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb247XHJcbiAgICB2YXIgaW5pdGlhbERyYWcgPSB0cnVlO1xyXG5cclxuICAgIGlmKCFpc0JvdW5kYXJ5S25vYikge1xyXG4gICAgICAgIGtub2IuZHJhZ2dhYmxlKHtcclxuICAgICAgICAgICAgZHJhZ0FsaWdubWVudCA6IG5ldyBEcmFnQWxpZ25tZW50KHRoYXQudHJhbnNpdGlvbi5kaWFncmFtLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBbe3NvdXJjZTogW2tub2IucG9zaXRpb24oKV0sIHRhcmdldDogdGhhdC5nZXRKb2luaW5nT3JpZW50YXRpb24oa25vYil9XTt9KSxcclxuICAgICAgICAgICAgZHJhZ01vdmUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vV2UganVzdCB1cGRhdGUgYm91bmRhcnkga25vYnMgaWYgdGhleSBhcmUgbm90IGluIHdpdGhpbiBtdWx0aXNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgaWYoISh0aGF0LnRyYW5zaXRpb24uZGlhZ3JhbS5pc011bHRpU2VsZWN0aW9uKCkgJiYgdGhhdC5pc0JvdW5kYXJ5SW5kZXgoa25vYkluZGV4KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZUtub2IodGhhdC5nZXRJbmRleEZvcktub2Ioa25vYiksIGtub2IucG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50cmFuc2l0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnRW5kIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZihpbml0aWFsRHJhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZXZlbnQudHJpZ2dlcigndHJhbnNpdGlvbl9kb2NraW5nX2NyZWF0ZWQnLCB7J3RyYW5zaXRpb24nOnRoYXQudHJhbnNpdGlvbi5pZCwgJ2RvY2tpbmdJbmRleCc6a25vYkluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERyYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKCd0cmFuc2l0aW9uX2RvY2tpbmdfZHJvcHBlZCcsIHsndHJhbnNpdGlvbic6dGhhdC50cmFuc2l0aW9uLmlkLCAnZG9ja2luZ0luZGV4Jzprbm9iSW5kZXh9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBrbm9iLmRyYWdnYWJsZSh7XHJcbiAgICAgICAgICAgIHByZXZlbnRBbGlnbm1lbnQgOiB0cnVlLFxyXG4gICAgICAgICAgICBkcmFnTW92ZSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy9XZSBqdXN0IHVwZGF0ZSBib3VuZGFyeSBrbm9icyBpZiB0aGV5IGFyZSBub3QgaW4gd2l0aGluIG11bHRpc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZighdGhhdC50cmFuc2l0aW9uLmRpYWdyYW0uaXNNdWx0aVNlbGVjdGlvbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZXRQYXRoTWFuYWdlcigpLnVwZGF0ZVBhcnQodGhhdC5nZXRJbmRleEZvcktub2Ioa25vYiksIGtub2IucG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50cmFuc2l0aW9uLnJlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnRW5kIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE86IGN1cnJlbnRseSB0aGUgZ2V0Tm9kZUJ5UG9zaXRpb24gZnVuY3Rpb24gZG9lcyByZXR1cm4gdGhlIGZpcnN0IG5vZGUgZm91bmQgbm90IHRoZSBvbmUgd2l0aCB0aGUgaGlnaGVzdCBpbmRleC4uLlxyXG4gICAgICAgICAgICAgICAgdmFyIGhvdmVyTm9kZSA9IHRoYXQudHJhbnNpdGlvbi5kaWFncmFtLmdldE5vZGVCeVBvc2l0aW9uKGtub2IucG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICBpZihrbm9iSW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50cmFuc2l0aW9uLnNldEVuZE5vZGUoaG92ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50cmFuc2l0aW9uLnNldFN0YXJ0Tm9kZShob3Zlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAga25vYi5vbignZGVzZWxlY3QnLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZih0aGF0LnRyYW5zaXRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAga25vYi5pbmFjdGl2ZVN0eWxlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAga25vYi5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAga25vYi5vbigncmVtb3ZlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhhdC5yZW1vdmVLbm9iKGtub2IpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy9UbyBwcmV2ZW50IGhpZGluZyB0aGUgaG92ZXJrbm9icyB3ZSBhZG9idCB0aGUgdHJhbnNpdGlvbiBob3ZlcmluZ1xyXG4gICAga25vYi5ob3ZlcmFibGUoe1xyXG4gICAgICAgIGluIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbi5ob3ZlcigpO1xyXG4gICAgICAgICAgICBpZigha25vYi5pc1NlbGVjdGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIGtub2IuZmlsbCgnIzlFOUU5RScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvdXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC50cmFuc2l0aW9uLmhvdmVyT3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ga25vYjtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5pc0luaXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpIDwgMjtcclxufVxyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTdGFydEtub2IgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgdGhpcy51cGRhdGVLbm9iKDAsIHBvc2l0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUudXBkYXRlRW5kS25vYiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUtub2IoLTEsIHBvc2l0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUudXBkYXRlS25vYiA9IGZ1bmN0aW9uKGtub2JJbmRleCwgcG9zaXRpb24pIHtcclxuICAgIGtub2JJbmRleCA9IG9iamVjdC5nZXRJbmRleCh0aGlzLmtub2JzLCBrbm9iSW5kZXgpO1xyXG5cclxuICAgIC8vIE5vdGUgdGhlIGZvbGxvd2luZyBpcyBvbmx5IG5lY2Nlc3NhcnkgZm9yIGJvdW5kYXJ5IGtub2JzIGJ1dCB3b24ndCBhZmZlY3Qgb3RoZXIga25vYnMgc2luY2UgdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgICAvLyBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBrbm9iIHBvc2l0aW9uIGFmdGVyIGRyYWcuXHJcbiAgICB0aGlzLmtub2JzW2tub2JJbmRleF0ubW92ZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBwYXRoXHJcbiAgICB0aGlzLmdldFBhdGhNYW5hZ2VyKCkudXBkYXRlUGFydChrbm9iSW5kZXgsIHBvc2l0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlS25vYiA9IGZ1bmN0aW9uKGtub2IpIHtcclxuICAgIGlmKCF0aGlzLnRyYW5zaXRpb24ucmVtb3ZlZCkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGb3JLbm9iKGtub2IpO1xyXG4gICAgICAgIHRoaXMua25vYnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB0aGlzLmdldFBhdGhNYW5hZ2VyKCkucmVtb3ZlUGF0aFBhcnQoaW5kZXgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbi51cGRhdGUoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMua25vYnMubGVuZ3RoO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5sYXN0SW5kZXggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNpemUoKSAtIDE7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmhhc0lubmVyS25vYnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmtub2JzLmxlbmd0aCA+IDI7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5rbm9icywgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZURvY2tpbmdNYXJrZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudHJhbnNpdGlvbi5ncm91cC4kKCkuY2hpbGRyZW4oJy5kb2NraW5nJykucmVtb3ZlKCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmlzQm91bmRhcnlLbm9iID0gZnVuY3Rpb24oa25vYikge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNCb3VuZGFyeUluZGV4KHRoaXMuZ2V0SW5kZXhGb3JLbm9iKGtub2IpKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuaXNCb3VuZGFyeUluZGV4ID0gZnVuY3Rpb24oa25vYkluZGV4KSB7XHJcbiAgICByZXR1cm4ga25vYkluZGV4ID09PSAwIHx8IGtub2JJbmRleCA9PT0gdGhpcy5sYXN0SW5kZXgoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0Sm9pbmluZ0RvY2tpbmdzID0gZnVuY3Rpb24oZG9ja2luZykge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleEZvcktub2IoZG9ja2luZyk7XHJcbiAgICByZXR1cm4gW3RoaXMua25vYnNbaW5kZXggLSAxXSwgdGhpcy5rbm9ic1tpbmRleCArIDFdXTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0Sm9pbmluZ09yaWVudGF0aW9uID0gZnVuY3Rpb24oa25vYikge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleEZvcktub2Ioa25vYik7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBpZihpbmRleCA8PSAxKSB7IC8vc3RhcnQgb3Igc2Vjb25kIGRvY2tpbmdcclxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnRyYW5zaXRpb24uZG9ja2luZ01hbmFnZXIuc3RhcnREb2NraW5nLnBvc2l0aW9uKCkpO1xyXG4gICAgfSBlbHNlIGlmKGluZGV4ICE9PSAwKXtcclxuICAgICAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLmtub2JzW2luZGV4IC0gMV0ucG9zaXRpb24oKTtcclxuICAgICAgICByZXN1bHQucHVzaCh7eCA6IG9yaWVudGF0aW9uLngsIHkgOiBvcmllbnRhdGlvbi55fSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoaW5kZXggPj0gdGhpcy5rbm9icy5sZW5ndGggLTIpIHsgLy9lbmQgb3Igb25lIGJlZm9yZSBlbmQgZG9ja2luZ1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMudHJhbnNpdGlvbi5kb2NraW5nTWFuYWdlci5lbmREb2NraW5nLnBvc2l0aW9uKCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLmtub2JzW2luZGV4ICsgMV0ucG9zaXRpb24oKTtcclxuICAgICAgICByZXN1bHQucHVzaCh7eCA6IG9yaWVudGF0aW9uLngsIHkgOiBvcmllbnRhdGlvbi55fSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0SW5kZXhGb3JLbm9iID0gZnVuY3Rpb24oa25vYikge1xyXG4gICAgcmV0dXJuIHRoaXMua25vYnMuaW5kZXhPZihrbm9iKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0S25vYlBvc2l0aW9ucyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5rbm9icywgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUucG9zaXRpb24oKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmdldFN0YXJ0S25vYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0S25vYigwKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0RW5kS25vYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0S25vYigtMSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRLbm9iKDApLnBvc2l0aW9uKCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0S25vYigtMSkucG9zaXRpb24oKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0S25vYiA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICByZXR1cm4gb2JqZWN0LnZhbHVlQnlJbmRleCh0aGlzLmtub2JzLCBpbmRleCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMua25vYnMsIGZ1bmN0aW9uKGluZGV4LCBrbm9iKSB7XHJcbiAgICAgICAgaWYoIWtub2IuaXNTZWxlY3RlZCgpKSB7XHJcbiAgICAgICAgICAgIGtub2IuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5pbmFjdGl2ZVN0eWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLmtub2JzLCBmdW5jdGlvbihpbmRleCwga25vYikge1xyXG4gICAgICAgIGlmKCFrbm9iLmlzU2VsZWN0ZWQoKSkge1xyXG4gICAgICAgICAgICBrbm9iLmluYWN0aXZlU3R5bGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUub3duc0tub2JOb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIG5vZGUucm9vdC4kKCkucGFyZW50KCkuYXR0cignaWQnKSA9PT0gdGhpcy50cmFuc2l0aW9uLmdyb3VwLiQoKS5hdHRyKCdpZCcpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICBpZihpbmRleCA8IHRoaXMuc2l6ZSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdC52YWx1ZUJ5SW5kZXgodGhpcy5rbm9icywgaW5kZXgpLnBvc2l0aW9uKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmdldFBhdGhNYW5hZ2VyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLnBhdGhNYW5hZ2VyO1xyXG59XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmlzSW5pdFN0YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZW5kS25vYjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uS25vYk1hbmFnZXI7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciB4bWwgPSByZXF1aXJlKCcuLi91dGlsL3htbCcpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcbnZhciBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi90cmFuc2l0aW9uJyk7XHJcblxyXG52YXIgQWJzdHJhY3RNYW5hZ2VyID0gcmVxdWlyZSgnLi9hYnN0cmFjdE1hbmFnZXInKTtcclxuXHJcbnZhciBFVlRfVFJBTlNJVElPTl9BRERFRCA9IFwidHJhbnNpdGlvbl9hZGRlZFwiO1xyXG52YXIgRVZUX1RSQU5TSVRJT05fU0VMRUNURUQgPSAndHJhbnNpdGlvbl9zZWxlY3RlZCc7XHJcbnZhciBFVlRfVFJBTlNJVElPTl9ERVNFTEVDVEVEID0gJ3RyYW5zaXRpb25fZGVzZWxlY3RlZCc7XHJcbnZhciBFVlRfVFJBTlNJVElPTl9SRU1PVkVEID0gJ3RyYW5zaXRpb25fcmVtb3ZlZCc7XHJcblxyXG52YXIgQ01EX0FERCA9IFwidHJhbnNpdGlvbl9hZGRcIjtcclxudmFyIENNRF9ERUwgPSBcInRyYW5zaXRpb25fZGVsZXRlXCI7XHJcbnZhciBDTURfRE9DX0NSRUFURUQgPSBcInRyYW5zaXRpb25fZG9jX2NyZWF0ZWRcIjtcclxudmFyIENNRF9ET0NfRFJPUFBFRCA9IFwidHJhbnNpdGlvbl9kb2NfZHJvcHBlZFwiO1xyXG52YXIgQ01EX0VESVQgPSBcInRyYW5zaXRpb25fZWRpdFwiO1xyXG5cclxudmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24oZGlhZ3JhbSkge1xyXG4gICAgLy8gQ29udGFpbnMgYWxsIG5vZGVzIGFkZGVkIHRvIHRoZSBkaWFncmFtXHJcbiAgICBBYnN0cmFjdE1hbmFnZXIuY2FsbCh0aGlzLCBkaWFncmFtKTtcclxuXHJcbiAgICB0aGlzLnRyYW5zaXRpb25zID0ge307XHJcbiAgICB0aGlzLmRpYWdyYW0gPSBkaWFncmFtO1xyXG4gICAgZXZlbnQubGlzdGVuKCd0cmFuc2l0aW9uX2RlbGV0ZScsIHRoaXMuZGVsZXRlVHJhbnNpdGlvbkxpc3RlbmVyLCB0aGlzKTtcclxuICAgIGV2ZW50Lmxpc3RlbigndHJhbnNpdGlvbl9kb2NraW5nX2NyZWF0ZWQnLCB0aGlzLnRyYW5zaXRpb25Eb2NraW5nQ3JlYXRlZExpc3RlbmVyLCB0aGlzKTtcclxuICAgIGV2ZW50Lmxpc3RlbigndHJhbnNpdGlvbl9kb2NraW5nX2Ryb3BwZWQnLCB0aGlzLnRyYW5zaXRpb25Eb2NraW5nRHJvcExpc3RlbmVyLCB0aGlzKTtcclxuXHJcbiAgICBldmVudC5saXN0ZW4oJ3RyYW5zaXRpb25fZWRpdCcsIHRoaXMuZWRpdFRyYW5zaXRpb25MaXN0ZW5lciwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5jb21tYW5kKENNRF9BREQsIHRoaXMuaW1wb3J0VHJhbnNpdGlvbiwgdGhpcy5kZWxldGVUcmFuc2l0aW9uKTtcclxuICAgIHRoaXMuY29tbWFuZChDTURfREVMLCB0aGlzLmRlbGV0ZVRyYW5zaXRpb24sIHRoaXMuaW1wb3J0VHJhbnNpdGlvbik7XHJcbiAgICB0aGlzLmNvbW1hbmQoQ01EX0RPQ19DUkVBVEVELCB0aGlzLmltcG9ydFRyYW5zaXRpb24sIHRoaXMuZGVsZXRlS25vYik7XHJcbiAgICB0aGlzLmNvbW1hbmQoQ01EX0RPQ19EUk9QUEVELCB0aGlzLmRyb3BEb2NraW5nLCB0aGlzLmRyb3BEb2NraW5nKTtcclxuICAgIHRoaXMuY29tbWFuZChDTURfRE9DX0RST1BQRUQsIHRoaXMuZHJvcERvY2tpbmcsIHRoaXMuZHJvcERvY2tpbmcpO1xyXG4gICAgdGhpcy5jb21tYW5kKENNRF9FRElULCB0aGlzLmVkaXRUcmFuc2l0aW9uLCB0aGlzLnVuZG9FZGl0KTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoVHJhbnNpdGlvbk1hbmFnZXIsIEFic3RyYWN0TWFuYWdlcik7XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuZWRpdFRyYW5zaXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLmdldFRyYW5zaXRpb24oZXZ0LmRhdGEudHJhbnNpdGlvbik7XHJcbiAgICB2YXIga2V5ID0gZXZ0LmRhdGEua2V5O1xyXG4gICAgdmFyIG9sZFZhbHVlID0gdHJhbnNpdGlvbi5hZGRpdGlvbnMuZWRpdC5nZXRWYWx1ZShrZXkpO1xyXG4gICAgdGhpcy5leGVjKENNRF9FRElULCBbdHJhbnNpdGlvbi5pZCwga2V5LCBldnQuZGF0YS52YWx1ZV0sIFt0cmFuc2l0aW9uLmlkLCBrZXksIG9sZFZhbHVlXSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuZWRpdFRyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uLCBrZXksIHZhbHVlKSB7XHJcbiAgICB0cmFuc2l0aW9uID0gdGhpcy5nZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG4gICAgdHJhbnNpdGlvbi5hZGRpdGlvbnMuZWRpdC5zZXRWYWx1ZShrZXksIHZhbHVlKTtcclxuICAgIGV2ZW50LnRyaWdnZXIoJ3RyYW5zaXRpb25fZWRpdGVkJywgdHJhbnNpdGlvbik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUudW5kb0VkaXQgPSBmdW5jdGlvbih0cmFuc2l0aW9uLCBrZXksIHZhbHVlKSB7XHJcbiAgICB0cmFuc2l0aW9uID0gdGhpcy5nZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG4gICAgdHJhbnNpdGlvbi5hZGRpdGlvbnMuZWRpdC5zZXRWYWx1ZShrZXksIHZhbHVlKTtcclxuICAgIGV2ZW50LnRyaWdnZXIoJ3RyYW5zaXRpb25fZWRpdF91bmRvJywgdHJhbnNpdGlvbik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUudHJhbnNpdGlvbkRvY2tpbmdEcm9wTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmIChldnQuZGF0YSkge1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gZXZ0LmRhdGEudHJhbnNpdGlvbjtcclxuICAgICAgICB2YXIgZG9ja2luZ0luZGV4ID0gZXZ0LmRhdGEuZG9ja2luZ0luZGV4O1xyXG4gICAgICAgIHZhciBkb2NraW5nID0gdGhpcy5nZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pLmtub2JNYW5hZ2VyLmdldEtub2IoZG9ja2luZ0luZGV4KTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRDbWQoQ01EX0RPQ19EUk9QUEVELFxyXG4gICAgICAgICAgICBbdHJhbnNpdGlvbiwgZG9ja2luZ0luZGV4LCBkb2NraW5nLm5vZGUucm9vdC5keFN1bSwgZG9ja2luZy5ub2RlLnJvb3QuZHlTdW1dLFxyXG4gICAgICAgICAgICBbdHJhbnNpdGlvbiwgZG9ja2luZ0luZGV4LCAoLTEgKiBkb2NraW5nLm5vZGUucm9vdC5keFN1bSksICgtMSAqIGRvY2tpbmcubm9kZS5yb290LmR5U3VtKV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmRyb3BEb2NraW5nID0gZnVuY3Rpb24odHJhbnNpdGlvbiwgZG9ja2luZ0luZGV4LCBkeFN1bSwgZHlTdW0pIHtcclxuICAgIHRyYW5zaXRpb24gPSB0aGlzLmdldFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbiAgICBpZih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIGRvY2tpbmcgPSB0cmFuc2l0aW9uLmtub2JNYW5hZ2VyLmdldEtub2IoZG9ja2luZ0luZGV4KTtcclxuICAgICAgICBkb2NraW5nLnRyaWdnZXJEcmFnKGR4U3VtLCBkeVN1bSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUudHJhbnNpdGlvbkRvY2tpbmdDcmVhdGVkTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmIChldnQuZGF0YSkge1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gZXZ0LmRhdGEudHJhbnNpdGlvbjtcclxuICAgICAgICB2YXIgZG9ja2luZ0luZGV4ID0gZXZ0LmRhdGEuZG9ja2luZ0luZGV4O1xyXG4gICAgICAgIHRoaXMuYWRkQ21kKENNRF9ET0NfQ1JFQVRFRCwgW3RoaXMuZ2V0VHJhbnNpdGlvblN0cmluZyh0cmFuc2l0aW9uKSwgdHJhbnNpdGlvbl0sIFt0cmFuc2l0aW9uLCBkb2NraW5nSW5kZXhdKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVLbm9iID0gZnVuY3Rpb24odHJhbnNpdGlvbiwgZG9ja2luZ0luZGV4KSB7XHJcbiAgICB0cmFuc2l0aW9uID0gdGhpcy5nZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG4gICAgaWYodHJhbnNpdGlvbikge1xyXG4gICAgICAgIHRyYW5zaXRpb24ua25vYk1hbmFnZXIuZ2V0S25vYihkb2NraW5nSW5kZXgpLnJlbW92ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmltcG9ydFRyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uU3RyLCB0cmFuc2l0aW9uKSB7XHJcbiAgICBpZih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbiA9IHRoaXMuZ2V0VHJhbnNpdGlvbih0cmFuc2l0aW9uKVxyXG4gICAgICAgIGlmKHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxldGVUcmFuc2l0aW9uKHRyYW5zaXRpb24uaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHJhbnNpdGlvbkVsZW1lbnQgPSB0aGlzLmRpYWdyYW0uaW1wb3J0KHRyYW5zaXRpb25TdHIpO1xyXG4gICAgdGhpcy5hY3RpdmF0ZVRyYW5zaXRpb24odHJhbnNpdGlvbkVsZW1lbnQpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRvQWN0aXZhdGUpIHtcclxuICAgIGlmKG9iamVjdC5pc0FycmF5KHRvQWN0aXZhdGUpKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBvYmplY3QuZWFjaCh0b0FjdGl2YXRlLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5hY3RpdmF0ZVRyYW5zaXRpb24oJCh0aGlzKS5nZXQoMCkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSBlbHNlICB7IC8vdG9BY3RpdmF0ZSBpcyBkb21FbGVtZW50XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkVHJhbnNpdGlvbihuZXcgVHJhbnNpdGlvbih0aGlzLmRpYWdyYW0sIHRvQWN0aXZhdGUpKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5pc0RyYWdUcmFuc2l0aW9uID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgcmV0dXJuIG9iamVjdC5pc0RlZmluZWQodGhpcy5kcmFnVHJhbnNpdGlvbik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnREcmFnVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIG1vdXNlKSB7XHJcbiAgICBtb3VzZSA9IG1vdXNlIHx8IG5vZGUuZ2V0Q2VudGVyKCk7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnVHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKG5vZGUsIG1vdXNlKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXREcmFnVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ1RyYW5zaXRpb247XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuZW5kRHJhZ1RyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuYWRkVHJhbnNpdGlvbih0aGlzLmRyYWdUcmFuc2l0aW9uKTtcclxuICAgIGRlbGV0ZSB0aGlzLmRyYWdUcmFuc2l0aW9uO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZFRyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGlzLmV2ZW50LnRyaWdnZXIoRVZUX1RSQU5TSVRJT05fQURERUQsIHRyYW5zaXRpb24pO1xyXG4gICAgdHJhbnNpdGlvbi5vbignc2VsZWN0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKEVWVF9UUkFOU0lUSU9OX1NFTEVDVEVELCB0cmFuc2l0aW9uKTtcclxuICAgIH0pLm9uKCdkZXNlbGVjdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoYXQuZXZlbnQudHJpZ2dlcihFVlRfVFJBTlNJVElPTl9ERVNFTEVDVEVELCB0cmFuc2l0aW9uKTtcclxuICAgIH0pLm9uKCdyZW1vdmUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGF0LmV2ZW50LnRyaWdnZXIoRVZUX1RSQU5TSVRJT05fUkVNT1ZFRCwgdHJhbnNpdGlvbik7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuYWRkQ21kKENNRF9BREQsIFt0aGlzLmdldFRyYW5zaXRpb25TdHJpbmcodHJhbnNpdGlvbildLCBbdHJhbnNpdGlvbi5pZF0pO1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbnNbdHJhbnNpdGlvbi5pZF0gPSB0cmFuc2l0aW9uO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zaXRpb25TdHJpbmcgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB0cmFuc2l0aW9uID0gdGhpcy5nZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG4gICAgcmV0dXJuIHhtbC5zZXJpYWxpemVUb1N0cmluZyh0cmFuc2l0aW9uLmluc3RhbmNlKCkpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVRyYW5zaXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgaWYoZXZ0LmRhdGEpIHtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGV2dC5kYXRhO1xyXG4gICAgICAgIHRoaXMuZXhlYyhDTURfREVMLCBbdHJhbnNpdGlvbi5pZF0sIFt0aGlzLmdldFRyYW5zaXRpb25TdHJpbmcodHJhbnNpdGlvbildKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5nZXRUcmFuc2l0aW9uKGlkKTtcclxuICAgIGlmKHRyYW5zaXRpb24pIHtcclxuICAgICAgICBkZWxldGUgdGhpcy50cmFuc2l0aW9uc1tpZF07XHJcbiAgICAgICAgdHJhbnNpdGlvbi5yZW1vdmUoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhpZCkgJiYgIWlzTmFOKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zW3BhcnNlSW50KGlkKV07XHJcbiAgICB9IGVsc2UgaWYoIWlzTmFOKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zW2lkXTtcclxuICAgIH0gZWxzZSBpZihpZCBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcclxuICAgICAgICAvL1dlIGFzc3VtZSBhIG5vZGUgaW5zdGFuY2VcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignZ2V0VHJhbnNpdGlvbiBjYWxsIHdpdGggbm8gcmVzdWx0IGZvciA6JytpZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zaXRpb25NYW5hZ2VyOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxuXHJcbnZhciBOT0RFX0RJU1RBTkNFID0gMTE7XHJcbnZhciBUUkFOU0lUSU9OX0RJU1RBTkNFID0gMTA7XHJcbnZhciBERUZfVEVYVF9IRUlHSFQgPSAxMztcclxuXHJcbnZhciBUcmFuc2l0aW9uVGV4dEFkZGl0aW9uID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgdGhpcy50ZXh0Tm9kZXMgPSBbXTtcclxuICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcbiAgICB0aGlzLmRpYWdyYW0gPSB0aGlzLnRyYW5zaXRpb24uZGlhZ3JhbTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgdXBkYXRlIGFkZGl0aW9uIGZ1bmN0aW9uIHJlcmVuZGVycyBhbGwgY29udGFpbmluZyB0ZXh0bm9kZXMgYnkgbWVhbnNcclxuICogb2YgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBzZXR0aW5ncy4gVGhpcyBmdW5jdGlvbiBpcyBkZWxlZ2F0ZWQgYnlcclxuICogdGhlIHRyYW5zaXRpb24gYXMgYWRkaXRpb24gY2FsbC5cclxuICovXHJcblRyYW5zaXRpb25UZXh0QWRkaXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy50ZXh0Tm9kZXMsIGZ1bmN0aW9uKGluZGV4LCB0ZXh0U1ZHKSB7XHJcbiAgICAgICAgaWYodGV4dFNWRykge1xyXG4gICAgICAgICAgICB0aGF0LnVwZGF0ZVRleHRQb3NpdGlvbihpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uVGV4dEFkZGl0aW9uLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24ocG9zKSB7XHJcbiAgICBpZih0aGlzLnRleHROb2Rlc1twb3NdKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dE5vZGVzW3Bvc10uJCgpLnRleHQoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSB0ZXh0IGZvciBhIGdpdmVuIHBvc2l0aW9uLiBJZiB0aGUgZ2l2ZW4gdGV4dCBwb3NpdGlvbiBpcyBub3RcclxuICogb2NjdXBpZWQgeWV0IHdlIGNyZWF0ZSBhIG5ldyB0ZXh0bm9kZS5cclxuICovXHJcblRyYW5zaXRpb25UZXh0QWRkaXRpb24ucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbihwb3MsIHRleHQpIHtcclxuICAgIGlmKCF0aGlzLnRleHROb2Rlc1twb3NdKSB7XHJcbiAgICAgICAgdmFyIGlkID0gJ3RleHQnK3BvcysnXycrdGhpcy50cmFuc2l0aW9uLmlkO1xyXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IHRoaXMudGV4dE5vZGVzW3Bvc10gPSB0aGlzLmRpYWdyYW0uc3ZnLnRleHQodGV4dCwge2lkIDogaWR9KS5oYW5naW5nKGZhbHNlKTtcclxuICAgICAgICB0aGlzLmRpYWdyYW0uc3ZnLmFkZFRvR3JvdXAodGhpcy50cmFuc2l0aW9uLmdyb3VwLCB0ZXh0Tm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudGV4dE5vZGVzW3Bvc10uY29udGVudCh0ZXh0KTtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlVGV4dFBvc2l0aW9uKHBvcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgdGV4dG5vZGUgcG9zaXRpb24gYW5kIGFuY2hvciBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGJ5IG1lYW5zIG9mIHRoZSBjdXJyZW50XHJcbiAqIHRyYW5zaXRpb24gc2V0dGluZ3MuXHJcbiAqL1xyXG5UcmFuc2l0aW9uVGV4dEFkZGl0aW9uLnByb3RvdHlwZS51cGRhdGVUZXh0UG9zaXRpb24gPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0VGV4dFBvc2l0aW9uKHBvcyk7XHJcblxyXG4gICAgLy9Gb3Igc29tZSBwb2ludHMgdGhlIHBvc2l0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkIG1haW5seSBvbiB0aGUgbm9kZSBjb3JuZXJcclxuICAgIGlmKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0Tm9kZXNbcG9zXS5tb3ZlVG8ocG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuc2V0QW5jaG9yKHBvcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uVGV4dEFkZGl0aW9uLnByb3RvdHlwZS5nZXRUZXh0UG9zaXRpb24gPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIHZhciB0ZXh0UG9zaXRpb247XHJcblxyXG4gICAgdmFyIHRleHRIZWlnaHQgPSB0aGlzLmdldFRleHRIZWlnaHQocG9zKTtcclxuXHJcbiAgICBpZihpc1N0YXJ0UG9zKHBvcykgfHwgaXNFbmRQb3MocG9zKSkge1xyXG4gICAgICAgIC8vTW92ZSBhbG9uZyB0aGUgdHJhbnNpdGlvbiBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uIHRoZSBpbmRleCAtMSBzZWFyY2hlcyB0aGUgbGFzdCB0cmFuc2l0aW9uUGFydFxyXG4gICAgICAgIHZhciBpbmRleCA9IGlzRW5kUG9zKHBvcykgPyAtMSA6IDE7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaXNFbmRQb3MocG9zKSA/IE5PREVfRElTVEFOQ0UgKiAtMSA6IE5PREVfRElTVEFOQ0U7XHJcbiAgICAgICAgdGV4dFBvc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uLmdldFBhdGgoKS5tb3ZlQWxvbmcoaW5kZXgsIGRpc3RhbmNlKTtcclxuXHJcbiAgICAgICAgc3dpdGNoKHRoaXMuZ2V0TG9jYXRpb24ocG9zKSkge1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uLnkgKz0gKGlzVG9wKHBvcykpID8gLVRSQU5TSVRJT05fRElTVEFOQ0UgOiBUUkFOU0lUSU9OX0RJU1RBTkNFICsgKHRleHRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24ueCArPSAoaXNUb3AocG9zKSkgPyBUUkFOU0lUSU9OX0RJU1RBTkNFIDogLVRSQU5TSVRJT05fRElTVEFOQ0U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vTWlkIFBvc2l0aW9uXHJcbiAgICAgICAgdGV4dFBvc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uLmdldFBhdGgoKS5nZXRDZW50ZXIoKTtcclxuICAgICAgICB0ZXh0UG9zaXRpb24ueSArPSBpc1RvcChwb3MpID8gVFJBTlNJVElPTl9ESVNUQU5DRSAqIC0xIDogVFJBTlNJVElPTl9ESVNUQU5DRSArIHRleHRIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRleHRQb3NpdGlvbjtcclxufTtcclxuXHJcblRyYW5zaXRpb25UZXh0QWRkaXRpb24ucHJvdG90eXBlLmdldFRleHRIZWlnaHQgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIHJldHVybiAodGhpcy50ZXh0Tm9kZXNbcG9zXSkgPyB0aGlzLnRleHROb2Rlc1twb3NdLmhlaWdodCgpIDogREVGX1RFWFRfSEVJR0hUO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvblRleHRBZGRpdGlvbi5wcm90b3R5cGUuZ2V0QWxpZ25Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgaWYoaXNTdGFydFBvcyhwb3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5zdGFydCgpO1xyXG4gICAgfSBlbHNlIGlmKGlzRW5kUG9zKHBvcykpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLmVuZCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvblRleHRBZGRpdGlvbi5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIGlmKGlzU3RhcnRQb3MocG9zKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24uZ2V0U3RhcnRMb2NhdGlvbigpO1xyXG4gICAgfSBlbHNlIGlmKGlzRW5kUG9zKHBvcykpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLmdldEVuZExvY2F0aW9uKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHRoZSB0ZXh0LWFuY2hvciBieSBtZWFucyBvZiB0aGUgY3VycmVudFxyXG4gKiBub2RlIGxvY2F0aW9uIHRvIGFzc3VyZSB0aGUgdGV4dCBpcyBub3Qgb3ZlcmxhcHBpbmcgb3RoZXIgdGV4dHMgb3IgdGhlXHJcbiAqIG5vZGUgaXRzZWxmLlxyXG4gKi9cclxuVHJhbnNpdGlvblRleHRBZGRpdGlvbi5wcm90b3R5cGUuc2V0QW5jaG9yID0gZnVuY3Rpb24ocG9zKSB7XHJcbiAgICB2YXIgdGV4dFNWRyA9IHRoaXMudGV4dE5vZGVzW3Bvc107XHJcbiAgICBpZighaXNNaWRQb3MocG9zKSkge1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLmdldExvY2F0aW9uKHBvcykpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICB0ZXh0U1ZHLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgIHRleHRTVkcuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgaWYoaXNCb3R0b20ocG9zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRTVkcuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRTVkcuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGV4dFNWRy5taWRkbGUoKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBpc0JvdHRvbSA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgcmV0dXJuICFpc1RvcChwb3MpO1xyXG59O1xyXG5cclxudmFyIGlzVG9wID0gZnVuY3Rpb24ocG9zKSB7XHJcbiAgICByZXR1cm4gcG9zICUgMiA9PT0gMDtcclxufTtcclxuXHJcbnZhciBpc1N0YXJ0UG9zID0gZnVuY3Rpb24ocG9zKSB7XHJcbiAgICByZXR1cm4gcG9zIDwgMjtcclxufTtcclxuXHJcbnZhciBpc01pZFBvcyA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgcmV0dXJuICFpc1N0YXJ0UG9zKHBvcykgJiYgIWlzRW5kUG9zKHBvcyk7XHJcbn07XHJcblxyXG52YXIgaXNFbmRQb3MgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIHJldHVybiBwb3MgPiAzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uVGV4dEFkZGl0aW9uO1xyXG4iLCJ2YXIgeG1sID0gcmVxdWlyZSgnLi4vdXRpbC94bWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcblxyXG52YXIgZWxlbWVudENhY2hlID0ge307XHJcblxyXG52YXIgY3JlYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcywgdGV4dCkge1xyXG4gICAgdmFyICRlbGVtZW50ID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpKTtcclxuXHJcbiAgICBpZihhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgJC5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICRlbGVtZW50LmF0dHIoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGV4dCkge1xyXG4gICAgICAgICRlbGVtZW50LnRleHQodGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJGVsZW1lbnQ7XHJcbn07XHJcblxyXG52YXIgcXVlcnkgPSBmdW5jdGlvbihzZWxlY3RvciwgY2FjaGUpIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBpZihjYWNoZSkge1xyXG4gICAgICAgIHJlc3VsdCA9ICQucUNhY2hlKHNlbGVjdG9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gJChzZWxlY3Rvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIGdldEpRdWVyeU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICBpZighbm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIFRoZSBub2RlIGlzIGVpdGhlciBhIGRvbSBub2RlIG9yIGEgc2VsZWN0b3JcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgIHJldHVybiBxdWVyeShub2RlKTtcclxuICAgIH0gZWxzZSBpZihub2RlLmdldEF0dHJpYnV0ZSl7XHJcbiAgICAgICAgdmFyIGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICAgICAgaWYoaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQucUNhY2hlKCcjJytub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSwgdHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmKG5vZGUualF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGUuZy4gZG9jdW1lbnQsIHdpbmRvdy4uLlxyXG4gICAgICAgIHJldHVybiAkKG5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIG1vdmVEb3duID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyICRub2RlID0gZ2V0SlF1ZXJ5Tm9kZShub2RlKTtcclxuICAgICRub2RlLmJlZm9yZSgkbm9kZS5uZXh0KCkpO1xyXG59O1xyXG5cclxudmFyIG1vdmVVcCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHZhciAkbm9kZSA9IGdldEpRdWVyeU5vZGUobm9kZSk7XHJcbiAgICAkbm9kZS5hZnRlcigkbm9kZS5wcmV2KCkpO1xyXG59O1xyXG5cclxudmFyIGluc2VydEFmdGVySW5kZXggPSBmdW5jdGlvbihub2RlLCBpbmRleCkge1xyXG4gICAgdmFyICRub2RlID0gZ2V0SlF1ZXJ5Tm9kZShub2RlKTtcclxuICAgICRub2RlLnBhcmVudCgpLmNoaWxkcmVuKCkuZXEoaW5kZXgpLmFmdGVyKCRub2RlKTtcclxufTtcclxuXHJcbnZhciBpbnNlcnRTVkdBZnRlciA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZWxlbWVudCwgdGV4dCwgaW5zZXJ0QWZ0ZXIpIHtcclxuICAgIHRleHQgPSB0ZXh0IHx8IGVsZW1lbnQudGV4dDtcclxuICAgIGRlbGV0ZSBlbGVtZW50LnRleHQ7XHJcbiAgICByZXR1cm4gYWRkU1ZHRWxlbWVudChjb250YWluZXIsZWxlbWVudCx0ZXh0LGluc2VydEFmdGVyKTtcclxufTtcclxuXHJcbnZhciBwcmVwZW5kU1ZHRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZWxlbWVudCwgdGV4dCkge1xyXG4gICAgdGV4dCA9IHRleHQgfHwgZWxlbWVudC50ZXh0O1xyXG4gICAgZGVsZXRlIGVsZW1lbnQudGV4dDtcclxuICAgIHJldHVybiBhZGRTVkdFbGVtZW50KGNvbnRhaW5lcixlbGVtZW50LHRydWUsdGV4dCk7XHJcbn07XHJcblxyXG52YXIgYXBwZW5kU1ZHRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZWxlbWVudCwgdGV4dCkge1xyXG4gICAgdGV4dCA9IHRleHQgfHwgZWxlbWVudC50ZXh0O1xyXG4gICAgZGVsZXRlIGVsZW1lbnQudGV4dDtcclxuICAgIHJldHVybiBhZGRTVkdFbGVtZW50KGNvbnRhaW5lcixlbGVtZW50LGZhbHNlLHRleHQpO1xyXG59O1xyXG5cclxudmFyIHByZXBlbmRUb1Jvb3QgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBpZighZWxlbWVudC5yb290Lmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICAgIGVsZW1lbnQuaW5zdGFuY2UoZWxlbWVudC5yb290LmFwcGVuZENoaWxkKGVsZW1lbnQuaW5zdGFuY2UoKSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtZW50Lmluc3RhbmNlKGVsZW1lbnQucm9vdC5pbnNlcnRCZWZvcmUoZWxlbWVudC5pbnN0YW5jZSgpLCBlbGVtZW50LnJvb3QuY2hpbGROb2Rlc1swXSkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGFkZFNWR0VsZW1lbnQgPSBmdW5jdGlvbihjb250YWluZXIsIGVsZW1lbnQsIHByZXBlbmQsIHRleHQsIGluc2VydEFmdGVyKSB7XHJcbiAgICBwcmVwZW5kID0gKG9iamVjdC5pc0RlZmluZWQocHJlcGVuZCkpPyBwcmVwZW5kIDogZmFsc2U7XHJcbiAgICAvLyBJZiBvbmx5IHRoZSBjb250YWluZXIgaXMgZ2l2ZW4gd2UgYXNzdW1lIGl0cyBhbiBTVkdFbGVtZW50IG9iamVjdCB3aXRoIGNvbnRhaW5lZCByb290IG5vZGVcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoY29udGFpbmVyKSAmJiAhb2JqZWN0LmlzRGVmaW5lZChlbGVtZW50KSkge1xyXG4gICAgICAgIGVsZW1lbnQgPSBjb250YWluZXI7XHJcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmdldFJvb3ROb2RlKCk7XHJcbiAgICB9IGVsc2UgaWYob2JqZWN0LmlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgICAgICBjb250YWluZXIgPSBxdWVyeShjb250YWluZXIpWzBdO1xyXG4gICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5pbnN0YW5jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnN0YW5jZTtcclxuXHJcbiAgICBpZighZWxlbWVudC5pbnN0YW5jZSB8fCAhb2JqZWN0LmlzRGVmaW5lZChlbGVtZW50Lmluc3RhbmNlKCkpKSB7XHJcbiAgICAgICAgaW5zdGFuY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBlbGVtZW50LnRhZ05hbWUpO1xyXG4gICAgICAgICQuZWFjaChlbGVtZW50LmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlID0gZWxlbWVudC5pbnN0YW5jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQodGV4dCkpIHtcclxuICAgICAgICB2YXIgdHh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xyXG4gICAgICAgIGluc3RhbmNlLmFwcGVuZENoaWxkKHR4dE5vZGUpO1xyXG4gICAgfVxyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChpbnNlcnRBZnRlcikpIHtcclxuICAgICAgICAvL2lmIHRoZSBwYXJlbnRzIGxhc3RjaGlsZCBpcyB0aGUgdGFyZ2V0RWxlbWVudC4uLlxyXG4gICAgICAgIGlmKGNvbnRhaW5lci5sYXN0Y2hpbGQgPT0gaW5zZXJ0QWZ0ZXIpIHtcclxuICAgICAgICAgICAgLy9hZGQgdGhlIG5ld0VsZW1lbnQgYWZ0ZXIgdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5zdGFuY2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGVsc2UgdGhlIHRhcmdldCBoYXMgc2libGluZ3MsIGluc2VydCB0aGUgbmV3IGVsZW1lbnQgYmV0d2VlbiB0aGUgdGFyZ2V0IGFuZCBpdCdzIG5leHQgc2libGluZy5cclxuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShpbnN0YW5jZSwgaW5zZXJ0QWZ0ZXIubmV4dFNpYmxpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZighcHJlcGVuZCB8fCAhY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSApIHtcclxuICAgICAgICBpbnN0YW5jZSA9IGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnN0YW5jZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlID0gY29udGFpbmVyLmluc2VydEJlZm9yZShpbnN0YW5jZSxjb250YWluZXIuY2hpbGROb2Rlc1swXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYob2JqZWN0LmlzRnVuY3Rpb24oZWxlbWVudC5pbnN0YW5jZSkpIHtcclxuICAgICAgICBlbGVtZW50Lmluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudC5pbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxudmFyIGltcG9ydFNWRyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgc3ZnWE1MLCBwcmVwZW5kKSB7XHJcbiAgICB2YXIgJHN2Z1hNTCwgbmFtZSwgYXR0cmlidXRlcztcclxuXHJcbiAgICBpZihzdmdYTUwuanF1ZXJ5KSB7XHJcbiAgICAgICAgJHN2Z1hNTCA9IHN2Z1hNTDtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNTdHJpbmcoc3ZnWE1MKSkge1xyXG4gICAgICAgICRzdmdYTUwgPSAkKHBhcnNlWE1MKHN2Z1hNTC50cmltKCkpKTtcclxuICAgICAgICAkc3ZnWE1MID0gJCgkc3ZnWE1MLmdldCgwKS5kb2N1bWVudEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAkc3ZnWE1MID0gJChzdmdYTUwpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCRzdmdYTUwubm9kZU5hbWUpIHtcclxuICAgICAgICBuYW1lID0gJHN2Z1hNTC5ub2RlTmFtZTtcclxuICAgICAgICBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcygkc3ZnWE1MKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmFtZSA9ICRzdmdYTUwuZ2V0KDApLnRhZ05hbWU7XHJcbiAgICAgICAgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXMoJHN2Z1hNTC5nZXQoMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vV2UgY3JlYXRlIGEgZHVtbXkgZWxlbWVudCBvYmplY3RcclxuICAgIHZhciBlbGVtZW50ID0ge1xyXG4gICAgICAgIHRhZ05hbWUgOiBuYW1lLFxyXG4gICAgICAgIGF0dHJpYnV0ZXMgOiBhdHRyaWJ1dGVzLFxyXG4gICAgICAgIGluc3RhbmNlIDogZnVuY3Rpb24oaW5zdCkge1xyXG4gICAgICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKGluc3QpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlRWxlbWVudCA9IGluc3Q7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmKCFwcmVwZW5kKSB7XHJcbiAgICAgICAgYXBwZW5kU1ZHRWxlbWVudChjb250YWluZXIsIGVsZW1lbnQsIF9nZXRDaGlsZFRleHQoJHN2Z1hNTCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBwcmVwZW5kU1ZHRWxlbWVudChjb250YWluZXIsIGVsZW1lbnQsIF9nZXRDaGlsZFRleHQoJHN2Z1hNTCkpO1xyXG4gICAgfVxyXG5cclxuICAgICRzdmdYTUwuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBjaGlsZCkge1xyXG4gICAgICAgIGltcG9ydFNWRyhlbGVtZW50Lmluc3RhbmNlKCksIGNoaWxkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50Lmluc3RhbmNlKCk7XHJcbn07XHJcblxyXG52YXIgX2dldENoaWxkVGV4dCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIGlmKCFub2RlLmpxdWVyeSkge1xyXG4gICAgICAgIG5vZGUgPSAkKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGlsZFRleHQgPSBub2RlLmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVR5cGUgPT09IDM7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGNoaWxkVGV4dCkgJiYgY2hpbGRUZXh0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXR1cm4gY2hpbGRUZXh0WzBdLm5vZGVWYWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBnZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgJChub2RlLmF0dHJpYnV0ZXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVzdWx0W3RoaXMubm9kZU5hbWVdID0gdGhpcy5ub2RlVmFsdWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgZmluZEluY2x1ZGVTZWxmID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiAkKG5vZGUpLmZpbmQoc2VsZWN0b3IpLmFuZFNlbGYoKS5maWx0ZXIoc2VsZWN0b3IpLmdldCgwKTtcclxufTtcclxuXHJcbnZhciBwYXJzZU5vZGVYTUwgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICBpZighbm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiAkLnBhcnNlWE1MKCQobm9kZSkudGV4dCgpKTtcclxufTtcclxuXHJcbnZhciBwYXJzZVhNTCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgcmV0dXJuIHhtbC5wYXJzZVhNTChzdHIpO1xyXG59O1xyXG5cclxudmFyIHBhcnNlTm9kZUpTT04gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICByZXR1cm4gJC5wYXJzZUpTT04oJChub2RlKS50ZXh0KCkpO1xyXG59O1xyXG5cclxudmFyIGdldFJhd0lkID0gZnVuY3Rpb24oaWRTZWxlY3Rvcikge1xyXG4gICAgaWYoIW9iamVjdC5pc1N0cmluZyhpZFNlbGVjdG9yKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZihpZFNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gJyMnKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkU2VsZWN0b3Iuc3Vic3RyaW5nKDEsIGlkU2VsZWN0b3IubGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGlkU2VsZWN0b3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgZ2V0SWRTZWxlY3RvciA9IGZ1bmN0aW9uKHJhd0lkKSB7XHJcbiAgICBpZighb2JqZWN0LmlzU3RyaW5nKHJhd0lkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmF3SWQuY2hhckF0KDApICE9PSAnIycpIHtcclxuICAgICAgICByZXR1cm4gJyMnICsgcmF3SWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByYXdJZDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgYXBwZW5kU1ZHRWxlbWVudCA6IGFwcGVuZFNWR0VsZW1lbnQsXHJcbiAgICBwcmVwZW5kU1ZHRWxlbWVudCA6IHByZXBlbmRTVkdFbGVtZW50LFxyXG4gICAgaW5zZXJ0U1ZHQWZ0ZXIgOiBpbnNlcnRTVkdBZnRlcixcclxuICAgIGluc2VydEFmdGVySW5kZXggOiBpbnNlcnRBZnRlckluZGV4LFxyXG4gICAgY3JlYXRlIDogY3JlYXRlLFxyXG4gICAgcHJlcGVuZFRvUm9vdCA6IHByZXBlbmRUb1Jvb3QsXHJcbiAgICBpbXBvcnRTVkcgOiBpbXBvcnRTVkcsXHJcbiAgICBtb3ZlRG93biA6IG1vdmVEb3duLFxyXG4gICAgbW92ZVVwIDogbW92ZVVwLFxyXG4gICAgZmluZEluY2x1ZGVTZWxmIDogZmluZEluY2x1ZGVTZWxmLFxyXG4gICAgcGFyc2VOb2RlWE1MIDogcGFyc2VOb2RlWE1MLFxyXG4gICAgcGFyc2VOb2RlSlNPTiA6IHBhcnNlTm9kZUpTT04sXHJcbiAgICBnZXRBdHRyaWJ1dGVzIDogZ2V0QXR0cmlidXRlcyxcclxuICAgIGdldFJhd0lkIDogZ2V0UmF3SWQsXHJcbiAgICBnZXRJZFNlbGVjdG9yOiBnZXRJZFNlbGVjdG9yXHJcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcblxyXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKHRhZ05hbWUsIGNmZywgYXR0cmlidXRlU2V0dGVyKSB7XHJcbiAgICB0aGlzLmF0dHJpYnV0ZVNldHRlciA9IGF0dHJpYnV0ZVNldHRlciB8fCB7fTtcclxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuICAgIGlmKG9iamVjdC5pc09iamVjdCh0YWdOYW1lKSkge1xyXG4gICAgICAgIGNmZyA9IHRhZ05hbWU7XHJcbiAgICAgICAgdGFnTmFtZSA9IGNmZy50YWdOYW1lO1xyXG4gICAgICAgIGRlbGV0ZSBjZmcudGFnTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xyXG5cclxuICAgIGlmKG9iamVjdC5pc09iamVjdChjZmcpKSB7XHJcbiAgICAgICAgaWYoY2ZnLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjZmcuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjZmcuY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNpbmdsZSA9IGNmZy5zaW5nbGUgfHwgZmFsc2U7XHJcbiAgICAgICAgZGVsZXRlIGNmZy5zaW5nbGU7XHJcblxyXG4gICAgICAgIC8vV2UgYXNzdW1lIGFsbCByZW1haW5pbmcgY2ZnIGVudHJpZXMgYXJlIGF0dHJpYnV0ZXNcclxuICAgICAgICBmb3IodmFyIGF0dHJpYnV0ZUtleSBpbiBjZmcpIHtcclxuICAgICAgICAgICAgaWYoY2ZnLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZUtleSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZShhdHRyaWJ1dGVLZXksIGNmZ1thdHRyaWJ1dGVLZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLmluc3RhbmNlID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoaW5zdGFuY2UpKSB7XHJcbiAgICAgICAgdGhpcy5kb21JbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIHRoaXMudGFnTmFtZSA9IGluc3RhbmNlLnRhZ05hbWU7XHJcbiAgICAgICAgdGhpcy5sb2FkQXR0cmlidXRlcyhpbnN0YW5jZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbUluc3RhbmNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWRzIGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIGRvbSBpbnN0YW5jZSBpbnRvIG91ciBhdHRyaWJ1dGUgYXJyYXkgZXhjZXB0IGFscmVhZHkgZXhpc3RpbmcgYXR0cmlidXRlcy5cclxuICogQHBhcmFtIGluc3RhbmNlXHJcbiAqL1xyXG5FbGVtZW50LnByb3RvdHlwZS5sb2FkQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XHJcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMgfHwge307XHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbS5nZXRBdHRyaWJ1dGVzKGluc3RhbmNlKTtcclxuICAgIGZvcih2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICBpZihhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMuYXR0cmlidXRlc1trZXldKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuRWxlbWVudC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbihuZXdJZCkge1xyXG4gICAgaWYob2JqZWN0LmlzU3RyaW5nKG5ld0lkKSkge1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZSgnaWQnLG5ld0lkKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaWQnKTtcclxuICAgIH1cclxufTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yKGF0dHJpYnV0ZUtleSBpbiB0aGlzLmF0dHJpYnV0ZVNldHRlcikge1xyXG4gICAgICAgIGlmKHRoaXMuYXR0cmlidXRlU2V0dGVyLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZUtleSkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoYXR0cmlidXRlS2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS51cGRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgIHRoaXMuX3NldEF0dHJpYnV0ZShrZXksIHRoaXMuYXR0cmlidXRlc1trZXldKTtcclxufTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLl9zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihrZXksIHZhbHVlLCBwcmV2RG9tU2V0KSB7XHJcbiAgICAvLyBJZiBmaXJzdCBhcmcgaXMgb2JqZWN0IGhhbmRsZSBpdHMgcHJvcGVydGllcyBhcyBhdHRyaWJ1dGVzXHJcbiAgICBpZihvYmplY3QuaXNPYmplY3Qoa2V5KSkge1xyXG4gICAgICAgIGZvcih2YXIgYXR0cmlidXRlIGluIGtleSkge1xyXG4gICAgICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKGF0dHJpYnV0ZSkgJiYga2V5Lmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGtleVthdHRyaWJ1dGVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFNvbWUgZWxlbWVudHR5cGVzIGNhbiB0cmFuc2Zvcm0gc3BlY2lmaWMgdHlwZXMgb2YgYXR0cmlidXRlcyB0byBzcGVjaWFsIG9iamVjdHNcclxuICAgICAgICAvLyB3aGljaCBhcmUgYWJsZSB0byByZW5kZXIgYW5kIHNldCB0aGUgdmFsdWVzIGluIGEgc3BlY2lhbCB3YXkuXHJcbiAgICAgICAgaWYoIXRoaXMuaGFzQ2xhc3MoJ25vUGFyc2UnKSAmJiBvYmplY3QuaXNTdHJpbmcodmFsdWUpICYmIG9iamVjdC5pc0RlZmluZWQodGhpcy5hdHRyaWJ1dGVTZXR0ZXJba2V5XSkpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmF0dHJpYnV0ZVNldHRlcltrZXldKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSnVzdCB0cmFuc2Zvcm0gc3RyaW5nbGl0cyB2YWx1ZXMgdG8gYXJyYXlzIGluIGNhc2UgaXRzIGEgc3RyaW5nIGxpc3RcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAvLyBEaXJlY3RseSBzZXQgaXQgdG8gdGhlIFNWRyBpbnN0YW5jZSBpZiBhbHJlYWR5IHJlbmRlcmVkXHJcbiAgICAgICAgaWYodGhpcy5kb21JbnN0YW5jZSAmJiAhcHJldkRvbVNldCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gRWxlbWVudC5nZXRBdHRyaWJ1dGVTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLmRvbUluc3RhbmNlLnNldEF0dHJpYnV0ZShrZXksdmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uKHNlYXJjaENsYXNzKSB7XHJcbiAgICBpZih0aGlzLmRvbUluc3RhbmNlKSB7XHJcbiAgICAgICAgLy9KcXVlcnkgaGFzY2xhc3MgZG9lcyBub3Qgd29yayB3aXRoIHN2ZyBlbGVtZW50c1xyXG4gICAgICAgIHZhciBlbGVtZW50Q2xhc3MgPSAnICcrIHRoaXMuYXR0cignY2xhc3MnKSsnICc7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRDbGFzcy5pbmRleE9mKCcgJytzZWFyY2hDbGFzcysnICcpID4gLTE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS4kID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgIGlmKCF0aGlzLiRkb21JbnN0YW5jZSAmJiB0aGlzLmRvbUluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy4kZG9tSW5zdGFuY2UgPSAkKHRoaXMuZG9tSW5zdGFuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoc2VsZWN0b3IpID8gdGhpcy4kZG9tSW5zdGFuY2UuZmluZChzZWxlY3RvcikgOiB0aGlzLiRkb21JbnN0YW5jZTtcclxufTtcclxuXHJcbkVsZW1lbnQuZ2V0QXR0cmlidXRlU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuXHJcbiAgICBpZighb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYob2JqZWN0LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgb2JqZWN0LmVhY2godmFsdWUsIGZ1bmN0aW9uKGluZGV4LCBwYXJ0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAoKytpbmRleCA9PT0gdmFsdWUubGVuZ3RoKSA/IHBhcnQgOiBwYXJ0KycgJztcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5FbGVtZW50LmdldEF0dHJpYnV0ZVZhbHVlRnJvbVN0cmluZ0xpc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYob2JqZWN0LmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5pbmRleE9mKCcgJykgPiAtMSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgvW1xcc10rLyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLmF0dHJOdW1iZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICB2YXIgdmFsID0gdXRpbC5hcHAucGFyc2VOdW1iZXJTdHJpbmcodGhpcy5hdHRyKGtleSwgdmFsdWUpKTtcclxuICAgIHJldHVybiAob2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpID8gdGhpcyA6IHZhbDtcclxufTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcclxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIG9iamVjdC5pc0RlZmluZWQoYXJndW1lbnRzWzFdKSkge1xyXG4gICAgICAgIC8vVE9ETzogaW1wbGVtZW50IGZvciBtb3IgdGhhbnQgMlxyXG4gICAgICAgIHZhciBvYmogPSB7fTtcclxuICAgICAgICBvYmpbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKG9iaik7XHJcbiAgICB9IGVsc2UgaWYob2JqZWN0LmlzU3RyaW5nKGF0dHJpYnV0ZSkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYoIXJlc3VsdCAmJiB0aGlzLmluc3RhbmNlKCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSAgdGhpcy4kKCkuYXR0cihhdHRyaWJ1dGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAgRWxlbWVudDtcclxuIiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi91dGlsL21hdGgnKS5WZWN0b3I7XHJcbnZhciBtYXRoID0gcmVxdWlyZSgnLi4vdXRpbC9tYXRoJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcclxuXHJcbnZhciBBYnN0cmFjdFBhdGhEYXRhVHlwZSA9IGZ1bmN0aW9uKHR5cGUsIGFic29sdXRlKSB7XHJcbiAgICB0aGlzLnZlY3RvciA9IG5ldyBWZWN0b3IoKTtcclxuICAgIHRoaXMudmVjdG9yLmFkZCh0eXBlKTtcclxuICAgIHRoaXMuYWJzb2x1dGUgPSBhYnNvbHV0ZSB8fCB0cnVlO1xyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoRGF0YVR5cGUucHJvdG90eXBlLnNldEFic29sdXRlID0gZnVuY3Rpb24oYWJzb2x1dGUpIHtcclxuICAgIHRoaXMuYWJzb2x1dGUgPSBhYnNvbHV0ZSB8fCB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhEYXRhVHlwZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHR5cGUgPSB0aGlzLnZhbHVlKDAsMCk7XHJcbiAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZSA/IHR5cGUudG9VcHBlckNhc2UoKSA6IHR5cGUudG9Mb3dlckNhc2UoKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aERhdGFUeXBlLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmVjdG9yLnZhbHVlKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoRGF0YVR5cGUucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24ocGF0aEFyciwgdmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLnZlY3Rvci5zZXRWYWx1ZShwYXRoQXJyLCB2YWx1ZSk7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhEYXRhVHlwZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24ocGF0aEFyciwgdmFsdWVzKSB7XHJcbiAgICByZXR1cm4gdGhpcy52ZWN0b3Iuc2V0VmFsdWUocGF0aEFyciwgdmFsdWVzKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aERhdGFUeXBlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS50b1VwcGVyQ2FzZSgpID09PSB0eXBlLnRvVXBwZXJDYXNlKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhEYXRhVHlwZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbihwYXRoQXJyLCB2YWx1ZXMpIHtcclxuICAgIC8vQUJTVFJBQ1RcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aERhdGFUeXBlLnByb3RvdHlwZS5wb2ludFRvU3RyaW5nID0gZnVuY3Rpb24ocCkge1xyXG4gICAgcmV0dXJuIHAueCArICcsJyArIHAueSsnICc7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhEYXRhVHlwZS5wcm90b3R5cGUuZ2V0T3JTZXQgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgIGlmKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZShpbmRleCwgdmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZShpbmRleCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWZWN0b3IgPSBbWydsJ10sIHt4OngsIHk6eX1dXHJcbiAqL1xyXG52YXIgTGluZVRvID0gZnVuY3Rpb24ocCwgYWJzb2x1dGUpIHtcclxuICAgIEFic3RyYWN0UGF0aERhdGFUeXBlLmNhbGwodGhpcywgJ2wnLCBhYnNvbHV0ZSk7XHJcbiAgICB0aGlzLnRvKHApO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhMaW5lVG8sIEFic3RyYWN0UGF0aERhdGFUeXBlKTtcclxuXHJcbkxpbmVUby5wcm90b3R5cGUudG8gPSBmdW5jdGlvbih4LHkpIHtcclxuICAgIHZhciBwID0gbWF0aC5nZXRQb2ludCh4LHkpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0T3JTZXQoMSxwKTtcclxufTtcclxuXHJcbkxpbmVUby5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSt0aGlzLnBvaW50VG9TdHJpbmcodGhpcy50bygpKTtcclxufTtcclxuXHJcbkxpbmVUby5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUoMSkueCA9IHZhbHVlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZSgxKS54O1xyXG59O1xyXG5cclxuTGluZVRvLnByb3RvdHlwZS55ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSgxKS55ID0gdmFsdWVcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnZhbHVlKDEpLnk7XHJcbn07XHJcblxyXG5MaW5lVG8ucHJvdG90eXBlLm1vdmVBbG9uZyA9IGZ1bmN0aW9uKGZyb20sIGRpc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gbWF0aC5MaW5lLm1vdmVBbG9uZyhmcm9tLCB0aGlzLnRvKCksIGRpc3RhbmNlKTtcclxufTtcclxuXHJcbnZhciBRQmV6aWVyID0gZnVuY3Rpb24oY29udHJvbFAsIHRvUCwgYWJzb2x1dGUpIHtcclxuICAgIEFic3RyYWN0UGF0aERhdGFUeXBlLmNhbGwodGhpcywgJ2wnLCBhYnNvbHV0ZSk7XHJcbiAgICB0aGlzLmNvbnRyb2woY29udHJvbFApO1xyXG4gICAgdGhpcy50byh0b1ApO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhRQmV6aWVyLCBBYnN0cmFjdFBhdGhEYXRhVHlwZSk7XHJcblxyXG5RQmV6aWVyLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgdmFyIHAgPSBtYXRoLmdldFBvaW50KHgseSk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRPclNldCgyLHApO1xyXG59O1xyXG5cclxuUUJlemllci5wcm90b3R5cGUuY29udHJvbCA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgdmFyIHAgPSBtYXRoLmdldFBvaW50KHgseSk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRPclNldCgxLHApO1xyXG59O1xyXG5cclxuUUJlemllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSt0aGlzLnBvaW50VG9TdHJpbmcodGhpcy5jb250cm9sKCkpK3RoaXMucG9pbnRUb1N0cmluZyh0aGlzLnRvKCkpO1xyXG59O1xyXG5cclxudmFyIENCZXppZXIgPSBmdW5jdGlvbihjb250cm9sUDEsIGNvbnRyb2xQMiwgdG9QLCBhYnNvbHV0ZSkge1xyXG4gICAgQWJzdHJhY3RQYXRoRGF0YVR5cGUuY2FsbCh0aGlzLCAnYycsIGFic29sdXRlKTtcclxuICAgIHRoaXMuY29udHJvbDEoY29udHJvbFAxKTtcclxuICAgIHRoaXMuY29udHJvbDIoY29udHJvbFAyKTtcclxuICAgIHRoaXMudG8odG9QKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoQ0JlemllciwgQWJzdHJhY3RQYXRoRGF0YVR5cGUpO1xyXG5cclxuQ0Jlemllci5wcm90b3R5cGUuY29udHJvbCA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udHJvbDEoeCx5KTtcclxufTtcclxuXHJcbkNCZXppZXIucHJvdG90eXBlLmNvbnRyb2wxID0gZnVuY3Rpb24oeCx5KSB7XHJcbiAgICB2YXIgcCA9IG1hdGguZ2V0UG9pbnQoeCx5KTtcclxuICAgIHJldHVybiB0aGlzLmdldE9yU2V0KDEscCk7XHJcbn07XHJcblxyXG5DQmV6aWVyLnByb3RvdHlwZS5jb250cm9sMiA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgdmFyIHAgPSBtYXRoLmdldFBvaW50KHgseSk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRPclNldCgyLHApO1xyXG59O1xyXG5cclxuQ0Jlemllci5wcm90b3R5cGUudG8gPSBmdW5jdGlvbih4LHkpIHtcclxuICAgIHZhciBwID0gbWF0aC5nZXRQb2ludCh4LHkpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0T3JTZXQoMyxwKTtcclxufTtcclxuXHJcbkNCZXppZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkrdGhpcy5wb2ludFRvU3RyaW5nKHRoaXMuY29udHJvbDEoKSkrdGhpcy5wb2ludFRvU3RyaW5nKHRoaXMuY29udHJvbDIoKSkrdGhpcy5wb2ludFRvU3RyaW5nKHRoaXMudG8oKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogY2FsY3VsYXRlcyB0aGUgbmVhcmVzdCBwb2ludCBvZiB0aGUgYmV6aWVyIGN1cnZlIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi4gc2luY2UgdGhlIENCZXppZXIgZG9lcyBub3Qga25vdyBpdHMgc3RhcnRcclxuICogcG9pbnQsIHdlIGhhdmUgdG8gcHJvdmlkZSB0aGUgZnJvbSBwb3NpdGlvbiBhcyB3ZWxsIGFzIHRoZSBzZWFyY2ggYmFzZSBwb3NpdGlvbi5cclxuICogQHBhcmFtIGZyb21cclxuICogQHBhcmFtIHBvc2l0aW9uXHJcbiAqIEByZXR1cm5zIHt7cG9pbnQsIGxvY2F0aW9ufXwqfVxyXG4gKi9cclxuQ0Jlemllci5wcm90b3R5cGUuZ2V0TmVhcmVzdFBvaW50ID0gZnVuY3Rpb24oZnJvbSwgcG9zaXRpb24pIHtcclxuICAgIHJldHVybiBtYXRoLmJlemllci5uZWFyZXN0UG9pbnRPbkN1cnZlKHBvc2l0aW9uLCB0aGlzLmdldEN1cnZlKGZyb20pKS5wb2ludDtcclxufTtcclxuXHJcbkNCZXppZXIucHJvdG90eXBlLm1vdmVBbG9uZyA9IGZ1bmN0aW9uKGZyb20sIGRpc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gbWF0aC5iZXppZXIubW92ZUFsb25nKHRoaXMuZ2V0Q3VydmUoZnJvbSksIGRpc3RhbmNlKTtcclxufTtcclxuXHJcbkNCZXppZXIucHJvdG90eXBlLmdldEN1cnZlID0gZnVuY3Rpb24oZnJvbSkge1xyXG4gICAgcmV0dXJuIFtmcm9tLCB0aGlzLmNvbnRyb2wxKCksIHRoaXMuY29udHJvbDIoKSwgdGhpcy50bygpXTtcclxufVxyXG5cclxudmFyIE1vdmVUbyA9IGZ1bmN0aW9uKHRvUCwgYWJzb2x1dGUpIHtcclxuICAgIEFic3RyYWN0UGF0aERhdGFUeXBlLmNhbGwodGhpcywgJ20nLCBhYnNvbHV0ZSk7XHJcbiAgICB0aGlzLnRvKHRvUCk7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKE1vdmVUbywgTGluZVRvKTtcclxuXHJcbnZhciBDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgQWJzdHJhY3RQYXRoRGF0YVR5cGUuY2FsbCh0aGlzLCAneicpO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhDb21wbGV0ZSwgQWJzdHJhY3RQYXRoRGF0YVR5cGUpO1xyXG5cclxuQ29tcGxldGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCk7XHJcbn07XHJcblxyXG52YXIgcGF0aFR5cGUgPSB7XHJcbiAgICB6IDogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgQ29tcGxldGUoKSB9LFxyXG4gICAgbSA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IE1vdmVUbyhhcmd1bWVudHNbMF0pOyB9LFxyXG4gICAgbCA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IExpbmVUbyhhcmd1bWVudHNbMF0pOyB9LFxyXG4gICAgcSA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFFCZXppZXIoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pOyB9LFxyXG4gICAgYyA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IENCZXppZXIoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sICBhcmd1bWVudHNbMl0pOyB9XHJcbn07XHJcblxyXG52YXIgUGF0aERhdGEgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgIHRoaXMuZGF0YSA9IG5ldyBWZWN0b3IoKTtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhkZWYpKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkRnJvbVN0cmluZyhkZWYpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmxvYWRGcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyVmFsKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAvLydNMTAwLDEwMCBRMjAwLDIwMCAzMDAsMzAwJyAtLT4gWydNMTAwLDEwMCAnLCAnUTIwMCwyMDAgMzAwLDMwMCddXHJcbiAgICB2YXIgZGVmaW5pdGlvbnMgPSBzdHJWYWwuc3BsaXQoLyg/PVtNbUxsSGhWdkNjU3NRcVR0QWFael0rKS8pO1xyXG4gICAgLy9FYWNoIGRUeXBlXHJcbiAgICAkLmVhY2goZGVmaW5pdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gdmFsdWUuY2hhckF0KDApO1xyXG4gICAgICAgIC8vJ1EyMDAsMjAwIDMwMCwzMDAgLT4gWycyMDAsMjAwJywgJzMwMCwzMDAnXVxyXG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZS5zdWJzdHJpbmcoMSx2YWx1ZS5sZW5ndGgpLnRyaW0oKS5zcGxpdCgnICcpO1xyXG4gICAgICAgIC8vWycyMDAsMjAwJywgJzMwMCwzMDAnXSAtPiBbe3g6MjAwLCB5OjIwMH0sIHt4OjMwMCwgeTozMDB9XVxyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAkLmVhY2godmFsdWVzLCBmdW5jdGlvbihpLCBjb29yZCkge1xyXG4gICAgICAgICAgICB2YXIgY29vcmRWYWxzID0gY29vcmQuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2gobWF0aC5nZXRQb2ludChwYXJzZUZsb2F0KGNvb3JkVmFsc1swXSksIHBhcnNlRmxvYXQoY29vcmRWYWxzWzFdKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoYXQuZGF0YS5hZGQocGF0aFR5cGVbdHlwZS50b0xvd2VyQ2FzZSgpXS5hcHBseSh1bmRlZmluZWQsIHBvaW50cykuc2V0QWJzb2x1dGUoKHR5cGUgPT0gdHlwZS50b1VwcGVyQ2FzZSgpKSkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRDb3JuZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgeE1pbiwgeE1heCwgeU1pbiwgeU1heDtcclxuICAgIHhNaW4gPSB5TWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgeE1heCA9IHlNYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcblxyXG4gICAgdGhpcy5kYXRhLmVhY2goZnVuY3Rpb24oaW5kZXgsIHBhdGhQYXJ0KSB7XHJcbiAgICAgICAgaWYocGF0aFBhcnQueCAmJiBwYXRoUGFydC55KSB7XHJcbiAgICAgICAgICAgIHhNaW4gPSAoeE1pbiA+IHBhdGhQYXJ0LngoKSkgPyBwYXRoUGFydC54KCkgOiB4TWluO1xyXG4gICAgICAgICAgICB5TWluID0gKHlNaW4gPiBwYXRoUGFydC55KCkpID8gcGF0aFBhcnQueSgpIDogeU1pbjtcclxuXHJcbiAgICAgICAgICAgIHhNYXggPSAoeE1heCA8IHBhdGhQYXJ0LngoKSkgPyBwYXRoUGFydC54KCkgOiB4TWF4O1xyXG4gICAgICAgICAgICB5TWF4ID0gKHlNYXggPCBwYXRoUGFydC55KCkpID8gcGF0aFBhcnQueSgpIDogeU1heDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHt4OnhNaW4sIHk6eU1pbn0sXHJcbiAgICAgICAge3g6eE1heCwgeTp5TWlufSxcclxuICAgICAgICB7eDp4TWF4LCB5OnlNYXh9LFxyXG4gICAgICAgIHt4OnhNaW4sIHk6eU1heH1cclxuICAgIF07XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29ybmVycygpWzBdLng7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29ybmVycygpWzBdLnk7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUucG9seW5vbXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMuZGF0YS52ZWN0b3JzLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpZih2YWx1ZS50bykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS50bygpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuc1xyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0UGF0aFBhcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgLy9XZSBzdGFydCBhdCBpbmRleCAxIGJlY2F1c2UgdGhlIDAgaW5kZXggb2YgdGhlIHZlY3RvciBjb250YWlucyB0aGUgcGF0aHBhcnQgdHlwZVxyXG4gICAgZm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLmxlbmd0aCgpIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZXRQYXRoUGFydChpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRQYXRoUGFydCA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICB2YXIgcGF0aFBhcnQgPSB0aGlzLnZhbHVlKGluZGV4KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhcnQ6IHRoaXMudmFsdWUoaW5kZXggLSAxKS50bygpLFxyXG4gICAgICAgIGVuZDogcGF0aFBhcnQudG8oKSxcclxuICAgICAgICB2YWx1ZTogcGF0aFBhcnRcclxuICAgIH07XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUubW92ZUFsb25nID0gZnVuY3Rpb24oaW5kZXgsIGRpc3RhbmNlLCBkaXJlY3Rpb24pIHtcclxuICAgIHZhciBwYXRoUGFydCA9IHRoaXMuZ2V0UGF0aFBhcnQoaW5kZXgpO1xyXG4gICAgaWYocGF0aFBhcnQudmFsdWUubW92ZUFsb25nKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhQYXJ0LnZhbHVlLm1vdmVBbG9uZyhwYXRoUGFydC5zdGFydCwgZGlzdGFuY2UsIGRpcmVjdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXRoLkxpbmUubW92ZUFsb25nKHBhdGhQYXJ0LnN0YXJ0LCBwYXRoUGFydC5lbmQsIGRpc3RhbmNlLCBkaXJlY3Rpb24pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHJvdWdoIGNlbnRlciBvZiB0aGUgcGF0aCBieSBjYWxjdWxhdGluZyB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBwYXRocGFydHMgKGFzIGRpcmVjdCBsaW5lcykgYW5kIG1vdmluZ1xyXG4gKiBhbG9uZyB0aG9zZSBsaW5lcyB0byB0aGUgY2VudGVyICh0b3RhbCBsZW5ndGggLyAyKS4gTm90ZSB3aXRoIHRoaXMgbWV0aG9kIHdlIGp1c3QgZ2V0IGEgZXhhY3QgcmVzdWx0IGZvciBzaW1wbGVcclxuICogbGluZSBwYXRocy4gSWYgdGhlIGNhbGN1bGF0ZWQgY2VudGVyIHBvc2l0aW9uIGlzIHdpdGhpbiBhIGN1YmljIGJlemllciBwYXRoIHBhcnQsIHdlIHJldHVybiB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgY3VydmVcclxuICogdG8gdGhlIGNhbGN1bGF0ZWQgY2VudGVyLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHREID0gdGhpcy5nZXREaXN0YW5jZSgpIC8gMjtcclxuICAgIHZhciBjdXJyZW50RCA9IDA7XHJcbiAgICB2YXIgY2VudGVyO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5nZXRQYXRoUGFydHMoKSwgZnVuY3Rpb24oaW5kZXgsIHBhcnQpIHtcclxuICAgICAgICB2YXIgbGluZUQgPSBtYXRoLkxpbmUuY2FsY0Rpc3RhbmNlKHBhcnQuc3RhcnQsIHBhcnQuZW5kKTtcclxuICAgICAgICB2YXIgbmV4dEQgPSBjdXJyZW50RCArIGxpbmVEO1xyXG4gICAgICAgIGlmKG5leHREID4gcmVzdWx0RCkge1xyXG4gICAgICAgICAgICB2YXIgZGlmZkQgPSAgcmVzdWx0RCAtIGN1cnJlbnREO1xyXG4gICAgICAgICAgICBjZW50ZXIgPSBtYXRoLkxpbmUubW92ZUFsb25nKHBhcnQuc3RhcnQsIHBhcnQuZW5kLCBkaWZmRCk7XHJcblxyXG4gICAgICAgICAgICAvL0lmIHdlIGhhdmUgYSBjdWJpYyBiZXppZXIgcGF0aCBwYXJ0IHdlIGNhbGN1bGF0ZSB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgY3VydmVcclxuICAgICAgICAgICAgaWYocGFydC52YWx1ZS5pcygnYycpKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIgPSBwYXJ0LnZhbHVlLmdldE5lYXJlc3RQb2ludChwYXJ0LnN0YXJ0LCBjZW50ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEQgPSBuZXh0RDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNlbnRlcjtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMuZ2V0UGF0aFBhcnRzKCksIGZ1bmN0aW9uKGluZGV4LCBwYXJ0KSB7XHJcbiAgICAgICAgZGlzdGFuY2UgKz0gbWF0aC5MaW5lLmNhbGNEaXN0YW5jZShwYXJ0LnN0YXJ0LCBwYXJ0LmVuZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkaXN0YW5jZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBc3N1bWluZyB0aGVyZSBhcmUgb25seSEgY3ViaWMgYmV6aWVyIGN1cnZlZCBwYXRoIHBhcnRzIHRoaXMgZnVuY3Rpb24gcmVjYWxjdWxhdGVzIGFsbCBjb250cm9sIHBvaW50cyBvZiB0aGUgY3VydmVzXHJcbiAqIHRvIHNtb290aGVuIHRoZSBlbnRpcmUgcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBvbHlub21zXHJcbiAqL1xyXG5QYXRoRGF0YS5wcm90b3R5cGUuc21vb3RoZW4gPSBmdW5jdGlvbihwb2x5bm9tcykge1xyXG4gICAgaWYoIXBvbHlub21zKSB7XHJcbiAgICAgICAgcG9seW5vbXMgPSB0aGlzLnBvbHlub21zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHggPSBbXTtcclxuICAgIHZhciB5ID0gW107XHJcblxyXG4gICAgb2JqZWN0LmVhY2gocG9seW5vbXMsIGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHhbaW5kZXhdID0gdmFsdWUueDtcclxuICAgICAgICB5W2luZGV4XSA9IHZhbHVlLnk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgcHggPSBtYXRoLmJlemllci5jYWxjdWxhdGVTbW9vdGhDb250cm9sUG9pbnRzKHgpO1xyXG4gICAgdmFyIHB5ID0gbWF0aC5iZXppZXIuY2FsY3VsYXRlU21vb3RoQ29udHJvbFBvaW50cyh5KTtcclxuXHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBvYmplY3QuZWFjaChweC5wMSwgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhhdC52YWx1ZShpbmRleCArIDEpLmNvbnRyb2wxKHB4LnAxW2luZGV4XSwgcHkucDFbaW5kZXhdKTtcclxuICAgICAgICB0aGF0LnZhbHVlKGluZGV4ICsgMSkuY29udHJvbDIocHgucDJbaW5kZXhdLCBweS5wMltpbmRleF0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRMaW5lQnlQYXRoSW5kZXggPSBmdW5jdGlvbihpbmRleCwgZnJvbUVuZCkge1xyXG4gICAgdmFyIHN0YXJ0SW5kZXggPSAoZnJvbUVuZCkgID8gKGluZGV4ICsgMSkgKiAtMSA6IGluZGV4O1xyXG4gICAgdmFyIGVuZEluZGV4ID0gICAoZnJvbUVuZCkgID8gKGluZGV4ICsgMikgKiAtMSA6IGluZGV4ICsgMTtcclxuICAgIHZhciBwMSA9IHRoaXMudmFsdWUoc3RhcnRJbmRleCkudG8oKTtcclxuICAgIHZhciBwMiA9IHRoaXMudmFsdWUoZW5kSW5kZXgpLnRvKCk7XHJcbiAgICByZXR1cm4gbmV3IG1hdGguTGluZShwMSwgcDIpO1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmdldFBhdGhJbmRleEZvclBvc2l0aW9uID0gZnVuY3Rpb24ocG9pbnQpIHtcclxuXHJcbiAgICBpZih0aGlzLmxlbmd0aCgpID09PSAyKSB7XHJcbiAgICAgICAgLy9JZiB0aGVyZSBpcyBqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGRvY2tpbmcgd2Uga25vdyB0aGUgbmV3IGluZGV4XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRvY2tpbmdJbmRleCA9IDE7XHJcbiAgICB2YXIgY2FuZGlkYXRlID0gWzEsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIF07XHJcblxyXG4gICAgb2JqZWN0LmVhY2godGhpcy5nZXRQYXRoUGFydHMoKSwgZnVuY3Rpb24oaW5kZXgsIHBhcnQpIHtcclxuICAgICAgICAvL1NvcnQgb3V0IHBhdGhwYXJ0cyB3aGljaCBhcmUgbm90IHdpdGhpbiB0aGUgYm91bmRhcnkgb2Ygc3RhcnQvZW5kIHBvaW50cyB3aXRoIGEgbGl0dGxlIHRvbGVyYW5jZSBvZiAxMHB4XHJcbiAgICAgICAgdmFyIHAgPSBuZXcgdXRpbC5tYXRoLlBvaW50KHBvaW50KTtcclxuICAgICAgICBpZihwLmlzV2l0aGluWEludGVydmFsKHBhcnQuc3RhcnQsIHBhcnQuZW5kLCAxMCkpIHtcclxuICAgICAgICAgICAgdmFyIGQ7XHJcbiAgICAgICAgICAgIHZhciBsaW5lID0gbmV3IG1hdGguTGluZShwYXJ0LnN0YXJ0LCBwYXJ0LmVuZCk7XHJcblxyXG4gICAgICAgICAgICBpZighbGluZS5pc1ZlcnRpY2FsKCkpIHtcclxuICAgICAgICAgICAgICAgIGQgPSBNYXRoLmFicyhsaW5lLmNhbGNGWChwb2ludC54KS55IC0gcG9pbnQueSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHAuaXNXaXRoaW5ZSW50ZXJ2YWwocGFydC5zdGFydCwgcGFydC5lbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAvL1NpbmNlIHRoZSBwb2ludCBpcyB3aXRoaW4geCAod2l0aCB0b2xlcmFuY2UpIGFuZCB5IGludGVydmFsIHdlIGNhbGN1bGF0ZSB0aGUgeCBkaXN0YW5jZVxyXG4gICAgICAgICAgICAgICAgZCA9IE1hdGguYWJzKHBhcnQuc3RhcnQueCAtIHAueCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGVbMV0gPiBkKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RoZSBwYXRoUGFydGluZGV4IGlzIHRoZSBhcnJheWluZGV4ICsgMSBzaW5jZSB3ZSB1c2UgdGhlIGVuZCBpbmRleCBvZiB0aGUgcGF0aCBhcyBpZGVudGl0eVxyXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlWzBdID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlWzFdID0gZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChjYW5kaWRhdGUpIHtcclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlWzBdO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIF9nZXRERm9yVmVydGljYWwgPSBmdW5jdGlvbihwYXJ0LCBwb2ludCkge1xyXG4gICAgaWYodXRpbC5tYXRoLmNoZWNrUmFuZ2UoKSlcclxuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXJ0LnN0YXJ0LnksIHBhcnQuZW5kLnkpO1xyXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHBhcnQuc3RhcnQueSwgcGFydC5lbmQueSk7XHJcbiAgICBpZiAocG9pbnQueSA8PSBtYXggJiYgcG9pbnQueSA+PSBtaW4pIHtcclxuXHJcbiAgICB9XHJcbn07XHJcblxyXG4vKlxyXG4gTGluZVBhdGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRHcmFkaWVuID0gZnVuY3Rpb24oeCx5KSB7XHJcbiB2YXIgcG9zaXRpb24gPSB1dGlsLm1hdGguZ2V0UG9pbnQoeCx5KTtcclxuIHZhciBpbmRleCA9IHRoaXMudHJhbnNpdGlvbi5nZXRLbm9iSW5kZXhGb3JQb2ludChwb3NpdGlvbik7XHJcbiB2YXIgcDEgPSB0aGlzLmRhdGEuZ2V0RG9ja2luZ0J5SW5kZXgoaW5kZXgpLnBvc2l0aW9uKCk7XHJcbiB2YXIgcDIgPSB0aGlzLmRhdGEuZ2V0RG9ja2luZ0J5SW5kZXgoaW5kZXggKyAxKS5wb3NpdGlvbigpO1xyXG4gcmV0dXJuIHV0aWwubWF0aC5MaW5lLmNhbGNHcmFkaWVudChwMSwgcDIpO1xyXG4gfTtcclxuXHJcbiBMaW5lUGF0aE1hbmFnZXIucHJvdG90eXBlLmdldEdyYWRpZW50QnlJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiB2YXIgcDEgPSB0aGlzLmRhdGEuZ2V0RG9ja2luZ0J5SW5kZXgoaW5kZXgpLnBvc2l0aW9uKCk7XHJcbiB2YXIgcDIgPSB0aGlzLmRhdGEuZ2V0RG9ja2luZ0J5SW5kZXgoaW5kZXggKyAxKS5wb3NpdGlvbigpO1xyXG4gcmV0dXJuIHV0aWwubWF0aC5MaW5lLmNhbGNHcmFkaWVudChwMSwgcDIpO1xyXG4gfTtcclxuXHJcblxyXG4gTGluZVBhdGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRWZWN0b3JCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgsIGZyb21FbmQpIHtcclxuIHZhciBwMSwgcDI7XHJcbiBpZihmcm9tRW5kKSB7XHJcbiBwMSA9IHRoaXMuZGF0YS5nZXREb2NraW5nQnlFbmRJbmRleChpbmRleCArIDEpLnBvc2l0aW9uKCk7XHJcbiBwMiA9IHRoaXMuZGF0YS5nZXREb2NraW5nQnlFbmRJbmRleChpbmRleCkucG9zaXRpb24oKTtcclxuIH0gZWxzZSB7XHJcbiBwMSA9IHRoaXMuZGF0YS5nZXREb2NraW5nQnlJbmRleChpbmRleCkucG9zaXRpb24oKTtcclxuIHAyID0gdGhpcy5kYXRhLmdldERvY2tpbmdCeUluZGV4KGluZGV4ICsgMSkucG9zaXRpb24oKTtcclxuIH1cclxuIHJldHVybiB1dGlsLm1hdGguTGluZS5jYWxjTm9ybWFsaXplZExpbmVWZWN0b3IocDEsIHAyKTtcclxuIH07XHJcbiAqL1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29ybmVycygpWzBdLnk7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0UmlnaHRYID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmdldENvcm5lcnMoKVsxXS54O1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmdldEJvdHRvbVkgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29ybmVycygpWzJdLnk7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZihvYmplY3QuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5kYXRhLmNsZWFyKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoKCk7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS52YWx1ZShpbmRleCk7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUudmFsdWVCeVR5cGUgPSBmdW5jdGlvbihpbmRleCwgdHlwZSkge1xyXG4gICAgdmFyIGNvdW50ID0gMDtcclxuICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgb2JqZWN0LmVhY2godGhpcy5kYXRhLnZlY3RvcnMsIGZ1bmN0aW9uKGksIHZhbHVlKSB7XHJcbiAgICAgICBpZih2YWx1ZS5pcyh0eXBlKSAmJiBjb3VudCsrID09PSBpbmRleCkge1xyXG4gICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKHAsIGFic29sdXRlKSB7XHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUoMCkudG8oKTtcclxuICAgIH1cclxuICAgIHRoaXMuZGF0YS5zZXRWYWx1ZSgwLCBuZXcgTW92ZVRvKHAsIGFic29sdXRlKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3QoKS50byh2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubGFzdCgpLnRvKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVE9ETzogcmVmYWN0b3IgdG8gc2V0VG9cclxuICogQHBhcmFtIGluZGV4XHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7UGF0aERhdGF9XHJcbiAqL1xyXG5QYXRoRGF0YS5wcm90b3R5cGUuc2V0VG8gPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgIHRoaXMuZGF0YS52YWx1ZShpbmRleCkudG8odmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUucmVtb3ZlUGF0aCA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICB0aGlzLmRhdGEucmVtb3ZlKGluZGV4KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRhdGEuYWRkKG5ldyBDb21wbGV0ZSgpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmxpbmUgPSBmdW5jdGlvbih4LHkpIHtcclxuICAgIHZhciBwID0gbWF0aC5nZXRQb2ludCh4LHkpO1xyXG4gICAgdGhpcy5kYXRhLmFkZChuZXcgTGluZVRvKHAsIHRydWUpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmNCZXppZXIgPSBmdW5jdGlvbihjMSwgYzIsIHRvKSB7XHJcbiAgICB0aGlzLmRhdGEuYWRkKG5ldyBDQmV6aWVyKGMxLGMyLCB0bywgdHJ1ZSkpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogVE9ETzogTGluZSB0b1xyXG4gKiBAcGFyYW0gaW5kZXhcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqIEBwYXJhbSBhYnNvbHV0ZVxyXG4gKiBAcmV0dXJucyB7UGF0aERhdGF9XHJcbiAqL1xyXG5QYXRoRGF0YS5wcm90b3R5cGUuaW5zZXJ0TGluZSA9IGZ1bmN0aW9uKGluZGV4LCB0bywgYWJzb2x1dGUpIHtcclxuICAgIHRoaXMuZGF0YS5pbnNlcnQoaW5kZXgsIG5ldyBMaW5lVG8odG8sYWJzb2x1dGUpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLnFCZXppZXIgPSBmdW5jdGlvbihjb250cm9sUCx0b1ApIHtcclxuICAgIHRoaXMuZGF0YS5hZGQobmV3IFFCZXppZXIoY29udHJvbFAsdG9QLCB0cnVlKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5pbnNlcnRRQmV6aWVyID0gZnVuY3Rpb24oaW5kZXgsYywgdG8sIGFic29sdXRlKSB7XHJcbiAgICB0aGlzLmRhdGEuaW5zZXJ0KGluZGV4LCBuZXcgUUJlemllcih0byxhYnNvbHV0ZSkpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuaW5zZXJ0Q0JlemllciA9IGZ1bmN0aW9uKGluZGV4LCBjMSwgYzIsIHRvLCBhYnNvbHV0ZSkge1xyXG4gICAgdGhpcy5kYXRhLmluc2VydChpbmRleCwgbmV3IENCZXppZXIoYzEsYzIsIHRvLGFic29sdXRlKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5kYXRhLmVhY2goZnVuY3Rpb24oaW5kZXgsIHBhdGhQYXJ0KSB7XHJcbiAgICAgICByZXN1bHQgKz0gcGF0aFBhcnQudG9TdHJpbmcoKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhdGhEYXRhOyIsInZhciBEb21FbGVtZW50ID0gcmVxdWlyZSgnLi4vZG9tL2RvbUVsZW1lbnQnKTtcclxudmFyIFN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxuXHJcbi8qXHJcbiAqIENvbnN0cnVjdG9yIGZvciBTVkcgRWxlbWVudHNcclxuICpcclxuICogQHBhcmFtIHt0eXBlfSBuYW1lIHRoZSBlbGVtZW50IE5hbWUgZS5nLiByZWN0LCBjaXJjbGUsIHBhdGguLi5cclxuICogQHBhcmFtIHt0eXBlfSBjZmcgYXR0cmlidXRlcyBhbmQgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uc1xyXG4gKiBAcGFyYW0ge3R5cGV9IGF0dHJpYnV0ZVNldHRlciB5b3UgY2FuIGFkZCBhZGRpdGlvbmFsIGF0dHJpYnV0ZSBzZXR0ZXJcclxuICogZm9yIHNwZWNpYWwgYXR0cmlidXRlcyBkZWZhdWx0IGF0dHJpYnV0ZSBzZXR0ZXIgZ2l2ZW4gYnkgdGhpcyBpbXBlbGVtZW50YXRpb25cclxuICogYXJlIHRyYW5zZm9ybSBhbmQgc3R5bGUgc2V0dGVyXHJcbiAqL1xyXG52YXIgU1ZHRWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIHN2ZywgY2ZnLCBhdHRyaWJ1dGVTZXR0ZXIpIHtcclxuICAgIHRoaXMuYXR0cmlidXRlU2V0dGVyID0gYXR0cmlidXRlU2V0dGVyIHx8IHt9O1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVTZXR0ZXIuc3R5bGUgPSB0aGlzLnN0eWxlQXR0cmlidXRlU2V0dGVyO1xyXG4gICAgdGhpcy5TVkdFbGVtZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBJZiBmaXJzdCBhdHRyaWJ1dGUgaXMgbm90IGEgc3RyaW5nIHdlIGFzc3VtZSBhIHN2ZyBub2RlIGNvbnN0cnVjdG9yIGNhbGwuXHJcbiAgICBpZighb2JqZWN0LmlzU3RyaW5nKG5hbWUpKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZShuYW1lKTtcclxuICAgICAgICBjZmcgPSBkb20uZ2V0QXR0cmlidXRlcyhuYW1lKTtcclxuICAgICAgICBuYW1lID0gbmFtZS50YWdOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3ZnID0gc3ZnO1xyXG4gICAgdGhpcy5yb290ID0gc3ZnLnJvb3QgfHwgdGhpcztcclxuICAgIERvbUVsZW1lbnQuY2FsbCh0aGlzLCBuYW1lLCBjZmcsIHRoaXMuYXR0cmlidXRlU2V0dGVyKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoU1ZHRWxlbWVudCwgRG9tRWxlbWVudCk7XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5zdHlsZUF0dHJpYnV0ZVNldHRlciA9IGZ1bmN0aW9uKHRybmFzZm9ybWF0aW9uU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0eWxlKHRybmFzZm9ybWF0aW9uU3RyaW5nKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLmdldFJvb3ROb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290Lmluc3RhbmNlKCk7XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICByZXN1bHQgPSBbXTtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgb2JqZWN0LmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihpbmRleCwgdmFsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuYXBwZW5kKHZhbCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJlc3VsdCA9ICB1dGlsLmRvbS5hcHBlbmRTVkdFbGVtZW50KHRoaXMuaW5zdGFuY2UoKSwgZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBvYmplY3QuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGluZGV4LCB2YWwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5wcmVwZW5kKHZhbCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJlc3VsdCA9ICB1dGlsLmRvbS5wcmVwZW5kU1ZHRWxlbWVudCh0aGlzLmluc3RhbmNlKCksIGFyZ3VtZW50c1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiQoKS5yZW1vdmUoKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLmZpcnN0Q2hpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAkLnFDYWNoZSgpLnN2Zyh0aGlzLiQoKS5jaGlsZHJlbigpLmZpcnN0KCkpO1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUuZG93biA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZG9tLm1vdmVEb3duKHRoaXMuaW5zdGFuY2UoKSk7XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZG9tLm1vdmVVcCh0aGlzLmluc3RhbmNlKCkpO1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZG9tLnByZXBlbmRUb1Jvb3QodGhpcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTVkcgU3R5bGVzXHJcbiAqL1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICBpZighb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgJiYgb2JqZWN0LmlzU3RyaW5nKGtleSkgJiYga2V5LmluZGV4T2YoJzonKSA8PSAwXHJcbiAgICAgICAgJiYgb2JqZWN0LmlzRGVmaW5lZCh0aGlzLmF0dHJpYnV0ZXMuc3R5bGUpKSB7XHJcbiAgICAgICAgLy9HRVRURVIgQ0FMTFxyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuc3R5bGUuZ2V0KGtleSk7XHJcbiAgICB9IGVsc2UgaWYoIW9iamVjdC5pc0RlZmluZWQodGhpcy5hdHRyaWJ1dGVzLnN0eWxlKSAmJiBvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5zdHlsZSA9IG5ldyBTdHlsZShrZXksIHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5kYWxhID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignZGFsYTonK2tleSwgdmFsdWUpO1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUuZ2V0QkJveCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UoKS5nZXRCQm94KCk7XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTVkcgRXZlbnRoYW5kbGluZ1xyXG4gKi9cclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihldnQsIGFyZ3MpIHtcclxuICAgIHRoaXMuJCgpLnRyaWdnZXIoZXZ0LCBhcmdzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldnQsIGhhbmRsZXIpIHtcclxuICAgIHRoaXMuJCgpLm9uKGV2dCwgaGFuZGxlcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uKGV2dCwgaGFuZGxlcikge1xyXG4gICAgdGhpcy4kKCkub25lKGV2dCwgaGFuZGxlcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdGhpcy4kKCkub2ZmKGV2dCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRoaXMuJCgpLnRyaWdnZXIoZXZ0KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB1dGlsLnhtbC5zZXJpYWxpemVUb1N0cmluZyh0aGlzLmluc3RhbmNlKCkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdFbGVtZW50O1xyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIFNWR0VsbGlwc2UgPSByZXF1aXJlKCcuL2VsbGlwc2UnKTtcclxudmFyIFNWR1NoYXBlID0gcmVxdWlyZSgnLi9nZW5lcmljU2hhcGUnKTtcclxuXHJcbnZhciBTVkdDaXJjbGUgPSBmdW5jdGlvbihzdmdSb290LCBjZmcpIHtcclxuICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgIFNWR1NoYXBlLmNhbGwodGhpcywgJ2NpcmNsZScsIHN2Z1Jvb3QsIGNmZyk7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKFNWR0NpcmNsZSwgU1ZHRWxsaXBzZSk7XHJcblxyXG5TVkdDaXJjbGUucHJvdG90eXBlLnIgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpICYmIHZhbHVlKSB8fCAhb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyTnVtYmVyKCdyJykgKyB0aGlzLnN0cm9rZVdpZHRoKCkgLyAyO1xyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ck51bWJlcigncicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmF0dHJOdW1iZXIoJ3InLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdDaXJjbGUucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZighb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgb2JqZWN0LmlzQm9vbGVhbih2YWx1ZSkpIHsgLy9HZXR0ZXJcclxuICAgICAgICByZXR1cm4gU1ZHQ2lyY2xlLnN1cGVyXy5wcm90b3R5cGUuaGVpZ2h0LmFwcGx5KHRoaXMsIFt2YWx1ZV0pO1xyXG4gICAgfSBlbHNlIHsgLy9TZXR0ZXJcclxuICAgICAgICB2YXIgdiA9IHZhbHVlIC8gMjtcclxuICAgICAgICB0aGlzLmN5KHYpLmN4KHYpLnIodik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdDaXJjbGUucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmhlaWdodCh2YWx1ZSk7XHJcbn07XHJcblxyXG5TVkdDaXJjbGUucHJvdG90eXBlLnJ4ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLnIodmFsdWUpO1xyXG59O1xyXG5cclxuU1ZHQ2lyY2xlLnByb3RvdHlwZS5yeSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yKHZhbHVlKTtcclxufTtcclxuXHJcblNWR0NpcmNsZS5wcm90b3R5cGUub3ZlcmxheUNoZWNrID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiBuZXcgdXRpbC5tYXRoLkNpcmNsZSh0aGlzLmdldENlbnRlcigpLCB0aGlzLnIoKSkub3ZlcmxheXMocG9zaXRpb24pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdDaXJjbGU7IiwidmFyIERyYWdDb25maWcgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaG9va3MgPSB7fTtcclxufTtcclxuXHJcbkRyYWdDb25maWcucHJvdG90eXBlLnhPbmx5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmhvb2tzLnJlc3RyaWN0aW9uWSA9IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkRyYWdDb25maWcucHJvdG90eXBlLnlPbmx5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmhvb2tzLnJlc3RyaWN0aW9uWCA9IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkRyYWdDb25maWcucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24oZ3NIb29rKSB7XHJcbiAgICB0aGlzLmhvb2tzLmdldFNjYWxlID0gZ3NIb29rO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5EcmFnQ29uZmlnLnByb3RvdHlwZS5kcmFnTW92ZSA9IGZ1bmN0aW9uKGRybUhvb2spIHtcclxuICAgIHRoaXMuaG9va3MuZHJhZ01vdmUgPSBkcm1Ib29rO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5EcmFnQ29uZmlnLnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbihkcnNIb29rKSB7XHJcbiAgICB0aGlzLmhvb2tzLmRyYWdTdGFydCA9IGRyc0hvb2s7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkRyYWdDb25maWcucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbihkcmVIb29rKSB7XHJcbiAgICB0aGlzLmhvb2tzLmRyYWdFbmQgPSBkcmVIb29rO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5EcmFnQ29uZmlnLnByb3RvdHlwZS5yZXN0cmljdGlvblggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmhvb2tzLnJlc3RyaWN0aW9uWDtcclxufTtcclxuXHJcbkRyYWdDb25maWcucHJvdG90eXBlLnJlc3RyaWN0aW9uWSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaG9va3MucmVzdHJpY3Rpb25ZO1xyXG59O1xyXG5cclxuRHJhZ0NvbmZpZy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ob29rcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHJhZ0NvbmZpZzsiLCJ2YXIgU1ZHU2hhcGUgPSByZXF1aXJlKCcuL2dlbmVyaWNTaGFwZScpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcblxyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxuXHJcbnZhciBTaGlmdERyYWcgPSBmdW5jdGlvbihjZmcpIHtcclxuICAgIHRoaXMuY2ZnID0gY2ZnO1xyXG4gICAgaWYoIWNmZy5yZXN0cmljdGlvblggJiYgIWNmZy5yZXN0cmljdGlvblkpIHtcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TaGlmdERyYWcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuc3RhdGUgPSAnaW5pdCc7XHJcbiAgICB0aGlzLnhTaGlmdCA9IHtcclxuICAgICAgICBzaGlmdEFsaWduIDogMCxcclxuICAgICAgICB1bnNoaWZ0QWxpZ24gOiAwXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMueVNoaWZ0ID0ge1xyXG4gICAgICAgIHNoaWZ0QWxpZ24gOiAwLFxyXG4gICAgICAgIHVuc2hpZnRBbGlnbiA6IDBcclxuICAgIH07XHJcbn07XHJcblxyXG5TaGlmdERyYWcucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuc3RhdGUgPSAnZGlzYWJsZWQnO1xyXG59O1xyXG5cclxuU2hpZnREcmFnLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihldnQsIGR4ICxkeSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcclxuICAgICAgICBjYXNlICdpbml0JyA6XHJcbiAgICAgICAgICAgIHRoaXMueFNoaWZ0LnNoaWZ0QWxpZ24gKz0gZHg7XHJcbiAgICAgICAgICAgIHRoaXMueVNoaWZ0LnNoaWZ0QWxpZ24gKz0gZHk7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmNoZWNrU2hpZnRIb29rKGV2dCkpIHtcclxuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKHRoaXMueFNoaWZ0LnNoaWZ0QWxpZ24pID4gTWF0aC5hYnModGhpcy55U2hpZnQuc2hpZnRBbGlnbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RyaWN0aW9uWCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RyaWN0aW9uWSA9IGZ1bmN0aW9uKGV2dCwgZHggLGR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnNoaWZ0UmVzdHJpY3Rpb24odGhhdC55U2hpZnQsIGR5KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnc2hpZnRlZFgnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RyaWN0aW9uWSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RyaWN0aW9uWCA9IGZ1bmN0aW9uKGV2dCwgZHggLCBkeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5zaGlmdFJlc3RyaWN0aW9uKHRoYXQueFNoaWZ0LCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3NoaWZ0ZWRZJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzaGlmdGVkWCc6XHJcbiAgICAgICAgICAgIGlmKCFldnQuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdHJpY3Rpb25ZID0gZnVuY3Rpb24oZXZ0LCBkeCwgZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC51blNoaWZ0UmVzdHJpY3Rpb24odGhhdC55U2hpZnQsIGR5KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ2luaXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3NoaWZ0ZWRZJzpcclxuICAgICAgICAgICAgaWYoIWV2dC5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0cmljdGlvblggPSBmdW5jdGlvbihldnQsIGR4ICxkeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnVuU2hpZnRSZXN0cmljdGlvbih0aGF0LnhTaGlmdCwgZHgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnaW5pdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuU2hpZnREcmFnLnByb3RvdHlwZS5zaGlmdFJlc3RyaWN0aW9uID0gZnVuY3Rpb24oc2hpZnREYXRhLCBkKSB7XHJcbiAgICAvL1VwZGF0ZSBzaGlmdGVkIGRcclxuICAgIHNoaWZ0RGF0YS51bnNoaWZ0QWxpZ24gKz0gZDtcclxuICAgIC8vQWxpZ24gc2hpZnQgZHJhZyBiYWNrIHRvIHRoZSBzdGFydCBwb3NpdGlvblxyXG4gICAgdmFyIHJlc3VsdCA9IChNYXRoLmFicyhzaGlmdERhdGEuc2hpZnRBbGlnbikgPiAwKSA/IHNoaWZ0RGF0YS5zaGlmdEFsaWduICogLTEgOiAwO1xyXG4gICAgc2hpZnREYXRhLnNoaWZ0QWxpZ24gPSAwO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblNoaWZ0RHJhZy5wcm90b3R5cGUudW5TaGlmdFJlc3RyaWN0aW9uID0gZnVuY3Rpb24oc2hpZnREYXRhLCBkKSB7XHJcbiAgICAvL0FsaWduIHNoaWZ0IGRyYWcgYmFjayB0byB0aGUgc3RhcnQgcG9zaXRpb25cclxuICAgIHZhciByZXN1bHQgPSBzaGlmdERhdGEudW5zaGlmdEFsaWduICsgZDtcclxuICAgIHNoaWZ0RGF0YS51bnNoaWZ0QWxpZ24gPSAwO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblNoaWZ0RHJhZy5wcm90b3R5cGUuY2hlY2tTaGlmdEhvb2sgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHJldHVybiBldnQuc2hpZnRLZXkgJiYgKE1hdGguYWJzKHRoaXMueFNoaWZ0LnNoaWZ0QWxpZ24pID4gNCB8fCBNYXRoLmFicyh0aGlzLnlTaGlmdC5zaGlmdEFsaWduKSA+IDQpO1xyXG59O1xyXG5cclxuLy9UT0RPOiB0aGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB0byB1c2UgdGhlIGFsaWdubWVudCBhbGlnbiBjZW50ZXIgdG8gY2VudGVyLnggaWYgY2hlY2tTaGlmdEhvb2tcclxuXHJcblNoaWZ0RHJhZy5wcm90b3R5cGUuZ2V0UmVzdHJpY3Rpb25YID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jZmcucmVzdHJpY3Rpb25YIHx8IHRoaXMucmVzdHJpY3Rpb25YO1xyXG59O1xyXG5cclxuU2hpZnREcmFnLnByb3RvdHlwZS5nZXRSZXN0cmljdGlvblkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmNmZy5yZXN0cmljdGlvblkgfHwgdGhpcy5yZXN0cmljdGlvblk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuZHJhZ2dhYmxlID0gZnVuY3Rpb24oY2ZnLCBkcmFnRWxlbWVudCkge1xyXG4gICAgdmFyIGNmZyA9IGNmZyB8fCB7fTtcclxuXHJcbiAgICBpZighb2JqZWN0LmlzRGVmaW5lZChkcmFnRWxlbWVudCkpIHtcclxuICAgICAgICBkcmFnRWxlbWVudCA9IHRoaXMuaW5zdGFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgdmFyIGRyYWdNb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgaWYoZXZ0LnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIWV2dC50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhhdC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYWN0dWFsZHggPSAob2JqZWN0LmlzRGVmaW5lZChldnQuZHgpKSA/IGV2dC5keCA6IGV2dC5jbGllbnRYIC0gdGhhdC5kcmFnQ3VycmVudFg7XHJcbiAgICAgICAgdmFyIGFjdHVhbGR5ID0gKG9iamVjdC5pc0RlZmluZWQoZXZ0LmR5KSkgPyBldnQuZHkgOiBldnQuY2xpZW50WSAtIHRoYXQuZHJhZ0N1cnJlbnRZO1xyXG5cclxuICAgICAgICAvLyBEUkFHIEJFRk9SRSBIT09LXHJcbiAgICAgICAgaWYoY2ZnLmRyYWdCZWZvcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgIGNmZy5kcmFnQmVmb3JlTW92ZS5hcHBseSh0aGF0LCBbZXZ0LCBhY3R1YWxkeCwgYWN0dWFsZHksIGRyYWdFbGVtZW50XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEUkFHIEFMSUdOTUVOVFxyXG4gICAgICAgIGlmKGNmZy5kcmFnQWxpZ25tZW50ICYmICFldnQudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnQgPSBjZmcuZHJhZ0FsaWdubWVudC5jaGVjayhhY3R1YWxkeCwgYWN0dWFsZHkpO1xyXG4gICAgICAgICAgICBhY3R1YWxkeCA9IGFsaWdubWVudC5keDtcclxuICAgICAgICAgICAgYWN0dWFsZHkgPSBhbGlnbm1lbnQuZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0NoZWNrIGZvciBzaGlmdERyYWcgcmVzdHJpY3Rpb24sIHNoaWZ0RHJhZyB3aWxsIG9ubHkgaG9vayB1cCBpZiBubyBvdGhlciByZXN0cmljdGlvbiBpcyBzZXQuXHJcbiAgICAgICAgLy9TaGlmdGRyYWcgaXMgbm90IGdpdmVuIGZvciB0cmlnZ2VyZHJhZ3NcclxuICAgICAgICBpZih0aGF0LnNoaWZ0RHJhZyAmJiAhZXZ0LnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgICAgICB0aGF0LnNoaWZ0RHJhZy51cGRhdGUoZXZ0LCBhY3R1YWxkeCwgYWN0dWFsZHkpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdHJpY3Rpb25YID0gdGhhdC5zaGlmdERyYWcuZ2V0UmVzdHJpY3Rpb25YKCk7XHJcbiAgICAgICAgICAgIHZhciByZXN0cmljdGlvblkgPSB0aGF0LnNoaWZ0RHJhZy5nZXRSZXN0cmljdGlvblkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERSQUcgUkVTVFJJQ1RJT05cclxuICAgICAgICB2YXIgZHggPSAocmVzdHJpY3Rpb25YICYmICFldnQudHJpZ2dlckV2ZW50KSA/IHJlc3RyaWN0aW9uWC5hcHBseSh0aGF0LCBbZXZ0LCBhY3R1YWxkeCwgYWN0dWFsZHldKSA6IGFjdHVhbGR4O1xyXG4gICAgICAgIHZhciBkeSA9IChyZXN0cmljdGlvblkgJiYgIWV2dC50cmlnZ2VyRXZlbnQpID8gcmVzdHJpY3Rpb25ZLmFwcGx5KHRoYXQsIFtldnQsIGFjdHVhbGR4LCBhY3R1YWxkeV0pIDogYWN0dWFsZHk7XHJcblxyXG4gICAgICAgIC8vVE9ETzogc29tZWhvdyB0aGUgc2NhbGUgc2hvdWxkIGJlIGRldGVybWluZWQgaW4gYSBtb3JlIGVsZWdhbnQgd2F5IHBlcmhhcHMgc3RvcmUgaXQgaW4gc3ZnIGluc3RhbmNlLi4uXHJcbiAgICAgICAgaWYoY2ZnLmdldFNjYWxlICYmICFldnQudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGNmZy5nZXRTY2FsZSgpO1xyXG4gICAgICAgICAgICBkeCAvPSBzY2FsZTtcclxuICAgICAgICAgICAgZHkgLz0gc2NhbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFWEVDVVRFIERSQUdcclxuICAgICAgICBpZihkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGF0Lm1vdmUoZHgsIGR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBldnREYXRhID0gZ2V0TW91c2VFdmVudERhdGEoZXZ0KTtcclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cclxuICAgICAgICB0aGF0LmRyYWdDdXJyZW50WCA9IGV2dERhdGEuY2xpZW50WDtcclxuICAgICAgICB0aGF0LmRyYWdDdXJyZW50WSA9IGV2dERhdGEuY2xpZW50WTtcclxuXHJcbiAgICAgICAgdGhhdC5keFN1bSArPSBkeDtcclxuICAgICAgICB0aGF0LmR5U3VtICs9IGR5O1xyXG5cclxuICAgICAgICAvLyBEUkFHIE1PVkUgSE9PS1xyXG4gICAgICAgIGlmKGNmZy5kcmFnTW92ZSkge1xyXG4gICAgICAgICAgICBjZmcuZHJhZ01vdmUuYXBwbHkodGhhdCwgW2V2dCwgZHgsIGR5LCBkcmFnRWxlbWVudF0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIGRyYWdFbmQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAvL1R1cm4gb2ZmIGRyYWcgZXZlbnRzXHJcbiAgICAgICAgZXZlbnQub2ZmKHRoYXQuZ2V0Um9vdE5vZGUoKSwgJ21vdXNlbW92ZScpO1xyXG4gICAgICAgIGV2ZW50Lm9mZihkb2N1bWVudCwgJ21vdXNldXAnLCBkcmFnRW5kKTtcclxuXHJcbiAgICAgICAgaWYoY2ZnLmRyYWdBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgY2ZnLmRyYWdBbGlnbm1lbnQucmVzZXQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZHJhZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZihjZmcuY3Vyc29yKSB7XHJcbiAgICAgICAgICAgICQoJ2JvZHknKS5jc3MoJ2N1cnNvcicsJ2RlZmF1bHQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERSQUcgRU5EIEhPT0tcclxuICAgICAgICBpZihjZmcuZHJhZ0VuZCkge1xyXG4gICAgICAgICAgICBjZmcuZHJhZ0VuZC5hcHBseSh0aGF0LCBbZXZ0XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGF0LmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgJ2FsbCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZihkcmFnRWxlbWVudCkge1xyXG4gICAgICAgIHZhciBldnRUeXBlID0gKGNmZy5vbmNlKT8gZXZlbnQub25jZSA6IGV2ZW50Lm9uO1xyXG4gICAgICAgIGV2dFR5cGUoZHJhZ0VsZW1lbnQsJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYoZS5jdHJsS2V5IHx8ICF0aGF0LmlzVmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAvLyBXZSBzdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbiB0byBwcmV2ZW50IHRoZSBkb2N1bWVudCBtb3VzZWRvd24gaGFuZGxlciB0byBmaXJlXHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICBpbml0RHJhZ1ZhbHVlcyh0aGF0LCBlLCBjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gRFJBRyBTVEFSVCBIT09LXHJcbiAgICAgICAgICAgIGlmKGNmZy5kcmFnU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGNmZy5kcmFnU3RhcnQuYXBwbHkodGhhdCwgW2VdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoY2ZnLmN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgJCgnYm9keScpLmNzcygnY3Vyc29yJywgY2ZnLmN1cnNvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoYXQuZHJhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGV2ZW50Lm9uKHRoYXQuZ2V0Um9vdE5vZGUoKSwgJ21vdXNlbW92ZScsIGRyYWdNb3ZlKTtcclxuICAgICAgICAgICAgZXZlbnQub24oZG9jdW1lbnQsICdtb3VzZXVwJywgZHJhZ0VuZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9TaW11bGF0ZXMgYW4gZHJhZyBzdGFydCBldmVudFxyXG4gICAgdGhpcy5pbml0RHJhZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICQoZHJhZ0VsZW1lbnQpLnRyaWdnZXIoJ21vdXNlZG93bicpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL0ZvciBtYW51YWwgZHJhZ2dpbmcgYSBzdmcgZWxlbWVudCB0aGUgdHJpZ2dlckV2ZW50IGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudCB3YXMgdHJpZ2dlcmVkIG1hbnVhbGx5XHJcbiAgICAvL1NlZSBTZWxlY3Rpb25tYW5hZ2VyIHNldE5vZGVTZWxlY3Rpb24gZHJhZ01vdmUgaGFuZGxlclxyXG4gICAgdGhpcy50cmlnZ2VyRHJhZyA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgICAgIGRyYWdNb3ZlLmFwcGx5KHRoaXMsW3tkeDpkeCwgZHk6ZHksIHRyaWdnZXJFdmVudDp0cnVlfV0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbnZhciBpbml0RHJhZ1ZhbHVlcyA9IGZ1bmN0aW9uKHRoYXQsIGV2dCwgY2ZnKSB7XHJcbiAgICB0aGF0LmR4U3VtID0gMDtcclxuICAgIHRoYXQuZHlTdW0gPSAwO1xyXG4gICAgdGhhdC5zaGlmdERyYWcgPSBuZXcgU2hpZnREcmFnKGNmZyk7XHJcbiAgICB2YXIgZXZ0RGF0YSA9IGdldE1vdXNlRXZlbnREYXRhKGV2dCk7XHJcbiAgICB0aGF0LmRyYWdDdXJyZW50WCA9IGV2dERhdGEuY2xpZW50WDtcclxuICAgIHRoYXQuZHJhZ0N1cnJlbnRZID0gZXZ0RGF0YS5jbGllbnRZO1xyXG5cclxuICAgIHRoYXQuZHJhZyA9IHRydWU7XHJcbn07XHJcblxyXG52YXIgZ2V0TW91c2VFdmVudERhdGEgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmKCFldnQuY2xpZW50WCkge1xyXG4gICAgICAgIHJldHVybiBldmVudC5tb3VzZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2dDtcclxufTsiLCJ2YXIgc2hhcGVzID0ge31cclxuc2hhcGVzLnN2ZyA9IHNoYXBlcy5TdmcgPSByZXF1aXJlKCcuL3N2Z1Jvb3QnKTtcclxuc2hhcGVzLmNpcmNsZSA9IHNoYXBlcy5DaXJjbGUgPSByZXF1aXJlKCcuL2NpcmNsZScpO1xyXG5zaGFwZXMuZWxsaXBzZSA9IHNoYXBlcy5FbGxpcHNlID0gcmVxdWlyZSgnLi9lbGxpcHNlJyk7XHJcbnNoYXBlcy50ZXh0ID0gc2hhcGVzLlRleHQgPSByZXF1aXJlKCcuL3RleHQnKTtcclxuc2hhcGVzLnRzcGFuID0gc2hhcGVzLlRTcGFuID0gcmVxdWlyZSgnLi90c3BhbicpO1xyXG5zaGFwZXMucGF0aCA9IHNoYXBlcy5QYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XHJcbnNoYXBlcy5yZWN0ID0gc2hhcGVzLlJlY3QgPSByZXF1aXJlKCcuL3JlY3QnKTtcclxuc2hhcGVzLmcgPSBzaGFwZXMuR3JvdXAgPSByZXF1aXJlKCcuL2dyb3VwJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gc2hhcGVzOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgU1ZHU2hhcGUgPSByZXF1aXJlKCcuL2dlbmVyaWNTaGFwZScpO1xyXG5cclxudmFyIFNWR0VsbGlwc2UgPSBmdW5jdGlvbihzdmdSb290LCBjZmcpIHtcclxuICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgIFNWR1NoYXBlLmNhbGwodGhpcywgJ2VsbGlwc2UnLCBzdmdSb290LCBjZmcpO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhTVkdFbGxpcHNlLCBTVkdTaGFwZSk7XHJcblxyXG5TVkdFbGxpcHNlLnByb3RvdHlwZS54ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jeCgpIC0gdGhpcy5yeCgpO1xyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKCFvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSB8fCBvYmplY3QuaXNCb29sZWFuKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ5KHZhbHVlKSAqIDI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vV2hlbiBzZXR0aW5nIHRoZSBoZWlnaHQgb2YgYW4gZWxsaXBzZSB3ZSBtb3ZlIHRoZSBjZW50ZXIgdG8gbm90IGNoYW5nZSB0aGUgeC95XHJcbiAgICAgICAgdmFyIHYgPSB2YWx1ZSAvIDI7XHJcbiAgICAgICAgdGhpcy5jeSh2KS5yeSh2KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcblNWR0VsbGlwc2UucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKCFvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSB8fCBvYmplY3QuaXNCb29sZWFuKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ4KHZhbHVlKSAqIDI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vV2hlbiBzZXR0aW5nIHRoZSBoZWlnaHQgb2YgYW4gZWxsaXBzZSB3ZSBtb3ZlIHRoZSBjZW50ZXIgdG8gbm90IGNoYW5nZSB0aGUgeC95XHJcbiAgICAgICAgdmFyIHYgPSB2YWx1ZSAvIDI7XHJcbiAgICAgICAgdGhpcy5jeCh2KS5yeCh2KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcblNWR0VsbGlwc2UucHJvdG90eXBlLnggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmN4KCkgLSB0aGlzLnJ4KCk7XHJcbn07XHJcblxyXG5TVkdFbGxpcHNlLnByb3RvdHlwZS55ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jeSgpIC0gdGhpcy5yeSgpO1xyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUucmlnaHRYID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jeCgpICsgdGhpcy5yeCgpO1xyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHggOiB0aGlzLmN4KCksXHJcbiAgICAgICAgeSA6IHRoaXMuY3koKVxyXG4gICAgfTtcclxufTtcclxuXHJcblNWR0VsbGlwc2UucHJvdG90eXBlLmJvdHRvbVkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmN5KCkgKyB0aGlzLnJ5KCk7XHJcbn07XHJcblxyXG5TVkdFbGxpcHNlLnByb3RvdHlwZS5jeCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZighdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVkWCh0aGlzLmF0dHJOdW1iZXIoJ2N4JykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmF0dHIoJ2N4JywgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUuY3kgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoIXZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlZFkodGhpcy5hdHRyTnVtYmVyKCdjeScpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hdHRyKCdjeScsIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcblNWR0VsbGlwc2UucHJvdG90eXBlLnJ4ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKCghb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgb2JqZWN0LmlzQm9vbGVhbih2YWx1ZSkgJiYgdmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ck51bWJlcigncngnKSArIHRoaXMuc3Ryb2tlV2lkdGgoKSAvIDI7XHJcbiAgICB9IGVsc2UgaWYob2JqZWN0LmlzQm9vbGVhbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyTnVtYmVyKCdyeCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmF0dHJOdW1iZXIoJ3J4JywgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUucnkgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoKCFvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSB8fCBvYmplY3QuaXNCb29sZWFuKHZhbHVlKSAmJiB2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyTnVtYmVyKCdyeScpICsgdGhpcy5zdHJva2VXaWR0aCgpIC8gMjtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNCb29sZWFuKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJOdW1iZXIoJ3J5Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYXR0ck51bWJlcigncnknLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdFbGxpcHNlLnByb3RvdHlwZS5vdmVybGF5Q2hlY2sgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIG5ldyB1dGlsLm1hdGguRWxsaXBzZSh0aGlzLmdldENlbnRlcigpLCB0aGlzLnJ4KCksIHRoaXMucnkoKSkub3ZlcmxheXMocG9zaXRpb24pO1xyXG59O1xyXG5cclxuLypcclxuU1ZHRWxlbWVudC5wcm90b3R5cGUub3ZlcmxheUNoZWNrID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuXHJcbn07Ki9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHRWxsaXBzZTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtJyk7XHJcblxyXG52YXIgU1ZHRWxlbWVudCA9IHJlcXVpcmUoJy4vU1ZHRWxlbWVudCcpO1xyXG5cclxudmFyIFNWR1NoYXBlID0gZnVuY3Rpb24obmFtZSwgc3ZnUm9vdCwgY2ZnLCBhdHRyaWJ1dGVTZXR0ZXIpIHtcclxuICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgIHRoaXMuYXR0cmlidXRlU2V0dGVyID0gYXR0cmlidXRlU2V0dGVyIHx8IHt9O1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVTZXR0ZXIudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm1hdGlvbkF0dHJpYnV0ZVNldHRlcjtcclxuICAgIFNWR0VsZW1lbnQuY2FsbCh0aGlzLCBuYW1lLCBzdmdSb290LCBjZmcsIGF0dHJpYnV0ZVNldHRlcik7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKFNWR1NoYXBlLCBTVkdFbGVtZW50KTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS50cmFuc2Zvcm1hdGlvbkF0dHJpYnV0ZVNldHRlciA9IGZ1bmN0aW9uKHRybmFzZm9ybWF0aW9uU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSh0cm5hc2Zvcm1hdGlvblN0cmluZyk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKCF0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtKSB7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNTdHJpbmcodGhpcy5hdHRyaWJ1dGVzLnRyYW5zZm9ybSkpIHtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSh0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLmdldFRyYW5zZm9ybWF0aW9uKCkuc2NhbGUoc2NhbGUpO1xyXG5cclxuICAgIGlmKHJlc3VsdCBpbnN0YW5jZW9mIFRyYW5zZm9ybSkge1xyXG4gICAgICAgIC8vIFRoZSB0cm5hc2xhdGUgc2V0dGVyIHJldHVybnMgdGhlIFRyYW5zZm9ybSBvYmplY3Qgc28gd2UgcmVzZXQgdGhlc3R5bGVcclxuICAgICAgICAvLyB0cmFuc2Zvcm0gYXR0cmlidXRlIGluIGRvbSAoc2V0dGVyIHdhcyBjYWxsZWQpXHJcbiAgICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUaGUgZ2V0dGVyIGp1c3QgcmV0dXJucyB0aGUgeCx5IHZhbHVlcyBvZiB0aGUgdHJhbnNsYXRlIHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbigpLnRyYW5zbGF0ZSh4LHkpO1xyXG5cclxuICAgIGlmKHJlc3VsdCBpbnN0YW5jZW9mIFRyYW5zZm9ybSkge1xyXG4gICAgICAgIC8vIFRoZSB0cm5hc2xhdGUgc2V0dGVyIHJldHVybnMgdGhlIFRyYW5zZm9ybSBvYmplY3Qgc28gd2UgcmVzZXQgdGhlXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGF0dHJpYnV0ZSBpbiBkb20gKHNldHRlciB3YXMgY2FsbGVkKVxyXG4gICAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGdldHRlciBqdXN0IHJldHVybnMgdGhlIHgseSB2YWx1ZXMgb2YgdGhlIHRyYW5zbGF0ZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUudHJhbnNsYXRlZCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbigpLnRyYW5zbGF0ZSgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4IDogdHJhbnNsYXRlLnggKyBwb3NpdGlvbi54LFxyXG4gICAgICAgIHkgOiB0cmFuc2xhdGUueSArIHBvc2l0aW9uLnlcclxuICAgIH1cclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS50cmFuc2xhdGVkWCA9IGZ1bmN0aW9uKHB4KSB7XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbigpLnRyYW5zbGF0ZSgpO1xyXG4gICAgcHggPSAob2JqZWN0LmlzRGVmaW5lZChweCkpID8gcHggOiAwO1xyXG4gICAgcmV0dXJuIHRyYW5zbGF0ZS54ICsgcHg7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUudHJhbnNsYXRlZFkgPSBmdW5jdGlvbihweSkge1xyXG4gICAgdmFyIHRyYW5zbGF0ZSA9IHRoaXMuZ2V0VHJhbnNmb3JtYXRpb24oKS50cmFuc2xhdGUoKTtcclxuICAgIHB5ID0gKG9iamVjdC5pc0RlZmluZWQocHkpKSA/IHB5IDogMDtcclxuICAgIHJldHVybiB0cmFuc2xhdGUueSArIHB5O1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLmhhc1RyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24odHJhbnNmb3JtYXRpb24pIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQodGhpcy5hdHRyaWJ1dGVzLnRyYW5zZm9ybSkpIHtcclxuICAgICAgICByZXR1cm4gKG9iamVjdC5pc0RlZmluZWQodGhpcy5hdHRyaWJ1dGVzLnRyYW5zZm9ybVt0cmFuc2Zvcm1hdGlvbl0pKTtcclxuICAgIH1cclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24oY29sb3IpIHtcclxuICAgIHJldHVybiB0aGlzLnN0eWxlKCdmaWxsJywgY29sb3IpO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLmZpbGxPcGFjaXR5ID0gZnVuY3Rpb24ob3BhY2l0eSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIG9wYWNpdHkpO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnN0cm9rZU9wYWNpdHkgPSBmdW5jdGlvbihvcGFjaXR5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCBvcGFjaXR5KTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5zdHJva2UgPSBmdW5jdGlvbihjb2xvciwgd2lkdGgpIHtcclxuICAgIGlmKHdpZHRoKSB7XHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCh3aWR0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZSgnc3Ryb2tlJywgY29sb3IpO1xyXG5cclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5zdHJva2VEYXNoYXJyYXkgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICBpZighdHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5Jyk7XHJcbiAgICB9XHJcbiAgICBpZihvYmplY3QuaXNTdHJpbmcodHlwZSkpIHtcclxuICAgICAgICB0aGlzLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JywgdHlwZSk7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgIH1cclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5zdHJva2VEYXNoVHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIGlmKCF0eXBlKSB7XHJcbiAgICAgICAgc3dpdGNoKHRoaXMuc3Ryb2tlRGFzaGFycmF5KCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIjUsNVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGNhc2UgXCIxMCwxMFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgICAgIGNhc2UgXCIyMCwxMCw1LDUsNSwxMFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN3aXRjaCh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJzEnOlxyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZURhc2hhcnJheShcIjUsNVwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcyJzpcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2VEYXNoYXJyYXkoXCIxMCwxMFwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICczJzpcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2VEYXNoYXJyYXkoXCIyMCwxMCw1LDUsNSwxMFwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2VEYXNoYXJyYXkoXCJub25lXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnN0cm9rZVdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcclxuICAgIHJldHVybiB1dGlsLmFwcC5wYXJzZU51bWJlclN0cmluZyh0aGlzLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB3aWR0aCkpIHx8IDA7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gKCF0aGlzLmZpbGxPcGFjaXR5KCkgfHwgdGhpcy5maWxsT3BhY2l0eSgpID4gMClcclxuICAgICAgICAmJiAoIXRoaXMuc3Ryb2tlT3BhY2l0eSgpIHx8IHRoaXMuc3Ryb2tlT3BhY2l0eSgpID4gMCk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5maWxsT3BhY2l0eSgwKTtcclxuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSgwKTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24ob3BhY2l0eSkge1xyXG4gICAgb3BhY2l0eSA9IG9wYWNpdHkgfHwgMTtcclxuICAgIHRoaXMuZmlsbE9wYWNpdHkob3BhY2l0eSk7XHJcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkob3BhY2l0eSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB0aGUgbG9jYXRpb24gb2YgYSBnaXZlbiBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3ZnIGVsZW1lbnQuXHJcbiAqICAgICAgX3RfXHJcbiAqICAgIHxcXCAgIC98XHJcbiAqICBsIHwgIGMgIHwgclxyXG4gKiAgICB8L19fX1xcfFxyXG4gKiAgICAgICBiXHJcbiAqIEBwYXJhbSBub2RlXHJcbiAqIEBwYXJhbSBwb3NpdGlvblxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWR1NoYXBlLnByb3RvdHlwZS5nZXRSZWxhdGl2ZUxvY2F0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIC8vRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIHBvaW50IGxpZXMgZGlyZWN0IG9uIHRoZSBib3VuZGFyeVxyXG4gICAgaWYocG9zaXRpb24ueCA9PT0gdGhpcy54KCkpIHtcclxuICAgICAgICByZXR1cm4gJ2xlZnQnO1xyXG4gICAgfSBlbHNlIGlmKHBvc2l0aW9uLnkgPT09IHRoaXMueSgpKSB7XHJcbiAgICAgICAgcmV0dXJuICd0b3AnO1xyXG4gICAgfSBlbHNlIGlmKHBvc2l0aW9uLnggPT09IHRoaXMuZ2V0UmlnaHRYKCkpIHtcclxuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcclxuICAgIH0gZWxzZSBpZihwb3NpdGlvbi55ID09PSB0aGlzLmdldEJvdHRvbVkoKSkge1xyXG4gICAgICAgIHJldHVybiAnYm90dG9tJztcclxuICAgIH1cclxuXHJcbiAgICAvL0lmIGl0cyBub3Qgb24gdGhlIGJvdW5kYXJ5IHdlIGNoZWNrIHRoZSBsb2NhdGlvbiBieSBtZWFucyBvZiB0aGUgbGluZSBncmFkaWVudFxyXG4gICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICB2YXIgZyA9IHV0aWwubWF0aC5MaW5lLmNhbGNHcmFkaWVudChjZW50ZXIsIHBvc2l0aW9uKTtcclxuICAgIGlmKHBvc2l0aW9uLnkgPCBjZW50ZXIueSkgeyAvL3Bvc2l0aW9uIG92ZXIgZWxlbWVudGNlbnRlclxyXG4gICAgICAgIGlmIChwb3NpdGlvbi54ID49IGNlbnRlci54KSB7IC8vcG9zaXRpb24gcmlnaHQgKG9yIGVxKSBvZiBlbGVtZW50Y2VudGVyXHJcbiAgICAgICAgICAgIHJldHVybiAoZyA+IC0xKSA/ICdyaWdodCcgOiAndG9wJztcclxuICAgICAgICB9IGVsc2UgaWYgKGcgPCAxKSB7Ly9wb3NpdGlvbiBsZWZ0IGFuZCBvdmVyIG9mIGVsZW1lbnRjZW50ZXJcclxuICAgICAgICAgICAgcmV0dXJuIChnIDwgMSkgPyAnbGVmdCcgOiAndG9wJztcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYocG9zaXRpb24ueCA+PSBjZW50ZXIueCkgeyAvL3Bvc2l0aW9uIHVuZGVyIChvciBlcSkgYW5kIHJpZ2h0IChvciBlcSkgb2YgZWxlbWVudGNlbnRlclxyXG4gICAgICAgIHJldHVybiAoZyA8IDEpID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xyXG4gICAgfSBlbHNlIHsgLy9wb3NpdGlvbiB1bmRlciBhbmQgbGVmdCBvZiBlbGVtZW50Y2VudGVyXHJcbiAgICAgICAgcmV0dXJuIChnIDwgLTEpID8gJ2JvdHRvbScgOiAnbGVmdCc7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlZFgoMCk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUueSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlZFkoMCk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IHRoYXQueCgpLFxyXG4gICAgICAgIHkgOiB0aGF0LnkoKVxyXG4gICAgfTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogdGhpcy54KCkgKyBNYXRoLmZsb29yKHRoaXMud2lkdGgoKSAvIDIpLFxyXG4gICAgICAgIHk6IHRoaXMueSgpICsgTWF0aC5mbG9vcih0aGlzLmhlaWdodCgpIC8gMilcclxuICAgIH07XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUub3ZlcmxheXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIG9iamVjdC5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oaW5kZXgsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYodGhhdC5vdmVybGF5Q2hlY2socG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9UTyBicmVhayB0aGUgZWFjaCBsb29wXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdyZXN1bHQ6JytyZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBnaXZlbiBwb3NpdGlvbiBsaWVzIHdpdGhpbiB0aGUgc3ZnRWxlbWVudC5cclxuICogVGhpcyBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgc2hhcGVzIGxpa2UgY2lyY2xlcyBhbmQgZWxsaXBzZS4uXHJcbiAqL1xyXG5TVkdTaGFwZS5wcm90b3R5cGUub3ZlcmxheUNoZWNrID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiBwb3NpdGlvbi54ID49IHRoaXMueCgpICYmIHBvc2l0aW9uLnggPD0gdGhpcy5nZXRSaWdodFgoKVxyXG4gICAgICAgICYmIHBvc2l0aW9uLnkgPj0gdGhpcy55KCkgJiYgcG9zaXRpb24ueSA8PSB0aGlzLmdldEJvdHRvbVkoKTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGUoKTtcclxuICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0ZS54ICsgZHgsIHRyYW5zbGF0ZS55ICsgZHkpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIHAgPSB1dGlsLm1hdGguZ2V0UG9pbnQoeCx5KTtcclxuXHJcbiAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGUoKTtcclxuICAgIGlmKHRoaXMueCgpICE9PSBwLnggfHwgdGhpcy55KCkgIT09IHAueSkge1xyXG4gICAgICAgIC8vVE9ETzogdGhpcyBkb2VzIG5vdCBjb25zaWRlciB4L3kgYXR0cmlidXRlIHNldHRpbmdzXHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGUocCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5tb3ZlWCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZSgpO1xyXG4gICAgaWYodHJhbnNsYXRlLnggIT09IHgpIHtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZSh4LCB0cmFuc2xhdGUueSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5tb3ZlWSA9IGZ1bmN0aW9uKHkpIHtcclxuICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZSgpO1xyXG4gICAgaWYodHJhbnNsYXRlLnkgIT09IHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUodHJhbnNsYXRlLngsIHkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogTm90ZTogdGhlIGltcGxlbWVudGF0aW9uIG9mIGdldEJCb3ggZGlmZmVycyBiZXR3ZWVuIGJyb3dzZXJzIHNvbWUgYWRkIHRoZSBzcm9rZS13aWR0aCBhbmQgc29tZSBkbyBub3QgYWRkIHN0cm9rZS13aWR0aFxyXG4gKi9cclxuU1ZHU2hhcGUucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QkJveCgpLmhlaWdodDtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QkJveCgpLndpZHRoO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLmdldEJvdHRvbVkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnkoKSArIHRoaXMuaGVpZ2h0KCk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuZ2V0UmlnaHRYID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy54KCkgKyB0aGlzLndpZHRoKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1NoYXBlOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgU1ZHU2hhcGUgPSByZXF1aXJlKCcuL2dlbmVyaWNTaGFwZScpO1xyXG5cclxudmFyIFNWR0dyb3VwID0gZnVuY3Rpb24oc3ZnUm9vdCwgY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICBTVkdTaGFwZS5jYWxsKHRoaXMsICdnJywgc3ZnUm9vdCwgY2ZnKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoU1ZHR3JvdXAsIFNWR1NoYXBlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHR3JvdXA7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBTVkdTaGFwZSA9IHJlcXVpcmUoJy4vZ2VuZXJpY1NoYXBlJyk7XHJcbnZhciBQYXRoRGF0YSA9IHJlcXVpcmUoJy4vcGF0aERhdGEnKTtcclxuXHJcbnZhciBTVkdQYXRoID0gZnVuY3Rpb24oc3ZnUm9vdCwgY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICB0aGlzLmF0dHJpYnV0ZVNldHRlciA9IHsgZCA6IFNWR1BhdGgucGF0aERhdGFBdHRyaWJ1dGVTZXR0ZXJ9O1xyXG4gICAgU1ZHU2hhcGUuY2FsbCh0aGlzLCAncGF0aCcsIHN2Z1Jvb3QsIGNmZywgdGhpcy5hdHRyaWJ1dGVTZXR0ZXIpO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhTVkdQYXRoLCBTVkdTaGFwZSk7XHJcblxyXG5TVkdQYXRoLnBhdGhEYXRhQXR0cmlidXRlU2V0dGVyID0gZnVuY3Rpb24ocGF0aERhdGFTdHJpbmcpIHtcclxuICAgIHJldHVybiBuZXcgUGF0aERhdGEocGF0aERhdGFTdHJpbmcpO1xyXG59O1xyXG5cclxuU1ZHUGF0aC5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZCgpLmdldFgoKTtcclxufTtcclxuXHJcblNWR1BhdGgucHJvdG90eXBlLnkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmQoKS5nZXRZKCk7XHJcbn07XHJcblxyXG5TVkdQYXRoLnByb3RvdHlwZS5kID0gZnVuY3Rpb24ocGF0aERhdGEpIHtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhwYXRoRGF0YSkpIHtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuZCA9IG5ldyBQYXRoRGF0YShwYXRoRGF0YSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoJ2QnKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNEZWZpbmVkKHBhdGhEYXRhKSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5kID0gcGF0aERhdGFcclxuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSgnZCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIGlmKCFvYmplY3QuaXNEZWZpbmVkKHRoaXMuYXR0cmlidXRlcy5kKSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5kID0gbmV3IFBhdGhEYXRhKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1BhdGg7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBTVkdTaGFwZSA9IHJlcXVpcmUoJy4vZ2VuZXJpY1NoYXBlJyk7XHJcblxyXG52YXIgU1ZHUmVjdCA9IGZ1bmN0aW9uKHN2Z1Jvb3QsIGNmZykge1xyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgU1ZHU2hhcGUuY2FsbCh0aGlzLCAncmVjdCcsIHN2Z1Jvb3QsIGNmZyk7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKFNWR1JlY3QsIFNWR1NoYXBlKTtcclxuXHJcblNWR1JlY3QucHJvdG90eXBlLnkgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB5ID0gdGhpcy5hdHRyTnVtYmVyKCd5JykgfHwgMDtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZWRZKHkpO1xyXG59O1xyXG5cclxuU1ZHUmVjdC5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHggPSB0aGlzLmF0dHJOdW1iZXIoJ3gnKSB8fCAwO1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlZFgoeCk7XHJcbn07XHJcblxyXG5TVkdSZWN0LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpICYmICF2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyTnVtYmVyKCdoZWlnaHQnKTtcclxuICAgIH0gZWxzZSBpZighb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpICYmIHZhbHVlKSkge1xyXG4gICAgICAgIC8vVE9ETzogbm90ZSB0aGF0IHRoZSBzdHJva2UgaXMgcmVuZGVyZWQgb24gdGhlIGNlbnRlciBvZiB0aGUgbm9kZSBib3JkZXJcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyTnVtYmVyKCdoZWlnaHQnKSArIHRoaXMuc3Ryb2tlV2lkdGgoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hdHRyKHtoZWlnaHQ6dmFsdWV9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcblNWR1JlY3QucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKChvYmplY3QuaXNCb29sZWFuKHZhbHVlKSAmJiAhdmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ck51bWJlcignd2lkdGgnKTtcclxuICAgIH0gZWxzZSBpZighb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpICYmIHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJOdW1iZXIoJ3dpZHRoJykgKyB0aGlzLnN0cm9rZVdpZHRoKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYXR0cih7d2lkdGg6dmFsdWV9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcbi8vVE9ETzogY29uc2lkZXIgc3Ryb2tlLXdpZHRoIC4uLlxyXG5TVkdSZWN0LnByb3RvdHlwZS5yaWdodFggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLngoKSArIHRoaXMud2lkdGgoKTtcclxufTtcclxuXHJcblNWR1JlY3QucHJvdG90eXBlLmJvdHRvbVkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnkoKSArIHRoaXMuaGVpZ2h0KCk7XHJcbn07XHJcblxyXG5TVkdSZWN0LnByb3RvdHlwZS5vdmVybGF5Q2hlY2sgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uLnggPj0gdGhpcy54KCkgJiYgcG9zaXRpb24ueCA8PSB0aGlzLnJpZ2h0WCgpXHJcbiAgICAgICAgJiYgcG9zaXRpb24ueSA+PSB0aGlzLnkoKSAmJiBwb3NpdGlvbi55IDw9IHRoaXMuYm90dG9tWSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdSZWN0OyIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJpbmcnKTtcclxuXHJcbnZhciBSRUdFWFBfUFJPUEVSVFlfU1VGRklYID0gJzpbYS16QS1aMC05IyxcXC5dKig7fCQpJztcclxuXHJcbnZhciBTdHlsZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhrZXkpICYmICFvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBrZXk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2V0KGtleSx2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TdHlsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYob2JqZWN0LmlzT2JqZWN0KGtleSkpIHtcclxuICAgICAgICBvYmplY3QuZWFjaChrZXksIGZ1bmN0aW9uKG9iaktleSwgdmFsKSB7XHJcbiAgICAgICAgICAgIGlmKGtleS5oYXNPd25Qcm9wZXJ0eShvYmpLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChvYmpLZXksdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc1N0cmluZyhrZXkpICYmIG9iamVjdC5pc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgaWYoIW9iamVjdC5pc0RlZmluZWQodGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLnZhbHVlLmluZGV4T2Yoa2V5Kyc6JykgPj0gMCkge1xyXG4gICAgICAgICAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cChrZXkrUkVHRVhQX1BST1BFUlRZX1NVRkZJWCwgJ2dpJyk7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnJlcGxhY2UocmVnRXhwLCB0aGlzLmNyZWF0ZVZhbHVlU3RyaW5nKGtleSx2YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgKz0gKCFzdHJpbmcuZW5kc1dpdGgodGhpcy52YWx1ZSwnOycpICYmIHRoaXMudmFsdWUubGVuZ3RoID4gMCkgPyAnOycgKyB0aGlzLmNyZWF0ZVZhbHVlU3RyaW5nKGtleSx2YWx1ZSkgOiB0aGlzLmNyZWF0ZVZhbHVlU3RyaW5nKGtleSx2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc1N0cmluZyhrZXkpKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGtleTtcclxuICAgIH1cclxufTtcclxuXHJcblN0eWxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKGtleStSRUdFWFBfUFJPUEVSVFlfU1VGRklYLCAnZ2knKTtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbHVlLm1hdGNoKHJlZ0V4cCk7XHJcbiAgICBpZihvYmplY3QuaXNBcnJheShyZXN1bHQpKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0WzBdO1xyXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IHZhbHVlLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYoc3BsaXR0ZWQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3BsaXR0ZWRbMV07XHJcbiAgICAgICAgICAgIHJldHVybiAoc3RyaW5nLmVuZHNXaXRoKHJlc3VsdCwgJzsnKSk/IHJlc3VsdC5zdWJzdHJpbmcoMCxyZXN1bHQubGVuZ3RoIC0xKSA6IHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TdHlsZS5wcm90b3R5cGUuY3JlYXRlVmFsdWVTdHJpbmcgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICByZXR1cm4ga2V5Kyc6Jyt2YWx1ZSsnOyc7XHJcbn07XHJcblxyXG5TdHlsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZTtcclxuIiwiLyoqXHJcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBhY2Nlc3NpbmcgU1ZHIGVsZW1lbnRzLlxyXG4gKiBBbGwgU1ZHIGVsZW1lbnRzIGNyZWF0ZWQgd2l0aCB0aGlzIG1vZHVsZSBjYW4gYmUgYWNjZXNzZWQgYnkgSUQgdGhyb3VnaCB0aGUgaW5zdGFuY2Ugb2JqZWN0LlxyXG4gKlxyXG4gKiBBbiBTVkcgZWxlbWVudCBjcmVhdGVkIHdpdGggdGhpcyBtb2R1bGUgY2FuIGJlIHNlcGVyYXRlZCBpbnRvIG11bHRpcGxlIHBhcnRzIHdoaWNoIGNhbiBiZSBtYW5hZ2VkIHNwZXJhdGx5LlxyXG4gKiBUaGUgJ3Jvb3QnIHBhcnQgd2lsbCBiZSBjcmVhdGVkIGJ5IGRlZmF1bHQuIFdoZW4gY3JlYXRpbmcgYSBuZXcgc3ZnIHBhcnQgeW91IGNhbiBzZXQgaXQgYXMgZGVmYXVsdCBwYXJ0LCBzbyBhbGwgYWN0aW9uc1xyXG4gKiBsaWtlIGluc2VydGlvbnMgd2lsbCBiZSBleGVjdXRlZCBvbiB0aGUgZGVmYXVsdCBwYXJ0IGlmIHRoZXJlIGlzIG5vIG90aGVyIHBhcnQgYXMgYXJndW1lbnQuXHJcbiAqL1xyXG52YXIgU1ZHR2VuZXJpY1NoYXBlID0gcmVxdWlyZSgnLi9nZW5lcmljU2hhcGUnKTtcclxucmVxdWlyZSgnLi9kcmFnZ2FibGUnKTtcclxudmFyIHNoYXBlcyA9IHJlcXVpcmUoJy4vZWxlbWVudHMnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcclxuXHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG5cclxudmFyIE5BTUVTUEFDRV9TVkcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG52YXIgTkFNRVNQQUNFX1hMSU5LID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5cclxudmFyIGluc3RhbmNlcyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjb25zdHJ1Y3RvciBpbml0aWFsaXplcyBhIG5ldyBTVkcgZWxlbWVudCB3aXRoaW4gdGhlIGdpdmVuIGNvbnRhaW5lcklkLlxyXG4gKiBUaGUgY29uc3RydWN0b3IgYWNjZXB0cyB0aGUgY29udGFpbmVySWQgZWl0aGVyIGFzIHNlbGVjdG9yICcjY29udGFpbmVySWQnIG9yIGFzIGlkIHN0cmluZyAnY29udGFpbmVySWQnLlxyXG4gKlxyXG4gKiBUaGUgaWQgb2YgdGhlIG53IFNWRyBlbGVtZW50IHdpbGwgYmUgdGhlIGNvbnRhaW5lcklkIHdpdGggdGhlIHN1ZmZpeCAnX3N2ZycgLT4gJ2NvbnRhaW5lcklkX3N2ZycuXHJcbiAqXHJcbiAqIEF0dHJpYnV0ZXMgb2YgdGhlIG5ldyBTVkcgZWxlbW50IGNhbiBiZSBzZXQgdGhyb3VnaCB0aGUgY29uc3RydWN0b3IgYXJndW1lbnQgJ2NmZycuXHJcbiAqXHJcbiAqIFRoZSBTVkcgY2FuIGJlIHNlcGVyYXRlZCBpbiBtdWx0aXBsZSBwYXJ0cyBzbyB5b3UgY2FuIGVhc2lseSBhcHBlbmQgZWxlbWVudHMgdG8gdGhlIGRpZmZlcmVudCBwYXJ0LlxyXG4gKiBUaGUgY29uc3RydWN0b3IgY3JlYXRlcyBhICdyb290JyBwYXJ0IGFzIGRlZmF1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250YWluZXJJZFxyXG4gKiBAcGFyYW0gY2ZnXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFNWRyA9IGZ1bmN0aW9uKGNvbnRhaW5lcklkLCBjZmcpIHtcclxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIFNWRykpIHtcclxuICAgICAgICByZXR1cm4gU1ZHLmdldChjb250YWluZXJJZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG5cclxuICAgIC8vR2V0IGlkIGZyb20gc2VsZWN0b3IgaWYgaXRzIGFuIHNlbGVjdG9yXHJcbiAgICB0aGlzLmNvbnRhaW5lcklkID0gZG9tLmdldFJhd0lkKGNvbnRhaW5lcklkKTtcclxuICAgIHRoaXMuJGNvbnRhaW5lciA9ICQucUNhY2hlKCcjJyt0aGlzLmNvbnRhaW5lcklkKS5nZXQoMCk7XHJcblxyXG4gICAgaWYoIXRoaXMuJGNvbnRhaW5lcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHQgdG8gaW5pdGlhdGUgc3ZnIHN0YWdlIGZvciBpbnZhbGlkIGNvbnRhaW5lcklkOiAnK3RoaXMuY29udGFpbmVySWQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN2Z0lkID0gdGhpcy5jb250YWluZXJJZCsnX3N2Zyc7XHJcblxyXG4gICAgLy8gQ3JlYXRlIFNWRyByb290IGVsZW1lbnQgd2l0aCBnaXZlbiBzZXR0aW5ncy5cclxuICAgIHRoaXMucm9vdCA9IG5ldyBzaGFwZXMuU3ZnKHRoaXMsIHtpZCA6IHRoaXMuc3ZnSWR9KTtcclxuXHJcbiAgICBjZmcuaGVpZ2h0ID0gY2ZnLmhlaWdodCB8fCAnMTAwJSc7XHJcbiAgICBjZmcud2lkdGggPSBjZmcud2lkdGggIHx8ICcxMDAlJztcclxuXHJcbiAgICAvLyBTZXQgY2ZnIHZhbHVlcyBhcyBzdmcgcm9vdCBhdHRyaWJ1dGVzXHJcbiAgICB0aGlzLnJvb3QuYXR0cihjZmcpO1xyXG5cclxuICAgIC8vIEFwcGVuZCB0aGUgc3ZnIHJvb3QgZWxlbWVudCB0byB0aGUgY29udGFpbmVybm9kZVxyXG4gICAgZG9tLmFwcGVuZFNWR0VsZW1lbnQodGhpcy4kY29udGFpbmVyLCB0aGlzLnJvb3QpO1xyXG5cclxuICAgIC8vIFRoZSByb290IHBhcnQgaXMgdGhlIHN2ZyBlbGVtZW50IGl0c2VsZlxyXG4gICAgdGhpcy5zdmdQYXJ0cyA9IHsncm9vdCc6dGhpcy5yb290fTtcclxuICAgIHRoaXMuZGVmYXVsdFBhcnQgPSB0aGlzLnJvb3Q7XHJcblxyXG4gICAgaW5zdGFuY2VzW3RoaXMuc3ZnSWRdID0gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdmcgcm9vdCBkb21Ob2RlLlxyXG4gKiBAcmV0dXJucyB7Kn0gc3ZnIHJvb3QgZG9tTm9kZVxyXG4gKi9cclxuU1ZHLnByb3RvdHlwZS5nZXRSb290Tm9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLnJvb3QpID8gdGhpcy5yb290Lmluc3RhbmNlKCkgOiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGNhY2hlZCBqUXVlcnkgb2JqZWN0IG9mIHRoZSByb290IG5vZGUuXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuU1ZHLnByb3RvdHlwZS4kID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJC5xQ2FjaGUoJyMnK3RoaXMuc3ZnSWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgaW1wb3J0aW5nIGRpYWdyYW1zIGludG8gdGhlIHN2ZyBpbnN0YW5jZS5cclxuICogQHBhcmFtIGVsZW1lbnRcclxuICovXHJcblNWRy5wcm90b3R5cGUuc2V0Um9vdCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHZhciBuZXdJZCA9IGRvbS5nZXRBdHRyaWJ1dGVzKGVsZW1lbnQpWydpZCddO1xyXG4gICAgdGhpcy5yb290Lmluc3RhbmNlKGVsZW1lbnQpO1xyXG4gICAgdGhpcy5yb290LmF0dHIoe2lkIDogbmV3SWR9KTtcclxuICAgIGluc3RhbmNlc1tuZXdJZF0gPSB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHJvb3QgZWxlbWVudCBhcyBTVkdFbGVtZW50XHJcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fGV4cG9ydHN8bW9kdWxlLmV4cG9ydHN8Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlZmF1bHRQYXJ0XHJcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fGV4cG9ydHN8bW9kdWxlLmV4cG9ydHN8Kn0gY3VycmVudCBkZWZhdWx0UGFydFxyXG4gKi9cclxuU1ZHLnByb3RvdHlwZS5nZXREZWZhdWx0UGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBzdmcgcGFydCB3aGljaCBpcyByZXByZXNlbnRlZCBieSBhIG5ldyBncm91cCB3aXRoaW4gdGhlIHJvb3QuXHJcbiAqIFRoZSBwYXJ0IGlkIGlzIGNvbXBvc2l0ZSBvZiB0aGUgc3ZnIHJvb3QgaWQgYW5kIHRoZSBwYXJ0SWQuXHJcbiAqIEJ5IHNldHRpbmcgdGhlIGlzRGVmYXVsdCBhcmd1bWVudCBhcyB0cnVlIHRoZSBuZXcgcGFydCB3aWxsIGJlIHNldCBhcyBkZWZhdWx0IHBhcnQuXHJcbiAqIEBwYXJhbSBwYXJ0SWRcclxuICogQHBhcmFtIGlzRGVmYXVsdFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuY3JlYXRlUGFydCA9IGZ1bmN0aW9uKHBhcnRJZCwgaXNEZWZhdWx0KSB7XHJcbiAgICAvL05ldyBwYXJ0cyBhcmUgYWx3YXlzIGFkZGVkIHRvIHRoZSByb290IHBhcnRcclxuICAgIHRoaXMuc3ZnUGFydHNbcGFydElkXSA9IHRoaXMuZyh7aWQ6IHRoaXMuc3ZnSWQrJ18nK3BhcnRJZCwgcGFyZW50UGFydDogJ3Jvb3QnfSk7XHJcbiAgICBpZihpc0RlZmF1bHQpIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHRQYXJ0ID0gdGhpcy5zdmdQYXJ0c1twYXJ0SWRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuc3ZnUGFydHNbcGFydElkXTtcclxufTtcclxuXHJcblNWRy5wcm90b3R5cGUucGFydCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdmdQYXJ0c1tpZF07XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBzdmcgZWxlbWVudCB0byB0aGUgZ2l2ZW4gcGFydC5cclxuICpcclxuICogQHBhcmFtIHBhcnRcclxuICogQHBhcmFtIGVsZW1lbnRcclxuICovXHJcblNWRy5wcm90b3R5cGUuYWRkVG9QYXJ0ID0gZnVuY3Rpb24ocGFydCwgZWxlbWVudCkge1xyXG4gICAgdGhpcy5hZGRUb0dyb3VwKHRoaXMuc3ZnUGFydHNbcGFydF0sIGVsZW1lbnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gYXBwZW5kIG9yIHByZXBlbmQgZWxlbWVudHMgd2l0aCB0ZXh0IHRvIHRoZSBzdmcgcm9vdC5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnRcclxuICogQHBhcmFtIHByZXBlbmRcclxuICogQHBhcmFtIHRleHRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmFkZFRvUm9vdCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByZXBlbmQsIHRleHQpIHtcclxuICAgIGlmKHByZXBlbmQpIHtcclxuICAgICAgICByZXR1cm4gZG9tLnByZXBlbmRTVkdFbGVtZW50KHRoaXMuZ2V0Um9vdCgpLCBlbGVtZW50LCB0ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRvbS5hcHBlbmRTVkdFbGVtZW50KHRoaXMuZ2V0Um9vdCgpLCBlbGVtZW50LCB0ZXh0KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGFwcGVuZC9wcmVwZW5kIGVsZW1lbnRzIHdpdGggdGV4dCB0byBhIGdpdmVuIChvciBkZWZhdWx0KSBzdmcgcGFydC5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnRcclxuICogQHBhcmFtIHBhcnRcclxuICogQHBhcmFtIHByZXBlbmRcclxuICogQHBhcmFtIHRleHRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHBhcnQsIHByZXBlbmQsIHRleHQpIHtcclxuICAgIHBhcnQgPSBwYXJ0IHx8IHRoaXMuZ2V0RGVmYXVsdFBhcnQoKTtcclxuICAgIGVsZW1lbnQucGFyZW50ID0gcGFydDtcclxuICAgIGlmKHByZXBlbmQpIHtcclxuICAgICAgICByZXR1cm4gZG9tLnByZXBlbmRTVkdFbGVtZW50KHBhcnQsIGVsZW1lbnQsIHRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZG9tLmFwcGVuZFNWR0VsZW1lbnQocGFydCwgZWxlbWVudCwgdGV4dCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogSW1wb3J0cyBhbiB4bWwgZG9jdW1lbnQgdG8gdGhlIGdpdmVuIHN2ZyBwYXJ0LlxyXG4gKiBAcGFyYW0gZWxlbWVudFhNTFxyXG4gKiBAcGFyYW0gcGFydFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuaW1wb3J0ID0gZnVuY3Rpb24oc3ZnU3RyLCBwYXJ0LCBwcmVwZW5kKSB7XHJcbiAgICBwYXJ0ID0gdGhpcy5zdmdQYXJ0c1twYXJ0XSB8fCB0aGlzLmdldERlZmF1bHRQYXJ0KCk7XHJcbiAgICByZXR1cm4gZG9tLmltcG9ydFNWRyhwYXJ0LCBzdmdTdHIsIHByZXBlbmQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW5kIHJldHVybnMgYSBuZXdseSBjcmVhdGVkIHN2ZyBSZWN0IHdpdGggdGhlIGdpdmVuIHNldHRpbmdzIHRvIHRoZSBnaXZlbiAob3IgZGVmYXVsdCkgcGFydC5cclxuICogQHBhcmFtIGNmZ1xyXG4gKiBAcGFyYW0gcGFydFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKGNmZywgcGFydCkge1xyXG4gICAgcGFydCA9IHRoaXMuc3ZnUGFydHNbcGFydF0gfHwgdGhpcy5nZXREZWZhdWx0UGFydCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKG5ldyBzaGFwZXMuUmVjdCh0aGlzLCBjZmcpLCBwYXJ0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuZCByZXR1cm5zIGEgbmV3bHkgY3JlYXRlZCBzdmcgVGV4dCB3aXRoIHRoZSBnaXZlbiBzZXR0aW5ncyB0byB0aGUgZ2l2ZW4gKG9yIGRlZmF1bHQpIHBhcnQuXHJcbiAqIEBwYXJhbSBjZmdcclxuICogQHBhcmFtIHBhcnRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih0ZXh0LCBjZmcsIHBhcnQpIHtcclxuICAgIHBhcnQgPSB0aGlzLnN2Z1BhcnRzW3BhcnRdIHx8IHRoaXMuZ2V0RGVmYXVsdFBhcnQoKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChuZXcgc2hhcGVzLlRleHQodGhpcywgY2ZnKSwgcGFydCwgZmFsc2UpLmNvbnRlbnQodGV4dCk7XHJcbn07XHJcblxyXG5TVkcucHJvdG90eXBlLnRzcGFuID0gZnVuY3Rpb24odGV4dCwgY2ZnLCBwYXJ0KSB7XHJcbiAgICBwYXJ0ID0gdGhpcy5zdmdQYXJ0c1twYXJ0XSB8fCB0aGlzLmdldERlZmF1bHRQYXJ0KCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQobmV3IHNoYXBlcy5UU3Bhbih0aGlzLCBjZmcpLCBwYXJ0LCBmYWxzZSkuY29udGVudCh0ZXh0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuZCByZXR1cm5zIGEgbmV3bHkgY3JlYXRlZCBzdmcgQ2lyY2xlIHdpdGggdGhlIGdpdmVuIHNldHRpbmdzIHRvIHRoZSBnaXZlbiAob3IgZGVmYXVsdCkgcGFydC5cclxuICogQHBhcmFtIGNmZ1xyXG4gKiBAcGFyYW0gcGFydFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuY2lyY2xlID0gZnVuY3Rpb24oY2ZnLCBwYXJ0KSB7XHJcbiAgICBwYXJ0ID0gdGhpcy5zdmdQYXJ0c1twYXJ0XSB8fCB0aGlzLmdldERlZmF1bHRQYXJ0KCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQobmV3IHNoYXBlcy5DaXJjbGUodGhpcywgY2ZnKSwgcGFydCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbmQgcmV0dXJucyBhIG5ld2x5IGNyZWF0ZWQgc3ZnIENpcmNsZSB3aXRoIHRoZSBnaXZlbiBzZXR0aW5ncyB0byB0aGUgZ2l2ZW4gKG9yIGRlZmF1bHQpIHBhcnQuXHJcbiAqIEBwYXJhbSBjZmdcclxuICogQHBhcmFtIHBhcnRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbihjZmcsIHBhcnQpIHtcclxuICAgIHBhcnQgPSB0aGlzLnN2Z1BhcnRzW3BhcnRdIHx8IHRoaXMuZ2V0RGVmYXVsdFBhcnQoKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChuZXcgc2hhcGVzLkVsbGlwc2UodGhpcywgY2ZnKSwgcGFydCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbmQgcmV0dXJucyBhIG5ld2x5IGNyZWF0ZWQgc3ZnIEdyb3VwIHdpdGggdGhlIGdpdmVuIHNldHRpbmdzIHRvIHRoZSBnaXZlbiAob3IgZGVmYXVsdCkgcGFydC5cclxuICogQHBhcmFtIGNmZ1xyXG4gKiBAcGFyYW0gcGFydFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuZyA9IGZ1bmN0aW9uKGNmZykge1xyXG4gICAgdmFyIGNmZyA9IGNmZyB8fHt9O1xyXG5cclxuICAgIHZhciBwYXJlbnRQYXJ0ID0gdGhpcy5zdmdQYXJ0c1tjZmcucGFyZW50UGFydF0gfHwgdGhpcy5nZXREZWZhdWx0UGFydCgpO1xyXG5cclxuICAgIGRlbGV0ZSBjZmcucGFydDtcclxuXHJcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmFkZChuZXcgc2hhcGVzLkdyb3VwKHRoaXMsIGNmZyksIHBhcmVudFBhcnQpO1xyXG5cclxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMTtpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZGRUb0dyb3VwOiAnK2dyb3VwLmF0dHIoJ2lkJykrJyAtICcrIGFyZ3VtZW50c1tpXS5hdHRyKCdpZCcpKTtcclxuICAgICAgICAgICAgZG9tLmFwcGVuZFNWR0VsZW1lbnQoZ3JvdXAuaW5zdGFuY2UoKSwgYXJndW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ3JvdXA7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbmRzIGFuIHN2ZyBlbGVtZW50IG90IHRoZSBnaXZlbiBncm91cC5cclxuICogQHBhcmFtIGNmZ1xyXG4gKiBAcGFyYW0gcGFydFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuYWRkVG9Hcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBlbGVtZW50KSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgaWYob2JqZWN0LmlzQXJyYXkoZWxlbWVudCkpIHtcclxuICAgICAgICByZXN1bHQgPSBbXTtcclxuICAgICAgICBvYmplY3QuZWFjaChlbGVtZW50LCBmdW5jdGlvbihpbmRleCwgdmFsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRvbS5hcHBlbmRTVkdFbGVtZW50KGdyb3VwLmluc3RhbmNlKCksIGVsZW1lbnQpKTtcclxuICAgICAgICB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZG9tLmFwcGVuZFNWR0VsZW1lbnQoZ3JvdXAuaW5zdGFuY2UoKSwgZWxlbWVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbmQgcmV0dXJucyBhIG5ld2x5IGNyZWF0ZWQgc3ZnIFBhdGggd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZ3MgdG8gdGhlIGdpdmVuIChvciBkZWZhdWx0KSBwYXJ0LlxyXG4gKiBAcGFyYW0gY2ZnXHJcbiAqIEBwYXJhbSBwYXJ0XHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuU1ZHLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24oY2ZnLCBwYXJ0KSB7XHJcbiAgICB2YXIgcGFydCA9IHRoaXMuc3ZnUGFydHNbcGFydF0gfHwgdGhpcy5nZXREZWZhdWx0UGFydCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKG5ldyBzaGFwZXMuUGF0aCh0aGlzLCBjZmcpLCBwYXJ0KTtcclxufTtcclxuXHJcblNWRy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcclxuICAgICQodGhpcy5yb290Lmluc3RhbmNlKCkpLmVtcHR5KCk7XHJcbn07XHJcblxyXG5TVkcucHJvdG90eXBlLmFzU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290LnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuIFNWR0VsZW1lbnQgb3V0IG9mIHRoZSBnaXZlbiBpZCBzZWxlY3RvciBlbGVtZW50LlxyXG4gKiBAcGFyYW0gaWRTZWxlY3RvclxyXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudHxleHBvcnRzfG1vZHVsZS5leHBvcnRzfVxyXG4gKi9cclxuU1ZHLmdldCA9IGZ1bmN0aW9uKGlkU2VsZWN0b3IpIHtcclxuICAgIHZhciAkbm9kZTtcclxuXHJcbiAgICBpZighb2JqZWN0LmlzU3RyaW5nKGlkU2VsZWN0b3IpKSB7XHJcbiAgICAgICAgJG5vZGUgPSAkKGlkU2VsZWN0b3IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAkbm9kZSA9ICQucUNhY2hlKGRvbS5nZXRJZFNlbGVjdG9yKGlkU2VsZWN0b3IpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZighJG5vZGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2NhbGwgU1ZHLmdldCBvbiBhIG5vbiBleGlzdGluZyBub2RlOiAnK2lkU2VsZWN0b3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgJHN2Z1Jvb3ROb2RlID0gJCgkbm9kZS5nZXQoMCkub3duZXJTVkdFbGVtZW50KTtcclxuXHJcbiAgICBpZigkc3ZnUm9vdE5vZGUubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHN2Z0luc3RhbmNlID0gaW5zdGFuY2VzWyRzdmdSb290Tm9kZS5hdHRyKCdpZCcpXTtcclxuICAgICAgICByZXR1cm4gU1ZHLl9zdmdJbnN0YW5jZSgkbm9kZSwgc3ZnSW5zdGFuY2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0NhbGwgU1ZHLmdldCBvbiBub2RlIHdpdGggbm8gc3ZnIHJvb3QnKTtcclxuICAgIH1cclxufTtcclxuXHJcblNWRy5fc3ZnSW5zdGFuY2UgPSBmdW5jdGlvbigkbm9kZSwgc3ZnKSB7XHJcbiAgICB2YXIgU1ZHU2hhcGUgPSBTVkcuZ2V0U2hhcGVCeU5hbWUoJG5vZGUuZ2V0KDApLm5vZGVOYW1lKTtcclxuICAgIHJldHVybiAoU1ZHU2hhcGUpID8gbmV3IFNWR1NoYXBlKHN2ZykuaW5zdGFuY2UoJG5vZGUuZ2V0KDApKSA6IG5ldyBTVkdHZW5lcmljU2hhcGUoJG5vZGUuZ2V0KDApLCBzdmcpO1xyXG59O1xyXG5cclxuU1ZHLmdldFNoYXBlQnlOYW1lID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHNoYXBlc1t0eXBlLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblNWRy5wcm90b3R5cGUuZ2V0ID0gU1ZHLmdldDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHO1xyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIFNWR0VsZW1lbnQgPSByZXF1aXJlKCcuL3N2Z0VsZW1lbnQnKTtcclxuXHJcbnZhciBOQU1FU1BBQ0VfU1ZHID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxudmFyIE5BTUVTUEFDRV9YTElOSyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcclxudmFyIFNWR19WRVJTSU9OID0gJzEuMSc7XHJcblxyXG52YXIgU1ZHUm9vdCA9IGZ1bmN0aW9uKHN2ZywgY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICBjZmdbJ3htbG5zJ10gPSBOQU1FU1BBQ0VfU1ZHO1xyXG4gICAgY2ZnWyd4bWxuczp4bGluayddID0gTkFNRVNQQUNFX1hMSU5LO1xyXG4gICAgY2ZnWyd2ZXJzaW9uJ10gPSBTVkdfVkVSU0lPTjtcclxuICAgIFNWR0VsZW1lbnQuY2FsbCh0aGlzLCAnc3ZnJywgc3ZnLCBjZmcpO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhTVkdSb290LCBTVkdFbGVtZW50KTtcclxuXHJcblNWR1Jvb3QucHJvdG90eXBlLnggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSkgPyB0aGlzLmF0dHJOdW1iZXIoJ3gnLCB2YWx1ZSkgOiB0aGlzLmF0dHJOdW1iZXIoJ3gnKSB8fCAwIDtcclxufTtcclxuXHJcblNWR1Jvb3QucHJvdG90eXBlLnkgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh2YWx1ZSkgPyB0aGlzLmF0dHJOdW1iZXIoJ3knLCB2YWx1ZSkgOiB0aGlzLmF0dHJOdW1iZXIoJ3knKSB8fCAwIDtcclxufTtcclxuXHJcblNWR1Jvb3QucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiB0aGlzLngoKSArIE1hdGguZmxvb3IodGhpcy53aWR0aCgpIC8gMiksXHJcbiAgICAgICAgeTogdGhpcy55KCkgKyBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0KCkgLyAyKVxyXG4gICAgfTtcclxufTtcclxuXHJcblNWR1Jvb3QucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZighdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kKCkuaGVpZ2h0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYXR0cignaGVpZ2h0JywgdmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHUm9vdC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoIXZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJCgpLndpZHRoKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYXR0cignd2lkdGgnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1Jvb3Q7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBTVkdTaGFwZSA9IHJlcXVpcmUoJy4vZ2VuZXJpY1NoYXBlJyk7XHJcblxyXG52YXIgREVGQVVMVF9GT05UX1NJWkUgPSAxMTtcclxudmFyIERFRkFVTFRfRk9OVF9GQU1JTFkgPSBcIkhlbHZldGljYVwiOyAvL1ZlcmRhbmEsIEFyaWFsLCBzYW5zLXNlcmlmID9cclxudmFyIERFRkFVTFRfVEVYVF9BTkNIT1IgPSBcInN0YXJ0XCI7XHJcbnZhciBERUZBVUxUX0RPTUlOQU5UX0JBU0VMSU5FID0gXCJoYW5naW5nXCI7XHJcblxyXG52YXIgREVGQVVMVF9TUEFOX1BBRERJTkcgPSAwO1xyXG5cclxudmFyIFNWR1RleHQgPSBmdW5jdGlvbihzdmdSb290LCBjZmcsIGF0dHJpYnV0ZVNldHRlcikge1xyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgY2ZnWydmb250LWZhbWlseSddID0gY2ZnWydmb250LXNpemUnXSB8fCBERUZBVUxUX0ZPTlRfRkFNSUxZO1xyXG4gICAgY2ZnWydmb250LXNpemUnXSA9IGNmZ1snZm9udC1zaXplJ10gfHwgREVGQVVMVF9GT05UX1NJWkU7XHJcbiAgICBjZmdbJ3RleHQtYW5jaG9yJ10gPSBjZmdbJ3RleHQtYW5jaG9yJ10gfHwgREVGQVVMVF9URVhUX0FOQ0hPUjtcclxuICAgIGNmZ1snZG9taW5hbnQtYmFzZWxpbmUnXSA9IGNmZ1snZG9taW5hbnQtYmFzZWxpbmUnXSB8fCBERUZBVUxUX0RPTUlOQU5UX0JBU0VMSU5FO1xyXG5cclxuICAgIHRoaXMuc3BhblBhZGRpbmcgPSBjZmdbJ3BhZGRpbmcnXSB8fCBERUZBVUxUX1NQQU5fUEFERElORztcclxuXHJcbiAgICBTVkdTaGFwZS5jYWxsKHRoaXMsICd0ZXh0Jywgc3ZnUm9vdCwgY2ZnLCBhdHRyaWJ1dGVTZXR0ZXIpO1xyXG4gICAgLy9UT0RPOiBTcGFuIC8gbXVsdGkgbGluZSB0ZXh0XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKFNWR1RleHQsIFNWR1NoYXBlKTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmZvbnRGYW1pbHkgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignZm9udC1mYW1pbHknLCB2YWx1ZSk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy5zcGFuUGFkZGluZyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2V0U3BhbkF0dHIoJ3gnLCB2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNwYW5QYWRkaW5nO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuZm9udEZhbWlseSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdmb250LWZhbWlseScsIHZhbHVlKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmZvbnRTaXplID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLmF0dHJOdW1iZXIoJ2ZvbnQtc2l6ZScsIHZhbHVlKTtcclxuICAgIGlmKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTcGFuQXR0cignZHknLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5zZXRTcGFuQXR0ciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgIHRoaXMuJCgpLmNoaWxkcmVuKCd0c3BhbicpLmF0dHIoa2V5LCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLnggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIChvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSkgPyB0aGlzLmF0dHJOdW1iZXIoJ3gnLCB2YWx1ZSkgOiB0aGlzLnRyYW5zbGF0ZWRYKHRoaXMuYXR0ck51bWJlcigneCcsIHZhbHVlKSkgfHwgMCA7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS55ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiAob2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpID8gdGhpcy5hdHRyTnVtYmVyKCd5JywgdmFsdWUpIDogdGhpcy50cmFuc2xhdGVkWSh0aGlzLmF0dHJOdW1iZXIoJ3knLCB2YWx1ZSkpIHx8IDAgO1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuZHggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0ck51bWJlcignZHgnLCB2YWx1ZSk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5keSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyTnVtYmVyKCdkeScsIHZhbHVlKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgIFNWR1RleHQuc3VwZXJfLnByb3RvdHlwZS5tb3ZlLmFwcGx5KHRoaXMsIFtkeCwgZHldKTtcclxuICAgIHRoaXMuYWxpZ25CYWNrZ3JvdW5kKCk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICBTVkdUZXh0LnN1cGVyXy5wcm90b3R5cGUubW92ZVRvLmFwcGx5KHRoaXMsIFt4LCB5XSk7XHJcbiAgICB0aGlzLmFsaWduQmFja2dyb3VuZCgpO1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgIGlmKCF0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHZhciBoZWlnaHQ7XHJcbiAgICB0aGlzLiQoKS5lbXB0eSgpO1xyXG4gICAgJC5lYWNoKHRleHQuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgdFNwYW4gPSB0aGF0LnN2Zy50c3Bhbih2YWx1ZSkueCh0aGF0LnNwYW5QYWRkaW5nKTtcclxuICAgICAgICAgICAgdGhhdC5hcHBlbmQodFNwYW4pO1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRTcGFuLmR5KGhlaWdodCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0U3Bhbi5oZWlnaHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB2YXIgJGNoaWxkcmVuID0gdGhpcy4kKCkuY2hpbGRyZW4oJ3RzcGFuJyk7XHJcbiAgICAkY2hpbGRyZW4uZWFjaChmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICByZXN1bHQgKz0gJCh0aGlzKS50ZXh0KCk7XHJcbiAgICAgICAgaWYoaW5kZXggIT0gJGNoaWxkcmVuLmxlbmd0aCAtMSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuc3dpdGNoQW5jaG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICBzd2l0Y2godGhpcy5hbmNob3IoKSkge1xyXG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgICBjYXNlICdlbmQnOlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5nZXRFeHRlbnRPZkNoYXIgPSBmdW5jdGlvbihjaGFyTnVtKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZSgpLmdldEV4dGVudE9mQ2hhcihjaGFyTnVtKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmdldENoYXJIZWlnaHQgPSBmdW5jdGlvbihjaGFyTnVtKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRFeHRlbnRPZkNoYXIoY2hhck51bSkuaGVpZ2h0O1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuZ2V0Q2hhckRpZmYgPSBmdW5jdGlvbihjaGFyTnVtKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oZWlnaHQoKSAtIHRoaXMuZ2V0Q2hhckhlaWdodChjaGFyTnVtKVxyXG4gICAgdGhpcy5nZXRDaGFySGVpZ2h0KGNoYXJOdW0pICsgdGhpcy5nZXRFeHRlbnRPZkNoYXIoY2hhck51bSkueTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hbmNob3IoJ3N0YXJ0Jyk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmFuY2hvcignZW5kJyk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5taWRkbGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmFuY2hvcignbWlkZGxlJyk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5hbmNob3IgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigndGV4dC1hbmNob3InLCB2YWx1ZSk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS50U3BhbiA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdmcuZ2V0KHRoaXMuJCgpLmNoaWxkcmVuKCd0c3BhbicpLmdldChpbmRleCkpO1xyXG59XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5oYW5naW5nID0gZnVuY3Rpb24oaGFuZ2luZykge1xyXG4gICAgdmFyIGhhbmdpbmcgPSBvYmplY3QuaXNEZWZpbmVkKGhhbmdpbmcpID8gaGFuZ2luZyA6IHRydWU7XHJcbiAgICB2YXIgdmFsdWUgPSBoYW5naW5nID8gJ2hhbmdpbmcnIDogJ2Jhc2VsaW5lJztcclxuICAgIHRoaXMuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCB2YWx1ZSk7XHJcbiAgICB2YXIgZmlyc3RTcGFuID0gdGhpcy50U3BhbigwKTtcclxuICAgIHZhciBkeSA9IChoYW5naW5nKSA/IDAgOiBmaXJzdFNwYW4uaGVpZ2h0KCkgKyB0aGlzLmdldEJCb3goKS55O1xyXG4gICAgZmlyc3RTcGFuLmR5KGR5KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vdGU6IHRoZSBiYWNrZ3JvdW5kIHdvbid0IGFsaWduIHdoZW4gdGhlIHRleHQgaXMgZHJhZ2dlZC4gUGVyaGFwcyBhZGQgZHJhZyBob29rXHJcbiAqIEBwYXJhbSBjb2xvclxyXG4gKi9cclxuU1ZHVGV4dC5wcm90b3R5cGUuYmFja2dyb3VuZCA9IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgICB2YXIgc3ZnQmFja2dyb3VuZCA9IHRoaXMuZ2V0QmFja2dyb3VuZCgpO1xyXG4gICAgaWYoY29sb3IpIHtcclxuICAgICAgICBpZighc3ZnQmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICBzdmdCYWNrZ3JvdW5kID0gdGhpcy5zdmcucmVjdCh7J2NsYXNzJzondGV4dEJhY2tncm91bmQnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN2Z0JhY2tncm91bmQuZmlsbChjb2xvcik7XHJcbiAgICAgICAgc3ZnQmFja2dyb3VuZC4kKCkuYWZ0ZXIodGhpcy4kKCkpO1xyXG4gICAgICAgIHRoaXMuYWxpZ25CYWNrZ3JvdW5kKCk7XHJcbiAgICB9IGVsc2UgaWYoc3ZnQmFja2dyb3VuZCkge1xyXG4gICAgICAgIHN2Z0JhY2tncm91bmQuZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogIFRPRE86IHByb2JhYmx5IGp1c3Qgd29ya3MgZm9yIGhhbmdpbmcgdGV4dHMgYmVjYXVzZSBvZiB0aGUgb2Zmc2V0Li4uXHJcbiAqL1xyXG5TVkdUZXh0LnByb3RvdHlwZS5hbGlnbkJhY2tncm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzdmdCYWNrZ3JvdW5kID0gdGhpcy5nZXRCYWNrZ3JvdW5kKCk7XHJcbiAgICBpZihzdmdCYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgdmFyIGJnSGVpZ2h0ID0gdGhpcy5oZWlnaHQoKSArIHRoaXMuZ2V0QkJveCgpLnk7IC8vcmVtb3ZlIHRleHQgb2Zmc2V0XHJcbiAgICAgICAgc3ZnQmFja2dyb3VuZC5oZWlnaHQoYmdIZWlnaHQpLndpZHRoKHRoaXMud2lkdGgoKSkudHJhbnNsYXRlKHRoaXMueCgpLCB0aGlzLnkoKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5nZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmJhY2tncm91bmRTVkcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kU1ZHO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2ID0gdGhpcy4kKCkucHJldigpO1xyXG4gICAgaWYocHJldi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIHN2Z0JhY2sgPSB0aGlzLnN2Zy5nZXQocHJldik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZFNWRyA9IChzdmdCYWNrLmhhc0NsYXNzKCd0ZXh0QmFja2dyb3VuZCcpKSA/IHN2Z0JhY2sgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5kb21pbmFudEJhc2VsaW5lID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgdmFsdWUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdUZXh0OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIERvbUVsZW1lbnQgPSByZXF1aXJlKCcuLi9kb20vZG9tRWxlbWVudCcpO1xyXG5cclxudmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgaWYodHlwZW9mIGRlZiAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzU3RyaW5nKGRlZikpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXREZWZpbml0aW9uRnJvbVN0cmluZyhkZWYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZjtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IHt9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZWZpbml0aW9uRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZighdGhpcy5kZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXh0cmFjdCAndHJhbnNsYXRlKDIwMCAyMDApIHJvdGF0ZSg0NSA1MCA1MCknIHRvIFwidHJhbnNsYXRlXCIgXCIyMDAgMjAwXCIgXCIgcm90YXRlXCIgXCI0NSA1MCA1MFwiIFwiXCJcclxuICAgIHZhciB0cmFuc2Zvcm1hdGlvbnMgPSB2YWx1ZS5zcGxpdCgvW1xcKFxcKV0rLyk7XHJcbiAgICBmb3IodmFyIGkgPSAwO2kgPCB0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbnNbaV0udHJpbSgpO1xyXG4gICAgICAgIGlmKHRyYW5zZm9ybWF0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IERvbUVsZW1lbnQuZ2V0QXR0cmlidXRlVmFsdWVGcm9tU3RyaW5nTGlzdCh0cmFuc2Zvcm1hdGlvbnNbaSsxXSk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHByZWZlciBpbnRlZ2VyIHZhbHVlcyBmb3IgY2FsY3VsYXRpb25zXHJcbiAgICAgICAgICAgICAgICBpZighaXNOYU4odmFsdWVzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IHBhcnNlSW50KHZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uW3RyYW5zZm9ybWF0aW9uXSA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICBmb3IodmFyIGtleSBpbiB0aGlzLmRlZmluaXRpb24pIHtcclxuICAgICAgICBpZih0aGlzLmRlZmluaXRpb24uaGFzT3duUHJvcGVydHkoKGtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIGZpcnN0IHdlIGFzc2FtYmxlIGFsbCB0cmFuc2Zvcm1hdGlvbnMgaW4gYW4gYXJyYXkgWyd0cmFuc2xhdGUoMzApJywncm90YXRlKDQ1IDUwIDUwKSddXHJcbiAgICAgICAgICAgIHZhciBzaW5nbGVUcmFuc2Zvcm1hdGlvbiA9IGtleSsnKCcrRG9tRWxlbWVudC5nZXRBdHRyaWJ1dGVTdHJpbmcodGhpcy5kZWZpbml0aW9uW2tleV0pKycpJztcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goc2luZ2xlVHJhbnNmb3JtYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG1lcmdlIHRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gb25lIGF0dHJpYnV0ZXN0cmluZ1xyXG4gICAgdmFyIHZhbHVlU3RyID0gRG9tRWxlbWVudC5nZXRBdHRyaWJ1dGVTdHJpbmcodmFsdWVzKTtcclxuXHJcbiAgICBpZih2YWx1ZVN0ci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSB0cmFuc29ybWF0aW9ucyBzZXQgd2UganVzdCByZXR1cm4gYW4gZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5oYXNUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgZGVmaW5pdGlvbltrZXldICE9PSAndW5kZWZpbmVkJyk7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24ocykge1xyXG4gICAgaWYocykge1xyXG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbi5zY2FsZSA9IHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24uc2NhbGU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHZhciBwID0gdXRpbC5tYXRoLmdldFBvaW50KHgseSk7XHJcblxyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChwKSkge1xyXG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbi50cmFuc2xhdGUgPSBbcC54LCBwLnldO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZih0aGlzLmRlZmluaXRpb24udHJhbnNsYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4IDogdGhpcy5kZWZpbml0aW9uLnRyYW5zbGF0ZVswXSxcclxuICAgICAgICAgICAgICAgIHkgOiB0aGlzLmRlZmluaXRpb24udHJhbnNsYXRlWzFdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHggOiAwLFxyXG4gICAgICAgICAgICAgICAgeSA6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBTVkdTaGFwZSA9IHJlcXVpcmUoJy4vZ2VuZXJpY1NoYXBlJyk7XHJcbnZhciBTVkdUZXh0ID0gcmVxdWlyZSgnLi90ZXh0Jyk7XHJcblxyXG52YXIgREVGQVVMVF9ET01JTkFOVF9CQVNFTElORSA9ICdpbmhlcml0J1xyXG5cclxudmFyIFNWR1RTcGFuID0gZnVuY3Rpb24oc3ZnUm9vdCwgY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICBjZmdbJ2RvbWluYW50LWJhc2VsaW5lJ10gPSBjZmdbJ2RvbWluYW50LWJhc2VsaW5lJ10gfHwgREVGQVVMVF9ET01JTkFOVF9CQVNFTElORTtcclxuICAgIFNWR1NoYXBlLmNhbGwodGhpcywgJ3RzcGFuJywgc3ZnUm9vdCwgY2ZnKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoU1ZHVFNwYW4sIFNWR1RleHQpO1xyXG5cclxuU1ZHVFNwYW4ucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYodmFsdWUpIHtcclxuICAgICAgICB0aGlzLiQoKS50ZXh0KHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJCgpLnRleHQoKTtcclxuICAgIH1cclxufTtcclxuXHJcblNWR1RTcGFuLnByb3RvdHlwZS5nZXRCQm94ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvL3NvbWUgYnJvd3NlciAoZS5nLiBmaXJlZm94KSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdldEJCb3ggZm9yIHRzcGFuIGVsZW1lbnRzLlxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1RTcGFuOyIsInZhciBkb20gPSByZXF1aXJlKCcuLi9kb20vZG9tJyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG5cclxuRWRpdFBhbmVsID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbkVkaXRQYW5lbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHBhZ2VYLCBwYWdlWSwgb25jbG9zZSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5jbG9zZSgpO1xyXG5cclxuICAgIHRoaXMub25jbG9zZSA9IG9uY2xvc2U7XHJcblxyXG4gICAgLy9Jbml0IEZvcm1cclxuICAgIHRoaXMuJGZvcm0gPSBkb20uY3JlYXRlKCdmb3JtJywge2FjdGlvbiA6ICdqYXZhc2NyaXB0OnZvaWQoMCk7J30pXHJcbiAgICAgICAgLm9uKCdzdWJtaXQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5jbG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIC8vSW5pdCBDb250YWluZXJcclxuICAgIHRoaXMuJGVkaXREaXYgPSBkb20uY3JlYXRlKCdkaXYnLCB7aWQ6J2VkaXRQYW5lbCd9KVxyXG4gICAgICAgIC5vZmZzZXQoe3RvcDogcGFnZVksIGxlZnQ6IChwYWdlWCs1KX0pXHJcbiAgICAgICAgLmNzcygncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gICAgICAgIC5jc3MoJ2JhY2tncm91bmQtY29sb3InLCAnc2lsdmVyJylcclxuICAgICAgICAuYXBwZW5kKHRoaXMuJGZvcm0pO1xyXG5cclxuICAgIC8vQXBwZW5kIHRvIGJvZHlcclxuICAgICQoJ2JvZHknKS5hcHBlbmQodGhpcy4kZWRpdERpdik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkVkaXRQYW5lbC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKHRoaXMub25jbG9zZSkge1xyXG4gICAgICAgIHRoaXMub25jbG9zZS5hcHBseSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuJGVkaXREaXYpIHtcclxuICAgICAgICB0aGlzLiRlZGl0RGl2LnJlbW92ZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5FZGl0UGFuZWwucHJvdG90eXBlLmNyZWF0ZVRleHRFZGl0ID0gZnVuY3Rpb24ocGFnZVggLHBhZ2VZLCBnZXR0ZXIsIHNldHRlcikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdmFyICRpbnB1dCA9IGRvbS5jcmVhdGUoJ2lucHV0Jywge3R5cGU6J3RleHQnLCB2YWx1ZSA6IGdldHRlcigpfSlcclxuICAgICAgICAuZm9jdXMoKVxyXG4gICAgICAgIC5vbignZm9jdXMnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignYmx1cicsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICB0aGF0LmNsb3NlKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICBzZXR0ZXIoJGlucHV0LnZhbCgpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB0aGlzLmluaXQocGFnZVggLHBhZ2VZKTtcclxuICAgIHRoaXMuJGZvcm0uYXBwZW5kKCRpbnB1dCk7XHJcbiAgICAkaW5wdXQuZm9jdXMoKTtcclxufTtcclxuXHJcbkVkaXRQYW5lbC5wcm90b3R5cGUuY3JlYXRlVGV4dEFyZWFFZGl0ID0gZnVuY3Rpb24ocGFnZVggLHBhZ2VZLCBnZXR0ZXIsIHNldHRlcikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdmFyICRpbnB1dCA9IGRvbS5jcmVhdGUoJ3RleHRhcmVhJylcclxuICAgICAgICAudmFsKGdldHRlcigpKVxyXG4gICAgICAgIC5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHNldHRlcigkaW5wdXQudmFsKCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdibHVyJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHRoYXQuY2xvc2UoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignZm9jdXMnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB0aGlzLmluaXQocGFnZVggLHBhZ2VZKTtcclxuICAgIHRoaXMuJGZvcm0uYXBwZW5kKCRpbnB1dCk7XHJcbiAgICAkaW5wdXQuZm9jdXMoKTtcclxufTtcclxuXHJcbkVkaXRQYW5lbC5wcm90b3R5cGUuc2V0VGV4dEFyZWFDb250ZW50ID0gZnVuY3Rpb24oJHRleHRBcmVhTm9kZSwgdHh0QXJlYUNvbnRlbnQpIHtcclxuICAgICR0ZXh0QXJlYU5vZGUuZW1wdHkoKTtcclxuICAgIC8vVE9ETzogd2UgZG8gbm90IGNvbnNpZGVyIHRoZSB0ZXh0IHNpemUgZm9yIGR5ICFcclxuICAgIHZhciBkeSA9IDExO1xyXG4gICAgJC5lYWNoKHR4dEFyZWFDb250ZW50LnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZG9tLmFwcGVuZFNWR0VsZW1lbnQoJHRleHRBcmVhTm9kZS5nZXQoMCksIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgOiAndHNwYW4nLFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA6IHtcclxuICAgICAgICAgICAgICAgICAgICBkeSA6IGR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHggOiAyXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkVkaXRQYW5lbC5wcm90b3R5cGUuZ2V0VGV4dEFyZWFDb250ZW50ID0gZnVuY3Rpb24oJHRleHRBcmVhTm9kZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgJHRleHRBcmVhTm9kZS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9ICQodGhpcykudGV4dCgpKydcXG4nO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFZGl0UGFuZWw7IiwidmFyIFNWRyA9IHJlcXVpcmUoJy4uL3N2Zy9zdmcnKTtcclxudmFyIHF1ZXJ5Q2FjaGUgPSByZXF1aXJlKCcuLi9jb3JlL2NhY2hlJyk7XHJcblxyXG4kLmZuLnN2ZyA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICBpZihzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiAkKHNlbGVjdG9yKS5zdmcoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBTVkcuZ2V0KHRoaXMpO1xyXG4gICAgfSBlbHNlIGlmKHRoaXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAgW107XHJcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChTVkcuZ2V0KHRoaXMpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4kLnN2ZyA9ICQuZm4uc3ZnO1xyXG5cclxuJC5xQ2FjaGUgPSBmdW5jdGlvbihzZWxlY3RvciwgcHJldmVudENhY2hlKSB7XHJcbiAgICBpZihzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBxdWVyeUNhY2hlLiQoc2VsZWN0b3IsIHByZXZlbnRDYWNoZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBxdWVyeUNhY2hlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuJC5xVW5jYWNoZSA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICByZXR1cm4gcXVlcnlDYWNoZS5yZW1vdmUoc2VsZWN0b3IpO1xyXG59XHJcblxyXG4kLmZuLmdyb3dsID0gZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICB2YXIgJHJvb3QgPSB0aGlzO1xyXG5cclxuICAgIC8vIHRvb2x0aXAgY29udGVudCBhbmQgc3R5bGluZ1xyXG4gICAgdmFyICRjb250ZW50ID0gJChcclxuICAgICAgICAnPGEgY2xhc3M9XCJpY29uLWNsb3NlXCIgaHJlZj1cIiNcIj48L2E+JytcclxuICAgICAgICAnPGgxIHN0eWxlPVwiY29sb3I6IHdoaXRlOyBmb250LXNpemU6IDEycHQ7IGZvbnQtd2VpZ2h0OiBib2xkOyBwYWRkaW5nLWJvdHRvbTogNXB4O1wiPicgKyBwYXJhbXMudGl0bGUgKyAnPC9oMT4nICtcclxuICAgICAgICAnPHAgc3R5bGU9XCJtYXJnaW46IDA7IHBhZGRpbmc6IDVweCAwIDVweCAwOyBmb250LXNpemU6IDEwcHQ7XCI+JyArIHBhcmFtcy50ZXh0ICsgJzwvcD4nKTtcclxuXHJcbiAgICAvLyBhZGQgJ0Nsb3NlJyBidXR0b24gZnVuY3Rpb25hbGl0eVxyXG4gICAgdmFyICRjbG9zZSA9ICQoJGNvbnRlbnRbMF0pO1xyXG4gICAgJGNsb3NlLmNsaWNrKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAkcm9vdC51aXRvb2x0aXAoJ2Nsb3NlJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBwcmV2ZW50IHN0YW5kYXJkIHRvb2x0aXAgZnJvbSBjbG9zaW5nXHJcbiAgICAkcm9vdC5iaW5kKCdmb2N1c291dCBtb3VzZWxlYXZlJywgZnVuY3Rpb24oZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7IHJldHVybiBmYWxzZTsgfSk7XHJcblxyXG4gICAgLy8gYnVpbGQgdG9vbHRpcFxyXG4gICAgJHJvb3QudWl0b29sdGlwKHtcclxuICAgICAgICBjb250ZW50OiBmdW5jdGlvbigpIHsgcmV0dXJuICRjb250ZW50OyB9LFxyXG4gICAgICAgIGl0ZW1zOiAkcm9vdC5zZWxlY3RvcixcclxuICAgICAgICB0b29sdGlwQ2xhc3M6ICdncm93bCAnICsgcGFyYW1zLmdyb3dsQ2xhc3MsXHJcbiAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgbXk6ICdyaWdodCB0b3AnLFxyXG4gICAgICAgICAgICBhdDogJ3JpZ2h0LTEwIHRvcCsxMCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xyXG4gICAgICAgICAgICAkcm9vdC51aXRvb2x0aXAoJ2Rlc3Ryb3knKTtcclxuICAgICAgICB9XHJcbiAgICB9KS51aXRvb2x0aXAoJ29wZW4nKTtcclxuXHJcbiAgICBpZihwYXJhbXMuY2xvc2VBZnRlcikge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgJHJvb3QudWl0b29sdGlwKCdjbG9zZScpOyB9LCBwYXJhbXMuY2xvc2VBZnRlcik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5pZigkLnVpKSB7XHJcbiAgICAkLndpZGdldCggXCJjdXN0b20uaWNvbnNlbGVjdG1lbnVcIiwgJC51aS5zZWxlY3RtZW51LCB7XHJcbiAgICAgICAgX3JlbmRlckl0ZW06IGZ1bmN0aW9uKCB1bCwgaXRlbSApIHtcclxuICAgICAgICAgICAgdmFyIGxpID0gJCggXCI8bGk+XCIsIHsgdGV4dDogaXRlbS5sYWJlbCB9ICk7XHJcbiAgICAgICAgICAgIGlmICggaXRlbS5kaXNhYmxlZCApIHtcclxuICAgICAgICAgICAgICAgIGxpLmFkZENsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkKCBcIjxzcGFuPlwiLCB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZTogaXRlbS5lbGVtZW50LmF0dHIoIFwiZGF0YS1zdHlsZVwiICksXHJcbiAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwidWktaWNvbiBcIiArIGl0ZW0uZWxlbWVudC5hdHRyKCBcImRhdGEtY2xhc3NcIiApXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oIGxpICk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaS5hcHBlbmRUbyggdWwgKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBvYmplY3Q6IHJlcXVpcmUoJy4vb2JqZWN0JyksXHJcbiAgICBzdHJpbmc6IHJlcXVpcmUoJy4vc3RyaW5nJyksXHJcbiAgICBkb206IHJlcXVpcmUoJy4vLi4vZG9tL2RvbScpLFxyXG4gICAgYXBwOiByZXF1aXJlKCcuL2FwcCcpLFxyXG4gICAgbWF0aDogcmVxdWlyZSgnLi9tYXRoJyksXHJcbiAgICB4bWwgOiByZXF1aXJlKCcuL3htbCcpLFxyXG4gICAgaW5oZXJpdHM6IHV0aWwuaW5oZXJpdHNcclxufSIsIi8qKlxyXG4gKiBUaGlzIG1vZHVsZSBzZXJ2ZXMgYXMgYW4gd3JhcHBlciBmb3IgZG9tIG1hbmlwdWxhdGlvbiBmdW5jdGlvbmFsaXR5LiBJdCBpc1xyXG4gKiBoaWdobHkgcHJlZmVyZWQgdG8gdXNlIHRoaXMgbW9kdWxlIGluc3RlYWQgb2YganF1ZXJ5IGRpcmVjdGx5IHdpdGhpbiBvdGhlclxyXG4gKiBtb2R1bGVzLlxyXG4gKi9cclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0Jyk7XHJcblxyXG52YXIgcGFyc2VGZWF0dXJlU3RyaW5ncyA9IGZ1bmN0aW9uKHZhbHVlLCBkZWZhdWx0VmFsKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcgJyk7XHJcbiAgICBvYmplY3QuZWFjaCh2YWx1ZSwgZnVuY3Rpb24oaW5kZXgsIGZlYXR1cmUpIHtcclxuICAgICAgICByZXN1bHRbaW5kZXhdID0gcGFyc2VGZWF0dXJlU3RyaW5nKGZlYXR1cmUsIGRlZmF1bHRWYWwpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIHBhcnNlIGEgZmVhdHVyZXN0aW5yZyBpbiB0aGUgZm9ybSBvZlxyXG4gKiAgJ2ZlYXR1cmVuYW1lKDMwLDMwKScgb3IgJ2ZlYXR1cmVuYW1lKDMwLjQpIG9yIGZlYXR1cmVuYW1lXHJcbiAqXHJcbiAqIFRoZSByZXN1bHQgaXMgd291bGQgYmVcclxuICogICAgICB7IHR5cGUgOiAnZmVhdHVyZW5hbWUnLCB2YWx1ZSA6IFszMCwzMF0gfVxyXG4gKiAgICAgIHsgdHlwZSA6ICdmZWF0dXJlbmFtZScsIHZhbHVlIDogMzAuNCB9XHJcbiAqICAgICAgeyB0eXBlIDogJ2ZlYXR1cmVuYW1lJywgdmFsdWUgOiB1bmRlZmluZWQgfVxyXG4gKiBAcGFyYW0ge3R5cGV9IGZlYXR1cmVcclxuICogQHJldHVybnMge0FwcF9MNi5wYXJzZUZlYXR1cmVTdHJpbmcucmVzdWx0fVxyXG4gKi9cclxudmFyIHBhcnNlRmVhdHVyZVN0cmluZyA9IGZ1bmN0aW9uKGZlYXR1cmUsIGRlZmF1bHRWYWwpIHtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmKGZlYXR1cmUuaW5kZXhPZignKCcpID4gLTEpIHtcclxuICAgICAgICB2YXIgc3BsaXR0ZWQgPSBmZWF0dXJlLnNwbGl0KCcoJyk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXR0ZWRbMV0uc3Vic3RyaW5nKDAsIHNwbGl0dGVkWzFdLmluZGV4T2YoJyknKSk7XHJcblxyXG4gICAgICAgIGlmKHZhbHVlLmluZGV4T2YoJywnKSA+IC0xKSB7IC8vIG11bHRpcGxlIGFyZ3NcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBvYmplY3QuZWFjaCh2YWx1ZSwgZnVuY3Rpb24oaW5kZXgsIHYpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IHBhcnNlTnVtYmVyU3RyaW5nKHYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgeyAvLyBzaW5nbGUgYXJnXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VOdW1iZXJTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQudHlwZSA9IHNwbGl0dGVkWzBdO1xyXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQudHlwZSA9IGZlYXR1cmU7XHJcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gZGVmYXVsdFZhbDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgcGFyc2VOdW1iZXJTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoIW9iamVjdC5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy9DdXQgdW5pdHMgMS4yZW0gLT4gMS4yXHJcbiAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KC8oPz1bYS16LEEtWl0rKS8pWzBdO1xyXG5cclxuICAgIGlmKCFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICBpZih2YWx1ZS5pbmRleE9mKCcuJykgPiAtMSkgeyAvL2Zsb2F0XHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHsgLy9pbnRcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxudmFyIGNyZWF0ZUZlYXR1cmVTdHJpbmcgPSBmdW5jdGlvbihmZWF0dXJlLCB2YWx1ZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IGZlYXR1cmU7XHJcblxyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICByZXN1bHQgKz0gJygnO1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBvYmplY3QuZWFjaCh2YWx1ZSwgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKGluZGV4ICE9PSAwKSA/ICcsJyt2YWx1ZSA6IHZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSAnKSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIGlzTWluRGlzdCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBtaW5EaXN0KSB7XHJcbiAgICByZXR1cm4gTWF0aC5hYnModG8ueCAtIGZyb20ueCkgPiBtaW5EaXN0IHx8IE1hdGguYWJzKHRvLnkgLSBmcm9tLnkpID4gbWluRGlzdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcGFyc2VGZWF0dXJlU3RyaW5nOnBhcnNlRmVhdHVyZVN0cmluZyxcclxuICAgIGNyZWF0ZUZlYXR1cmVTdHJpbmc6Y3JlYXRlRmVhdHVyZVN0cmluZyxcclxuICAgIHBhcnNlRmVhdHVyZVN0cmluZ3M6cGFyc2VGZWF0dXJlU3RyaW5ncyxcclxuICAgIHBhcnNlTnVtYmVyU3RyaW5nIDogcGFyc2VOdW1iZXJTdHJpbmcsXHJcbiAgICBpc01pbkRpc3QgOiBpc01pbkRpc3RcclxufTtcclxuIiwiLyoqXHJcbiAqIG1vc3QgQmV6aWVyIGhlbHB0ZXIgZnVuY3Rpb25zIGFyZSB0YWtlbiBmcm9tIGpzQmV6aWVyIGxpYnJhcnkgaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNCZXppZXIvYmxvYi9tYXN0ZXIvanMvMC42L2pzQmV6aWVyLTAuNi5qc1xyXG4gKiBjaGVjayAvbGlicy9qc0Jlemllci5qcyBmb3IgbW9yZSBmdW5jdGlvbnMgaWYgcmVxdWlyZWQuXHJcbiAqXHJcbiAqXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBNYXRoLnNnbiA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBNYXRoLnNnbiA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPT0gMCA/IDAgOiB4ID4gMCA/IDEgOiAtMTtcclxuICAgIH07XHJcbn1cclxuXHJcbnZhciBWZWN0b3JzID0ge1xyXG4gICAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAodjEsIHYyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7eDogdjEueCAtIHYyLngsIHk6IHYxLnkgLSB2Mi55fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRvdFByb2R1Y3Q6IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh2MS54ICogdjIueCkgKyAodjEueSAqIHYyLnkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3F1YXJlOiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh2LnggKiB2LngpICsgKHYueSAqIHYueSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uICh2LCBzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7eDogdi54ICogcywgeTogdi55ICogc307XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtYXhSZWN1cnNpb24gPSA2NCxcclxuICAgIGZsYXRuZXNzVG9sZXJhbmNlID0gTWF0aC5wb3coMi4wLCAtbWF4UmVjdXJzaW9uIC0gMSk7XHJcblxyXG4vKipcclxuICogZmluZHMgdGhlIG5lYXJlc3QgcG9pbnQgb24gdGhlIGN1cnZlIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuICovXHJcbnZhciBfbmVhcmVzdFBvaW50T25DdXJ2ZSA9IGZ1bmN0aW9uIChwb2ludCwgY3VydmUpIHtcclxuICAgIHZhciB0ZCA9IF9kaXN0YW5jZUZyb21DdXJ2ZShwb2ludCwgY3VydmUpO1xyXG4gICAgcmV0dXJuIHtwb2ludDogX2JlemllcihjdXJ2ZSwgY3VydmUubGVuZ3RoIC0gMSwgdGQubG9jYXRpb24sIG51bGwsIG51bGwpLCBsb2NhdGlvbjogdGQubG9jYXRpb259O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIHRoYXQgdGhlIHBvaW50IGxpZXMgZnJvbSB0aGUgY3VydmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwb2ludCBhIHBvaW50IGluIHRoZSBmb3JtIHt4OjU2NywgeTozMzQyfVxyXG4gKiBAcGFyYW0gY3VydmUgYSBCZXppZXIgY3VydmUgaW4gdGhlIGZvcm0gW3t4Oi4uLiwgeTouLi59LCB7eDouLi4sIHk6Li4ufSwge3g6Li4uLCB5Oi4uLn0sIHt4Oi4uLiwgeTouLi59XS4gIG5vdGUgdGhhdCB0aGlzIGlzIGN1cnJlbnRseVxyXG4gKiBoYXJkY29kZWQgdG8gYXNzdW1lIGN1Yml6IGJlemllcnMsIGJ1dCB3b3VsZCBiZSBiZXR0ZXIgb2ZmIHN1cHBvcnRpbmcgYW55IGRlZ3JlZS5cclxuICogQHJldHVybiBhIEpTIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgbG9jYXRpb24gYW5kIGRpc3RhbmNlLCBmb3IgZXhhbXBsZToge2xvY2F0aW9uOjAuMzUsIGRpc3RhbmNlOjEwfS4gIExvY2F0aW9uIGlzIGFuYWxvZ291cyB0byB0aGUgbG9jYXRpb25cclxuICogYXJndW1lbnQgeW91IHBhc3MgdG8gdGhlIHBvaW50T25QYXRoIGZ1bmN0aW9uOiBpdCBpcyBhIHJhdGlvIG9mIGRpc3RhbmNlIHRyYXZlbGxlZCBhbG9uZyB0aGUgY3VydmUuICBEaXN0YW5jZSBpcyB0aGUgZGlzdGFuY2UgaW4gcGl4ZWxzIGZyb21cclxuICogdGhlIHBvaW50IHRvIHRoZSBjdXJ2ZS5cclxuICovXHJcbnZhciBfZGlzdGFuY2VGcm9tQ3VydmUgPSBmdW5jdGlvbiAocG9pbnQsIGN1cnZlKSB7XHJcbiAgICB2YXIgY2FuZGlkYXRlcyA9IFtdLFxyXG4gICAgICAgIHcgPSBfY29udmVydFRvQmV6aWVyKHBvaW50LCBjdXJ2ZSksXHJcbiAgICAgICAgZGVncmVlID0gY3VydmUubGVuZ3RoIC0gMSwgaGlnaGVyRGVncmVlID0gKDIgKiBkZWdyZWUpIC0gMSxcclxuICAgICAgICBudW1Tb2x1dGlvbnMgPSBfZmluZFJvb3RzKHcsIGhpZ2hlckRlZ3JlZSwgY2FuZGlkYXRlcywgMCksXHJcbiAgICAgICAgdiA9IFZlY3RvcnMuc3VidHJhY3QocG9pbnQsIGN1cnZlWzBdKSwgZGlzdCA9IFZlY3RvcnMuc3F1YXJlKHYpLCB0ID0gMC4wO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU29sdXRpb25zOyBpKyspIHtcclxuICAgICAgICB2ID0gVmVjdG9ycy5zdWJ0cmFjdChwb2ludCwgX2JlemllcihjdXJ2ZSwgZGVncmVlLCBjYW5kaWRhdGVzW2ldLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgdmFyIG5ld0Rpc3QgPSBWZWN0b3JzLnNxdWFyZSh2KTtcclxuICAgICAgICBpZiAobmV3RGlzdCA8IGRpc3QpIHtcclxuICAgICAgICAgICAgZGlzdCA9IG5ld0Rpc3Q7XHJcbiAgICAgICAgICAgIHQgPSBjYW5kaWRhdGVzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHYgPSBWZWN0b3JzLnN1YnRyYWN0KHBvaW50LCBjdXJ2ZVtkZWdyZWVdKTtcclxuICAgIG5ld0Rpc3QgPSBWZWN0b3JzLnNxdWFyZSh2KTtcclxuICAgIGlmIChuZXdEaXN0IDwgZGlzdCkge1xyXG4gICAgICAgIGRpc3QgPSBuZXdEaXN0O1xyXG4gICAgICAgIHQgPSAxLjA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge2xvY2F0aW9uOiB0LCBkaXN0YW5jZTogZGlzdH07XHJcbn07XHJcblxyXG52YXIgX2NvbnZlcnRUb0JlemllciA9IGZ1bmN0aW9uIChwb2ludCwgY3VydmUpIHtcclxuICAgIHZhciBkZWdyZWUgPSBjdXJ2ZS5sZW5ndGggLSAxLCBoaWdoZXJEZWdyZWUgPSAoMiAqIGRlZ3JlZSkgLSAxLFxyXG4gICAgICAgIGMgPSBbXSwgZCA9IFtdLCBjZFRhYmxlID0gW10sIHcgPSBbXSxcclxuICAgICAgICB6ID0gW1sxLjAsIDAuNiwgMC4zLCAwLjFdLCBbMC40LCAwLjYsIDAuNiwgMC40XSwgWzAuMSwgMC4zLCAwLjYsIDEuMF1dO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRlZ3JlZTsgaSsrKSBjW2ldID0gVmVjdG9ycy5zdWJ0cmFjdChjdXJ2ZVtpXSwgcG9pbnQpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGVncmVlIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgZFtpXSA9IFZlY3RvcnMuc3VidHJhY3QoY3VydmVbaSArIDFdLCBjdXJ2ZVtpXSk7XHJcbiAgICAgICAgZFtpXSA9IFZlY3RvcnMuc2NhbGUoZFtpXSwgMy4wKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8PSBkZWdyZWUgLSAxOyByb3crKykge1xyXG4gICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8PSBkZWdyZWU7IGNvbHVtbisrKSB7XHJcbiAgICAgICAgICAgIGlmICghY2RUYWJsZVtyb3ddKSBjZFRhYmxlW3Jvd10gPSBbXTtcclxuICAgICAgICAgICAgY2RUYWJsZVtyb3ddW2NvbHVtbl0gPSBWZWN0b3JzLmRvdFByb2R1Y3QoZFtyb3ddLCBjW2NvbHVtbl0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPD0gaGlnaGVyRGVncmVlOyBpKyspIHtcclxuICAgICAgICBpZiAoIXdbaV0pIHdbaV0gPSBbXTtcclxuICAgICAgICB3W2ldLnkgPSAwLjA7XHJcbiAgICAgICAgd1tpXS54ID0gcGFyc2VGbG9hdChpKSAvIGhpZ2hlckRlZ3JlZTtcclxuICAgIH1cclxuICAgIHZhciBuID0gZGVncmVlLCBtID0gZGVncmVlIC0gMTtcclxuICAgIGZvciAodmFyIGsgPSAwOyBrIDw9IG4gKyBtOyBrKyspIHtcclxuICAgICAgICB2YXIgbGIgPSBNYXRoLm1heCgwLCBrIC0gbSksXHJcbiAgICAgICAgICAgIHViID0gTWF0aC5taW4oaywgbik7XHJcbiAgICAgICAgZm9yIChpID0gbGI7IGkgPD0gdWI7IGkrKykge1xyXG4gICAgICAgICAgICBqID0gayAtIGk7XHJcbiAgICAgICAgICAgIHdbaSArIGpdLnkgKz0gY2RUYWJsZVtqXVtpXSAqIHpbal1baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHc7XHJcbn07XHJcbi8qKlxyXG4gKiBjb3VudHMgaG93IG1hbnkgcm9vdHMgdGhlcmUgYXJlLlxyXG4gKi9cclxudmFyIF9maW5kUm9vdHMgPSBmdW5jdGlvbiAodywgZGVncmVlLCB0LCBkZXB0aCkge1xyXG4gICAgdmFyIGxlZnQgPSBbXSwgcmlnaHQgPSBbXSxcclxuICAgICAgICBsZWZ0X2NvdW50LCByaWdodF9jb3VudCxcclxuICAgICAgICBsZWZ0X3QgPSBbXSwgcmlnaHRfdCA9IFtdO1xyXG5cclxuICAgIHN3aXRjaCAoX2dldENyb3NzaW5nQ291bnQodywgZGVncmVlKSkge1xyXG4gICAgICAgIGNhc2UgMCA6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxIDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkZXB0aCA+PSBtYXhSZWN1cnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHRbMF0gPSAod1swXS54ICsgd1tkZWdyZWVdLngpIC8gMi4wO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF9pc0ZsYXRFbm91Z2godywgZGVncmVlKSkge1xyXG4gICAgICAgICAgICAgICAgdFswXSA9IF9jb21wdXRlWEludGVyY2VwdCh3LCBkZWdyZWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2Jlemllcih3LCBkZWdyZWUsIDAuNSwgbGVmdCwgcmlnaHQpO1xyXG4gICAgbGVmdF9jb3VudCA9IF9maW5kUm9vdHMobGVmdCwgZGVncmVlLCBsZWZ0X3QsIGRlcHRoICsgMSk7XHJcbiAgICByaWdodF9jb3VudCA9IF9maW5kUm9vdHMocmlnaHQsIGRlZ3JlZSwgcmlnaHRfdCwgZGVwdGggKyAxKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdF9jb3VudDsgaSsrKSB0W2ldID0gbGVmdF90W2ldO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaWdodF9jb3VudDsgaSsrKSB0W2kgKyBsZWZ0X2NvdW50XSA9IHJpZ2h0X3RbaV07XHJcbiAgICByZXR1cm4gKGxlZnRfY291bnQgKyByaWdodF9jb3VudCk7XHJcbn07XHJcbnZhciBfZ2V0Q3Jvc3NpbmdDb3VudCA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGVncmVlKSB7XHJcbiAgICB2YXIgbl9jcm9zc2luZ3MgPSAwLCBzaWduLCBvbGRfc2lnbjtcclxuICAgIHNpZ24gPSBvbGRfc2lnbiA9IE1hdGguc2duKGN1cnZlWzBdLnkpO1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcclxuICAgICAgICBzaWduID0gTWF0aC5zZ24oY3VydmVbaV0ueSk7XHJcbiAgICAgICAgaWYgKHNpZ24gIT0gb2xkX3NpZ24pIG5fY3Jvc3NpbmdzKys7XHJcbiAgICAgICAgb2xkX3NpZ24gPSBzaWduO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5fY3Jvc3NpbmdzO1xyXG59O1xyXG52YXIgX2lzRmxhdEVub3VnaCA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGVncmVlKSB7XHJcbiAgICB2YXIgZXJyb3IsXHJcbiAgICAgICAgaW50ZXJjZXB0XzEsIGludGVyY2VwdF8yLCBsZWZ0X2ludGVyY2VwdCwgcmlnaHRfaW50ZXJjZXB0LFxyXG4gICAgICAgIGEsIGIsIGMsIGRldCwgZEludiwgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMjtcclxuICAgIGEgPSBjdXJ2ZVswXS55IC0gY3VydmVbZGVncmVlXS55O1xyXG4gICAgYiA9IGN1cnZlW2RlZ3JlZV0ueCAtIGN1cnZlWzBdLng7XHJcbiAgICBjID0gY3VydmVbMF0ueCAqIGN1cnZlW2RlZ3JlZV0ueSAtIGN1cnZlW2RlZ3JlZV0ueCAqIGN1cnZlWzBdLnk7XHJcblxyXG4gICAgdmFyIG1heF9kaXN0YW5jZV9hYm92ZSA9IG1heF9kaXN0YW5jZV9iZWxvdyA9IDAuMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGRlZ3JlZTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gYSAqIGN1cnZlW2ldLnggKyBiICogY3VydmVbaV0ueSArIGM7XHJcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4X2Rpc3RhbmNlX2Fib3ZlKVxyXG4gICAgICAgICAgICBtYXhfZGlzdGFuY2VfYWJvdmUgPSB2YWx1ZTtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IG1heF9kaXN0YW5jZV9iZWxvdylcclxuICAgICAgICAgICAgbWF4X2Rpc3RhbmNlX2JlbG93ID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgYTEgPSAwLjA7XHJcbiAgICBiMSA9IDEuMDtcclxuICAgIGMxID0gMC4wO1xyXG4gICAgYTIgPSBhO1xyXG4gICAgYjIgPSBiO1xyXG4gICAgYzIgPSBjIC0gbWF4X2Rpc3RhbmNlX2Fib3ZlO1xyXG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyICogYjE7XHJcbiAgICBkSW52ID0gMS4wIC8gZGV0O1xyXG4gICAgaW50ZXJjZXB0XzEgPSAoYjEgKiBjMiAtIGIyICogYzEpICogZEludjtcclxuICAgIGEyID0gYTtcclxuICAgIGIyID0gYjtcclxuICAgIGMyID0gYyAtIG1heF9kaXN0YW5jZV9iZWxvdztcclxuICAgIGRldCA9IGExICogYjIgLSBhMiAqIGIxO1xyXG4gICAgZEludiA9IDEuMCAvIGRldDtcclxuICAgIGludGVyY2VwdF8yID0gKGIxICogYzIgLSBiMiAqIGMxKSAqIGRJbnY7XHJcbiAgICBsZWZ0X2ludGVyY2VwdCA9IE1hdGgubWluKGludGVyY2VwdF8xLCBpbnRlcmNlcHRfMik7XHJcbiAgICByaWdodF9pbnRlcmNlcHQgPSBNYXRoLm1heChpbnRlcmNlcHRfMSwgaW50ZXJjZXB0XzIpO1xyXG4gICAgZXJyb3IgPSByaWdodF9pbnRlcmNlcHQgLSBsZWZ0X2ludGVyY2VwdDtcclxuICAgIHJldHVybiAoZXJyb3IgPCBmbGF0bmVzc1RvbGVyYW5jZSkgPyAxIDogMDtcclxufTtcclxudmFyIF9jb21wdXRlWEludGVyY2VwdCA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGVncmVlKSB7XHJcbiAgICB2YXIgWExLID0gMS4wLCBZTEsgPSAwLjAsXHJcbiAgICAgICAgWE5NID0gY3VydmVbZGVncmVlXS54IC0gY3VydmVbMF0ueCwgWU5NID0gY3VydmVbZGVncmVlXS55IC0gY3VydmVbMF0ueSxcclxuICAgICAgICBYTUsgPSBjdXJ2ZVswXS54IC0gMC4wLCBZTUsgPSBjdXJ2ZVswXS55IC0gMC4wLFxyXG4gICAgICAgIGRldCA9IFhOTSAqIFlMSyAtIFlOTSAqIFhMSywgZGV0SW52ID0gMS4wIC8gZGV0LFxyXG4gICAgICAgIFMgPSAoWE5NICogWU1LIC0gWU5NICogWE1LKSAqIGRldEludjtcclxuICAgIHJldHVybiAwLjAgKyBYTEsgKiBTO1xyXG59O1xyXG5cclxudmFyIF9iZXppZXIgPSBmdW5jdGlvbiAoY3VydmUsIGRlZ3JlZSwgdCwgbGVmdCwgcmlnaHQpIHtcclxuICAgIHZhciB0ZW1wID0gW1tdXTtcclxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZTsgaisrKSB0ZW1wWzBdW2pdID0gY3VydmVbal07XHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoIXRlbXBbaV0pIHRlbXBbaV0gPSBbXTtcclxuICAgICAgICAgICAgaWYgKCF0ZW1wW2ldW2pdKSB0ZW1wW2ldW2pdID0ge307XHJcbiAgICAgICAgICAgIHRlbXBbaV1bal0ueCA9ICgxLjAgLSB0KSAqIHRlbXBbaSAtIDFdW2pdLnggKyB0ICogdGVtcFtpIC0gMV1baiArIDFdLng7XHJcbiAgICAgICAgICAgIHRlbXBbaV1bal0ueSA9ICgxLjAgLSB0KSAqIHRlbXBbaSAtIDFdW2pdLnkgKyB0ICogdGVtcFtpIC0gMV1baiArIDFdLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQgIT0gbnVsbClcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDw9IGRlZ3JlZTsgaisrKSBsZWZ0W2pdID0gdGVtcFtqXVswXTtcclxuICAgIGlmIChyaWdodCAhPSBudWxsKVxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPD0gZGVncmVlOyBqKyspIHJpZ2h0W2pdID0gdGVtcFtkZWdyZWUgLSBqXVtqXTtcclxuXHJcbiAgICByZXR1cm4gKHRlbXBbZGVncmVlXVswXSk7XHJcbn07XHJcblxyXG52YXIgX2N1cnZlRnVuY3Rpb25DYWNoZSA9IHt9O1xyXG52YXIgX2dldEN1cnZlRnVuY3Rpb25zID0gZnVuY3Rpb24gKG9yZGVyKSB7XHJcbiAgICB2YXIgZm5zID0gX2N1cnZlRnVuY3Rpb25DYWNoZVtvcmRlcl07XHJcbiAgICBpZiAoIWZucykge1xyXG4gICAgICAgIGZucyA9IFtdO1xyXG4gICAgICAgIHZhciBmX3Rlcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3codCwgb3JkZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbF90ZXJtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KCgxIC0gdCksIG9yZGVyKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNfdGVybSA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRfdGVybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25lX21pbnVzX3RfdGVybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC0gdDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF90ZXJtRnVuYyA9IGZ1bmN0aW9uICh0ZXJtcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybXMubGVuZ3RoOyBpKyspIHAgPSBwICogdGVybXNbaV0odCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICBmbnMucHVzaChuZXcgZl90ZXJtKCkpOyAgLy8gZmlyc3QgaXMgdCB0byB0aGUgcG93ZXIgb2YgdGhlIGN1cnZlIG9yZGVyXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvcmRlcjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXJtcyA9IFtuZXcgY190ZXJtKG9yZGVyKV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgKG9yZGVyIC0gaSk7IGorKykgdGVybXMucHVzaChuZXcgdF90ZXJtKCkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykgdGVybXMucHVzaChuZXcgb25lX21pbnVzX3RfdGVybSgpKTtcclxuICAgICAgICAgICAgZm5zLnB1c2gobmV3IF90ZXJtRnVuYyh0ZXJtcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmbnMucHVzaChuZXcgbF90ZXJtKCkpOyAgLy8gbGFzdCBpcyAoMS10KSB0byB0aGUgcG93ZXIgb2YgdGhlIGN1cnZlIG9yZGVyXHJcblxyXG4gICAgICAgIF9jdXJ2ZUZ1bmN0aW9uQ2FjaGVbb3JkZXJdID0gZm5zO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmbnM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZXMgYSBwb2ludCBvbiB0aGUgY3VydmUsIGZvciBhIEJlemllciBvZiBhcmJpdHJhcnkgb3JkZXIuXHJcbiAqIEBwYXJhbSBjdXJ2ZSBhbiBhcnJheSBvZiBjb250cm9sIHBvaW50cywgZWcgW3t4OjEwLHk6MjB9LCB7eDo1MCx5OjUwfSwge3g6MTAwLHk6MTAwfSwge3g6MTIwLHk6MTAwfV0uICBGb3IgYSBjdWJpYyBiZXppZXIgdGhpcyBzaG91bGQgaGF2ZSBmb3VyIHBvaW50cy5cclxuICogQHBhcmFtIGxvY2F0aW9uIGEgZGVjaW1hbCBpbmRpY2F0aW5nIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgdGhlIHBvaW50IHNob3VsZCBiZSBsb2NhdGVkIGF0LiAgdGhpcyBpcyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlIGFzIGl0IHRyYXZlbHMsIHRha2luZyB0aGUgd2F5IGl0IGJlbmRzIGludG8gYWNjb3VudC4gIHNob3VsZCBiZSBhIG51bWJlciBmcm9tIDAgdG8gMSwgaW5jbHVzaXZlLlxyXG4gKi9cclxudmFyIF9wb2ludE9uUGF0aCA9IGZ1bmN0aW9uIChjdXJ2ZSwgbG9jYXRpb24pIHtcclxuICAgIHZhciBjYyA9IF9nZXRDdXJ2ZUZ1bmN0aW9ucyhjdXJ2ZS5sZW5ndGggLSAxKSxcclxuICAgICAgICBfeCA9IDAsIF95ID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBfeCA9IF94ICsgKGN1cnZlW2ldLnggKiBjY1tpXShsb2NhdGlvbikpO1xyXG4gICAgICAgIF95ID0gX3kgKyAoY3VydmVbaV0ueSAqIGNjW2ldKGxvY2F0aW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHt4OiBfeCwgeTogX3l9O1xyXG59O1xyXG5cclxudmFyIF9kaXN0ID0gZnVuY3Rpb24gKHAxLCBwMikge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMS54IC0gcDIueCwgMikgKyBNYXRoLnBvdyhwMS55IC0gcDIueSwgMikpO1xyXG59O1xyXG5cclxudmFyIF9pc1BvaW50ID0gZnVuY3Rpb24gKGN1cnZlKSB7XHJcbiAgICByZXR1cm4gY3VydmVbMF0ueCA9PSBjdXJ2ZVsxXS54ICYmIGN1cnZlWzBdLnkgPT0gY3VydmVbMV0ueTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBmaW5kcyB0aGUgcG9pbnQgdGhhdCBpcyAnZGlzdGFuY2UnIGFsb25nIHRoZSBwYXRoIGZyb20gJ2xvY2F0aW9uJy4gIHRoaXMgbWV0aG9kIHJldHVybnMgYm90aCB0aGUgeCx5IGxvY2F0aW9uIG9mIHRoZSBwb2ludCBhbmQgYWxzb1xyXG4gKiBpdHMgJ2xvY2F0aW9uJyAocHJvcG9ydGlvbiBvZiB0cmF2ZWwgYWxvbmcgdGhlIHBhdGgpOyB0aGUgbWV0aG9kIGJlbG93IC0gX3BvaW50QWxvbmdQYXRoRnJvbSAtIGNhbGxzIHRoaXMgbWV0aG9kIGFuZCBqdXN0IHJldHVybnMgdGhlXHJcbiAqIHBvaW50LlxyXG4gKi9cclxudmFyIF9wb2ludEFsb25nUGF0aCA9IGZ1bmN0aW9uIChjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKSB7XHJcblxyXG4gICAgaWYgKF9pc1BvaW50KGN1cnZlKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBvaW50OiBjdXJ2ZVswXSxcclxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJldiA9IF9wb2ludE9uUGF0aChjdXJ2ZSwgbG9jYXRpb24pLFxyXG4gICAgICAgIHRhbGx5ID0gMCxcclxuICAgICAgICBjdXJMb2MgPSBsb2NhdGlvbixcclxuICAgICAgICBkaXJlY3Rpb24gPSBkaXN0YW5jZSA+IDAgPyAxIDogLTEsXHJcbiAgICAgICAgY3VyID0gbnVsbDtcclxuXHJcbiAgICB3aGlsZSAodGFsbHkgPCBNYXRoLmFicyhkaXN0YW5jZSkpIHtcclxuICAgICAgICBjdXJMb2MgKz0gKDAuMDA1ICogZGlyZWN0aW9uKTtcclxuICAgICAgICBjdXIgPSBfcG9pbnRPblBhdGgoY3VydmUsIGN1ckxvYyk7XHJcbiAgICAgICAgdGFsbHkgKz0gX2Rpc3QoY3VyLCBwcmV2KTtcclxuICAgICAgICBwcmV2ID0gY3VyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtwb2ludDogY3VyLCBsb2NhdGlvbjogY3VyTG9jfTtcclxufTtcclxuXHJcbnZhciBfbGVuZ3RoID0gZnVuY3Rpb24gKGN1cnZlKSB7XHJcbiAgICBpZiAoX2lzUG9pbnQoY3VydmUpKSByZXR1cm4gMDtcclxuXHJcbiAgICB2YXIgcHJldiA9IF9wb2ludE9uUGF0aChjdXJ2ZSwgMCksXHJcbiAgICAgICAgdGFsbHkgPSAwLFxyXG4gICAgICAgIGN1ckxvYyA9IDAsXHJcbiAgICAgICAgZGlyZWN0aW9uID0gMSxcclxuICAgICAgICBjdXIgPSBudWxsO1xyXG5cclxuICAgIHdoaWxlIChjdXJMb2MgPCAxKSB7XHJcbiAgICAgICAgY3VyTG9jICs9ICgwLjAwNSAqIGRpcmVjdGlvbik7XHJcbiAgICAgICAgY3VyID0gX3BvaW50T25QYXRoKGN1cnZlLCBjdXJMb2MpO1xyXG4gICAgICAgIHRhbGx5ICs9IF9kaXN0KGN1ciwgcHJldik7XHJcbiAgICAgICAgcHJldiA9IGN1cjtcclxuICAgIH1cclxuICAgIHJldHVybiB0YWxseTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBmaW5kcyB0aGUgcG9pbnQgdGhhdCBpcyAnZGlzdGFuY2UnIGFsb25nIHRoZSBwYXRoIGZyb20gJ2xvY2F0aW9uJy5cclxuICovXHJcbnZhciBfcG9pbnRBbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24gKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpIHtcclxuICAgIHJldHVybiBfcG9pbnRBbG9uZ1BhdGgoY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSkucG9pbnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogZmluZHMgdGhlIGxvY2F0aW9uIHRoYXQgaXMgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgcGF0aCBmcm9tICdsb2NhdGlvbicuXHJcbiAqL1xyXG52YXIgX2xvY2F0aW9uQWxvbmdQYXRoRnJvbSA9IGZ1bmN0aW9uIChjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gX3BvaW50QWxvbmdQYXRoKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpLmxvY2F0aW9uO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIHJldHVybnMgdGhlIGdyYWRpZW50IG9mIHRoZSBjdXJ2ZSBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24sIHdoaWNoIGlzIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlLlxyXG4gKlxyXG4gKiB0aGFua3MgLy8gaHR0cDovL2JpbWl4dWFsLm9yZy9BbmltYXRpb25MaWJyYXJ5L2JlemllcnRhbmdlbnRzLmh0bWxcclxuICovXHJcbnZhciBfZ3JhZGllbnRBdFBvaW50ID0gZnVuY3Rpb24gKGN1cnZlLCBsb2NhdGlvbikge1xyXG4gICAgdmFyIHAxID0gX3BvaW50T25QYXRoKGN1cnZlLCBsb2NhdGlvbiksXHJcbiAgICAgICAgcDIgPSBfcG9pbnRPblBhdGgoY3VydmUuc2xpY2UoMCwgY3VydmUubGVuZ3RoIC0gMSksIGxvY2F0aW9uKSxcclxuICAgICAgICBkeSA9IHAyLnkgLSBwMS55LCBkeCA9IHAyLnggLSBwMS54O1xyXG4gICAgcmV0dXJuIGR5ID09IDAgPyBJbmZpbml0eSA6IE1hdGguYXRhbihkeSAvIGR4KTtcclxufTtcclxuXHJcbi8qKlxyXG4gcmV0dXJucyB0aGUgZ3JhZGllbnQgb2YgdGhlIGN1cnZlIGF0IHRoZSBwb2ludCB3aGljaCBpcyAnZGlzdGFuY2UnIGZyb20gdGhlIGdpdmVuIGxvY2F0aW9uLlxyXG4gaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIHRoYW4gbG9jYXRpb24gMSwgdGhlIGdyYWRpZW50IGF0IGxvY2F0aW9uIDEgaXMgcmV0dXJuZWQuXHJcbiBpZiB0aGlzIHBvaW50IGlzIGxlc3MgdGhhbiBsb2NhdGlvbiAwLCB0aGUgZ3JhZGllbnQgYXQgbG9jYXRpb24gMCBpcyByZXR1cm5lZC5cclxuICovXHJcbnZhciBfZ3JhZGllbnRBdFBvaW50QWxvbmdQYXRoRnJvbSA9IGZ1bmN0aW9uIChjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKSB7XHJcbiAgICB2YXIgcCA9IF9wb2ludEFsb25nUGF0aChjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKTtcclxuICAgIGlmIChwLmxvY2F0aW9uID4gMSkgcC5sb2NhdGlvbiA9IDE7XHJcbiAgICBpZiAocC5sb2NhdGlvbiA8IDApIHAubG9jYXRpb24gPSAwO1xyXG4gICAgcmV0dXJuIF9ncmFkaWVudEF0UG9pbnQoY3VydmUsIHAubG9jYXRpb24pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZXMgYSBsaW5lIHRoYXQgaXMgJ2xlbmd0aCcgcGl4ZWxzIGxvbmcsIHBlcnBlbmRpY3VsYXIgdG8sIGFuZCBjZW50ZXJlZCBvbiwgdGhlIHBhdGggYXQgJ2Rpc3RhbmNlJyBwaXhlbHMgZnJvbSB0aGUgZ2l2ZW4gbG9jYXRpb24uXHJcbiAqIGlmIGRpc3RhbmNlIGlzIG5vdCBzdXBwbGllZCwgdGhlIHBlcnBlbmRpY3VsYXIgZm9yIHRoZSBnaXZlbiBsb2NhdGlvbiBpcyBjb21wdXRlZCAoaWUuIHdlIHNldCBkaXN0YW5jZSB0byB6ZXJvKS5cclxuICovXHJcbnZhciBfcGVycGVuZGljdWxhclRvUGF0aEF0ID0gZnVuY3Rpb24gKGN1cnZlLCBsb2NhdGlvbiwgbGVuZ3RoLCBkaXN0YW5jZSkge1xyXG4gICAgZGlzdGFuY2UgPSBkaXN0YW5jZSA9PSBudWxsID8gMCA6IGRpc3RhbmNlO1xyXG4gICAgdmFyIHAgPSBfcG9pbnRBbG9uZ1BhdGgoY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSksXHJcbiAgICAgICAgbSA9IF9ncmFkaWVudEF0UG9pbnQoY3VydmUsIHAubG9jYXRpb24pLFxyXG4gICAgICAgIF90aGV0YTIgPSBNYXRoLmF0YW4oLTEgLyBtKSxcclxuICAgICAgICB5ID0gbGVuZ3RoIC8gMiAqIE1hdGguc2luKF90aGV0YTIpLFxyXG4gICAgICAgIHggPSBsZW5ndGggLyAyICogTWF0aC5jb3MoX3RoZXRhMik7XHJcbiAgICByZXR1cm4gW3t4OiBwLnBvaW50LnggKyB4LCB5OiBwLnBvaW50LnkgKyB5fSwge3g6IHAucG9pbnQueCAtIHgsIHk6IHAucG9pbnQueSAtIHl9XTtcclxufTtcclxuXHJcbnZhciBfY2FsY3VsYXRlU21vb3RoQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKEspIHtcclxuICAgIHZhciByZXN1bHRQMSA9IFtdO1xyXG4gICAgdmFyIHJlc3VsdFAyID0gW107XHJcbiAgICB2YXIgbiA9IEsubGVuZ3RoLTE7XHJcblxyXG4gICAgLypyaHMgdmVjdG9yIGluaXQgbGVmdCBtb3N0IHNlZ21lbnQqL1xyXG4gICAgdmFyIGEgPSBbMF07XHJcbiAgICB2YXIgYiA9IFsyXTtcclxuICAgIHZhciBjID0gWzFdO1xyXG4gICAgdmFyIHIgPSBbS1swXSArIDIgKiBLWzFdXTtcclxuXHJcbiAgICAvKmludGVybmFsIHNlZ21lbnRzKi9cclxuICAgIGZvcihpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcclxuICAgICAgICBhW2ldID0gMTtcclxuICAgICAgICBiW2ldID0gNDtcclxuICAgICAgICBjW2ldID0gMTtcclxuICAgICAgICByW2ldID0gNCAqIEtbaV0gKyAyICogS1tpKzFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qcmlnaHQgc2VnbWVudCovXHJcbiAgICBhW24tMV0gPSAyO1xyXG4gICAgYltuLTFdID0gNztcclxuICAgIGNbbi0xXSA9IDA7XHJcbiAgICByW24tMV0gPSA4ICogS1tuLTFdICsgS1tuXTtcclxuXHJcbiAgICAvKnNvbHZlcyBBeD1iIHdpdGggdGhlIFRob21hcyBhbGdvcml0aG0qL1xyXG4gICAgZm9yKGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgbSA9IGFbaV0gLyBiW2ktMV07XHJcbiAgICAgICAgYltpXSA9IGJbaV0gLSBtICogY1tpIC0gMV07XHJcbiAgICAgICAgcltpXSA9IHJbaV0gLSBtICogcltpLTFdO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdFAxW24tMV0gPSByW24tMV0gLyBiW24tMV07XHJcbiAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICByZXN1bHRQMVtpXSA9IChyW2ldIC0gY1tpXSAqIHJlc3VsdFAxW2kgKyAxXSkgLyBiW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qd2UgaGF2ZSBwMSwgbm93IGNvbXB1dGUgcDIqL1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcclxuICAgICAgICByZXN1bHRQMltpXSA9IDIgKiBLW2kgKyAxXSAtIHJlc3VsdFAxW2kgKyAxXTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHRQMltuLTFdID0gMC41ICogKEtbbl0gKyByZXN1bHRQMVtuLTFdKTtcclxuXHJcbiAgICByZXR1cm4ge3AxOnJlc3VsdFAxLCBwMjpyZXN1bHRQMn07XHJcbn07XHJcblxyXG4vKipcclxuICogTW92ZXMgYSBwb2ludCBhbG9uZyB0aGUgZ2l2ZW4gY3VydmVcclxuICogQHBhcmFtIGN1cnZlXHJcbiAqIEBwYXJhbSBkaXN0YW5jZVxyXG4gKiBAcmV0dXJucyB7Knx7eCwgeX19XHJcbiAqL1xyXG52YXIgbW92ZUFsb25nID0gZnVuY3Rpb24oY3VydmUsIGRpc3RhbmNlKSB7XHJcbiAgICAvLyBTb21laG93IHRoZSBwb2ludEFsb25nUGF0aCBjYWxjdWxhdGVzIGluIHRoZSB3cm9uZyBkaXJlY3Rpb24gc28gd2Ugc3dpdGNoIHRoZSBiYWhhdmlvdXIgYnkgc2V0dGluZ1xyXG4gICAgLy8gdGhlIGxvY2F0aW9uIHRvIDEgKGVuZCkgZm9yIHBvc2l0aXZlIGRpc3RhbmNlcy5cclxuICAgIC8vIGFuZCBuZWdvdGlhdGUgdGhlIGRpc3RhbmNlIHZhbHVlLlxyXG4gICAgdmFyIGxvY2F0aW9uID0gZGlzdGFuY2UgPiAwID8gMSA6IDA7XHJcbiAgICB2YXIgZGlzdGFuY2UgPSBkaXN0YW5jZSAqIC0xO1xyXG4gICAgcmV0dXJuIF9wb2ludEFsb25nUGF0aChjdXJ2ZSxsb2NhdGlvbiwgZGlzdGFuY2UpLnBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBuZWFyZXN0UG9pbnRPbkN1cnZlIDogX25lYXJlc3RQb2ludE9uQ3VydmUsXHJcbiAgICBjYWxjdWxhdGVTbW9vdGhDb250cm9sUG9pbnRzIDogX2NhbGN1bGF0ZVNtb290aENvbnRyb2xQb2ludHMsXHJcbiAgICBtb3ZlQWxvbmcgOiBtb3ZlQWxvbmcsXHJcbiAgICBsZW5ndGggOiBfbGVuZ3RoXHJcbn1cclxuXHJcbiIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuL29iamVjdCcpO1xyXG52YXIgYmV6aWVyID0gcmVxdWlyZSgnLi9iZXppZXInKTtcclxuXHJcbnZhciBjYWxjTGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHBhMSwgcGEyLCBwYjEsIHBiMikge1xyXG4gICAgcmV0dXJuIG5ldyBMaW5lKHBhMSxwYTIpLmNhbGNMaW5lSW50ZXJjZXB0KG5ldyBMaW5lKHBiMSxwYjIpKTtcclxufTtcclxuXHJcbnZhciBQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHZhciBwID0gZ2V0UG9pbnQoeCx5KTtcclxuICAgIHRoaXMueCA9IHAueDtcclxuICAgIHRoaXMueSA9IHAueTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5pc1dpdGhpbkludGVydmFsID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgdG9sZXJhbmNlKSB7XHJcbiAgICByZXR1cm4gaXNQb2ludEluSW50ZXJ2YWwodGhpcywgc3RhcnQsIGVuZCwgdG9sZXJhbmNlKTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5pc1dpdGhpblhJbnRlcnZhbCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHRvbGVyYW5jZSkge1xyXG4gICAgcmV0dXJuIF9pbkludGVydmFsKHRoaXMsIHN0YXJ0LCBlbmQsIHRvbGVyYW5jZSwgJ3gnKTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5pc1dpdGhpbllJbnRlcnZhbCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHRvbGVyYW5jZSkge1xyXG4gICAgcmV0dXJuIF9pbkludGVydmFsKHRoaXMsIHN0YXJ0LCBlbmQsIHRvbGVyYW5jZSwgJ3knKTtcclxufTs7XHJcblxyXG52YXIgaXNQb2ludEluSW50ZXJ2YWwgPSBmdW5jdGlvbihwb2ludCwgc3RhcnQsIGVuZCwgdG9sZXJhbmNlKSB7XHJcbiAgICByZXR1cm4gX2luSW50ZXJ2YWwocG9pbnQsIHN0YXJ0LCBlbmQsIHRvbGVyYW5jZSwgJ3gnKSAmJiBfaXNQb2ludEluSW50ZXJ2YWwocG9pbnQsIHN0YXJ0LCBlbmQsIHRvbGVyYW5jZSwgJ3knKTtcclxufTtcclxuXHJcbnZhciBfaW5JbnRlcnZhbCA9IGZ1bmN0aW9uKHAsIHN0YXJ0LCBlbmQsIHRvbGVyYW5jZSwgZGltZW5zaW9uKSB7XHJcbiAgICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMDtcclxuICAgIHZhciBib3VuZGFyeSA9IG1pbk1heChzdGFydFtkaW1lbnNpb25dLCBlbmRbZGltZW5zaW9uXSk7XHJcbiAgICBib3VuZGFyeS5taW4gLT0gdG9sZXJhbmNlO1xyXG4gICAgYm91bmRhcnkubWF4ICs9IHRvbGVyYW5jZTtcclxuICAgIHJldHVybiAocFtkaW1lbnNpb25dIDw9IGJvdW5kYXJ5Lm1heCAmJiBwW2RpbWVuc2lvbl0gPj0gYm91bmRhcnkubWluKTtcclxufTtcclxuXHJcbnZhciBtaW5NYXggPSBmdW5jdGlvbih2YWwxLCB2YWwyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pbiA6ICBNYXRoLm1pbih2YWwxLCB2YWwyKSxcclxuICAgICAgICBtYXggOiBNYXRoLm1heCh2YWwxLCB2YWwyKVxyXG4gICAgfTtcclxufTtcclxuXHJcbnZhciBMaW5lID0gZnVuY3Rpb24ocDEsIHAyKSB7XHJcbiAgICAvL3kgPSBteCArIHRcclxuICAgIGlmKHAxLngpIHtcclxuICAgICAgICB0aGlzLm9wMSA9IHAxO1xyXG4gICAgICAgIHRoaXMub3AyID0gcDI7XHJcbiAgICAgICAgdGhpcy5wMSA9IChwMS54IDw9IHAyLngpPyBwMSA6IHAyO1xyXG4gICAgICAgIHRoaXMucDIgPSAocDEueCA+IHAyLngpPyBwMSA6IHAyO1xyXG4gICAgICAgIHRoaXMubSA9IHRoaXMuY2FsY0dyYWRpZW50KCk7XHJcbiAgICAgICAgdGhpcy50ID0gdGhpcy5jYWxjWUludGVyY2VwdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm0gPSBwMTtcclxuICAgICAgICB0aGlzLnQgPSBwMjtcclxuICAgIH1cclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNhbGNZSW50ZXJjZXB0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvLyB5ID0gbSAqIHggKyB0ID0+IHQgPSAtbXggKyB5XHJcbiAgICByZXR1cm4gKC0xICogdGhpcy5tICogdGhpcy5wMS54KSArIHRoaXMucDEueTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmdldE9ydGhvZ29uYWwgPSBmdW5jdGlvbihwKSB7XHJcbiAgICAvL1xyXG4gICAgdmFyIG5ld00gPSAtMSAvIHRoaXMubTtcclxuICAgIHZhciB0ID0gcC55IC0gKG5ld00gKiBwLngpO1xyXG4gICAgcmV0dXJuIG5ldyBMaW5lKG5ld00sdCk7XHJcbn07XHJcblxyXG5MaW5lLnByb3RvdHlwZS5jYWxjR3JhZGllbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBMaW5lLmNhbGNHcmFkaWVudCh0aGlzLnAxLCB0aGlzLnAyKTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNhbGNOb3JtYWxpemVkTGluZVZlY3RvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIExpbmUuY2FsY05vcm1hbGl6ZWRMaW5lVmVjdG9yKHRoaXMucDEsIHRoaXMucDIpO1xyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuaXNMdFIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm9wMS54IDwgdGhpcy5vcDIueDtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmlzVHRCID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcDEueSA8IHRoaXMub3AyLnk7XHJcbn07XHJcblxyXG5cclxuTGluZS5jYWxjTm9ybWFsaXplZExpbmVWZWN0b3IgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuICAgIHZhciB2ZWN0b3IgPSB7XHJcbiAgICAgICAgeCA6IHAyLnggLSBwMS54LFxyXG4gICAgICAgIHkgOiBwMi55IC0gcDEueVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KHZlY3Rvci54KnZlY3Rvci54ICsgdmVjdG9yLnkqdmVjdG9yLnkpO1xyXG5cclxuICAgIHZlY3Rvci54ID0gdmVjdG9yLnggLyBsZW5ndGg7XHJcbiAgICB2ZWN0b3IueSA9IHZlY3Rvci55IC8gbGVuZ3RoO1xyXG4gICAgcmV0dXJuIHZlY3RvcjtcclxufTtcclxuXHJcbi8qXHJcbiAqICBUT0RPOiB0aGlzIGlzIHdvcmtpbmcgaWYgeW91IHByb3ZpZGUgc3RhcnQvZW5kIGFuZCBkaXN0YW5jZSAobmVnYXRpdmUgb3IgcG9zaXRpdmUpIGJ1dCBub3QgdGVzdGVkIChhbmQgcHJlc3VtYWJseSBub3Qgd29ya2luZylcclxuICogIHdoZW4gZ2l2ZW4gc3RhcnQvZW5kIGRpc3QgYW5kIGRpcmVjdGlvbiBlLmcgbW92ZSBmcm9tIHN0YXJ0IHBvaW50IC0zMCBiYWNrLlxyXG4gKi9cclxuTGluZS5tb3ZlQWxvbmcgPSBmdW5jdGlvbihwMSxwMiwgZGlzdCwgZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgdmVjdG9yID0gTGluZS5jYWxjTm9ybWFsaXplZExpbmVWZWN0b3IocDEscDIpO1xyXG5cclxuICAgIC8vSWYgdGhlcmUgaXMgbm8gZGlyZWN0aW9uIGdpdmVuIHdlIGhhbmRsZSBuZWdhdGl2ZSBkaXN0YW5jZXMgYXMgZGlyZWN0aW9uIC0xIChmcm9tIGVuZCB0byBzdGFydClcclxuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAoZGlzdCA8IDApID8gLTEgOiAxO1xyXG5cclxuICAgIGlmKGRpcmVjdGlvbiA8IDEpIHtcclxuICAgICAgICBkaXN0ID0gTGluZS5jYWxjRGlzdGFuY2UocDEscDIpICsgZGlzdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHggOiBwMS54ICsgdmVjdG9yLnggKiBkaXN0LFxyXG4gICAgICAgIHkgOiBwMS55ICsgdmVjdG9yLnkgKiBkaXN0XHJcbiAgICB9O1xyXG59O1xyXG5cclxuTGluZS5jYWxjR3JhZGllbnQgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuICAgIHJldHVybiAocDIueSAtIHAxLnkpIC8gKHAyLnggLSBwMS54KTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNhbGNGWCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHZhciB5ID0gKHRoaXMubSkgKiB4ICsgdGhpcy50O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4IDogeCxcclxuICAgICAgICB5IDogeVxyXG4gICAgfTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNhbGNNaWRQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIExpbmUuY2FsY01pZFBvaW50KHRoaXMucDEsIHRoaXMucDIpO1xyXG59O1xyXG5cclxuTGluZS5jYWxjTWlkUG9pbnQgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IChwMS54K3AyLngpIC8gMixcclxuICAgICAgICB5IDogKHAxLnkrcDIueSkgLyAyXHJcbiAgICB9O1xyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuaXNWZXJ0aWNhbCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiAhaXNGaW5pdGUodGhpcy5tKTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmlzSG9yaXpvbnRhbCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiB0aGlzLm0gPT09IDA7XHJcbn07XHJcblxyXG5MaW5lLnByb3RvdHlwZS5jYWxjTGluZUludGVyY2VwdCA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAvL214KDEpICsgdCgxKSA9IG14KDIpICt0KDIpXHJcbiAgICB2YXIgbSA9IG90aGVyLm0gKyAoLTEgKiB0aGlzLm0pO1xyXG4gICAgdmFyIHQgPSB0aGlzLnQgKyAoLTEgKiBvdGhlci50KTtcclxuICAgIHZhciB4ID0gKG0gIT09IDApID8gdCAvIG0gOiB0O1xyXG4gICAgcmV0dXJuIHRoaXMuY2FsY0ZYKHgpO1xyXG59O1xyXG5cclxuTGluZS5jYWxjRGlzdGFuY2UgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coKHAyLnkgLSBwMS55KSwyKSArIE1hdGgucG93KChwMi54IC0gcDEueCksMikpO1xyXG59XHJcblxyXG52YXIgU2ltcGxlVmVjdG9yID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbn07XHJcblxyXG5TaW1wbGVWZWN0b3IucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHRoYXQpIHtcclxuICAgIHJldHVybiB0aGlzLngqdGhhdC54ICsgdGhpcy55KnRoYXQueTtcclxufTtcclxuXHJcblNpbXBsZVZlY3Rvci5mcm9tUG9pbnRzID0gZnVuY3Rpb24ocDEsIHAyKSB7XHJcbiAgICByZXR1cm4gbmV3IFNpbXBsZVZlY3RvcihcclxuICAgICAgICBwMi54IC0gcDEueCxcclxuICAgICAgICBwMi55IC0gcDEueVxyXG4gICAgKTtcclxufTtcclxuXHJcblNpbXBsZVZlY3Rvci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbih0aGF0KSB7XHJcbiAgICByZXR1cm4gbmV3IFNpbXBsZVZlY3Rvcih0aGlzLnggLSB0aGF0LngsIHRoaXMueSAtIHRoYXQueSk7XHJcbn07XHJcblxyXG52YXIgRWxsaXBzZSA9IGZ1bmN0aW9uKGN4LCBjeSwgcngsIHJ5KSB7XHJcbiAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgdGhpcy5jID0ge3g6Y3gseTpjeX07XHJcbiAgICAgICAgICAgIHRoaXMucnggPSByeDtcclxuICAgICAgICAgICAgdGhpcy5yeSA9IHJ5O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHRoaXMuYyA9IGN4O1xyXG4gICAgICAgICAgICB0aGlzLnJ4ID0gY3k7XHJcbiAgICAgICAgICAgIHRoaXMucnkgPSByeDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcblxyXG5FbGxpcHNlLnByb3RvdHlwZS5jYWxjTGluZUludGVyY2VwdCA9IGZ1bmN0aW9uKHAxLHAyKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHAyID0gcDEucDI7XHJcbiAgICAgICAgcDEgPSBwMS5wMTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3JpZ2luID0gbmV3IFNpbXBsZVZlY3RvcihwMS54LCBwMS55KTtcclxuICAgIHZhciBkaXIgPSBTaW1wbGVWZWN0b3IuZnJvbVBvaW50cyhwMSwgcDIpO1xyXG4gICAgdmFyIGNlbnRlciA9IG5ldyBTaW1wbGVWZWN0b3IodGhpcy5jLngsIHRoaXMuYy55KTtcclxuICAgIHZhciBkaWZmID0gb3JpZ2luLnN1YnRyYWN0KGNlbnRlcik7XHJcbiAgICB2YXIgbURpciA9IG5ldyBTaW1wbGVWZWN0b3IoZGlyLngvKHRoaXMucngqdGhpcy5yeCksICBkaXIueS8odGhpcy5yeSp0aGlzLnJ5KSk7XHJcbiAgICB2YXIgbURpZmYgPSBuZXcgU2ltcGxlVmVjdG9yKGRpZmYueC8odGhpcy5yeCp0aGlzLnJ4KSwgZGlmZi55Lyh0aGlzLnJ5KnRoaXMucnkpKTtcclxuXHJcbiAgICB2YXIgYURpZmYgPSBkaXIuZG90KG1EaXIpO1xyXG4gICAgdmFyIGJEaWZmID0gZGlyLmRvdChtRGlmZik7XHJcbiAgICB2YXIgY0RpZmYgPSBkaWZmLmRvdChtRGlmZikgLSAxLjA7XHJcbiAgICB2YXIgZERpZmYgPSBiRGlmZipiRGlmZiAtIGFEaWZmKmNEaWZmO1xyXG5cclxuICAgIGlmIChkRGlmZiA+IDApIHtcclxuICAgICAgICB2YXIgcm9vdCA9IE1hdGguc3FydChkRGlmZik7XHJcbiAgICAgICAgdmFyIHRBICA9ICgtYkRpZmYgLSByb290KSAvIGFEaWZmO1xyXG4gICAgICAgIHZhciB0QiAgPSAoLWJEaWZmICsgcm9vdCkgLyBhRGlmZjtcclxuXHJcbiAgICAgICAgaWYgKCEoKHRBIDwgMCB8fCAxIDwgdEEpICYmICh0QiA8IDAgfHwgMSA8IHRCKSkpIHtcclxuICAgICAgICAgICAgaWYgKDAgPD0gdEEgJiYgdEEgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVycChwMSwgcDIsIHRBKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCAwIDw9IHRCICYmIHRCIDw9IDEgKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsZXJwKHAxLCBwMiwgdEIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHQgPSAtYkRpZmYvYURpZmY7XHJcbiAgICAgICAgaWYgKDAgPD0gdCAmJiB0IDw9IDEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVycChwMS4gYTIsIHQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbkVsbGlwc2UucHJvdG90eXBlLm92ZXJsYXlzID0gZnVuY3Rpb24ocCkge1xyXG4gICAgdmFyIGJ4ID0gTWF0aC5wb3coKHAueCAtIHRoaXMuYy54KSwgMikgLyBNYXRoLnBvdyh0aGlzLnJ4LCAyKTtcclxuICAgIHZhciBieSA9IE1hdGgucG93KChwLnkgLSB0aGlzLmMueSksIDIpIC8gTWF0aC5wb3codGhpcy5yeSwgMik7XHJcbiAgICByZXR1cm4gYnggKyBieSA8PSAxXHJcbn07XHJcblxyXG52YXIgQ2lyY2xlID0gZnVuY3Rpb24oY3gsIGN5LCByKSB7XHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgdGhpcy5jID0gY3g7XHJcbiAgICAgICAgdGhpcy5yID0gY3k7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYyA9IHt4OiBjeCwgeSA6IGN5fTtcclxuICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ2lyY2xlLnByb3RvdHlwZS5vdmVybGF5cyA9IGZ1bmN0aW9uKHApIHtcclxuICAgIHZhciBieCA9IE1hdGgucG93KChwLnggLSB0aGlzLmMueCksIDIpO1xyXG4gICAgdmFyIGJ5ID0gTWF0aC5wb3coKHAueSAtIHRoaXMuYy55KSwgMik7XHJcbiAgICByZXR1cm4gYnggKyBieSA8IE1hdGgucG93KHRoaXMuciwgMik7XHJcbn07XHJcblxyXG5DaXJjbGUucHJvdG90eXBlLmNhbGNMaW5lSW50ZXJjZXB0ID0gZnVuY3Rpb24ocDEsIHAyKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHAyID0gcDEucDI7XHJcbiAgICAgICAgcDEgPSBwMS5wMTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYSA9IChwMi54IC0gcDEueCkgKiAocDIueCAtIHAxLngpXHJcbiAgICAgICAgKyAocDIueSAtIHAxLnkpICogKHAyLnkgLSBwMS55KTtcclxuICAgIHZhciBiICA9IDIgKiAoKHAyLnggLSBwMS54KSAqIChwMS54IC0gdGhpcy5jLngpXHJcbiAgICAgICAgKyAocDIueSAtIHAxLnkpICogKHAxLnkgLSB0aGlzLmMueSkgICApO1xyXG4gICAgdmFyIGNjID0gdGhpcy5jLngqdGhpcy5jLnggKyB0aGlzLmMueSp0aGlzLmMueSArIHAxLngqcDEueCArIHAxLnkqcDEueSAtXHJcbiAgICAgICAgMiAqICh0aGlzLmMueCAqIHAxLnggKyB0aGlzLmMueSAqIHAxLnkpIC0gdGhpcy5yKnRoaXMucjtcclxuICAgIHZhciBkZXRlciA9IGIqYiAtIDQqYSpjYztcclxuXHJcbiAgICBpZihkZXRlciA+IDApIHtcclxuICAgICAgICB2YXIgcm9vdCAgPSBNYXRoLnNxcnQoZGV0ZXIpO1xyXG4gICAgICAgIHZhciB0QSA9ICgtYiArIHJvb3QpIC8gKDIqYSk7XHJcbiAgICAgICAgdmFyIHRCID0gKC1iIC0gcm9vdCkgLyAoMiphKTtcclxuXHJcbiAgICAgICAgaWYgKCEoKHRBIDwgMCB8fCB0QSA+IDEpICYmICh0QiA8IDAgfHwgdEIgPiAxKSkpIHtcclxuICAgICAgICAgICAgaWYgKDAgPD0gdEEgJiYgdEEgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVycChwMSwgcDIsIHRBKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgwIDw9IHRCICYmIHRCIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlcnAocDEsIHAyLCB0QikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnZhciBsZXJwID0gZnVuY3Rpb24oYSwgYiwgdCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4IDogYS54ICsgKGIueCAtIGEueCkgKiB0LFxyXG4gICAgICAgIHkgOiBhLnkgKyAoYi55IC0gYS55KSAqIHRcclxuICAgIH07XHJcbn07XHJcblxyXG52YXIgVmVjdG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnZlY3RvcnMgPSBbXTtcclxuICAgIHZhciBjdXJyZW50QXJyO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0FycmF5KGFyZ3VtZW50c1tpXSkpIHtcclxuICAgICAgICAgICAgaWYoY3VycmVudEFycikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY3VycmVudEFycik7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXJyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFyciA9IGN1cnJlbnRBcnIgfHwgW107XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcnIucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYoY3VycmVudEFycikge1xyXG4gICAgICAgIHRoaXMuYWRkKGN1cnJlbnRBcnIpO1xyXG4gICAgICAgIGRlbGV0ZSBjdXJyZW50QXJyO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSB2ZWN0b3IgdmFsdWUgZWl0aGVyIGJ5IHByb3ZpZGluZyBzZXBlcmF0ZWQgYXJndW1lbnRzIG9yIGFuIGFycmF5IG9mIHZhbHVlc1xyXG4gKi9cclxuVmVjdG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgdmFsdWUgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xyXG4gICAgfVxyXG4gICAgdGhpcy52ZWN0b3JzLnB1c2godmFsdWUpO1xyXG59O1xyXG5cclxuVmVjdG9yLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgcGF0aCA9IG9iamVjdC5pc0FycmF5KGFyZ3VtZW50c1swXSkgPyBhcmd1bWVudHNbMF0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBnZXRWZWN0b3JWYWx1ZSh0aGlzLnZlY3RvcnMsIHBhdGgpO1xyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2V0IHZhbHVlIHZlY3RvciBmYWlsZWQgLSAnK3RoaXMudmVjdG9ycysnIGFyZ3M6ICcrYXJndW1lbnRzKTtcclxuICAgIH1cclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudmVjdG9ycyA9IFtdO1xyXG59O1xyXG5cclxuVmVjdG9yLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHBhdGhBcnIsIHZhbHVlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHBhdGhBcnIgPSAhb2JqZWN0LmlzQXJyYXkocGF0aEFycikgPyBbcGF0aEFycl0gOiBwYXRoQXJyO1xyXG4gICAgICAgIHZhciBwYXJlbnRQYXRoID0gcGF0aEFyci5zcGxpY2UoMCwgcGF0aEFyci5sZW5ndGggLTEpO1xyXG4gICAgICAgIHRoaXMudmFsdWUocGFyZW50UGF0aClbcGF0aEFycltwYXRoQXJyLmxlbmd0aCAtMV1dID0gdmFsdWU7XHJcbiAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdzZXQgdmFsdWUgdmVjdG9yIGZhaWxlZCAtICcrdGhpcy52ZWN0b3JzKycgYXJnczogJythcmd1bWVudHMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVmVjdG9yLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihwYXRoQXJyLCB2YWx1ZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBwYXRoQXJyID0gIW9iamVjdC5pc0FycmF5KHBhdGhBcnIpID8gW3BhdGhBcnJdIDogcGF0aEFycjtcclxuICAgICAgICB2YXIgcGFyZW50UGF0aCA9IHBhdGhBcnIuc3BsaWNlKDAsIHBhdGhBcnIubGVuZ3RoIC0xKTtcclxuICAgICAgICB0aGlzLnZhbHVlKHBhcmVudFBhdGgpLnNwbGljZShwYXRoQXJyW3BhdGhBcnIubGVuZ3RoIC0xXSwgMCwgdmFsdWUpO1xyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignc2V0IHZhbHVlIHZlY3RvciBmYWlsZWQgLSAnK3RoaXMudmVjdG9ycysnIGFyZ3M6ICcrYXJndW1lbnRzKTtcclxuICAgIH1cclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy52ZWN0b3JzLmxlbmd0aDtcclxufVxyXG5cclxuVmVjdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwYXRoQXJyKSB7XHJcbiAgICBwYXRoQXJyID0gIW9iamVjdC5pc0FycmF5KHBhdGhBcnIpID8gW3BhdGhBcnJdIDogcGF0aEFycjtcclxuICAgIHZhciBwYXJlbnRQYXRoID0gcGF0aEFyci5zcGxpY2UoMCwgcGF0aEFyci5sZW5ndGggLTEpO1xyXG4gICAgdGhpcy52YWx1ZShwYXJlbnRQYXRoKS5zcGxpY2UocGF0aEFycltwYXRoQXJyLmxlbmd0aCAtMV0sIDEpO1xyXG59O1xyXG5cclxuVmVjdG9yLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy52ZWN0b3JzW3RoaXMudmVjdG9ycy5sZW5ndGggLTFdO1xyXG59O1xyXG5cclxuVmVjdG9yLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oaGFuZGxlcikge1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy52ZWN0b3JzLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBoYW5kbGVyKGluZGV4LHZhbHVlKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vdGUgdGhlIGluZGV4ZXMgY2FuIGJlIG5lZ2F0aXZlIHRvIHJldHJpZXZlIHZhbHVlcyBmcm9tIHRoZSBlbmQgb2YgdGhlIHZlY3RvciBlLmcuIC0xIGlzIHRoZSBsYXN0XHJcbiAqIEBwYXJhbSB2ZWN0b3JBcnJcclxuICogQHBhcmFtIGFyZ3NcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG52YXIgZ2V0VmVjdG9yVmFsdWUgPSBmdW5jdGlvbih2ZWN0b3JBcnIsIGFyZ3MpIHtcclxuICAgIGlmKCFhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHZlY3RvckFycjtcclxuICAgIH1lbHNlIGlmKG9iamVjdC5pc0FycmF5KGFyZ3MpKSB7XHJcbiAgICAgICAgc3dpdGNoKGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZWN0b3JBcnI7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QudmFsdWVCeUluZGV4KHZlY3RvckFyciwgYXJnc1swXSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFZlY3RvclZhbHVlKHZlY3RvckFycltpbmRleF0sIGFyZ3Muc3BsaWNlKDEpKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBvYmplY3QudmFsdWVCeUluZGV4KHZlY3RvckFyciwgYXJncyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gc291cmNlIGFuZCB0YXJnZXQgdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgZ2l2ZW4gcmFuZ2UgdmFsdWVcclxuICovXHJcbnZhciBjaGVja1JhbmdlRGlmZiA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0LCByYW5nZSkge1xyXG4gICAgcmV0dXJuIGlzSW5EaWZmUmFuZ2UodGFyZ2V0LCBzb3VyY2UsIHJhbmdlKTtcclxufTtcclxuXHJcbnZhciBpc0luRGlmZlJhbmdlID0gZnVuY3Rpb24ocDEsIHAyLCByYW5nZSkge1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKHAxIC0gcDIpIDwgcmFuZ2U7XHJcbn07XHJcblxyXG52YXIgZ2V0UG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgaWYoeCAmJiBvYmplY3QuaXNEZWZpbmVkKHgueCkgJiYgb2JqZWN0LmlzRGVmaW5lZCh4LnkpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0geDtcclxuICAgIH0gZWxzZSBpZighaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB4IDogeCxcclxuICAgICAgICAgICAgeSA6IHlcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc0RlZmluZWQoeCkgJiYgb2JqZWN0LmlzRGVmaW5lZCh5KSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHRvUG9pbnQoeCx5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgdG9Qb2ludCA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgeCA9IChvYmplY3QuaXNTdHJpbmcoeCkpID8gcGFyc2VGbG9hdCh4KSA6IHg7XHJcbiAgICB5ID0gKG9iamVjdC5pc1N0cmluZyh5KSkgPyBwYXJzZUZsb2F0KHkpIDogeTtcclxuXHJcbiAgICByZXR1cm4ge3g6eCx5Onl9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBjYWxjTGluZUludGVyc2VjdGlvbiA6IGNhbGNMaW5lSW50ZXJzZWN0aW9uLFxyXG4gICAgTGluZSA6IExpbmUsXHJcbiAgICBDaXJjbGUgOiBDaXJjbGUsXHJcbiAgICBFbGxpcHNlIDogRWxsaXBzZSxcclxuICAgIFZlY3RvciA6IFZlY3RvcixcclxuICAgIFBvaW50IDogUG9pbnQsXHJcbiAgICBpc1BvaW50SW5JbnRlcnZhbCA6IGlzUG9pbnRJbkludGVydmFsLFxyXG4gICAgbWluTWF4IDogbWluTWF4LFxyXG4gICAgY2hlY2tSYW5nZURpZmYgOiBjaGVja1JhbmdlRGlmZixcclxuICAgIGdldFBvaW50IDogZ2V0UG9pbnQsXHJcbiAgICBiZXppZXIgOiBiZXppZXJcclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGVhY2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAkLmVhY2goYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdyZXA6IGZ1bmN0aW9uKGFyciwgZmlsdGVyLCBpbnZlcnQpIHtcclxuICAgICAgICByZXR1cm4gJC5ncmVwKGFyciwgZmlsdGVyLCBpbnZlcnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0FycmF5OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gJC5pc0FycmF5KG9iaik7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvQXJyYXkgOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gJC5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUZyb21BcnJheTogZnVuY3Rpb24oYXJyLCBpdGVtKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XHJcbiAgICAgICAgaWYoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgc29ydDogZnVuY3Rpb24ob2JqLCBzb3J0KSB7XHJcbiAgICAgICAgdmFyIGFycjtcclxuICAgICAgICBpZighb2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2UgaWYodGhpcy5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgYXJyID0gb2JqO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgYXJyID0gJC5tYXAob2JqLCBmdW5jdGlvbiAoaW5kZXgsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialt2YWxdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIuc29ydChzb3J0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdmFsdWVCeUluZGV4OiBmdW5jdGlvbihhcnIsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleChhcnIsaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiBhcnJbaW5kZXhdO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRJbmRleDogZnVuY3Rpb24oYXJyLCBpbmRleCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAvLyBmb3IgbmVnYXRpdmUgaW5kZXhlcyB3ZSByZXR1cm4gdmFsdWVzIGNvdW50ZWQgZnJvbSB0aGUgb3RoZXIgc2lkZSBzbyAtMSBpcyB0aGUgbGFzdCBpbmRleFxyXG4gICAgICAgIC8vIGlmIHRoZSBuZWdhdGl2ZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2Ugd2UgcmV0dXJuIHRoZSBsYXN0IGluZGV4LlxyXG4gICAgICAgIGlmKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBhcnIubGVuZ3RoICsgaW5kZXg7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPiBhcnIubGVuZ3RoIC0xIHx8IHJlc3VsdCA8IDApID8gYXJyLmxlbmd0aCAtMSA6IHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuICQuaXNQbGFpbk9iamVjdChvYmopO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0pRdWVyeTogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iai5qcXVlcnk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdib29sZWFuJztcclxuICAgIH0sXHJcblxyXG4gICAgaXNEZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmKCF0aGF0LmlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnO1xyXG4gICAgfSxcclxuXHJcbiAgICBtZXJnZTogZnVuY3Rpb24odGFyZ2V0LCB0b01lcmdlKSB7XHJcbiAgICAgICAgcmV0dXJuICQubWVyZ2UodGFyZ2V0LCB0b01lcmdlKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIGFkZFZhbHVlOiBmdW5jdGlvbih0YXJnZXQsIG5ld1ZhbCkge1xyXG4gICAgICAgIGlmKGlzQXJyYXkobmV3VmFsKSkge1xyXG4gICAgICAgICAgICBtZXJnZSh0YXJnZXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCwgb2JqMSwgb2JqMikge1xyXG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh0YXJnZXQsb2JqMSxvYmoyKTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmVBcnJheTogZnVuY3Rpb24oYXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyci5zbGljZSgwKTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmVPYmplY3Q6IGZ1bmN0aW9uKG9sZE9iamVjdCwgZGVlcCkge1xyXG4gICAgICAgIGRlZXAgPSBkZWVwIHx8IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiAkLmV4dGVuZChkZWVwLCB7fSwgb2xkT2JqZWN0KTtcclxuICAgIH1cclxuICAgIFxyXG59IiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0Jyk7XHJcblxyXG5leHBvcnRzLmVuZHNXaXRoID0gZnVuY3Rpb24odmFsLCBzdWZmaXgpIHtcclxuICAgIGlmKCFvYmplY3QuaXNEZWZpbmVkKHZhbCkgfHwgIW9iamVjdC5pc0RlZmluZWQoc3VmZml4KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWwuaW5kZXhPZihzdWZmaXgsIHZhbC5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XHJcbn07XHJcblxyXG5leHBvcnRzLnN0YXJ0c1dpdGggPSBmdW5jdGlvbih2YWwsIHByZWZpeCkge1xyXG4gICAgaWYoIW9iamVjdC5pc0RlZmluZWQodmFsKSB8fCAhb2JqZWN0LmlzRGVmaW5lZChwcmVmaXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbC5pbmRleE9mKHByZWZpeCkgPT09IDA7XHJcbn07IiwidmFyIHN0cmluZyA9IHJlcXVpcmUoJy4vc3RyaW5nJyk7XHJcblxyXG52YXIgc2VyaWFsaXplVG9TdHJpbmcgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICB2YXIgcyA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XHJcbiAgICBub2RlID0gKG5vZGUualF1ZXJ5KSA/IG5vZGVbMF0gOiBub2RlO1xyXG4gICAgcmV0dXJuIHMuc2VyaWFsaXplVG9TdHJpbmcobm9kZSk7XHJcbn07XHJcblxyXG52YXIgcGFyc2VYTUwgPSBmdW5jdGlvbihzdHJEYXRhKSB7XHJcbiAgICByZXR1cm4gJC5wYXJzZVhNTChzdHJEYXRhKTtcclxufTtcclxuXHJcbnZhciBmb3JtYXQgPSBmdW5jdGlvbiAoeG1sKSB7XHJcbiAgICB2YXIgaW50ZW5kID0gLTE7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB4bWwgPSB4bWwucmVwbGFjZSgvKFxcclxcbnxcXG58XFxyKS9nbSxcIlwiKTtcclxuICAgIHZhciBsYXN0V2FzQ2xvc2UgPSBmYWxzZTtcclxuICAgIHZhciBsYXN0SGFkVGV4dCA9IGZhbHNlO1xyXG4gICAgJC5lYWNoKHhtbC5zcGxpdCgnPCcpLCBmdW5jdGlvbihpbmRleCwgbm9kZSkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlLnRyaW0oKTtcclxuICAgICAgICBpZihub2RlKSB7XHJcbiAgICAgICAgICAgIGlmKG5vZGUuaW5kZXhPZignLycpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZighbGFzdFdhc0Nsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZW5kKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdEhhZFRleHQgPSAhc3RyaW5nLmVuZHNXaXRoKG5vZGUsICc+Jyk7XHJcbiAgICAgICAgICAgICAgICBsYXN0V2FzQ2xvc2UgPSBzdHJpbmcuZW5kc1dpdGgobm9kZSwgJy8+Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZighbGFzdEhhZFRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0V2FzQ2xvc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVuZC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdEhhZFRleHQgPSAhc3RyaW5nLmVuZHNXaXRoKG5vZGUsICc+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gJyc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmcgKz0gJyAgJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHRleHQ7XHJcbiAgICAgICAgICAgIGlmKGxhc3RIYWRUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXR0ZWQgPSBub2RlLnNwbGl0KCc+Jyk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gc3BsaXR0ZWRbMF0gKyAnPic7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gc3BsaXR0ZWRbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9IHBhZGRpbmcgKyAnPCcrbm9kZSsnXFxyXFxuJztcclxuXHJcbiAgICAgICAgICAgIGlmKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwYWRkaW5nICsgJyAgJyArIHRleHQrJ1xcclxcbic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzZXJpYWxpemVUb1N0cmluZyA6IHNlcmlhbGl6ZVRvU3RyaW5nLFxyXG4gICAgcGFyc2VYTUwgOiBwYXJzZVhNTCxcclxuICAgIGZvcm1hdDogZm9ybWF0XHJcbn07IiwiLyogQHByZXNlcnZlXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE0IFBldGthIEFudG9ub3ZcbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqIFxuICovXG4vKipcbiAqIGJsdWViaXJkIGJ1aWxkIHZlcnNpb24gMi45LjM0XG4gKiBGZWF0dXJlcyBlbmFibGVkOiBjb3JlLCByYWNlLCBjYWxsX2dldCwgZ2VuZXJhdG9ycywgbWFwLCBub2RlaWZ5LCBwcm9taXNpZnksIHByb3BzLCByZWR1Y2UsIHNldHRsZSwgc29tZSwgY2FuY2VsLCB1c2luZywgZmlsdGVyLCBhbnksIGVhY2gsIHRpbWVyc1xuKi9cbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLlByb21pc2U9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIF9kZXJlcV89PVwiZnVuY3Rpb25cIiYmX2RlcmVxXztpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgX2RlcmVxXz09XCJmdW5jdGlvblwiJiZfZGVyZXFfO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIFNvbWVQcm9taXNlQXJyYXkgPSBQcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5O1xuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoMSk7XG4gICAgcmV0LnNldFVud3JhcCgpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UuYW55ID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIGFueShwcm9taXNlcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZmlyc3RMaW5lRXJyb3I7XG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7Zmlyc3RMaW5lRXJyb3IgPSBlO31cbnZhciBzY2hlZHVsZSA9IF9kZXJlcV8oXCIuL3NjaGVkdWxlLmpzXCIpO1xudmFyIFF1ZXVlID0gX2RlcmVxXyhcIi4vcXVldWUuanNcIik7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG5cbmZ1bmN0aW9uIEFzeW5jKCkge1xuICAgIHRoaXMuX2lzVGlja1VzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXRlUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IHRydWU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZHJhaW5RdWV1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2RyYWluUXVldWVzKCk7XG4gICAgfTtcbiAgICB0aGlzLl9zY2hlZHVsZSA9XG4gICAgICAgIHNjaGVkdWxlLmlzU3RhdGljID8gc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcykgOiBzY2hlZHVsZTtcbn1cblxuQXN5bmMucHJvdG90eXBlLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3NhcnkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5oYXNEZXZUb29scykge1xuICAgICAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5lbmFibGVUcmFtcG9saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5oYXZlSXRlbXNRdWV1ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vcm1hbFF1ZXVlLmxlbmd0aCgpID4gMDtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS50aHJvd0xhdGVyID0gZnVuY3Rpb24oZm4sIGFyZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFyZyA9IGZuO1xuICAgICAgICBmbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgYXJnOyB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB0cnkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL20zT1RYa1xcdTAwMGFcIik7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQXN5bmNJbnZva2VMYXRlcihmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX2xhdGVRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuZnVuY3Rpb24gQXN5bmNJbnZva2UoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuZnVuY3Rpb24gQXN5bmNTZXR0bGVQcm9taXNlcyhwcm9taXNlKSB7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUuX3B1c2hPbmUocHJvbWlzZSk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmlmICghdXRpbC5oYXNEZXZUb29scykge1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IEFzeW5jSW52b2tlTGF0ZXI7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IEFzeW5jSW52b2tlO1xuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IEFzeW5jU2V0dGxlUHJvbWlzZXM7XG59IGVsc2Uge1xuICAgIGlmIChzY2hlZHVsZS5pc1N0YXRpYykge1xuICAgICAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uKGZuKSB7IHNldFRpbWVvdXQoZm4sIDApOyB9O1xuICAgIH1cbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlTGF0ZXIgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY0ludm9rZUxhdGVyLmNhbGwodGhpcywgZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jSW52b2tlLmNhbGwodGhpcywgZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY1NldHRsZVByb21pc2VzLmNhbGwodGhpcywgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5Bc3luYy5wcm90b3R5cGUuaW52b2tlRmlyc3QgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS51bnNoaWZ0KGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fZHJhaW5RdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCgpID4gMCkge1xuICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGFyZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX25vcm1hbFF1ZXVlKTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbGF0ZVF1ZXVlKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcXVldWVUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNUaWNrVXNlZCkge1xuICAgICAgICB0aGlzLl9pc1RpY2tVc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBBc3luYygpO1xubW9kdWxlLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3IgPSBmaXJzdExpbmVFcnJvcjtcblxufSx7XCIuL3F1ZXVlLmpzXCI6MjgsXCIuL3NjaGVkdWxlLmpzXCI6MzEsXCIuL3V0aWwuanNcIjozOH1dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlKSB7XG52YXIgcmVqZWN0VGhpcyA9IGZ1bmN0aW9uKF8sIGUpIHtcbiAgICB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG52YXIgdGFyZ2V0UmVqZWN0ZWQgPSBmdW5jdGlvbihlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICBjb250ZXh0LmJpbmRpbmdQcm9taXNlLl90aGVuKHJlamVjdFRoaXMsIHJlamVjdFRoaXMsIG51bGwsIHRoaXMsIGUpO1xufTtcblxudmFyIGJpbmRpbmdSZXNvbHZlZCA9IGZ1bmN0aW9uKHRoaXNBcmcsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKGNvbnRleHQudGFyZ2V0KTtcbiAgICB9XG59O1xuXG52YXIgYmluZGluZ1JlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGlmICghY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkKSB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzQXJnKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fcHJvcGFnYXRlRnJvbSh0aGlzLCAxKTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG5cbiAgICByZXQuX3NldEJvdW5kVG8obWF5YmVQcm9taXNlKTtcbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHByb21pc2VSZWplY3Rpb25RdWV1ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvbWlzZTogcmV0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBiaW5kaW5nUHJvbWlzZTogbWF5YmVQcm9taXNlXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5fdGhlbihJTlRFUk5BTCwgdGFyZ2V0UmVqZWN0ZWQsIHJldC5fcHJvZ3Jlc3MsIHJldCwgY29udGV4dCk7XG4gICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgIGJpbmRpbmdSZXNvbHZlZCwgYmluZGluZ1JlamVjdGVkLCByZXQuX3Byb2dyZXNzLCByZXQsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5fcmVzb2x2ZUNhbGxiYWNrKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Qm91bmRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEzMTA3MjtcbiAgICAgICAgdGhpcy5fYm91bmRUbyA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMzEwNzIpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMzEwNzIpID09PSAxMzEwNzI7XG59O1xuXG5Qcm9taXNlLmJpbmQgPSBmdW5jdGlvbiAodGhpc0FyZywgdmFsdWUpIHtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzQXJnKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuXG4gICAgcmV0Ll9zZXRCb3VuZFRvKG1heWJlUHJvbWlzZSk7XG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0Ll9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB9LCByZXQuX3JlamVjdCwgcmV0Ll9wcm9ncmVzcywgcmV0LCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xufTtcblxufSx7fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBvbGQ7XG5pZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIpIG9sZCA9IFByb21pc2U7XG5mdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgIHRyeSB7IGlmIChQcm9taXNlID09PSBibHVlYmlyZCkgUHJvbWlzZSA9IG9sZDsgfVxuICAgIGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBibHVlYmlyZDtcbn1cbnZhciBibHVlYmlyZCA9IF9kZXJlcV8oXCIuL3Byb21pc2UuanNcIikoKTtcbmJsdWViaXJkLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xubW9kdWxlLmV4cG9ydHMgPSBibHVlYmlyZDtcblxufSx7XCIuL3Byb21pc2UuanNcIjoyM31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY3IgPSBPYmplY3QuY3JlYXRlO1xuaWYgKGNyKSB7XG4gICAgdmFyIGNhbGxlckNhY2hlID0gY3IobnVsbCk7XG4gICAgdmFyIGdldHRlckNhY2hlID0gY3IobnVsbCk7XG4gICAgY2FsbGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IGdldHRlckNhY2hlW1wiIHNpemVcIl0gPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgaXNJZGVudGlmaWVyID0gdXRpbC5pc0lkZW50aWZpZXI7XG5cbnZhciBnZXRNZXRob2RDYWxsZXI7XG52YXIgZ2V0R2V0dGVyO1xuaWYgKCF0cnVlKSB7XG52YXIgbWFrZU1ldGhvZENhbGxlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImVuc3VyZU1ldGhvZFwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBlbnN1cmVNZXRob2Qob2JqLCAnbWV0aG9kTmFtZScpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSk7ICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSk7ICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSk7ICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoubWV0aG9kTmFtZS5hcHBseShvYmosIHRoaXMpOyAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoL21ldGhvZE5hbWUvZywgbWV0aG9kTmFtZSkpKGVuc3VyZU1ldGhvZCk7XG59O1xuXG52YXIgbWFrZUdldHRlciA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwib2JqXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIG9iai5wcm9wZXJ0eU5hbWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcInByb3BlcnR5TmFtZVwiLCBwcm9wZXJ0eU5hbWUpKTtcbn07XG5cbnZhciBnZXRDb21waWxlZCA9IGZ1bmN0aW9uKG5hbWUsIGNvbXBpbGVyLCBjYWNoZSkge1xuICAgIHZhciByZXQgPSBjYWNoZVtuYW1lXTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBjb21waWxlcihuYW1lKTtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSByZXQ7XG4gICAgICAgIGNhY2hlW1wiIHNpemVcIl0rKztcbiAgICAgICAgaWYgKGNhY2hlW1wiIHNpemVcIl0gPiA1MTIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkgZGVsZXRlIGNhY2hlW2tleXNbaV1dO1xuICAgICAgICAgICAgY2FjaGVbXCIgc2l6ZVwiXSA9IGtleXMubGVuZ3RoIC0gMjU2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5nZXRNZXRob2RDYWxsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VNZXRob2RDYWxsZXIsIGNhbGxlckNhY2hlKTtcbn07XG5cbmdldEdldHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZUdldHRlciwgZ2V0dGVyQ2FjaGUpO1xufTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBmbjtcbiAgICBpZiAob2JqICE9IG51bGwpIGZuID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiT2JqZWN0IFwiICsgdXRpbC5jbGFzc1N0cmluZyhvYmopICsgXCIgaGFzIG5vIG1ldGhvZCAnXCIgK1xuICAgICAgICAgICAgdXRpbC50b1N0cmluZyhtZXRob2ROYW1lKSArIFwiJ1wiO1xuICAgICAgICB0aHJvdyBuZXcgUHJvbWlzZS5UeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY2FsbGVyKG9iaikge1xuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5wb3AoKTtcbiAgICB2YXIgZm4gPSBlbnN1cmVNZXRob2Qob2JqLCBtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCB0aGlzKTtcbn1cblByb21pc2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHZhciAkX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIGFyZ3MgPSBuZXcgQXJyYXkoJF9sZW4gLSAxKTsgZm9yKHZhciAkX2kgPSAxOyAkX2kgPCAkX2xlbjsgKyskX2kpIHthcmdzWyRfaSAtIDFdID0gYXJndW1lbnRzWyRfaV07fVxuICAgIGlmICghdHJ1ZSkge1xuICAgICAgICBpZiAoY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXliZUNhbGxlciA9IGdldE1ldGhvZENhbGxlcihtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIGlmIChtYXliZUNhbGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXJncy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKGNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG59O1xuXG5mdW5jdGlvbiBuYW1lZEdldHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqW3RoaXNdO1xufVxuZnVuY3Rpb24gaW5kZXhlZEdldHRlcihvYmopIHtcbiAgICB2YXIgaW5kZXggPSArdGhpcztcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IE1hdGgubWF4KDAsIGluZGV4ICsgb2JqLmxlbmd0aCk7XG4gICAgcmV0dXJuIG9ialtpbmRleF07XG59XG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGlzSW5kZXggPSAodHlwZW9mIHByb3BlcnR5TmFtZSA9PT0gXCJudW1iZXJcIik7XG4gICAgdmFyIGdldHRlcjtcbiAgICBpZiAoIWlzSW5kZXgpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVHZXR0ZXIgPSBnZXRHZXR0ZXIocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGdldHRlciA9IG1heWJlR2V0dGVyICE9PSBudWxsID8gbWF5YmVHZXR0ZXIgOiBuYW1lZEdldHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldHRlciA9IG5hbWVkR2V0dGVyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gaW5kZXhlZEdldHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZ2V0dGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lLCB1bmRlZmluZWQpO1xufTtcbn07XG5cbn0se1wiLi91dGlsLmpzXCI6Mzh9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzLmpzXCIpO1xudmFyIGFzeW5jID0gX2RlcmVxXyhcIi4vYXN5bmMuanNcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLmlzQ2FuY2VsbGFibGUoKSkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHBhcmVudDtcbiAgICB2YXIgcHJvbWlzZVRvUmVqZWN0ID0gdGhpcztcbiAgICB3aGlsZSAoKHBhcmVudCA9IHByb21pc2VUb1JlamVjdC5fY2FuY2VsbGF0aW9uUGFyZW50KSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHBhcmVudC5pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgcHJvbWlzZVRvUmVqZWN0ID0gcGFyZW50O1xuICAgIH1cbiAgICB0aGlzLl91bnNldENhbmNlbGxhYmxlKCk7XG4gICAgcHJvbWlzZVRvUmVqZWN0Ll90YXJnZXQoKS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBmYWxzZSwgdHJ1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLmlzQ2FuY2VsbGFibGUoKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHJlYXNvbiA9PT0gdW5kZWZpbmVkKSByZWFzb24gPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKTtcbiAgICBhc3luYy5pbnZva2VMYXRlcih0aGlzLl9jYW5jZWwsIHRoaXMsIHJlYXNvbik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYW5jZWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fY2FuY2VsbGFibGUoKSkgcmV0dXJuIHRoaXM7XG4gICAgYXN5bmMuZW5hYmxlVHJhbXBvbGluZSgpO1xuICAgIHRoaXMuX3NldENhbmNlbGxhYmxlKCk7XG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudW5jYW5jZWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy50aGVuKCk7XG4gICAgcmV0Ll91bnNldENhbmNlbGxhYmxlKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBkaWRQcm9ncmVzcykge1xuICAgIHZhciByZXQgPSB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgZGlkUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuXG4gICAgcmV0Ll9zZXRDYW5jZWxsYWJsZSgpO1xuICAgIHJldC5fY2FuY2VsbGF0aW9uUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXQ7XG59O1xufTtcblxufSx7XCIuL2FzeW5jLmpzXCI6MixcIi4vZXJyb3JzLmpzXCI6MTN9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbnZhciBhc3luYyA9IF9kZXJlcV8oXCIuL2FzeW5jLmpzXCIpO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGJsdWViaXJkRnJhbWVQYXR0ZXJuID1cbiAgICAvW1xcXFxcXC9dYmx1ZWJpcmRbXFxcXFxcL11qc1tcXFxcXFwvXShtYWlufGRlYnVnfHphbGdvfGluc3RydW1lbnRlZCkvO1xudmFyIHN0YWNrRnJhbWVQYXR0ZXJuID0gbnVsbDtcbnZhciBmb3JtYXRTdGFjayA9IG51bGw7XG52YXIgaW5kZW50U3RhY2tGcmFtZXMgPSBmYWxzZTtcbnZhciB3YXJuO1xuXG5mdW5jdGlvbiBDYXB0dXJlZFRyYWNlKHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gMSArIChwYXJlbnQgPT09IHVuZGVmaW5lZCA/IDAgOiBwYXJlbnQuX2xlbmd0aCk7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2FwdHVyZWRUcmFjZSk7XG4gICAgaWYgKGxlbmd0aCA+IDMyKSB0aGlzLnVuY3ljbGUoKTtcbn1cbnV0aWwuaW5oZXJpdHMoQ2FwdHVyZWRUcmFjZSwgRXJyb3IpO1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS51bmN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBzdGFja1RvSW5kZXggPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBub2RlID0gdGhpczsgbm9kZSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuX3BhcmVudDtcbiAgICB9XG4gICAgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gaTtcbiAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gbm9kZXNbaV0uc3RhY2s7XG4gICAgICAgIGlmIChzdGFja1RvSW5kZXhbc3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrVG9JbmRleFtzdGFja10gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICB2YXIgaW5kZXggPSBzdGFja1RvSW5kZXhbY3VycmVudFN0YWNrXTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tpbmRleCAtIDFdLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzW2ldLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBub2Rlc1tpXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHZhciBjeWNsZUVkZ2VOb2RlID0gaSA+IDAgPyBub2Rlc1tpIC0gMV0gOiB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gbm9kZXNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQudW5jeWNsZSgpO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudC5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudENoaWxkTGVuZ3RoID0gY3ljbGVFZGdlTm9kZS5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gMjsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tqXS5fbGVuZ3RoID0gY3VycmVudENoaWxkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGlsZExlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbn07XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLmhhc1BhcmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQgIT09IHVuZGVmaW5lZDtcbn07XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLmF0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSByZXR1cm47XG4gICAgdGhpcy51bmN5Y2xlKCk7XG4gICAgdmFyIHBhcnNlZCA9IENhcHR1cmVkVHJhY2UucGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgIHZhciBtZXNzYWdlID0gcGFyc2VkLm1lc3NhZ2U7XG4gICAgdmFyIHN0YWNrcyA9IFtwYXJzZWQuc3RhY2tdO1xuXG4gICAgdmFyIHRyYWNlID0gdGhpcztcbiAgICB3aGlsZSAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFja3MucHVzaChjbGVhblN0YWNrKHRyYWNlLnN0YWNrLnNwbGl0KFwiXFxuXCIpKSk7XG4gICAgICAgIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKTtcbiAgICByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKTtcbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcInN0YWNrXCIsIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJfX3N0YWNrQ2xlYW5lZF9fXCIsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVjb25zdHJ1Y3RTdGFjayhtZXNzYWdlLCBzdGFja3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgc3RhY2tzW2ldLnB1c2goXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiKTtcbiAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgc3RhY2tzLmxlbmd0aCkge1xuICAgICAgICBzdGFja3NbaV0gPSBzdGFja3NbaV0uam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2tzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZU9yRW1wdHlKdW1wcyhzdGFja3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc3RhY2tzW2ldLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKChpICsgMSA8IHN0YWNrcy5sZW5ndGgpICYmIHN0YWNrc1tpXVswXSA9PT0gc3RhY2tzW2krMV1bMF0pKSB7XG4gICAgICAgICAgICBzdGFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDb21tb25Sb290cyhzdGFja3MpIHtcbiAgICB2YXIgY3VycmVudCA9IHN0YWNrc1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcHJldiA9IHN0YWNrc1tpXTtcbiAgICAgICAgdmFyIGN1cnJlbnRMYXN0SW5kZXggPSBjdXJyZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBjdXJyZW50TGFzdExpbmUgPSBjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdO1xuICAgICAgICB2YXIgY29tbW9uUm9vdE1lZXRQb2ludCA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBwcmV2Lmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICBpZiAocHJldltqXSA9PT0gY3VycmVudExhc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgY29tbW9uUm9vdE1lZXRQb2ludCA9IGo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gY29tbW9uUm9vdE1lZXRQb2ludDsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gcHJldltqXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdID09PSBsaW5lKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGFzdEluZGV4LS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBwcmV2O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5TdGFjayhzdGFjaykge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIHZhciBpc1RyYWNlTGluZSA9IHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkgfHxcbiAgICAgICAgICAgIFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZTtcbiAgICAgICAgdmFyIGlzSW50ZXJuYWxGcmFtZSA9IGlzVHJhY2VMaW5lICYmIHNob3VsZElnbm9yZShsaW5lKTtcbiAgICAgICAgaWYgKGlzVHJhY2VMaW5lICYmICFpc0ludGVybmFsRnJhbWUpIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnRTdGFja0ZyYW1lcyAmJiBsaW5lLmNoYXJBdCgwKSAhPT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gXCIgICAgXCIgKyBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc3RhY2tGcmFtZXNBc0FycmF5KGVycm9yKSB7XG4gICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXFxzKyQvZywgXCJcIikuc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiID09PSBsaW5lIHx8IHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpID4gMCkge1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG5cbkNhcHR1cmVkVHJhY2UucGFyc2VTdGFja0FuZE1lc3NhZ2UgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICBzdGFjayA9IHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIiAmJiBzdGFjay5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIDogW1wiICAgIChObyBzdGFjayB0cmFjZSlcIl07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IGNsZWFuU3RhY2soc3RhY2spXG4gICAgfTtcbn07XG5cbkNhcHR1cmVkVHJhY2UuZm9ybWF0QW5kTG9nRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgdGl0bGUpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRpdGxlICsgZm9ybWF0U3RhY2soc3RhY2ssIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIFN0cmluZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3YXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm4obWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5DYXB0dXJlZFRyYWNlLnVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICBDYXB0dXJlZFRyYWNlLmZvcm1hdEFuZExvZ0Vycm9yKHJlYXNvbiwgXCJeLS0tIFdpdGggYWRkaXRpb25hbCBzdGFjayB0cmFjZTogXCIpO1xufTtcblxuQ2FwdHVyZWRUcmFjZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG5DYXB0dXJlZFRyYWNlLmZpcmVSZWplY3Rpb25FdmVudCA9XG5mdW5jdGlvbihuYW1lLCBsb2NhbEhhbmRsZXIsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgIHZhciBsb2NhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2NhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICB9XG5cbiAgICB2YXIgZ2xvYmFsRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSBmaXJlR2xvYmFsRXZlbnQobmFtZSwgcmVhc29uLCBwcm9taXNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgIH1cblxuICAgIHZhciBkb21FdmVudEZpcmVkID0gZmFsc2U7XG4gICAgaWYgKGZpcmVEb21FdmVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9tRXZlbnRGaXJlZCA9IGZpcmVEb21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZG9tRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFnbG9iYWxFdmVudEZpcmVkICYmICFsb2NhbEV2ZW50RmlyZWQgJiYgIWRvbUV2ZW50RmlyZWQgJiZcbiAgICAgICAgbmFtZSA9PT0gXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikge1xuICAgICAgICBDYXB0dXJlZFRyYWNlLmZvcm1hdEFuZExvZ0Vycm9yKHJlYXNvbiwgXCJVbmhhbmRsZWQgcmVqZWN0aW9uIFwiKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXROb25FcnJvcihvYmopIHtcbiAgICB2YXIgc3RyO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3RyID0gXCJbZnVuY3Rpb24gXCIgK1xuICAgICAgICAgICAgKG9iai5uYW1lIHx8IFwiYW5vbnltb3VzXCIpICtcbiAgICAgICAgICAgIFwiXVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IG9iai50b1N0cmluZygpO1xuICAgICAgICB2YXIgcnVzZWxlc3NUb1N0cmluZyA9IC9cXFtvYmplY3QgW2EtekEtWjAtOSRfXStcXF0vO1xuICAgICAgICBpZiAocnVzZWxlc3NUb1N0cmluZy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1N0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgICAgICAgICAgc3RyID0gbmV3U3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN0ciA9IFwiKGVtcHR5IGFycmF5KVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXCIoPFwiICsgc25pcChzdHIpICsgXCI+LCBubyBzdGFjayB0cmFjZSlcIik7XG59XG5cbmZ1bmN0aW9uIHNuaXAoc3RyKSB7XG4gICAgdmFyIG1heENoYXJzID0gNDE7XG4gICAgaWYgKHN0ci5sZW5ndGggPCBtYXhDaGFycykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBtYXhDaGFycyAtIDMpICsgXCIuLi5cIjtcbn1cblxudmFyIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG52YXIgcGFyc2VMaW5lSW5mb1JlZ2V4ID0gL1tcXC88XFwoXShbXjpcXC9dKyk6KFxcZCspOig/OlxcZCspXFwpP1xccyokLztcbmZ1bmN0aW9uIHBhcnNlTGluZUluZm8obGluZSkge1xuICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChwYXJzZUxpbmVJbmZvUmVnZXgpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgICAgIGxpbmU6IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKVxuICAgICAgICB9O1xuICAgIH1cbn1cbkNhcHR1cmVkVHJhY2Uuc2V0Qm91bmRzID0gZnVuY3Rpb24oZmlyc3RMaW5lRXJyb3IsIGxhc3RMaW5lRXJyb3IpIHtcbiAgICBpZiAoIUNhcHR1cmVkVHJhY2UuaXNTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBmaXJzdFN0YWNrTGluZXMgPSBmaXJzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgbGFzdFN0YWNrTGluZXMgPSBsYXN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBmaXJzdEluZGV4ID0gLTE7XG4gICAgdmFyIGxhc3RJbmRleCA9IC0xO1xuICAgIHZhciBmaXJzdEZpbGVOYW1lO1xuICAgIHZhciBsYXN0RmlsZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8oZmlyc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgZmlyc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8obGFzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsYXN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaXJzdEluZGV4IDwgMCB8fCBsYXN0SW5kZXggPCAwIHx8ICFmaXJzdEZpbGVOYW1lIHx8ICFsYXN0RmlsZU5hbWUgfHxcbiAgICAgICAgZmlyc3RGaWxlTmFtZSAhPT0gbGFzdEZpbGVOYW1lIHx8IGZpcnN0SW5kZXggPj0gbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUxpbmVJbmZvKGxpbmUpO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKGluZm8uZmlsZU5hbWUgPT09IGZpcnN0RmlsZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAoZmlyc3RJbmRleCA8PSBpbmZvLmxpbmUgJiYgaW5mby5saW5lIDw9IGxhc3RJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn07XG5cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IChmdW5jdGlvbiBzdGFja0RldGVjdGlvbigpIHtcbiAgICB2YXIgdjhzdGFja0ZyYW1lUGF0dGVybiA9IC9eXFxzKmF0XFxzKi87XG4gICAgdmFyIHY4c3RhY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmIChlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICsgNjtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlO1xuXG4gICAgICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVjZWl2ZXIsIGlnbm9yZVVudGlsKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQgKyA2O1xuICAgICAgICAgICAgY2FwdHVyZVN0YWNrVHJhY2UocmVjZWl2ZXIsIGlnbm9yZVVudGlsKTtcbiAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdCAtIDY7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgIGlmICh0eXBlb2YgZXJyLnN0YWNrID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGVyci5zdGFjay5zcGxpdChcIlxcblwiKVswXS5pbmRleE9mKFwic3RhY2tEZXRlY3Rpb25AXCIpID49IDApIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSAvQC87XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgaW5kZW50U3RhY2tGcmFtZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgby5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNTdGFja0FmdGVyVGhyb3c7XG4gICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIGhhc1N0YWNrQWZ0ZXJUaHJvdyA9IChcInN0YWNrXCIgaW4gZSk7XG4gICAgfVxuICAgIGlmICghKFwic3RhY2tcIiBpbiBlcnIpICYmIGhhc1N0YWNrQWZ0ZXJUaHJvdyAmJlxuICAgICAgICB0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICsgNjtcbiAgICAgICAgICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgICAgICAgICBjYXRjaChlKSB7IG8uc3RhY2sgPSBlLnN0YWNrOyB9XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQgLSA2O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvcm1hdFN0YWNrID0gZnVuY3Rpb24oc3RhY2ssIGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIpIHJldHVybiBzdGFjaztcblxuICAgICAgICBpZiAoKHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgICBlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG51bGw7XG5cbn0pKFtdKTtcblxudmFyIGZpcmVEb21FdmVudDtcbnZhciBmaXJlR2xvYmFsRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCByZWFzb24sIHByb21pc2UpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcInJlamVjdGlvbkhhbmRsZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLmVtaXQobmFtZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLmVtaXQobmFtZSwgcmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3VzdG9tRXZlbnRXb3JrcyA9IGZhbHNlO1xuICAgICAgICB2YXIgYW55RXZlbnRXb3JrcyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBuZXcgc2VsZi5DdXN0b21FdmVudChcInRlc3RcIik7XG4gICAgICAgICAgICBjdXN0b21FdmVudFdvcmtzID0gZXYgaW5zdGFuY2VvZiBDdXN0b21FdmVudDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgaWYgKCFjdXN0b21FdmVudFdvcmtzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFwidGVzdGluZ3RoZWV2ZW50XCIsIGZhbHNlLCB0cnVlLCB7fSk7XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhbnlFdmVudFdvcmtzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUV2ZW50V29ya3MpIHtcbiAgICAgICAgICAgIGZpcmVEb21FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIGRldGFpbCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRXZlbnRXb3Jrcykge1xuICAgICAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBzZWxmLkN1c3RvbUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGZhbHNlLCB0cnVlLCBkZXRhaWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudCA/ICFzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpIDogZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvV2luZG93TWV0aG9kTmFtZU1hcCA9IHt9O1xuICAgICAgICB0b1dpbmRvd01ldGhvZE5hbWVNYXBbXCJ1bmhhbmRsZWRSZWplY3Rpb25cIl0gPSAoXCJvblwiICtcbiAgICAgICAgICAgIFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRvV2luZG93TWV0aG9kTmFtZU1hcFtcInJlamVjdGlvbkhhbmRsZWRcIl0gPSAoXCJvblwiICtcbiAgICAgICAgICAgIFwicmVqZWN0aW9uSGFuZGxlZFwiKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCByZWFzb24sIHByb21pc2UpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gdG9XaW5kb3dNZXRob2ROYW1lTWFwW25hbWVdO1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHNlbGZbbWV0aG9kTmFtZV07XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoc2VsZiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKHNlbGYsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5pZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfTtcbiAgICBpZiAodXRpbC5pc05vZGUgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICAgICAgd2FybiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKFwiXFx1MDAxYlszMW1cIiArIG1lc3NhZ2UgKyBcIlxcdTAwMWJbMzltXFxuXCIpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNOb2RlICYmIHR5cGVvZiAobmV3IEVycm9yKCkuc3RhY2spID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHdhcm4gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCIlY1wiICsgbWVzc2FnZSwgXCJjb2xvcjogcmVkXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxucmV0dXJuIENhcHR1cmVkVHJhY2U7XG59O1xuXG59LHtcIi4vYXN5bmMuanNcIjoyLFwiLi91dGlsLmpzXCI6Mzh9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihORVhUX0ZJTFRFUikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9ycy5qc1wiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGtleXMgPSBfZGVyZXFfKFwiLi9lczUuanNcIikua2V5cztcbnZhciBUeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xuXG5mdW5jdGlvbiBDYXRjaEZpbHRlcihpbnN0YW5jZXMsIGNhbGxiYWNrLCBwcm9taXNlKSB7XG4gICAgdGhpcy5faW5zdGFuY2VzID0gaW5zdGFuY2VzO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fcHJvbWlzZSA9IHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHNhZmVQcmVkaWNhdGUocHJlZGljYXRlLCBlKSB7XG4gICAgdmFyIHNhZmVPYmplY3QgPSB7fTtcbiAgICB2YXIgcmV0ZmlsdGVyID0gdHJ5Q2F0Y2gocHJlZGljYXRlKS5jYWxsKHNhZmVPYmplY3QsIGUpO1xuXG4gICAgaWYgKHJldGZpbHRlciA9PT0gZXJyb3JPYmopIHJldHVybiByZXRmaWx0ZXI7XG5cbiAgICB2YXIgc2FmZUtleXMgPSBrZXlzKHNhZmVPYmplY3QpO1xuICAgIGlmIChzYWZlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IG5ldyBUeXBlRXJyb3IoXCJDYXRjaCBmaWx0ZXIgbXVzdCBpbmhlcml0IGZyb20gRXJyb3Igb3IgYmUgYSBzaW1wbGUgcHJlZGljYXRlIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvbzg0bzY4XFx1MDAwYVwiKTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbiAgICByZXR1cm4gcmV0ZmlsdGVyO1xufVxuXG5DYXRjaEZpbHRlci5wcm90b3R5cGUuZG9GaWx0ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBjYiA9IHRoaXMuX2NhbGxiYWNrO1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTtcbiAgICB2YXIgYm91bmRUbyA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faW5zdGFuY2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5faW5zdGFuY2VzW2ldO1xuICAgICAgICB2YXIgaXRlbUlzRXJyb3JUeXBlID0gaXRlbSA9PT0gRXJyb3IgfHxcbiAgICAgICAgICAgIChpdGVtICE9IG51bGwgJiYgaXRlbS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvcik7XG5cbiAgICAgICAgaWYgKGl0ZW1Jc0Vycm9yVHlwZSAmJiBlIGluc3RhbmNlb2YgaXRlbSkge1xuICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBORVhUX0ZJTFRFUi5lID0gcmV0LmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiICYmICFpdGVtSXNFcnJvclR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRIYW5kbGUgPSBzYWZlUHJlZGljYXRlKGl0ZW0sIGUpO1xuICAgICAgICAgICAgaWYgKHNob3VsZEhhbmRsZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBlID0gZXJyb3JPYmouZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIE5FWFRfRklMVEVSLmUgPSByZXQuZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIE5FWFRfRklMVEVSLmUgPSBlO1xuICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbn07XG5cbnJldHVybiBDYXRjaEZpbHRlcjtcbn07XG5cbn0se1wiLi9lcnJvcnMuanNcIjoxMyxcIi4vZXM1LmpzXCI6MTQsXCIuL3V0aWwuanNcIjozOH1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIENhcHR1cmVkVHJhY2UsIGlzRGVidWdnaW5nKSB7XG52YXIgY29udGV4dFN0YWNrID0gW107XG5mdW5jdGlvbiBDb250ZXh0KCkge1xuICAgIHRoaXMuX3RyYWNlID0gbmV3IENhcHR1cmVkVHJhY2UocGVla0NvbnRleHQoKSk7XG59XG5Db250ZXh0LnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc0RlYnVnZ2luZygpKSByZXR1cm47XG4gICAgaWYgKHRoaXMuX3RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGV4dFN0YWNrLnB1c2godGhpcy5fdHJhY2UpO1xuICAgIH1cbn07XG5cbkNvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNEZWJ1Z2dpbmcoKSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHRTdGFjay5wb3AoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xuICAgIGlmIChpc0RlYnVnZ2luZygpKSByZXR1cm4gbmV3IENvbnRleHQoKTtcbn1cblxuZnVuY3Rpb24gcGVla0NvbnRleHQoKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNvbnRleHRTdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dFN0YWNrW2xhc3RJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IHBlZWtDb250ZXh0O1xuUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0O1xuUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dDtcblxucmV0dXJuIGNyZWF0ZUNvbnRleHQ7XG59O1xuXG59LHt9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgQ2FwdHVyZWRUcmFjZSkge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciBhc3luYyA9IF9kZXJlcV8oXCIuL2FzeW5jLmpzXCIpO1xudmFyIFdhcm5pbmcgPSBfZGVyZXFfKFwiLi9lcnJvcnMuanNcIikuV2FybmluZztcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciBjYW5BdHRhY2hUcmFjZSA9IHV0aWwuY2FuQXR0YWNoVHJhY2U7XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZDtcbnZhciBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbjtcbnZhciBkZWJ1Z2dpbmcgPSBmYWxzZSB8fCAodXRpbC5pc05vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKCEhcHJvY2Vzcy5lbnZbXCJCTFVFQklSRF9ERUJVR1wiXSB8fFxuICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnZbXCJOT0RFX0VOVlwiXSA9PT0gXCJkZXZlbG9wbWVudFwiKSk7XG5cbmlmIChkZWJ1Z2dpbmcpIHtcbiAgICBhc3luYy5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5KCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLl9pZ25vcmVSZWplY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxNjc3NzIxNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCh0aGlzLl9iaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgYXN5bmMuaW52b2tlTGF0ZXIodGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBDYXB0dXJlZFRyYWNlLmZpcmVSZWplY3Rpb25FdmVudChcInJlamVjdGlvbkhhbmRsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkLCB1bmRlZmluZWQsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNSZWplY3Rpb25VbmhhbmRsZWQoKSkge1xuICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fZ2V0Q2FycmllZFN0YWNrVHJhY2UoKSB8fCB0aGlzLl9zZXR0bGVkVmFsdWU7XG4gICAgICAgIHRoaXMuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgQ2FwdHVyZWRUcmFjZS5maXJlUmVqZWN0aW9uRXZlbnQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24sIHJlYXNvbiwgdGhpcyk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDUyNDI4ODtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NTI0Mjg4KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MjQyODgpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjA5NzE1Mjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjIwOTcxNTIpO1xuICAgIGlmICh0aGlzLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkKCkpIHtcbiAgICAgICAgdGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgIHRoaXMuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1JlamVjdGlvblVuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhcnJpZWRTdGFja1RyYWNlID0gZnVuY3Rpb24gKGNhcHR1cmVkVHJhY2UpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTA0ODU3NjtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gY2FwdHVyZWRUcmFjZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0NhcnJ5aW5nU3RhY2tUcmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTA0ODU3NikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2dldENhcnJpZWRTdGFja1RyYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0NhcnJ5aW5nU3RhY2tUcmFjZSgpXG4gICAgICAgID8gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMFxuICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZGVidWdnaW5nKSB7XG4gICAgICAgIHRoaXMuX3RyYWNlID0gbmV3IENhcHR1cmVkVHJhY2UodGhpcy5fcGVla0NvbnRleHQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbiAoZXJyb3IsIGlnbm9yZVNlbGYpIHtcbiAgICBpZiAoZGVidWdnaW5nICYmIGNhbkF0dGFjaFRyYWNlKGVycm9yKSkge1xuICAgICAgICB2YXIgdHJhY2UgPSB0aGlzLl90cmFjZTtcbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmVTZWxmKSB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNlLmF0dGFjaEV4dHJhVHJhY2UoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gQ2FwdHVyZWRUcmFjZS5wYXJzZVN0YWNrQW5kTWVzc2FnZShlcnJvcik7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcInN0YWNrXCIsXG4gICAgICAgICAgICAgICAgcGFyc2VkLm1lc3NhZ2UgKyBcIlxcblwiICsgcGFyc2VkLnN0YWNrLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJfX3N0YWNrQ2xlYW5lZF9fXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3dhcm4gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdmFyIHdhcm5pbmcgPSBuZXcgV2FybmluZyhtZXNzYWdlKTtcbiAgICB2YXIgY3R4ID0gdGhpcy5fcGVla0NvbnRleHQoKTtcbiAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBDYXB0dXJlZFRyYWNlLnBhcnNlU3RhY2tBbmRNZXNzYWdlKHdhcm5pbmcpO1xuICAgICAgICB3YXJuaW5nLnN0YWNrID0gcGFyc2VkLm1lc3NhZ2UgKyBcIlxcblwiICsgcGFyc2VkLnN0YWNrLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIENhcHR1cmVkVHJhY2UuZm9ybWF0QW5kTG9nRXJyb3Iod2FybmluZywgXCJcIik7XG59O1xuXG5Qcm9taXNlLm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24gPVxuICAgICAgICB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIiA/IChkb21haW4gPT09IG51bGwgPyBmbiA6IGRvbWFpbi5iaW5kKGZuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5vblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9XG4gICAgICAgIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gKGRvbWFpbiA9PT0gbnVsbCA/IGZuIDogZG9tYWluLmJpbmQoZm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLmxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkgJiZcbiAgICAgICAgZGVidWdnaW5nID09PSBmYWxzZVxuICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9EVDFxeUdcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBkZWJ1Z2dpbmcgPSBDYXB0dXJlZFRyYWNlLmlzU3VwcG9ydGVkKCk7XG4gICAgaWYgKGRlYnVnZ2luZykge1xuICAgICAgICBhc3luYy5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlYnVnZ2luZyAmJiBDYXB0dXJlZFRyYWNlLmlzU3VwcG9ydGVkKCk7XG59O1xuXG5pZiAoIUNhcHR1cmVkVHJhY2UuaXNTdXBwb3J0ZWQoKSkge1xuICAgIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKXt9O1xuICAgIGRlYnVnZ2luZyA9IGZhbHNlO1xufVxuXG5yZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlYnVnZ2luZztcbn07XG59O1xuXG59LHtcIi4vYXN5bmMuanNcIjoyLFwiLi9lcnJvcnMuanNcIjoxMyxcIi4vdXRpbC5qc1wiOjM4fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgaXNQcmltaXRpdmUgPSB1dGlsLmlzUHJpbWl0aXZlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciByZXR1cm5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbn07XG52YXIgdGhyb3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyB0aGlzO1xufTtcbnZhciByZXR1cm5VbmRlZmluZWQgPSBmdW5jdGlvbigpIHt9O1xudmFyIHRocm93VW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgdW5kZWZpbmVkO1xufTtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAodmFsdWUsIGFjdGlvbikge1xuICAgIGlmIChhY3Rpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSAyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG5Qcm9taXNlLnByb3RvdHlwZVtcInJldHVyblwiXSA9XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnRoZW4ocmV0dXJuVW5kZWZpbmVkKTtcblxuICAgIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB3cmFwcGVyKHZhbHVlLCAyKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKHJldHVybmVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdmFsdWUsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVtcInRocm93XCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5UaHJvdyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICBpZiAocmVhc29uID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnRoZW4odGhyb3dVbmRlZmluZWQpO1xuXG4gICAgaWYgKGlzUHJpbWl0aXZlKHJlYXNvbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB3cmFwcGVyKHJlYXNvbiwgMSksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbih0aHJvd2VyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcmVhc29uLCB1bmRlZmluZWQpO1xufTtcbn07XG5cbn0se1wiLi91dGlsLmpzXCI6Mzh9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBQcm9taXNlUmVkdWNlID0gUHJvbWlzZS5yZWR1Y2U7XG5cblByb21pc2UucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZSh0aGlzLCBmbiwgbnVsbCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgbnVsbCwgSU5URVJOQUwpO1xufTtcbn07XG5cbn0se31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNS5qc1wiKTtcbnZhciBPYmplY3RmcmVlemUgPSBlczUuZnJlZXplO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGluaGVyaXRzID0gdXRpbC5pbmhlcml0cztcbnZhciBub3RFbnVtZXJhYmxlUHJvcCA9IHV0aWwubm90RW51bWVyYWJsZVByb3A7XG5cbmZ1bmN0aW9uIHN1YkVycm9yKG5hbWVQcm9wZXJ0eSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICBmdW5jdGlvbiBTdWJFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdWJFcnJvcikpIHJldHVybiBuZXcgU3ViRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogZGVmYXVsdE1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm5hbWVcIiwgbmFtZVByb3BlcnR5KTtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5oZXJpdHMoU3ViRXJyb3IsIEVycm9yKTtcbiAgICByZXR1cm4gU3ViRXJyb3I7XG59XG5cbnZhciBfVHlwZUVycm9yLCBfUmFuZ2VFcnJvcjtcbnZhciBXYXJuaW5nID0gc3ViRXJyb3IoXCJXYXJuaW5nXCIsIFwid2FybmluZ1wiKTtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IHN1YkVycm9yKFwiQ2FuY2VsbGF0aW9uRXJyb3JcIiwgXCJjYW5jZWxsYXRpb24gZXJyb3JcIik7XG52YXIgVGltZW91dEVycm9yID0gc3ViRXJyb3IoXCJUaW1lb3V0RXJyb3JcIiwgXCJ0aW1lb3V0IGVycm9yXCIpO1xudmFyIEFnZ3JlZ2F0ZUVycm9yID0gc3ViRXJyb3IoXCJBZ2dyZWdhdGVFcnJvclwiLCBcImFnZ3JlZ2F0ZSBlcnJvclwiKTtcbnRyeSB7XG4gICAgX1R5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICBfUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG59IGNhdGNoKGUpIHtcbiAgICBfVHlwZUVycm9yID0gc3ViRXJyb3IoXCJUeXBlRXJyb3JcIiwgXCJ0eXBlIGVycm9yXCIpO1xuICAgIF9SYW5nZUVycm9yID0gc3ViRXJyb3IoXCJSYW5nZUVycm9yXCIsIFwicmFuZ2UgZXJyb3JcIik7XG59XG5cbnZhciBtZXRob2RzID0gKFwiam9pbiBwb3AgcHVzaCBzaGlmdCB1bnNoaWZ0IHNsaWNlIGZpbHRlciBmb3JFYWNoIHNvbWUgXCIgK1xuICAgIFwiZXZlcnkgbWFwIGluZGV4T2YgbGFzdEluZGV4T2YgcmVkdWNlIHJlZHVjZVJpZ2h0IHNvcnQgcmV2ZXJzZVwiKS5zcGxpdChcIiBcIik7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlW21ldGhvZHNbaV1dID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW21ldGhvZHNbaV1dID0gQXJyYXkucHJvdG90eXBlW21ldGhvZHNbaV1dO1xuICAgIH1cbn1cblxuZXM1LmRlZmluZVByb3BlcnR5KEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgIHZhbHVlOiAwLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5BZ2dyZWdhdGVFcnJvci5wcm90b3R5cGVbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcbnZhciBsZXZlbCA9IDA7XG5BZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZW50ID0gQXJyYXkobGV2ZWwgKiA0ICsgMSkuam9pbihcIiBcIik7XG4gICAgdmFyIHJldCA9IFwiXFxuXCIgKyBpbmRlbnQgKyBcIkFnZ3JlZ2F0ZUVycm9yIG9mOlwiICsgXCJcXG5cIjtcbiAgICBsZXZlbCsrO1xuICAgIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3RyID0gdGhpc1tpXSA9PT0gdGhpcyA/IFwiW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXVwiIDogdGhpc1tpXSArIFwiXCI7XG4gICAgICAgIHZhciBsaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgbGluZXNbal0gPSBpbmRlbnQgKyBsaW5lc1tqXTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICByZXQgKz0gc3RyICsgXCJcXG5cIjtcbiAgICB9XG4gICAgbGV2ZWwtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gT3BlcmF0aW9uYWxFcnJvcihtZXNzYWdlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE9wZXJhdGlvbmFsRXJyb3IpKVxuICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSk7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIFwiT3BlcmF0aW9uYWxFcnJvclwiKTtcbiAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IG1lc3NhZ2U7XG4gICAgdGhpc1tcImlzT3BlcmF0aW9uYWxcIl0gPSB0cnVlO1xuXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJzdGFja1wiLCBtZXNzYWdlLnN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cblxufVxuaW5oZXJpdHMoT3BlcmF0aW9uYWxFcnJvciwgRXJyb3IpO1xuXG52YXIgZXJyb3JUeXBlcyA9IEVycm9yW1wiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiXTtcbmlmICghZXJyb3JUeXBlcykge1xuICAgIGVycm9yVHlwZXMgPSBPYmplY3RmcmVlemUoe1xuICAgICAgICBDYW5jZWxsYXRpb25FcnJvcjogQ2FuY2VsbGF0aW9uRXJyb3IsXG4gICAgICAgIFRpbWVvdXRFcnJvcjogVGltZW91dEVycm9yLFxuICAgICAgICBPcGVyYXRpb25hbEVycm9yOiBPcGVyYXRpb25hbEVycm9yLFxuICAgICAgICBSZWplY3Rpb25FcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgQWdncmVnYXRlRXJyb3I6IEFnZ3JlZ2F0ZUVycm9yXG4gICAgfSk7XG4gICAgbm90RW51bWVyYWJsZVByb3AoRXJyb3IsIFwiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiLCBlcnJvclR5cGVzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuXG59LHtcIi4vZXM1LmpzXCI6MTQsXCIuL3V0aWwuanNcIjozOH1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0VTNSA9IChmdW5jdGlvbigpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzID09PSB1bmRlZmluZWQ7XG59KSgpO1xuXG5pZiAoaXNFUzUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZnJlZXplOiBPYmplY3QuZnJlZXplLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgIHJldHVybiAhISghZGVzY3JpcHRvciB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG59IGVsc2Uge1xuICAgIHZhciBoYXMgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgc3RyID0ge30udG9TdHJpbmc7XG4gICAgdmFyIHByb3RvID0ge30uY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgdmFyIE9iamVjdEtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwobywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldERlc2NyaXB0b3IgPSBmdW5jdGlvbihvLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogb1trZXldfTtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG8sIGtleSwgZGVzYykge1xuICAgICAgICBvW2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChvYmopLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBBcnJheUlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNBcnJheTogQXJyYXlJc0FycmF5LFxuICAgICAgICBrZXlzOiBPYmplY3RLZXlzLFxuICAgICAgICBuYW1lczogT2JqZWN0S2V5cyxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3RHZXREZXNjcmlwdG9yLFxuICAgICAgICBmcmVlemU6IE9iamVjdEZyZWV6ZSxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdEdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbn0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VNYXAgPSBQcm9taXNlLm1hcDtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAodGhpcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZmlsdGVyID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcbn07XG5cbn0se31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBORVhUX0ZJTFRFUiwgdHJ5Q29udmVydFRvUHJvbWlzZSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGlzUHJpbWl0aXZlID0gdXRpbC5pc1ByaW1pdGl2ZTtcbnZhciB0aHJvd2VyID0gdXRpbC50aHJvd2VyO1xuXG5mdW5jdGlvbiByZXR1cm5UaGlzKCkge1xuICAgIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gdGhyb3dUaGlzKCkge1xuICAgIHRocm93IHRoaXM7XG59XG5mdW5jdGlvbiByZXR1cm4kKHIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG59XG5mdW5jdGlvbiB0aHJvdyQocikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgcjtcbiAgICB9O1xufVxuZnVuY3Rpb24gcHJvbWlzZWRGaW5hbGx5KHJldCwgcmVhc29uT3JWYWx1ZSwgaXNGdWxmaWxsZWQpIHtcbiAgICB2YXIgdGhlbjtcbiAgICBpZiAoaXNQcmltaXRpdmUocmVhc29uT3JWYWx1ZSkpIHtcbiAgICAgICAgdGhlbiA9IGlzRnVsZmlsbGVkID8gcmV0dXJuJChyZWFzb25PclZhbHVlKSA6IHRocm93JChyZWFzb25PclZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGVuID0gaXNGdWxmaWxsZWQgPyByZXR1cm5UaGlzIDogdGhyb3dUaGlzO1xuICAgIH1cbiAgICByZXR1cm4gcmV0Ll90aGVuKHRoZW4sIHRocm93ZXIsIHVuZGVmaW5lZCwgcmVhc29uT3JWYWx1ZSwgdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gZmluYWxseUhhbmRsZXIocmVhc29uT3JWYWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuXG4gICAgdmFyIHJldCA9IHByb21pc2UuX2lzQm91bmQoKVxuICAgICAgICAgICAgICAgICAgICA/IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCkpXG4gICAgICAgICAgICAgICAgICAgIDogaGFuZGxlcigpO1xuXG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgcHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VkRmluYWxseShtYXliZVByb21pc2UsIHJlYXNvbk9yVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmlzRnVsZmlsbGVkKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIE5FWFRfRklMVEVSLmUgPSByZWFzb25PclZhbHVlO1xuICAgICAgICByZXR1cm4gTkVYVF9GSUxURVI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlYXNvbk9yVmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0YXBIYW5kbGVyKHZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG5cbiAgICB2YXIgcmV0ID0gcHJvbWlzZS5faXNCb3VuZCgpXG4gICAgICAgICAgICAgICAgICAgID8gaGFuZGxlci5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaGFuZGxlcih2YWx1ZSk7XG5cbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCBwcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZWRGaW5hbGx5KG1heWJlUHJvbWlzZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuX3Bhc3NUaHJvdWdoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBpc0ZpbmFsbHkpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRoaXMudGhlbigpO1xuXG4gICAgdmFyIHByb21pc2VBbmRIYW5kbGVyID0ge1xuICAgICAgICBwcm9taXNlOiB0aGlzLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgaXNGaW5hbGx5ID8gZmluYWxseUhhbmRsZXIgOiB0YXBIYW5kbGVyLFxuICAgICAgICAgICAgaXNGaW5hbGx5ID8gZmluYWxseUhhbmRsZXIgOiB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByb21pc2VBbmRIYW5kbGVyLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubGFzdGx5ID1cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoSGFuZGxlcihoYW5kbGVyLCB0cnVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoSGFuZGxlcihoYW5kbGVyLCBmYWxzZSk7XG59O1xufTtcblxufSx7XCIuL3V0aWwuanNcIjozOH1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlKSB7XG52YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzLmpzXCIpO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciB5aWVsZEhhbmRsZXJzID0gW107XG5cbmZ1bmN0aW9uIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKHZhbHVlLCB5aWVsZEhhbmRsZXJzLCB0cmFjZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeWllbGRIYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHlpZWxkSGFuZGxlcnNbaV0pKHZhbHVlKTtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KGVycm9yT2JqLmUpO1xuICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzdWx0LCB0cmFjZVBhcmVudCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCByZWNlaXZlciwgeWllbGRIYW5kbGVyLCBzdGFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jdGlvbjtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl95aWVsZEhhbmRsZXJzID0gdHlwZW9mIHlpZWxkSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gW3lpZWxkSGFuZGxlcl0uY29uY2F0KHlpZWxkSGFuZGxlcnMpXG4gICAgICAgIDogeWllbGRIYW5kbGVycztcbn1cblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uLmNhbGwodGhpcy5fcmVjZWl2ZXIpO1xuICAgIHRoaXMuX3JlY2VpdmVyID1cbiAgICAgICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbmV4dCh1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fY29udGludWUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgIGlmIChyZXN1bHQuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgcHJvbWlzZUZyb21ZaWVsZEhhbmRsZXIobWF5YmVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkSGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3coXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkEgdmFsdWUgJXMgd2FzIHlpZWxkZWQgdGhhdCBjb3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC80WTRwRGtcXHUwMDBhXFx1MDAwYVwiLnJlcGxhY2UoXCIlc1wiLCB2YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJGcm9tIGNvcm91dGluZTpcXHUwMDBhXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSwgLTcpLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgIHRoaXMuX25leHQsXG4gICAgICAgICAgICB0aGlzLl90aHJvdyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl90aHJvdyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pXG4gICAgICAgIC5jYWxsKHRoaXMuX2dlbmVyYXRvciwgcmVhc29uKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3IubmV4dCkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHZhbHVlKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2UuY29yb3V0aW5lID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBnZW5lcmF0b3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC82VnFobTBcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgeWllbGRIYW5kbGVyID0gT2JqZWN0KG9wdGlvbnMpLnlpZWxkSGFuZGxlcjtcbiAgICB2YXIgUHJvbWlzZVNwYXduJCA9IFByb21pc2VTcGF3bjtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3biQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHlpZWxkSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2spO1xuICAgICAgICBzcGF3bi5fZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICBzcGF3bi5fbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gc3Bhd24ucHJvbWlzZSgpO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmNvcm91dGluZS5hZGRZaWVsZEhhbmRsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgeWllbGRIYW5kbGVycy5wdXNoKGZuKTtcbn07XG5cblByb21pc2Uuc3Bhd24gPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzZWcWhtMFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciBzcGF3biA9IG5ldyBQcm9taXNlU3Bhd24oZ2VuZXJhdG9yRnVuY3Rpb24sIHRoaXMpO1xuICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgc3Bhd24uX3J1bihQcm9taXNlLnNwYXduKTtcbiAgICByZXR1cm4gcmV0O1xufTtcbn07XG5cbn0se1wiLi9lcnJvcnMuanNcIjoxMyxcIi4vdXRpbC5qc1wiOjM4fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgcmVqZWN0O1xuXG5pZiAoIXRydWUpIHtcbmlmIChjYW5FdmFsdWF0ZSkge1xuICAgIHZhciB0aGVuQ2FsbGJhY2sgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJ2YWx1ZVwiLCBcImhvbGRlclwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGhvbGRlci5wSW5kZXggPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGhvbGRlci5jaGVja0Z1bGZpbGxtZW50KHRoaXMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFwiLnJlcGxhY2UoL0luZGV4L2csIGkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNhbGxlciA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY291bnQ7ICsraSkgdmFsdWVzLnB1c2goXCJob2xkZXIucFwiICsgaSk7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBob2xkZXIuZm47ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWVzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC92YWx1ZXMvZywgdmFsdWVzLmpvaW4oXCIsIFwiKSkpO1xuICAgIH07XG4gICAgdmFyIHRoZW5DYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgY2FsbGVycyA9IFt1bmRlZmluZWRdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDU7ICsraSkge1xuICAgICAgICB0aGVuQ2FsbGJhY2tzLnB1c2godGhlbkNhbGxiYWNrKGkpKTtcbiAgICAgICAgY2FsbGVycy5wdXNoKGNhbGxlcihpKSk7XG4gICAgfVxuXG4gICAgdmFyIEhvbGRlciA9IGZ1bmN0aW9uKHRvdGFsLCBmbikge1xuICAgICAgICB0aGlzLnAxID0gdGhpcy5wMiA9IHRoaXMucDMgPSB0aGlzLnA0ID0gdGhpcy5wNSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLm5vdyA9IDA7XG4gICAgfTtcblxuICAgIEhvbGRlci5wcm90b3R5cGUuY2FsbGVycyA9IGNhbGxlcnM7XG4gICAgSG9sZGVyLnByb3RvdHlwZS5jaGVja0Z1bGZpbGxtZW50ID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3c7XG4gICAgICAgIG5vdysrO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICBpZiAobm93ID49IHRvdGFsKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuY2FsbGVyc1t0b3RhbF07XG4gICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGhhbmRsZXIpKHRoaXMpO1xuICAgICAgICAgICAgcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXQuZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2socmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm93ID0gbm93O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgIH07XG59XG59XG5cblByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBmbjtcbiAgICBpZiAobGFzdCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1tsYXN0XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgNiAmJiBjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgIHZhciBob2xkZXIgPSBuZXcgSG9sZGVyKGxhc3QsIGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3Q7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShhcmd1bWVudHNbaV0sIHJldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZS5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3RoZW4oY2FsbGJhY2tzW2ldLCByZWplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0LCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXliZVByb21pc2UuX2lzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl92YWx1ZSgpLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheSgkX2xlbik7IGZvcih2YXIgJF9pID0gMDsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2ldID0gYXJndW1lbnRzWyRfaV07fVxuICAgIGlmIChmbikgYXJncy5wb3AoKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VBcnJheShhcmdzKS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyByZXQuc3ByZWFkKGZuKSA6IHJldDtcbn07XG5cbn07XG5cbn0se1wiLi91dGlsLmpzXCI6Mzh9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIGFzeW5jID0gX2RlcmVxXyhcIi4vYXN5bmMuanNcIik7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBQRU5ESU5HID0ge307XG52YXIgRU1QVFlfQVJSQVkgPSBbXTtcblxuZnVuY3Rpb24gTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gZG9tYWluID09PSBudWxsID8gZm4gOiBkb21haW4uYmluZChmbik7XG4gICAgdGhpcy5fcHJlc2VydmVkVmFsdWVzID0gX2ZpbHRlciA9PT0gSU5URVJOQUxcbiAgICAgICAgPyBuZXcgQXJyYXkodGhpcy5sZW5ndGgoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgdGhpcy5faW5GbGlnaHQgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gbGltaXQgPj0gMSA/IFtdIDogRU1QVFlfQVJSQVk7XG4gICAgYXN5bmMuaW52b2tlKGluaXQsIHRoaXMsIHVuZGVmaW5lZCk7XG59XG51dGlsLmluaGVyaXRzKE1hcHBpbmdQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5mdW5jdGlvbiBpbml0KCkge3RoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTIpO31cblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB2YXIgcHJlc2VydmVkVmFsdWVzID0gdGhpcy5fcHJlc2VydmVkVmFsdWVzO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuICAgIGlmICh2YWx1ZXNbaW5kZXhdID09PSBQRU5ESU5HKSB7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2luRmxpZ2h0LS07XG4gICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGltaXQgPj0gMSAmJiB0aGlzLl9pbkZsaWdodCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaChpbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCkgcHJlc2VydmVkVmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9wcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChjYWxsYmFjaykuY2FsbChyZWNlaXZlciwgdmFsdWUsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSByZXR1cm4gdGhpcy5fcmVqZWN0KHJldC5lKTtcblxuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXQsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UuX2lzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ID49IDEpIHRoaXMuX2luRmxpZ2h0Kys7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IFBFTkRJTkc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fcHJveHlQcm9taXNlQXJyYXkodGhpcywgaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXliZVByb21pc2UuX2lzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBtYXliZVByb21pc2UuX3ZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcih2YWx1ZXMsIHByZXNlcnZlZFZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgIH1cbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faW5GbGlnaHQgPCBsaW1pdCkge1xuICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgIHZhciBpbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZmlsdGVyID0gZnVuY3Rpb24gKGJvb2xlYW5zLCB2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGJvb2xlYW5zW2ldKSByZXRbaisrXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0Lmxlbmd0aCA9IGo7XG4gICAgdGhpcy5fcmVzb2x2ZShyZXQpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUucHJlc2VydmVkVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG59O1xuXG5mdW5jdGlvbiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgdmFyIGxpbWl0ID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbFxuICAgICAgICA/IG9wdGlvbnMuY29uY3VycmVuY3lcbiAgICAgICAgOiAwO1xuICAgIGxpbWl0ID0gdHlwZW9mIGxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIGlzRmluaXRlKGxpbWl0KSAmJiBsaW1pdCA+PSAxID8gbGltaXQgOiAwO1xuICAgIHJldHVybiBuZXcgTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZm4gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvOTE2bEpKXFx1MDAwYVwiKTtcblxuICAgIHJldHVybiBtYXAodGhpcywgZm4sIG9wdGlvbnMsIG51bGwpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UubWFwID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGFwaVJlamVjdGlvbihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgcmV0dXJuIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpLnByb21pc2UoKTtcbn07XG5cblxufTtcblxufSx7XCIuL2FzeW5jLmpzXCI6MixcIi4vdXRpbC5qc1wiOjM4fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuXG5Qcm9taXNlLm1ldGhvZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgUHJvbWlzZS5UeXBlRXJyb3IoXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHJldC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJ5Q2F0Y2goZm4pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldC5fcG9wQ29udGV4dCgpO1xuICAgICAgICByZXQuX3Jlc29sdmVGcm9tU3luY1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5hdHRlbXB0ID0gUHJvbWlzZVtcInRyeVwiXSA9IGZ1bmN0aW9uIChmbiwgYXJncywgY3R4KSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHZhbHVlID0gdXRpbC5pc0FycmF5KGFyZ3MpXG4gICAgICAgID8gdHJ5Q2F0Y2goZm4pLmFwcGx5KGN0eCwgYXJncylcbiAgICAgICAgOiB0cnlDYXRjaChmbikuY2FsbChjdHgsIGFyZ3MpO1xuICAgIHJldC5fcG9wQ29udGV4dCgpO1xuICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21TeW5jVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHV0aWwuZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2sodmFsdWUuZSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxufTtcbn07XG5cbn0se1wiLi91dGlsLmpzXCI6Mzh9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGFzeW5jID0gX2RlcmVxXyhcIi4vYXN5bmMuanNcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gc3ByZWFkQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghdXRpbC5pc0FycmF5KHZhbCkpIHJldHVybiBzdWNjZXNzQWRhcHRlci5jYWxsKHByb21pc2UsIHZhbCwgbm9kZWJhY2spO1xuICAgIHZhciByZXQgPVxuICAgICAgICB0cnlDYXRjaChub2RlYmFjaykuYXBwbHkocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCBbbnVsbF0uY29uY2F0KHZhbCkpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3VjY2Vzc0FkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgdmFyIHJldCA9IHZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwpXG4gICAgICAgIDogdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwsIHZhbCk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3JBZGFwdGVyKHJlYXNvbiwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB2YXIgbmV3UmVhc29uID0gdGFyZ2V0Ll9nZXRDYXJyaWVkU3RhY2tUcmFjZSgpO1xuICAgICAgICBuZXdSZWFzb24uY2F1c2UgPSByZWFzb247XG4gICAgICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgcmVhc29uKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLmFzQ2FsbGJhY2sgPVxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygbm9kZWJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhZGFwdGVyID0gc3VjY2Vzc0FkYXB0ZXI7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0KG9wdGlvbnMpLnNwcmVhZCkge1xuICAgICAgICAgICAgYWRhcHRlciA9IHNwcmVhZEFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGhlbihcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICBlcnJvckFkYXB0ZXIsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbm9kZWJhY2tcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xufTtcblxufSx7XCIuL2FzeW5jLmpzXCI6MixcIi4vdXRpbC5qc1wiOjM4fV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGFzeW5jID0gX2RlcmVxXyhcIi4vYXN5bmMuanNcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3NlZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4odW5kZWZpbmVkLCB1bmRlZmluZWQsIGhhbmRsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzRm9sbG93aW5nT3JGdWxmaWxsZWRPclJlamVjdGVkKCkpIHJldHVybjtcbiAgICB0aGlzLl90YXJnZXQoKS5fcHJvZ3Jlc3NVbmNoZWNrZWQocHJvZ3Jlc3NWYWx1ZSk7XG5cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9ncmVzc0hhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMFxuICAgICAgICA/IHRoaXMuX3Byb2dyZXNzSGFuZGxlcjBcbiAgICAgICAgOiB0aGlzWyhpbmRleCA8PCAyKSArIGluZGV4IC0gNSArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2RvUHJvZ3Jlc3NXaXRoID0gZnVuY3Rpb24gKHByb2dyZXNzaW9uKSB7XG4gICAgdmFyIHByb2dyZXNzVmFsdWUgPSBwcm9ncmVzc2lvbi52YWx1ZTtcbiAgICB2YXIgaGFuZGxlciA9IHByb2dyZXNzaW9uLmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBwcm9ncmVzc2lvbi5wcm9taXNlO1xuICAgIHZhciByZWNlaXZlciA9IHByb2dyZXNzaW9uLnJlY2VpdmVyO1xuXG4gICAgdmFyIHJldCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHByb2dyZXNzVmFsdWUpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGlmIChyZXQuZSAhPSBudWxsICYmXG4gICAgICAgICAgICByZXQuZS5uYW1lICE9PSBcIlN0b3BQcm9ncmVzc1Byb3BhZ2F0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciB0cmFjZSA9IHV0aWwuY2FuQXR0YWNoVHJhY2UocmV0LmUpXG4gICAgICAgICAgICAgICAgPyByZXQuZSA6IG5ldyBFcnJvcih1dGlsLnRvU3RyaW5nKHJldC5lKSk7XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX3Byb2dyZXNzKHJldC5lKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQuX3RoZW4ocHJvbWlzZS5fcHJvZ3Jlc3MsIG51bGwsIG51bGwsIHByb21pc2UsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZS5fcHJvZ3Jlc3MocmV0KTtcbiAgICB9XG59O1xuXG5cblByb21pc2UucHJvdG90eXBlLl9wcm9ncmVzc1VuY2hlY2tlZCA9IGZ1bmN0aW9uIChwcm9ncmVzc1ZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aCgpO1xuICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuX3Byb2dyZXNzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9wcm9ncmVzc0hhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCBwcm9ncmVzc1ZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQcm9taXNlQXJyYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZVByb2dyZXNzZWQocHJvZ3Jlc3NWYWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhc3luYy5pbnZva2UodGhpcy5fZG9Qcm9ncmVzc1dpdGgsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZXI6IHRoaXMuX3JlY2VpdmVyQXQoaSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2dyZXNzVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuaW52b2tlKHByb2dyZXNzLCBwcm9taXNlLCBwcm9ncmVzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG59O1xuXG59LHtcIi4vYXN5bmMuanNcIjoyLFwiLi91dGlsLmpzXCI6Mzh9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG52YXIgbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJjaXJjdWxhciBwcm9taXNlIHJlc29sdXRpb24gY2hhaW5cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9MaEZwbzBcXHUwMDBhXCIpO1xufTtcbnZhciByZWZsZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xuXG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG5cbnZhciBnZXREb21haW47XG5pZiAodXRpbC5pc05vZGUpIHtcbiAgICBnZXREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJldCA9IHByb2Nlc3MuZG9tYWluO1xuICAgICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHJldCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG51dGlsLm5vdEVudW1lcmFibGVQcm9wKFByb21pc2UsIFwiX2dldERvbWFpblwiLCBnZXREb21haW4pO1xuXG52YXIgYXN5bmMgPSBfZGVyZXFfKFwiLi9hc3luYy5qc1wiKTtcbnZhciBlcnJvcnMgPSBfZGVyZXFfKFwiLi9lcnJvcnMuanNcIik7XG52YXIgVHlwZUVycm9yID0gUHJvbWlzZS5UeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xuUHJvbWlzZS5SYW5nZUVycm9yID0gZXJyb3JzLlJhbmdlRXJyb3I7XG5Qcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yID0gZXJyb3JzLkNhbmNlbGxhdGlvbkVycm9yO1xuUHJvbWlzZS5UaW1lb3V0RXJyb3IgPSBlcnJvcnMuVGltZW91dEVycm9yO1xuUHJvbWlzZS5PcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG5Qcm9taXNlLlJlamVjdGlvbkVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG5Qcm9taXNlLkFnZ3JlZ2F0ZUVycm9yID0gZXJyb3JzLkFnZ3JlZ2F0ZUVycm9yO1xudmFyIElOVEVSTkFMID0gZnVuY3Rpb24oKXt9O1xudmFyIEFQUExZID0ge307XG52YXIgTkVYVF9GSUxURVIgPSB7ZTogbnVsbH07XG52YXIgdHJ5Q29udmVydFRvUHJvbWlzZSA9IF9kZXJlcV8oXCIuL3RoZW5hYmxlcy5qc1wiKShQcm9taXNlLCBJTlRFUk5BTCk7XG52YXIgUHJvbWlzZUFycmF5ID1cbiAgICBfZGVyZXFfKFwiLi9wcm9taXNlX2FycmF5LmpzXCIpKFByb21pc2UsIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbnZhciBDYXB0dXJlZFRyYWNlID0gX2RlcmVxXyhcIi4vY2FwdHVyZWRfdHJhY2UuanNcIikoKTtcbnZhciBpc0RlYnVnZ2luZyA9IF9kZXJlcV8oXCIuL2RlYnVnZ2FiaWxpdHkuanNcIikoUHJvbWlzZSwgQ2FwdHVyZWRUcmFjZSk7XG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbnZhciBjcmVhdGVDb250ZXh0ID1cbiAgICBfZGVyZXFfKFwiLi9jb250ZXh0LmpzXCIpKFByb21pc2UsIENhcHR1cmVkVHJhY2UsIGlzRGVidWdnaW5nKTtcbnZhciBDYXRjaEZpbHRlciA9IF9kZXJlcV8oXCIuL2NhdGNoX2ZpbHRlci5qc1wiKShORVhUX0ZJTFRFUik7XG52YXIgUHJvbWlzZVJlc29sdmVyID0gX2RlcmVxXyhcIi4vcHJvbWlzZV9yZXNvbHZlci5qc1wiKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSBQcm9taXNlUmVzb2x2ZXIuX25vZGViYWNrRm9yUHJvbWlzZTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhlIHByb21pc2UgY29uc3RydWN0b3IgcmVxdWlyZXMgYSByZXNvbHZlciBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL0VDMjJZblxcdTAwMGFcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBQcm9taXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgaW52b2tlZCBkaXJlY3RseVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL0tzSWxnZVxcdTAwMGFcIik7XG4gICAgfVxuICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb2dyZXNzSGFuZGxlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NldHRsZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAocmVzb2x2ZXIgIT09IElOVEVSTkFMKSB0aGlzLl9yZXNvbHZlRnJvbVJlc29sdmVyKHJlc29sdmVyKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBQcm9taXNlXVwiO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F1Z2h0ID0gUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgIHZhciBjYXRjaEluc3RhbmNlcyA9IG5ldyBBcnJheShsZW4gLSAxKSxcbiAgICAgICAgICAgIGogPSAwLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2F0Y2hJbnN0YW5jZXNbaisrXSA9IGl0ZW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFR5cGVFcnJvcihcIkNhdGNoIGZpbHRlciBtdXN0IGluaGVyaXQgZnJvbSBFcnJvciBvciBiZSBhIHNpbXBsZSBwcmVkaWNhdGUgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9vODRvNjhcXHUwMDBhXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdmFyIGNhdGNoRmlsdGVyID0gbmV3IENhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBmbiwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90aGVuKHVuZGVmaW5lZCwgY2F0Y2hGaWx0ZXIuZG9GaWx0ZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhdGNoRmlsdGVyLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbih1bmRlZmluZWQsIGZuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlZmxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4ocmVmbGVjdCwgcmVmbGVjdCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChkaWRGdWxmaWxsLCBkaWRSZWplY3QsIGRpZFByb2dyZXNzKSB7XG4gICAgaWYgKGlzRGVidWdnaW5nKCkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgdHlwZW9mIGRpZEZ1bGZpbGwgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZGlkUmVqZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiLnRoZW4oKSBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGJ1dCB3YXMgcGFzc2VkOiBcIiArXG4gICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhkaWRGdWxmaWxsKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIsIFwiICsgdXRpbC5jbGFzc1N0cmluZyhkaWRSZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dhcm4obXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBkaWRQcm9ncmVzcyxcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChkaWRGdWxmaWxsLCBkaWRSZWplY3QsIGRpZFByb2dyZXNzKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgZGlkUHJvZ3Jlc3MsXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICBwcm9taXNlLl9zZXRJc0ZpbmFsKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIEFQUExZLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNSZXNvbHZlZCgpICYmXG4gICAgICAgIHRoaXMuX2NhbmNlbGxhYmxlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldCA9IHtcbiAgICAgICAgaXNGdWxmaWxsZWQ6IGZhbHNlLFxuICAgICAgICBpc1JlamVjdGVkOiBmYWxzZSxcbiAgICAgICAgZnVsZmlsbG1lbnRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICByZWplY3Rpb25SZWFzb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKHRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICByZXQuZnVsZmlsbG1lbnRWYWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgcmV0LmlzRnVsZmlsbGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIHJldC5yZWplY3Rpb25SZWFzb24gPSB0aGlzLnJlYXNvbigpO1xuICAgICAgICByZXQuaXNSZWplY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5jYXVnaHQodXRpbC5vcmlnaW5hdGVzRnJvbVJlamVjdGlvbiwgZm4pO1xufTtcblxuUHJvbWlzZS5pcyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgUHJvbWlzZTtcbn07XG5cblByb21pc2UuZnJvbU5vZGUgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKGZuKShub2RlYmFja0ZvclByb21pc2UocmV0KSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLmRlZmVyID0gUHJvbWlzZS5wZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVJlc29sdmVyKHByb21pc2UpO1xufTtcblxuUHJvbWlzZS5jYXN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXQgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaik7XG4gICAgaWYgKCEocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgdmFyIHZhbCA9IHJldDtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2Z1bGZpbGxVbmNoZWNrZWQodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucmVzb2x2ZSA9IFByb21pc2UuZnVsZmlsbGVkID0gUHJvbWlzZS5jYXN0O1xuXG5Qcm9taXNlLnJlamVjdCA9IFByb21pc2UucmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZWFzb24sIHRydWUpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnNldFNjaGVkdWxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZm4gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvOTE2bEpKXFx1MDAwYVwiKTtcbiAgICB2YXIgcHJldiA9IGFzeW5jLl9zY2hlZHVsZTtcbiAgICBhc3luYy5fc2NoZWR1bGUgPSBmbjtcbiAgICByZXR1cm4gcHJldjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl90aGVuID0gZnVuY3Rpb24gKFxuICAgIGRpZEZ1bGZpbGwsXG4gICAgZGlkUmVqZWN0LFxuICAgIGRpZFByb2dyZXNzLFxuICAgIHJlY2VpdmVyLFxuICAgIGludGVybmFsRGF0YVxuKSB7XG4gICAgdmFyIGhhdmVJbnRlcm5hbERhdGEgPSBpbnRlcm5hbERhdGEgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgcmV0ID0gaGF2ZUludGVybmFsRGF0YSA/IGludGVybmFsRGF0YSA6IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcblxuICAgIGlmICghaGF2ZUludGVybmFsRGF0YSkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20odGhpcywgNCB8IDEpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIGlmICh0YXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQpIHJlY2VpdmVyID0gdGhpcy5fYm91bmRUbztcbiAgICAgICAgaWYgKCFoYXZlSW50ZXJuYWxEYXRhKSByZXQuX3NldElzTWlncmF0ZWQoKTtcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2tJbmRleCA9IHRhcmdldC5fYWRkQ2FsbGJhY2tzKGRpZEZ1bGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRSZWplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RG9tYWluKCkpO1xuXG4gICAgaWYgKHRhcmdldC5faXNSZXNvbHZlZCgpICYmICF0YXJnZXQuX2lzU2V0dGxlUHJvbWlzZXNRdWV1ZWQoKSkge1xuICAgICAgICBhc3luYy5pbnZva2UoXG4gICAgICAgICAgICB0YXJnZXQuX3NldHRsZVByb21pc2VBdFBvc3RSZXNvbHV0aW9uLCB0YXJnZXQsIGNhbGxiYWNrSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUF0UG9zdFJlc29sdXRpb24gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAodGhpcy5faXNSZWplY3Rpb25VbmhhbmRsZWQoKSkgdGhpcy5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHRoaXMuX3NldHRsZVByb21pc2VBdChpbmRleCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRGaWVsZCAmIDEzMTA3MTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0ZvbGxvd2luZ09yRnVsZmlsbGVkT3JSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgOTM5NTI0MDk2KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGb2xsb3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUzNjg3MDkxMikgPT09IDUzNjg3MDkxMjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSAodGhpcy5fYml0RmllbGQgJiAtMTMxMDcyKSB8XG4gICAgICAgIChsZW4gJiAxMzEwNzEpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjY4NDM1NDU2O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzQyMTc3Mjg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Rm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA1MzY4NzA5MTI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0SXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMzM1NTQ0MzI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMzM1NTQ0MzIpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjcxMDg4NjQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjcxMDg4NjQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH42NzEwODg2NCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0SXNNaWdyYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNDE5NDMwNDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldElzTWlncmF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NDE5NDMwNCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNNaWdyYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlY2VpdmVyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gaW5kZXggPT09IDBcbiAgICAgICAgPyB0aGlzLl9yZWNlaXZlcjBcbiAgICAgICAgOiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA1IC0gNSArIDRdO1xuICAgIGlmIChyZXQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9pc0JvdW5kKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IDBcbiAgICAgICAgPyB0aGlzLl9wcm9taXNlMFxuICAgICAgICA6IHRoaXNbaW5kZXggKiA1IC0gNSArIDNdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSAwXG4gICAgICAgID8gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMFxuICAgICAgICA6IHRoaXNbaW5kZXggKiA1IC0gNSArIDBdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdGlvbkhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMFxuICAgICAgICA/IHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwXG4gICAgICAgIDogdGhpc1tpbmRleCAqIDUgLSA1ICsgMV07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzLl9ib3VuZFRvO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKHJldC5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldC52YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrcyA9IGZ1bmN0aW9uIChmb2xsb3dlciwgaW5kZXgpIHtcbiAgICB2YXIgZnVsZmlsbCA9IGZvbGxvd2VyLl9mdWxmaWxsbWVudEhhbmRsZXJBdChpbmRleCk7XG4gICAgdmFyIHJlamVjdCA9IGZvbGxvd2VyLl9yZWplY3Rpb25IYW5kbGVyQXQoaW5kZXgpO1xuICAgIHZhciBwcm9ncmVzcyA9IGZvbGxvd2VyLl9wcm9ncmVzc0hhbmRsZXJBdChpbmRleCk7XG4gICAgdmFyIHByb21pc2UgPSBmb2xsb3dlci5fcHJvbWlzZUF0KGluZGV4KTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdChpbmRleCk7XG4gICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSBwcm9taXNlLl9zZXRJc01pZ3JhdGVkKCk7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGZ1bGZpbGwsIHJlamVjdCwgcHJvZ3Jlc3MsIHByb21pc2UsIHJlY2VpdmVyLCBudWxsKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9hZGRDYWxsYmFja3MgPSBmdW5jdGlvbiAoXG4gICAgZnVsZmlsbCxcbiAgICByZWplY3QsXG4gICAgcHJvZ3Jlc3MsXG4gICAgcHJvbWlzZSxcbiAgICByZWNlaXZlcixcbiAgICBkb21haW5cbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2xlbmd0aCgpO1xuXG4gICAgaWYgKGluZGV4ID49IDEzMTA3MSAtIDUpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UwID0gcHJvbWlzZTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSB1bmRlZmluZWQpIHRoaXMuX3JlY2VpdmVyMCA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bGZpbGwgPT09IFwiZnVuY3Rpb25cIiAmJiAhdGhpcy5faXNDYXJyeWluZ1N0YWNrVHJhY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IGRvbWFpbi5iaW5kKGZ1bGZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyByZWplY3QgOiBkb21haW4uYmluZChyZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVyMCA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gcHJvZ3Jlc3MgOiBkb21haW4uYmluZChwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNSAtIDU7XG4gICAgICAgIHRoaXNbYmFzZSArIDNdID0gcHJvbWlzZTtcbiAgICAgICAgdGhpc1tiYXNlICsgNF0gPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogZG9tYWluLmJpbmQoZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpc1tiYXNlICsgMV0gPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IGRvbWFpbi5iaW5kKHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9ncmVzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzW2Jhc2UgKyAyXSA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gcHJvZ3Jlc3MgOiBkb21haW4uYmluZChwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0TGVuZ3RoKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFByb3h5SGFuZGxlcnMgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHByb21pc2VTbG90VmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSAxMzEwNzEgLSA1KSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZTAgPSBwcm9taXNlU2xvdFZhbHVlO1xuICAgICAgICB0aGlzLl9yZWNlaXZlcjAgPSByZWNlaXZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNSAtIDU7XG4gICAgICAgIHRoaXNbYmFzZSArIDNdID0gcHJvbWlzZVNsb3RWYWx1ZTtcbiAgICAgICAgdGhpc1tiYXNlICsgNF0gPSByZWNlaXZlcjtcbiAgICB9XG4gICAgdGhpcy5fc2V0TGVuZ3RoKGluZGV4ICsgMSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcHJveHlQcm9taXNlQXJyYXkgPSBmdW5jdGlvbiAocHJvbWlzZUFycmF5LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFByb3h5SGFuZGxlcnMocHJvbWlzZUFycmF5LCBpbmRleCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUNhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUsIHNob3VsZEJpbmQpIHtcbiAgICBpZiAodGhpcy5faXNGb2xsb3dpbmdPckZ1bGZpbGxlZE9yUmVqZWN0ZWQoKSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcylcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdENhbGxiYWNrKG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCksIGZhbHNlLCB0cnVlKTtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcyk7XG4gICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHJldHVybiB0aGlzLl9mdWxmaWxsKHZhbHVlKTtcblxuICAgIHZhciBwcm9wYWdhdGlvbkZsYWdzID0gMSB8IChzaG91bGRCaW5kID8gNCA6IDApO1xuICAgIHRoaXMuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCBwcm9wYWdhdGlvbkZsYWdzKTtcbiAgICB2YXIgcHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgaWYgKHByb21pc2UuX2lzUGVuZGluZygpKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9sZW5ndGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fbWlncmF0ZUNhbGxiYWNrcyh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGb2xsb3dpbmcoKTtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgICAgICB0aGlzLl9zZXRGb2xsb3dlZShwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKHByb21pc2UuX2lzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgdGhpcy5fZnVsZmlsbFVuY2hlY2tlZChwcm9taXNlLl92YWx1ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZWplY3RVbmNoZWNrZWQocHJvbWlzZS5fcmVhc29uKCksXG4gICAgICAgICAgICBwcm9taXNlLl9nZXRDYXJyaWVkU3RhY2tUcmFjZSgpKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0Q2FsbGJhY2sgPVxuZnVuY3Rpb24ocmVhc29uLCBzeW5jaHJvbm91cywgc2hvdWxkTm90TWFya09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbikge1xuICAgIGlmICghc2hvdWxkTm90TWFya09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbikge1xuICAgICAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihyZWFzb24pO1xuICAgIH1cbiAgICB2YXIgdHJhY2UgPSB1dGlsLmVuc3VyZUVycm9yT2JqZWN0KHJlYXNvbik7XG4gICAgdmFyIGhhc1N0YWNrID0gdHJhY2UgPT09IHJlYXNvbjtcbiAgICB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlLCBzeW5jaHJvbm91cyA/IGhhc1N0YWNrIDogZmFsc2UpO1xuICAgIHRoaXMuX3JlamVjdChyZWFzb24sIGhhc1N0YWNrID8gdW5kZWZpbmVkIDogdHJhY2UpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Jlc29sdmVGcm9tUmVzb2x2ZXIgPSBmdW5jdGlvbiAocmVzb2x2ZXIpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHIgPSB0cnlDYXRjaChyZXNvbHZlcikoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHByb21pc2UgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIHN5bmNocm9ub3VzKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAociAhPT0gdW5kZWZpbmVkICYmIHIgPT09IGVycm9yT2JqICYmIHByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2soci5lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlciA9IGZ1bmN0aW9uIChcbiAgICBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2Vcbikge1xuICAgIGlmIChwcm9taXNlLl9pc1JlamVjdGVkKCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkgJiYgIXRoaXMuX2lzUmVqZWN0ZWQoKSkge1xuICAgICAgICB4ID0gdHJ5Q2F0Y2goaGFuZGxlcikuYXBwbHkodGhpcy5fYm91bmRWYWx1ZSgpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuXG4gICAgaWYgKHggPT09IGVycm9yT2JqIHx8IHggPT09IHByb21pc2UgfHwgeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgdmFyIGVyciA9IHggPT09IHByb21pc2UgPyBtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpIDogeC5lO1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhlcnIsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhblZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fY2FuY2VsbGFibGUoKSkge1xuICAgICAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBmdW5jdGlvbiAocGFyZW50LCBmbGFncykge1xuICAgIGlmICgoZmxhZ3MgJiAxKSA+IDAgJiYgcGFyZW50Ll9jYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIHRoaXMuX3NldENhbmNlbGxhYmxlKCk7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgaWYgKChmbGFncyAmIDQpID4gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNGb2xsb3dpbmdPckZ1bGZpbGxlZE9yUmVqZWN0ZWQoKSkgcmV0dXJuO1xuICAgIHRoaXMuX2Z1bGZpbGxVbmNoZWNrZWQodmFsdWUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24sIGNhcnJpZWRTdGFja1RyYWNlKSB7XG4gICAgaWYgKHRoaXMuX2lzRm9sbG93aW5nT3JGdWxmaWxsZWRPclJlamVjdGVkKCkpIHJldHVybjtcbiAgICB0aGlzLl9yZWplY3RVbmNoZWNrZWQocmVhc29uLCBjYXJyaWVkU3RhY2tUcmFjZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciBpc1Byb21pc2UgPSBwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZTtcblxuICAgIGlmIChpc1Byb21pc2UgJiYgcHJvbWlzZS5faXNNaWdyYXRlZCgpKSB7XG4gICAgICAgIHByb21pc2UuX3Vuc2V0SXNNaWdyYXRlZCgpO1xuICAgICAgICByZXR1cm4gYXN5bmMuaW52b2tlKHRoaXMuX3NldHRsZVByb21pc2VBdCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2lzRnVsZmlsbGVkKClcbiAgICAgICAgPyB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJBdChpbmRleClcbiAgICAgICAgOiB0aGlzLl9yZWplY3Rpb25IYW5kbGVyQXQoaW5kZXgpO1xuXG4gICAgdmFyIGNhcnJpZWRTdGFja1RyYWNlID1cbiAgICAgICAgdGhpcy5faXNDYXJyeWluZ1N0YWNrVHJhY2UoKSA/IHRoaXMuX2dldENhcnJpZWRTdGFja1RyYWNlKCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5fc2V0dGxlZFZhbHVlO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaW5kZXgpO1xuICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpbmRleCk7XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQcm9taXNlQXJyYXkpIHtcbiAgICAgICAgaWYgKCFyZWNlaXZlci5faXNSZXNvbHZlZCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlUmVqZWN0ZWQodmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1Byb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlLCBjYXJyaWVkU3RhY2tUcmFjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPj0gNCAmJiAoaW5kZXggJiAzMSkgPT09IDQpXG4gICAgICAgIGFzeW5jLmludm9rZUxhdGVyKHRoaXMuX3NldExlbmd0aCwgdGhpcywgMCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhcnJ5aW5nU3RhY2tUcmFjZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID1cbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVyMCA9XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyMCA9XG4gICAgICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlID0gaW5kZXggKiA1IC0gNTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPVxuICAgICAgICB0aGlzW2Jhc2UgKyA0XSA9XG4gICAgICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICAgICAgdGhpc1tiYXNlICsgMV0gPVxuICAgICAgICB0aGlzW2Jhc2UgKyAyXSA9IHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNTZXR0bGVQcm9taXNlc1F1ZXVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICZcbiAgICAgICAgICAgIC0xMDczNzQxODI0KSA9PT0gLTEwNzM3NDE4MjQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0U2V0dGxlUHJvbWlzZXNRdWV1ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IC0xMDczNzQxODI0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0U2V0dGxlUHJvbWlzZXNRdWV1ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+LTEwNzM3NDE4MjQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3F1ZXVlU2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbigpIHtcbiAgICBhc3luYy5zZXR0bGVQcm9taXNlcyh0aGlzKTtcbiAgICB0aGlzLl9zZXRTZXR0bGVQcm9taXNlc1F1ZXVlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxVbmNoZWNrZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdFVuY2hlY2tlZChlcnIsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEZ1bGZpbGxlZCgpO1xuICAgIHRoaXMuX3NldHRsZWRWYWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX2NsZWFuVmFsdWVzKCk7XG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlU2V0dGxlUHJvbWlzZXMoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0VW5jaGVja2VkQ2hlY2tFcnJvciA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgdHJhY2UgPSB1dGlsLmVuc3VyZUVycm9yT2JqZWN0KHJlYXNvbik7XG4gICAgdGhpcy5fcmVqZWN0VW5jaGVja2VkKHJlYXNvbiwgdHJhY2UgPT09IHJlYXNvbiA/IHVuZGVmaW5lZCA6IHRyYWNlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3RVbmNoZWNrZWQgPSBmdW5jdGlvbiAocmVhc29uLCB0cmFjZSkge1xuICAgIGlmIChyZWFzb24gPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdFVuY2hlY2tlZChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRSZWplY3RlZCgpO1xuICAgIHRoaXMuX3NldHRsZWRWYWx1ZSA9IHJlYXNvbjtcbiAgICB0aGlzLl9jbGVhblZhbHVlcygpO1xuXG4gICAgaWYgKHRoaXMuX2lzRmluYWwoKSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChcInN0YWNrXCIgaW4gZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmludm9rZUZpcnN0KFxuICAgICAgICAgICAgICAgICAgICBDYXB0dXJlZFRyYWNlLnVuaGFuZGxlZFJlamVjdGlvbiwgdW5kZWZpbmVkLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sIHRyYWNlID09PSB1bmRlZmluZWQgPyByZWFzb24gOiB0cmFjZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHJhY2UgIT09IHVuZGVmaW5lZCAmJiB0cmFjZSAhPT0gcmVhc29uKSB7XG4gICAgICAgIHRoaXMuX3NldENhcnJpZWRTdGFja1RyYWNlKHRyYWNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlU2V0dGxlUHJvbWlzZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdW5zZXRTZXR0bGVQcm9taXNlc1F1ZXVlZCgpO1xuICAgIHZhciBsZW4gPSB0aGlzLl9sZW5ndGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VBdChpKTtcbiAgICB9XG59O1xuXG51dGlsLm5vdEVudW1lcmFibGVQcm9wKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgIFwiX21ha2VTZWxmUmVzb2x1dGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgIG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKTtcblxuX2RlcmVxXyhcIi4vcHJvZ3Jlc3MuanNcIikoUHJvbWlzZSwgUHJvbWlzZUFycmF5KTtcbl9kZXJlcV8oXCIuL21ldGhvZC5qc1wiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbl9kZXJlcV8oXCIuL2JpbmQuanNcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UpO1xuX2RlcmVxXyhcIi4vZmluYWxseS5qc1wiKShQcm9taXNlLCBORVhUX0ZJTFRFUiwgdHJ5Q29udmVydFRvUHJvbWlzZSk7XG5fZGVyZXFfKFwiLi9kaXJlY3RfcmVzb2x2ZS5qc1wiKShQcm9taXNlKTtcbl9kZXJlcV8oXCIuL3N5bmNocm9ub3VzX2luc3BlY3Rpb24uanNcIikoUHJvbWlzZSk7XG5fZGVyZXFfKFwiLi9qb2luLmpzXCIpKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwpO1xuUHJvbWlzZS5Qcm9taXNlID0gUHJvbWlzZTtcbl9kZXJlcV8oJy4vbWFwLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMKTtcbl9kZXJlcV8oJy4vY2FuY2VsLmpzJykoUHJvbWlzZSk7XG5fZGVyZXFfKCcuL3VzaW5nLmpzJykoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBjcmVhdGVDb250ZXh0KTtcbl9kZXJlcV8oJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UpO1xuX2RlcmVxXygnLi9ub2RlaWZ5LmpzJykoUHJvbWlzZSk7XG5fZGVyZXFfKCcuL2NhbGxfZ2V0LmpzJykoUHJvbWlzZSk7XG5fZGVyZXFfKCcuL3Byb3BzLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pO1xuX2RlcmVxXygnLi9yYWNlLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5fZGVyZXFfKCcuL3JlZHVjZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSk7XG5fZGVyZXFfKCcuL3NvbWUuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbik7XG5fZGVyZXFfKCcuL3Byb21pc2lmeS5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbl9kZXJlcV8oJy4vYW55LmpzJykoUHJvbWlzZSk7XG5fZGVyZXFfKCcuL2VhY2guanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL3RpbWVycy5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbl9kZXJlcV8oJy4vZmlsdGVyLmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlLnByb3RvdHlwZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmdW5jdGlvbiBmaWxsVHlwZXModmFsdWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3Byb2dyZXNzSGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9wcm9taXNlMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVjZWl2ZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3NldHRsZWRWYWx1ZSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAvLyBDb21wbGV0ZSBzbGFjayB0cmFja2luZywgb3B0IG91dCBvZiBmaWVsZC10eXBlIHRyYWNraW5nIGFuZCAgICAgICAgICAgXG4gICAgLy8gc3RhYmlsaXplIG1hcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YTogMX0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2I6IDJ9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtjOiAzfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcygxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZnVuY3Rpb24oKXt9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHVuZGVmaW5lZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyhmYWxzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMobmV3IFByb21pc2UoSU5URVJOQUwpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgQ2FwdHVyZWRUcmFjZS5zZXRCb3VuZHMoYXN5bmMuZmlyc3RMaW5lRXJyb3IsIHV0aWwubGFzdExpbmVFcnJvcik7ICAgICAgIFxuICAgIHJldHVybiBQcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxufTtcblxufSx7XCIuL2FueS5qc1wiOjEsXCIuL2FzeW5jLmpzXCI6MixcIi4vYmluZC5qc1wiOjMsXCIuL2NhbGxfZ2V0LmpzXCI6NSxcIi4vY2FuY2VsLmpzXCI6NixcIi4vY2FwdHVyZWRfdHJhY2UuanNcIjo3LFwiLi9jYXRjaF9maWx0ZXIuanNcIjo4LFwiLi9jb250ZXh0LmpzXCI6OSxcIi4vZGVidWdnYWJpbGl0eS5qc1wiOjEwLFwiLi9kaXJlY3RfcmVzb2x2ZS5qc1wiOjExLFwiLi9lYWNoLmpzXCI6MTIsXCIuL2Vycm9ycy5qc1wiOjEzLFwiLi9maWx0ZXIuanNcIjoxNSxcIi4vZmluYWxseS5qc1wiOjE2LFwiLi9nZW5lcmF0b3JzLmpzXCI6MTcsXCIuL2pvaW4uanNcIjoxOCxcIi4vbWFwLmpzXCI6MTksXCIuL21ldGhvZC5qc1wiOjIwLFwiLi9ub2RlaWZ5LmpzXCI6MjEsXCIuL3Byb2dyZXNzLmpzXCI6MjIsXCIuL3Byb21pc2VfYXJyYXkuanNcIjoyNCxcIi4vcHJvbWlzZV9yZXNvbHZlci5qc1wiOjI1LFwiLi9wcm9taXNpZnkuanNcIjoyNixcIi4vcHJvcHMuanNcIjoyNyxcIi4vcmFjZS5qc1wiOjI5LFwiLi9yZWR1Y2UuanNcIjozMCxcIi4vc2V0dGxlLmpzXCI6MzIsXCIuL3NvbWUuanNcIjozMyxcIi4vc3luY2hyb25vdXNfaW5zcGVjdGlvbi5qc1wiOjM0LFwiLi90aGVuYWJsZXMuanNcIjozNSxcIi4vdGltZXJzLmpzXCI6MzYsXCIuL3VzaW5nLmpzXCI6MzcsXCIuL3V0aWwuanNcIjozOH1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciBpc0FycmF5ID0gdXRpbC5pc0FycmF5O1xuXG5mdW5jdGlvbiB0b1Jlc29sdXRpb25WYWx1ZSh2YWwpIHtcbiAgICBzd2l0Y2godmFsKSB7XG4gICAgY2FzZSAtMjogcmV0dXJuIFtdO1xuICAgIGNhc2UgLTM6IHJldHVybiB7fTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHBhcmVudDtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwYXJlbnQgPSB2YWx1ZXM7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20ocGFyZW50LCAxIHwgNCk7XG4gICAgfVxuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQgPSAwO1xuICAgIHRoaXMuX2luaXQodW5kZWZpbmVkLCAtMik7XG59XG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoXywgcmVzb2x2ZVZhbHVlSWZFbXB0eSkge1xuICAgIHZhciB2YWx1ZXMgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMuX3ZhbHVlcywgdGhpcy5fcHJvbWlzZSk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLl90YXJnZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICBpZiAodmFsdWVzLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuX3ZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgUHJvbWlzZS5UeXBlRXJyb3IoXCJleHBlY3RpbmcgYW4gYXJyYXksIGEgcHJvbWlzZSBvciBhIHRoZW5hYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvczhNTWhjXFx1MDAwYVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFyZFJlamVjdF9fKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlcy5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgIHZhbHVlcy5fdGhlbihcbiAgICAgICAgICAgICAgICBpbml0LFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVJZkVtcHR5XG4gICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QodmFsdWVzLl9yZWFzb24oKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0KGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBhcnJheSwgYSBwcm9taXNlIG9yIGEgdGhlbmFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9zOE1NaGNcXHUwMDBhXCIpLl9yZWFzb24oKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAocmVzb2x2ZVZhbHVlSWZFbXB0eSA9PT0gLTUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eUFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRvUmVzb2x1dGlvblZhbHVlKHJlc29sdmVWYWx1ZUlmRW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZW4gPSB0aGlzLmdldEFjdHVhbExlbmd0aCh2YWx1ZXMubGVuZ3RoKTtcbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgdGhpcy5fdmFsdWVzID0gdGhpcy5zaG91bGRDb3B5VmFsdWVzKCkgPyBuZXcgQXJyYXkobGVuKSA6IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgaXNSZXNvbHZlZCA9IHRoaXMuX2lzUmVzb2x2ZWQoKTtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWVzW2ldLCBwcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5faWdub3JlUmVqZWN0aW9ucygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXliZVByb21pc2UuX2lzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eVByb21pc2VBcnJheSh0aGlzLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZChtYXliZVByb21pc2UuX3ZhbHVlKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ZWQobWF5YmVQcm9taXNlLl9yZWFzb24oKSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyA9PT0gbnVsbDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fX2hhcmRSZWplY3RfXyA9XG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIGZhbHNlLCB0cnVlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VQcm9ncmVzc2VkID0gZnVuY3Rpb24gKHByb2dyZXNzVmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHJvZ3Jlc3Moe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHZhbHVlOiBwcm9ncmVzc1ZhbHVlXG4gICAgfSk7XG59O1xuXG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbiwgaW5kZXgpIHtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkKys7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmdldEFjdHVhbExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICByZXR1cm4gbGVuO1xufTtcblxucmV0dXJuIFByb21pc2VBcnJheTtcbn07XG5cbn0se1wiLi91dGlsLmpzXCI6Mzh9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9ycy5qc1wiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBlcnJvcnMuVGltZW91dEVycm9yO1xudmFyIE9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcbnZhciBoYXZlR2V0dGVycyA9IHV0aWwuaGF2ZUdldHRlcnM7XG52YXIgZXM1ID0gX2RlcmVxXyhcIi4vZXM1LmpzXCIpO1xuXG5mdW5jdGlvbiBpc1VudHlwZWRFcnJvcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgZXM1LmdldFByb3RvdHlwZU9mKG9iaikgPT09IEVycm9yLnByb3RvdHlwZTtcbn1cblxudmFyIHJFcnJvcktleSA9IC9eKD86bmFtZXxtZXNzYWdlfHN0YWNrfGNhdXNlKSQvO1xuZnVuY3Rpb24gd3JhcEFzT3BlcmF0aW9uYWxFcnJvcihvYmopIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChpc1VudHlwZWRFcnJvcihvYmopKSB7XG4gICAgICAgIHJldCA9IG5ldyBPcGVyYXRpb25hbEVycm9yKG9iaik7XG4gICAgICAgIHJldC5uYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIHJldC5tZXNzYWdlID0gb2JqLm1lc3NhZ2U7XG4gICAgICAgIHJldC5zdGFjayA9IG9iai5zdGFjaztcbiAgICAgICAgdmFyIGtleXMgPSBlczUua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFyRXJyb3JLZXkudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb21pc2UgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHdyYXBBc09wZXJhdGlvbmFsRXJyb3IobWF5YmVXcmFwQXNFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod3JhcHBlZCk7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3Qod3JhcHBlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciAkX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIGFyZ3MgPSBuZXcgQXJyYXkoJF9sZW4gLSAxKTsgZm9yKHZhciAkX2kgPSAxOyAkX2kgPCAkX2xlbjsgKyskX2kpIHthcmdzWyRfaSAtIDFdID0gYXJndW1lbnRzWyRfaV07fVxuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbChhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfTtcbn1cblxuXG52YXIgUHJvbWlzZVJlc29sdmVyO1xuaWYgKCFoYXZlR2V0dGVycykge1xuICAgIFByb21pc2VSZXNvbHZlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuYXNDYWxsYmFjayA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IHRoaXMuYXNDYWxsYmFjaztcbiAgICB9O1xufVxuZWxzZSB7XG4gICAgUHJvbWlzZVJlc29sdmVyID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB9O1xufVxuaWYgKGhhdmVHZXR0ZXJzKSB7XG4gICAgdmFyIHByb3AgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZWJhY2tGb3JQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShQcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLCBcImFzQ2FsbGJhY2tcIiwgcHJvcCk7XG4gICAgZXM1LmRlZmluZVByb3BlcnR5KFByb21pc2VSZXNvbHZlci5wcm90b3R5cGUsIFwiY2FsbGJhY2tcIiwgcHJvcCk7XG59XG5cblByb21pc2VSZXNvbHZlci5fbm9kZWJhY2tGb3JQcm9taXNlID0gbm9kZWJhY2tGb3JQcm9taXNlO1xuXG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZVJlc29sdmVyXVwiO1xufTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID1cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUuZnVsZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlUmVzb2x2ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb24sIHJlc29sdmVyIHJlc29sdmUvcmVqZWN0IG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhIHJlc29sdmVyIGNvbnRleHQuIENvbnNpZGVyIHVzaW5nIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGluc3RlYWQuXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvc2RrWEw5XFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xufTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VSZXNvbHZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvbiwgcmVzb2x2ZXIgcmVzb2x2ZS9yZWplY3QgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGEgcmVzb2x2ZXIgY29udGV4dC4gQ29uc2lkZXIgdXNpbmcgdGhlIHByb21pc2UgY29uc3RydWN0b3IgaW5zdGVhZC5cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9zZGtYTDlcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB0aGlzLnByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbik7XG59O1xuXG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VSZXNvbHZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvbiwgcmVzb2x2ZXIgcmVzb2x2ZS9yZWplY3QgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGEgcmVzb2x2ZXIgY29udGV4dC4gQ29uc2lkZXIgdXNpbmcgdGhlIHByb21pc2UgY29uc3RydWN0b3IgaW5zdGVhZC5cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9zZGtYTDlcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB0aGlzLnByb21pc2UuX3Byb2dyZXNzKHZhbHVlKTtcbn07XG5cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGVycikge1xuICAgIHRoaXMucHJvbWlzZS5jYW5jZWwoZXJyKTtcbn07XG5cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlamVjdChuZXcgVGltZW91dEVycm9yKFwidGltZW91dFwiKSk7XG59O1xuXG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZS5pc1Jlc29sdmVkKCk7XG59O1xuXG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlLnRvSlNPTigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlUmVzb2x2ZXI7XG5cbn0se1wiLi9lcnJvcnMuanNcIjoxMyxcIi4vZXM1LmpzXCI6MTQsXCIuL3V0aWwuanNcIjozOH1dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFRISVMgPSB7fTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSBfZGVyZXFfKFwiLi9wcm9taXNlX3Jlc29sdmVyLmpzXCIpXG4gICAgLl9ub2RlYmFja0ZvclByb21pc2U7XG52YXIgd2l0aEFwcGVuZGVkID0gdXRpbC53aXRoQXBwZW5kZWQ7XG52YXIgbWF5YmVXcmFwQXNFcnJvciA9IHV0aWwubWF5YmVXcmFwQXNFcnJvcjtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgVHlwZUVycm9yID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcjtcbnZhciBkZWZhdWx0U3VmZml4ID0gXCJBc3luY1wiO1xudmFyIGRlZmF1bHRQcm9taXNpZmllZCA9IHtfX2lzUHJvbWlzaWZpZWRfXzogdHJ1ZX07XG52YXIgbm9Db3B5UHJvcHMgPSBbXG4gICAgXCJhcml0eVwiLCAgICBcImxlbmd0aFwiLFxuICAgIFwibmFtZVwiLFxuICAgIFwiYXJndW1lbnRzXCIsXG4gICAgXCJjYWxsZXJcIixcbiAgICBcImNhbGxlZVwiLFxuICAgIFwicHJvdG90eXBlXCIsXG4gICAgXCJfX2lzUHJvbWlzaWZpZWRfX1wiXG5dO1xudmFyIG5vQ29weVByb3BzUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBub0NvcHlQcm9wcy5qb2luKFwifFwiKSArIFwiKSRcIik7XG5cbnZhciBkZWZhdWx0RmlsdGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB1dGlsLmlzSWRlbnRpZmllcihuYW1lKSAmJlxuICAgICAgICBuYW1lLmNoYXJBdCgwKSAhPT0gXCJfXCIgJiZcbiAgICAgICAgbmFtZSAhPT0gXCJjb25zdHJ1Y3RvclwiO1xufTtcblxuZnVuY3Rpb24gcHJvcHNGaWx0ZXIoa2V5KSB7XG4gICAgcmV0dXJuICFub0NvcHlQcm9wc1BhdHRlcm4udGVzdChrZXkpO1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2lmaWVkKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuLl9faXNQcm9taXNpZmllZF9fID09PSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSB7XG4gICAgdmFyIHZhbCA9IHV0aWwuZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0KG9iaiwga2V5ICsgc3VmZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvbWlzaWZpZWQpO1xuICAgIHJldHVybiB2YWwgPyBpc1Byb21pc2lmaWVkKHZhbCkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXRbaV07XG4gICAgICAgIGlmIChzdWZmaXhSZWdleHAudGVzdChrZXkpKSB7XG4gICAgICAgICAgICB2YXIga2V5V2l0aG91dEFzeW5jU3VmZml4ID0ga2V5LnJlcGxhY2Uoc3VmZml4UmVnZXhwLCBcIlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmV0Lmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldFtqXSA9PT0ga2V5V2l0aG91dEFzeW5jU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcHJvbWlzaWZ5IGFuIEFQSSB0aGF0IGhhcyBub3JtYWwgbWV0aG9kcyB3aXRoICclcyctc3VmZml4XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvaVdyWmJ3XFx1MDAwYVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIiVzXCIsIHN1ZmZpeCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKSB7XG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKG9iaik7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHZhciBwYXNzZXNEZWZhdWx0RmlsdGVyID0gZmlsdGVyID09PSBkZWZhdWx0RmlsdGVyXG4gICAgICAgICAgICA/IHRydWUgOiBkZWZhdWx0RmlsdGVyKGtleSwgdmFsdWUsIG9iaik7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgIWlzUHJvbWlzaWZpZWQodmFsdWUpICYmXG4gICAgICAgICAgICAhaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkgJiZcbiAgICAgICAgICAgIGZpbHRlcihrZXksIHZhbHVlLCBvYmosIHBhc3Nlc0RlZmF1bHRGaWx0ZXIpKSB7XG4gICAgICAgICAgICByZXQucHVzaChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApO1xuICAgIHJldHVybiByZXQ7XG59XG5cbnZhciBlc2NhcGVJZGVudFJlZ2V4ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWyRdKS8sIFwiXFxcXCRcIik7XG59O1xuXG52YXIgbWFrZU5vZGVQcm9taXNpZmllZEV2YWw7XG5pZiAoIXRydWUpIHtcbnZhciBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlciA9IGZ1bmN0aW9uKGxpa2VseUFyZ3VtZW50Q291bnQpIHtcbiAgICB2YXIgcmV0ID0gW2xpa2VseUFyZ3VtZW50Q291bnRdO1xuICAgIHZhciBtaW4gPSBNYXRoLm1heCgwLCBsaWtlbHlBcmd1bWVudENvdW50IC0gMSAtIDMpO1xuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgLSAxOyBpID49IG1pbjsgLS1pKSB7XG4gICAgICAgIHJldC5wdXNoKGkpO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSBsaWtlbHlBcmd1bWVudENvdW50ICsgMTsgaSA8PSAzOyArK2kpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG52YXIgYXJndW1lbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uKGFyZ3VtZW50Q291bnQpIHtcbiAgICByZXR1cm4gdXRpbC5maWxsZWRSYW5nZShhcmd1bWVudENvdW50LCBcIl9hcmdcIiwgXCJcIik7XG59O1xuXG52YXIgcGFyYW1ldGVyRGVjbGFyYXRpb24gPSBmdW5jdGlvbihwYXJhbWV0ZXJDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKFxuICAgICAgICBNYXRoLm1heChwYXJhbWV0ZXJDb3VudCwgMyksIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJDb3VudCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbi5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGZuLmxlbmd0aCwgMTAyMyArIDEpLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG5tYWtlTm9kZVByb21pc2lmaWVkRXZhbCA9XG5mdW5jdGlvbihjYWxsYmFjaywgcmVjZWl2ZXIsIG9yaWdpbmFsTmFtZSwgZm4pIHtcbiAgICB2YXIgbmV3UGFyYW1ldGVyQ291bnQgPSBNYXRoLm1heCgwLCBwYXJhbWV0ZXJDb3VudChmbikgLSAxKTtcbiAgICB2YXIgYXJndW1lbnRPcmRlciA9IHN3aXRjaENhc2VBcmd1bWVudE9yZGVyKG5ld1BhcmFtZXRlckNvdW50KTtcbiAgICB2YXIgc2hvdWxkUHJveHlUaGlzID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiIHx8IHJlY2VpdmVyID09PSBUSElTO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudChjb3VudCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50U2VxdWVuY2UoY291bnQpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIGNvbW1hID0gY291bnQgPiAwID8gXCIsIFwiIDogXCJcIjtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYgKHNob3VsZFByb3h5VGhpcykge1xuICAgICAgICAgICAgcmV0ID0gXCJyZXQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gcmVjZWl2ZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gXCJyZXQgPSBjYWxsYmFjayh7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIlxuICAgICAgICAgICAgICAgIDogXCJyZXQgPSBjYWxsYmFjay5jYWxsKHJlY2VpdmVyLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0LnJlcGxhY2UoXCJ7e2FyZ3N9fVwiLCBhcmdzKS5yZXBsYWNlKFwiLCBcIiwgY29tbWEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkge1xuICAgICAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudE9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXQgKz0gXCJjYXNlIFwiICsgYXJndW1lbnRPcmRlcltpXSArXCI6XCIgK1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoYXJndW1lbnRPcmRlcltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgKz0gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBpID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBub2RlYmFjazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFtDb2RlRm9yQ2FsbF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcIltDb2RlRm9yQ2FsbF1cIiwgKHNob3VsZFByb3h5VGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwicmV0ID0gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XFxuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcXG5cIikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHZhciBnZXRGdW5jdGlvbkNvZGUgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoXCJ0aGlzICE9IG51bGwgPyB0aGlzWydcIitjYWxsYmFjaytcIiddIDogZm5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImZuXCI7XG5cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWNlaXZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aXRoQXBwZW5kZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWF5YmVXcmFwQXNFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub2RlYmFja0ZvclByb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHJ5Q2F0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXJyb3JPYmpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm90RW51bWVyYWJsZVByb3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSU5URVJOQUxcIixcIid1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgdmFyIHJldCA9IGZ1bmN0aW9uIChQYXJhbWV0ZXJzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBub2RlYmFjayA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlKTsgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRyeUNhdGNoKFtHZXRGdW5jdGlvbkNvZGVdKTsgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHN3aXRjaChsZW4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBbQ29kZUZvclN3aXRjaENhc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKHJldC5lKSwgdHJ1ZSwgdHJ1ZSk7XFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AocmV0LCAnX19pc1Byb21pc2lmaWVkX18nLCB0cnVlKTsgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCJcbiAgICAgICAgLnJlcGxhY2UoXCJQYXJhbWV0ZXJzXCIsIHBhcmFtZXRlckRlY2xhcmF0aW9uKG5ld1BhcmFtZXRlckNvdW50KSlcbiAgICAgICAgLnJlcGxhY2UoXCJbQ29kZUZvclN3aXRjaENhc2VdXCIsIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKFwiW0dldEZ1bmN0aW9uQ29kZV1cIiwgZ2V0RnVuY3Rpb25Db2RlKSkoXG4gICAgICAgICAgICBQcm9taXNlLFxuICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICByZWNlaXZlcixcbiAgICAgICAgICAgIHdpdGhBcHBlbmRlZCxcbiAgICAgICAgICAgIG1heWJlV3JhcEFzRXJyb3IsXG4gICAgICAgICAgICBub2RlYmFja0ZvclByb21pc2UsXG4gICAgICAgICAgICB1dGlsLnRyeUNhdGNoLFxuICAgICAgICAgICAgdXRpbC5lcnJvck9iaixcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AsXG4gICAgICAgICAgICBJTlRFUk5BTFxuICAgICAgICApO1xufTtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmUoY2FsbGJhY2ssIHJlY2VpdmVyLCBfLCBmbikge1xuICAgIHZhciBkZWZhdWx0VGhpcyA9IChmdW5jdGlvbigpIHtyZXR1cm4gdGhpczt9KSgpO1xuICAgIHZhciBtZXRob2QgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYWxsYmFjayA9IGZuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9taXNpZmllZCgpIHtcbiAgICAgICAgdmFyIF9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IFRISVMpIF9yZWNlaXZlciA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICB2YXIgY2IgPSB0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiICYmIHRoaXMgIT09IGRlZmF1bHRUaGlzXG4gICAgICAgICAgICA/IHRoaXNbbWV0aG9kXSA6IGNhbGxiYWNrO1xuICAgICAgICB2YXIgZm4gPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYi5hcHBseShfcmVjZWl2ZXIsIHdpdGhBcHBlbmRlZChhcmd1bWVudHMsIGZuKSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sobWF5YmVXcmFwQXNFcnJvcihlKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AocHJvbWlzaWZpZWQsIFwiX19pc1Byb21pc2lmaWVkX19cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHByb21pc2lmaWVkO1xufVxuXG52YXIgbWFrZU5vZGVQcm9taXNpZmllZCA9IGNhbkV2YWx1YXRlXG4gICAgPyBtYWtlTm9kZVByb21pc2lmaWVkRXZhbFxuICAgIDogbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmU7XG5cbmZ1bmN0aW9uIHByb21pc2lmeUFsbChvYmosIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllcikge1xuICAgIHZhciBzdWZmaXhSZWdleHAgPSBuZXcgUmVnRXhwKGVzY2FwZUlkZW50UmVnZXgoc3VmZml4KSArIFwiJFwiKTtcbiAgICB2YXIgbWV0aG9kcyA9XG4gICAgICAgIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2RzW2ldO1xuICAgICAgICB2YXIgZm4gPSBtZXRob2RzW2krMV07XG4gICAgICAgIHZhciBwcm9taXNpZmllZEtleSA9IGtleSArIHN1ZmZpeDtcbiAgICAgICAgb2JqW3Byb21pc2lmaWVkS2V5XSA9IHByb21pc2lmaWVyID09PSBtYWtlTm9kZVByb21pc2lmaWVkXG4gICAgICAgICAgICAgICAgPyBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LCBmbiwgc3VmZml4KVxuICAgICAgICAgICAgICAgIDogcHJvbWlzaWZpZXIoZm4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU5vZGVQcm9taXNpZmllZChrZXksIFRISVMsIGtleSwgZm4sIHN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmeShjYWxsYmFjaywgcmVjZWl2ZXIpIHtcbiAgICByZXR1cm4gbWFrZU5vZGVQcm9taXNpZmllZChjYWxsYmFjaywgcmVjZWl2ZXIsIHVuZGVmaW5lZCwgY2FsbGJhY2spO1xufVxuXG5Qcm9taXNlLnByb21pc2lmeSA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgfVxuICAgIGlmIChpc1Byb21pc2lmaWVkKGZuKSkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIHZhciByZXQgPSBwcm9taXNpZnkoZm4sIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gVEhJUyA6IHJlY2VpdmVyKTtcbiAgICB1dGlsLmNvcHlEZXNjcmlwdG9ycyhmbiwgcmV0LCBwcm9wc0ZpbHRlcik7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvbWlzaWZ5QWxsID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhlIHRhcmdldCBvZiBwcm9taXNpZnlBbGwgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzlJVGxWMFxcdTAwMGFcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4O1xuICAgIGlmICh0eXBlb2Ygc3VmZml4ICE9PSBcInN0cmluZ1wiKSBzdWZmaXggPSBkZWZhdWx0U3VmZml4O1xuICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgIHZhciBwcm9taXNpZmllciA9IG9wdGlvbnMucHJvbWlzaWZpZXI7XG4gICAgaWYgKHR5cGVvZiBwcm9taXNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBwcm9taXNpZmllciA9IG1ha2VOb2RlUHJvbWlzaWZpZWQ7XG5cbiAgICBpZiAoIXV0aWwuaXNJZGVudGlmaWVyKHN1ZmZpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzdWZmaXggbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC84RlpvNVZcXHUwMDBhXCIpO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyh0YXJnZXQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0YXJnZXRba2V5c1tpXV07XG4gICAgICAgIGlmIChrZXlzW2ldICE9PSBcImNvbnN0cnVjdG9yXCIgJiZcbiAgICAgICAgICAgIHV0aWwuaXNDbGFzcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZS5wcm90b3R5cGUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllcik7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzaWZ5QWxsKHRhcmdldCwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyKTtcbn07XG59O1xuXG5cbn0se1wiLi9lcnJvcnNcIjoxMyxcIi4vcHJvbWlzZV9yZXNvbHZlci5qc1wiOjI1LFwiLi91dGlsLmpzXCI6Mzh9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oXG4gICAgUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG52YXIgZXM1ID0gX2RlcmVxXyhcIi4vZXM1LmpzXCIpO1xuXG5mdW5jdGlvbiBQcm9wZXJ0aWVzUHJvbWlzZUFycmF5KG9iaikge1xuICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4gKiAyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5XTtcbiAgICAgICAgdmFsdWVzW2kgKyBsZW5dID0ga2V5O1xuICAgIH1cbiAgICB0aGlzLmNvbnN0cnVjdG9yJCh2YWx1ZXMpO1xufVxudXRpbC5pbmhlcml0cyhQcm9wZXJ0aWVzUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC0zKSA7XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSB7fTtcbiAgICAgICAgdmFyIGtleU9mZnNldCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aCgpOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhbFt0aGlzLl92YWx1ZXNbaSArIGtleU9mZnNldF1dID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodmFsKTtcbiAgICB9XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVByb2dyZXNzZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHJvZ3Jlc3Moe1xuICAgICAgICBrZXk6IHRoaXMuX3ZhbHVlc1tpbmRleCArIHRoaXMubGVuZ3RoKCldLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW4gPj4gMTtcbn07XG5cbmZ1bmN0aW9uIHByb3BzKHByb21pc2VzKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgY2FzdFZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KGNhc3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImNhbm5vdCBhd2FpdCBwcm9wZXJ0aWVzIG9mIGEgbm9uLW9iamVjdFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL09zRktDOFxcdTAwMGFcIik7XG4gICAgfSBlbHNlIGlmIChjYXN0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldCA9IGNhc3RWYWx1ZS5fdGhlbihcbiAgICAgICAgICAgIFByb21pc2UucHJvcHMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb3BlcnRpZXNQcm9taXNlQXJyYXkoY2FzdFZhbHVlKS5wcm9taXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKGNhc3RWYWx1ZSwgNCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcyh0aGlzKTtcbn07XG5cblByb21pc2UucHJvcHMgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gcHJvcHMocHJvbWlzZXMpO1xufTtcbn07XG5cbn0se1wiLi9lczUuanNcIjoxNCxcIi4vdXRpbC5qc1wiOjM4fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcnJheU1vdmUoc3JjLCBzcmNJbmRleCwgZHN0LCBkc3RJbmRleCwgbGVuKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgICBkc3RbaiArIGRzdEluZGV4XSA9IHNyY1tqICsgc3JjSW5kZXhdO1xuICAgICAgICBzcmNbaiArIHNyY0luZGV4XSA9IHZvaWQgMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Zyb250ID0gMDtcbn1cblxuUXVldWUucHJvdG90eXBlLl93aWxsQmVPdmVyQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhY2l0eSA8IHNpemU7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3B1c2hPbmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgaSA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzW2ldID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3Vuc2hpZnRPbmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBjYXBhY2l0eSA9IHRoaXMuX2NhcGFjaXR5O1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkodGhpcy5sZW5ndGgoKSArIDEpO1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBpID0gKCgoKCBmcm9udCAtIDEgKSAmXG4gICAgICAgICAgICAgICAgICAgICggY2FwYWNpdHkgLSAxKSApIF4gY2FwYWNpdHkgKSAtIGNhcGFjaXR5ICk7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICAgIHRoaXMuX2Zyb250ID0gaTtcbiAgICB0aGlzLl9sZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl91bnNoaWZ0T25lKGFyZyk7XG4gICAgdGhpcy5fdW5zaGlmdE9uZShyZWNlaXZlcik7XG4gICAgdGhpcy5fdW5zaGlmdE9uZShmbik7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMztcbiAgICBpZiAodGhpcy5fd2lsbEJlT3ZlckNhcGFjaXR5KGxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShmbik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUocmVjZWl2ZXIpO1xuICAgICAgICB0aGlzLl9wdXNoT25lKGFyZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGogPSB0aGlzLl9mcm9udCArIGxlbmd0aCAtIDM7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGgpO1xuICAgIHZhciB3cmFwTWFzayA9IHRoaXMuX2NhcGFjaXR5IC0gMTtcbiAgICB0aGlzWyhqICsgMCkgJiB3cmFwTWFza10gPSBmbjtcbiAgICB0aGlzWyhqICsgMSkgJiB3cmFwTWFza10gPSByZWNlaXZlcjtcbiAgICB0aGlzWyhqICsgMikgJiB3cmFwTWFza10gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250LFxuICAgICAgICByZXQgPSB0aGlzW2Zyb250XTtcblxuICAgIHRoaXNbZnJvbnRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Zyb250ID0gKGZyb250ICsgMSkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzLl9sZW5ndGgtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBpZiAodGhpcy5fY2FwYWNpdHkgPCBzaXplKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvKHRoaXMuX2NhcGFjaXR5IDw8IDEpO1xuICAgIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gKGZyb250ICsgbGVuZ3RoKSAmIChvbGRDYXBhY2l0eSAtIDEpO1xuICAgIGFycmF5TW92ZSh0aGlzLCAwLCB0aGlzLCBvbGRDYXBhY2l0eSwgbW92ZUl0ZW1zQ291bnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcblxufSx7fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciBpc0FycmF5ID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKS5pc0FycmF5O1xuXG52YXIgcmFjZUxhdGVyID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIHJldHVybiByYWNlKGFycmF5LCBwcm9taXNlKTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIHJhY2UocHJvbWlzZXMsIHBhcmVudCkge1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzKTtcblxuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByYWNlTGF0ZXIobWF5YmVQcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKCFpc0FycmF5KHByb21pc2VzKSkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGFuIGFycmF5LCBhIHByb21pc2Ugb3IgYSB0aGVuYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL3M4TU1oY1xcdTAwMGFcIik7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHBhcmVudCwgNCB8IDEpO1xuICAgIH1cbiAgICB2YXIgZnVsZmlsbCA9IHJldC5fZnVsZmlsbDtcbiAgICB2YXIgcmVqZWN0ID0gcmV0Ll9yZWplY3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB2YWwgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgIShpIGluIHByb21pc2VzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmNhc3QodmFsKS5fdGhlbihmdWxmaWxsLCByZWplY3QsIHVuZGVmaW5lZCwgcmV0LCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHJhY2UocHJvbWlzZXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYWNlKHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuXG59LHtcIi4vdXRpbC5qc1wiOjM4fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCkge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciBhc3luYyA9IF9kZXJlcV8oXCIuL2FzeW5jLmpzXCIpO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG5mdW5jdGlvbiBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBhY2N1bSwgX2VhY2gpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXMgPSBfZWFjaCA9PT0gSU5URVJOQUwgPyBbXSA6IG51bGw7XG4gICAgdGhpcy5femVyb3RoSXNBY2N1bSA9IChhY2N1bSA9PT0gdW5kZWZpbmVkKTtcbiAgICB0aGlzLl9nb3RBY2N1bSA9IGZhbHNlO1xuICAgIHRoaXMuX3JlZHVjaW5nSW5kZXggPSAodGhpcy5femVyb3RoSXNBY2N1bSA/IDEgOiAwKTtcbiAgICB0aGlzLl92YWx1ZXNQaGFzZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShhY2N1bSwgdGhpcy5fcHJvbWlzZSk7XG4gICAgdmFyIHJlamVjdGVkID0gZmFsc2U7XG4gICAgdmFyIGlzUHJvbWlzZSA9IG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eVByb21pc2VBcnJheSh0aGlzLCAtMSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICBhY2N1bSA9IG1heWJlUHJvbWlzZS5fdmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuX2dvdEFjY3VtID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgIHJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIShpc1Byb21pc2UgfHwgdGhpcy5femVyb3RoSXNBY2N1bSkpIHRoaXMuX2dvdEFjY3VtID0gdHJ1ZTtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBkb21haW4gPT09IG51bGwgPyBmbiA6IGRvbWFpbi5iaW5kKGZuKTtcbiAgICB0aGlzLl9hY2N1bSA9IGFjY3VtO1xuICAgIGlmICghcmVqZWN0ZWQpIGFzeW5jLmludm9rZShpbml0LCB0aGlzLCB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbn1cbnV0aWwuaW5oZXJpdHMoUmVkdWN0aW9uUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9nb3RBY2N1bSB8fCB0aGlzLl96ZXJvdGhJc0FjY3VtKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fcHJlc2VydmVkVmFsdWVzICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdIDogdGhpcy5fYWNjdW0pO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdmFyIHByZXNlcnZlZFZhbHVlcyA9IHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbiAgICB2YXIgaXNFYWNoID0gcHJlc2VydmVkVmFsdWVzICE9PSBudWxsO1xuICAgIHZhciBnb3RBY2N1bSA9IHRoaXMuX2dvdEFjY3VtO1xuICAgIHZhciB2YWx1ZXNQaGFzZSA9IHRoaXMuX3ZhbHVlc1BoYXNlO1xuICAgIHZhciB2YWx1ZXNQaGFzZUluZGV4O1xuICAgIGlmICghdmFsdWVzUGhhc2UpIHtcbiAgICAgICAgdmFsdWVzUGhhc2UgPSB0aGlzLl92YWx1ZXNQaGFzZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IgKHZhbHVlc1BoYXNlSW5kZXg9MDsgdmFsdWVzUGhhc2VJbmRleDxsZW5ndGg7ICsrdmFsdWVzUGhhc2VJbmRleCkge1xuICAgICAgICAgICAgdmFsdWVzUGhhc2VbdmFsdWVzUGhhc2VJbmRleF0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlc1BoYXNlSW5kZXggPSB2YWx1ZXNQaGFzZVtpbmRleF07XG5cbiAgICBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5femVyb3RoSXNBY2N1bSkge1xuICAgICAgICB0aGlzLl9hY2N1bSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9nb3RBY2N1bSA9IGdvdEFjY3VtID0gdHJ1ZTtcbiAgICAgICAgdmFsdWVzUGhhc2VbaW5kZXhdID0gKCh2YWx1ZXNQaGFzZUluZGV4ID09PSAwKVxuICAgICAgICAgICAgPyAxIDogMik7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fYWNjdW0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZ290QWNjdW0gPSBnb3RBY2N1bSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlc1BoYXNlSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHZhbHVlc1BoYXNlW2luZGV4XSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXNQaGFzZVtpbmRleF0gPSAyO1xuICAgICAgICAgICAgdGhpcy5fYWNjdW0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdvdEFjY3VtKSByZXR1cm47XG5cbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9wcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgdmFyIHJldDtcblxuICAgIGZvciAodmFyIGkgPSB0aGlzLl9yZWR1Y2luZ0luZGV4OyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWVzUGhhc2VJbmRleCA9IHZhbHVlc1BoYXNlW2ldO1xuICAgICAgICBpZiAodmFsdWVzUGhhc2VJbmRleCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5fcmVkdWNpbmdJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlc1BoYXNlSW5kZXggIT09IDEpIHJldHVybjtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIGlmIChpc0VhY2gpIHtcbiAgICAgICAgICAgIHByZXNlcnZlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJldCA9IHRyeUNhdGNoKGNhbGxiYWNrKS5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgaSwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHRyeUNhdGNoKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYWxsKHJlY2VpdmVyLCB0aGlzLl9hY2N1bSwgdmFsdWUsIGksIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSByZXR1cm4gdGhpcy5fcmVqZWN0KHJldC5lKTtcblxuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXQsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UuX2lzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzUGhhc2VbaV0gPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2UuX3Byb3h5UHJvbWlzZUFycmF5KHRoaXMsIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXliZVByb21pc2UuX2lzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBtYXliZVByb21pc2UuX3ZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWR1Y2luZ0luZGV4ID0gaSArIDE7XG4gICAgICAgIHRoaXMuX2FjY3VtID0gcmV0O1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc29sdmUoaXNFYWNoID8gcHJlc2VydmVkVmFsdWVzIDogdGhpcy5fYWNjdW0pO1xufTtcblxuZnVuY3Rpb24gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGFwaVJlamVjdGlvbihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgdmFyIGFycmF5ID0gbmV3IFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xuICAgIHJldHVybiBhcnJheS5wcm9taXNlKCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBmbiwgaW5pdGlhbFZhbHVlLCBudWxsKTtcbn07XG5cblByb21pc2UucmVkdWNlID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHJldHVybiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbn07XG59O1xuXG59LHtcIi4vYXN5bmMuanNcIjoyLFwiLi91dGlsLmpzXCI6Mzh9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBzY2hlZHVsZTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBub0FzeW5jU2NoZWR1bGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL20zT1RYa1xcdTAwMGFcIik7XG59O1xuaWYgKHV0aWwuaXNOb2RlICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIEdsb2JhbFNldEltbWVkaWF0ZSA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIFByb2Nlc3NOZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgc2NoZWR1bGUgPSB1dGlsLmlzUmVjZW50Tm9kZVxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oZm4pIHsgR2xvYmFsU2V0SW1tZWRpYXRlLmNhbGwoZ2xvYmFsLCBmbik7IH1cbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGZuKSB7IFByb2Nlc3NOZXh0VGljay5jYWxsKHByb2Nlc3MsIGZuKTsgfTtcbn0gZWxzZSBpZiAoKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSAmJlxuICAgICAgICAgICEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvciAmJlxuICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZuKTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShkaXYsIHthdHRyaWJ1dGVzOiB0cnVlfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIik7IH07XG4gICAgfTtcbiAgICBzY2hlZHVsZS5pc1N0YXRpYyA9IHRydWU7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgc2NoZWR1bGUgPSBub0FzeW5jU2NoZWR1bGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzY2hlZHVsZTtcblxufSx7XCIuL3V0aWxcIjozOH1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuICAgIGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSkge1xudmFyIFByb21pc2VJbnNwZWN0aW9uID0gUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcblxuZnVuY3Rpb24gU2V0dGxlZFByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJCh2YWx1ZXMpO1xufVxudXRpbC5pbmhlcml0cyhTZXR0bGVkUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlc29sdmVkID0gZnVuY3Rpb24gKGluZGV4LCBpbnNwZWN0aW9uKSB7XG4gICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IGluc3BlY3Rpb247XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICB9XG59O1xuXG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDI2ODQzNTQ1NjtcbiAgICByZXQuX3NldHRsZWRWYWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDEzNDIxNzcyODtcbiAgICByZXQuX3NldHRsZWRWYWx1ZSA9IHJlYXNvbjtcbiAgICB0aGlzLl9wcm9taXNlUmVzb2x2ZWQoaW5kZXgsIHJldCk7XG59O1xuXG5Qcm9taXNlLnNldHRsZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBuZXcgU2V0dGxlZFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0dGxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU2V0dGxlZFByb21pc2VBcnJheSh0aGlzKS5wcm9taXNlKCk7XG59O1xufTtcblxufSx7XCIuL3V0aWwuanNcIjozOH1dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciBSYW5nZUVycm9yID0gX2RlcmVxXyhcIi4vZXJyb3JzLmpzXCIpLlJhbmdlRXJyb3I7XG52YXIgQWdncmVnYXRlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnMuanNcIikuQWdncmVnYXRlRXJyb3I7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcblxuXG5mdW5jdGlvbiBTb21lUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG4gICAgdGhpcy5faG93TWFueSA9IDA7XG4gICAgdGhpcy5fdW53cmFwID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoU29tZVByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9ob3dNYW55ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xuICAgIHZhciBpc0FycmF5UmVzb2x2ZWQgPSBpc0FycmF5KHRoaXMuX3ZhbHVlcyk7XG4gICAgaWYgKCF0aGlzLl9pc1Jlc29sdmVkKCkgJiZcbiAgICAgICAgaXNBcnJheVJlc29sdmVkICYmXG4gICAgICAgIHRoaXMuX2hvd01hbnkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QodGhpcy5fZ2V0UmFuZ2VFcnJvcih0aGlzLmxlbmd0aCgpKSk7XG4gICAgfVxufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5faW5pdCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0VW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Vud3JhcCA9IHRydWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5ob3dNYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3dNYW55O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0SG93TWFueSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHRoaXMuX2hvd01hbnkgPSBjb3VudDtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fYWRkRnVsZmlsbGVkKHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZnVsZmlsbGVkKCkgPT09IHRoaXMuaG93TWFueSgpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSB0aGlzLmhvd01hbnkoKTtcbiAgICAgICAgaWYgKHRoaXMuaG93TWFueSgpID09PSAxICYmIHRoaXMuX3Vud3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl9hZGRSZWplY3RlZChyZWFzb24pO1xuICAgIGlmICh0aGlzLmhvd01hbnkoKSA+IHRoaXMuX2NhblBvc3NpYmx5RnVsZmlsbCgpKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEFnZ3JlZ2F0ZUVycm9yKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCgpOyBpIDwgdGhpcy5fdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBlLnB1c2godGhpcy5fdmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWplY3QoZSk7XG4gICAgfVxufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxSZXNvbHZlZDtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aCAtIHRoaXMubGVuZ3RoKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYWRkUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdmFsdWVzLnB1c2gocmVhc29uKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hZGRGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZXNbdGhpcy5fdG90YWxSZXNvbHZlZCsrXSA9IHZhbHVlO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2NhblBvc3NpYmx5RnVsZmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGgoKSAtIHRoaXMuX3JlamVjdGVkKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZ2V0UmFuZ2VFcnJvciA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHZhciBtZXNzYWdlID0gXCJJbnB1dCBhcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgXCIgK1xuICAgICAgICAgICAgdGhpcy5faG93TWFueSArIFwiIGl0ZW1zIGJ1dCBjb250YWlucyBvbmx5IFwiICsgY291bnQgKyBcIiBpdGVtc1wiO1xuICAgIHJldHVybiBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlRW1wdHlBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZWplY3QodGhpcy5fZ2V0UmFuZ2VFcnJvcigwKSk7XG59O1xuXG5mdW5jdGlvbiBzb21lKHByb21pc2VzLCBob3dNYW55KSB7XG4gICAgaWYgKChob3dNYW55IHwgMCkgIT09IGhvd01hbnkgfHwgaG93TWFueSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIHBvc2l0aXZlIGludGVnZXJcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC8xd0FtSHhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFNvbWVQcm9taXNlQXJyYXkocHJvbWlzZXMpO1xuICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICByZXQuc2V0SG93TWFueShob3dNYW55KTtcbiAgICByZXQuaW5pdCgpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnNvbWUgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGhvd01hbnkpIHtcbiAgICByZXR1cm4gc29tZShwcm9taXNlcywgaG93TWFueSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGhvd01hbnkpIHtcbiAgICByZXR1cm4gc29tZSh0aGlzLCBob3dNYW55KTtcbn07XG5cblByb21pc2UuX1NvbWVQcm9taXNlQXJyYXkgPSBTb21lUHJvbWlzZUFycmF5O1xufTtcblxufSx7XCIuL2Vycm9ycy5qc1wiOjEzLFwiLi91dGlsLmpzXCI6Mzh9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xuZnVuY3Rpb24gUHJvbWlzZUluc3BlY3Rpb24ocHJvbWlzZSkge1xuICAgIGlmIChwcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB0aGlzLl9zZXR0bGVkVmFsdWUgPSBwcm9taXNlLl9zZXR0bGVkVmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCBmdWxmaWxsbWVudCB2YWx1ZSBvZiBhIG5vbi1mdWxmaWxsZWQgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL2hjMURMalxcdTAwMGFcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWU7XG59O1xuXG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuZXJyb3IgPVxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IHJlamVjdGlvbiByZWFzb24gb2YgYSBub24tcmVqZWN0ZWQgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL2hQdWl3QlxcdTAwMGFcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWU7XG59O1xuXG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPVxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjg0MzU0NTYpID4gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1JlamVjdGVkID1cblByb21pc2UucHJvdG90eXBlLl9pc1JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMzQyMTc3MjgpID4gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1BlbmRpbmcgPVxuUHJvbWlzZS5wcm90b3R5cGUuX2lzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDAyNjUzMTg0KSA9PT0gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1Jlc29sdmVkID1cblByb21pc2UucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA0MDI2NTMxODQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5faXNQZW5kaW5nKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldCgpLl9pc1JlamVjdGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5faXNGdWxmaWxsZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX2lzUmVzb2x2ZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVhc29uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICBpZiAoIXRhcmdldC5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIG9mIGEgbm9uLWZ1bGZpbGxlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvaGMxRExqXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5fc2V0dGxlZFZhbHVlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVhc29uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIGlmICghdGFyZ2V0LmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCByZWplY3Rpb24gcmVhc29uIG9mIGEgbm9uLXJlamVjdGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9oUHVpd0JcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICByZXR1cm4gdGFyZ2V0Ll9zZXR0bGVkVmFsdWU7XG59O1xuXG5cblByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlSW5zcGVjdGlvbjtcbn07XG5cbn0se31dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIHRyeUNvbnZlcnRUb1Byb21pc2Uob2JqLCBjb250ZXh0KSB7XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSkge1xuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgIG9iai5fdGhlbihcbiAgICAgICAgICAgICAgICByZXQuX2Z1bGZpbGxVbmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgcmV0Ll9yZWplY3RVbmNoZWNrZWRDaGVja0Vycm9yLFxuICAgICAgICAgICAgICAgIHJldC5fcHJvZ3Jlc3NVbmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGVuID0gdXRpbC50cnlDYXRjaChnZXRUaGVuKShvYmopO1xuICAgICAgICBpZiAodGhlbiA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KHRoZW4uZSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9UaGVuYWJsZShvYmosIHRoZW4sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xufVxuXG52YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSB7XG4gICAgcmV0dXJuIGhhc1Byb3AuY2FsbChvYmosIFwiX3Byb21pc2UwXCIpO1xufVxuXG5mdW5jdGlvbiBkb1RoZW5hYmxlKHgsIHRoZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICB2YXIgcmV0ID0gcHJvbWlzZTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgdmFyIHN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbC50cnlDYXRjaCh0aGVuKS5jYWxsKHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZyb21UaGVuYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RGcm9tVGhlbmFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NGcm9tVGhlbmFibGUpO1xuICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgaWYgKHByb21pc2UgJiYgcmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tVGhlbmFibGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlKSByZXR1cm47XG4gICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdEZyb21UaGVuYWJsZShyZWFzb24pIHtcbiAgICAgICAgaWYgKCFwcm9taXNlKSByZXR1cm47XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgc3luY2hyb25vdXMsIHRydWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9ncmVzc0Zyb21UaGVuYWJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9taXNlLl9wcm9ncmVzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9wcm9ncmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxucmV0dXJuIHRyeUNvbnZlcnRUb1Byb21pc2U7XG59O1xuXG59LHtcIi4vdXRpbC5qc1wiOjM4fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgVGltZW91dEVycm9yID0gUHJvbWlzZS5UaW1lb3V0RXJyb3I7XG5cbnZhciBhZnRlclRpbWVvdXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgbWVzc2FnZSkge1xuICAgIGlmICghcHJvbWlzZS5pc1BlbmRpbmcoKSkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gXCJvcGVyYXRpb24gdGltZWQgb3V0XCI7XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGVycik7XG4gICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShlcnIpO1xuICAgIHByb21pc2UuX2NhbmNlbChlcnIpO1xufTtcblxudmFyIGFmdGVyVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZGVsYXkoK3RoaXMpLnRoZW5SZXR1cm4odmFsdWUpOyB9O1xudmFyIGRlbGF5ID0gUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uICh2YWx1ZSwgbXMpIHtcbiAgICBpZiAobXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtcyA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgcmV0Ll9mdWxmaWxsKCk7IH0sIG1zKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgbXMgPSArbXM7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkuX3RoZW4oYWZ0ZXJWYWx1ZSwgbnVsbCwgbnVsbCwgbXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChtcykge1xuICAgIHJldHVybiBkZWxheSh0aGlzLCBtcyk7XG59O1xuXG5mdW5jdGlvbiBzdWNjZXNzQ2xlYXIodmFsdWUpIHtcbiAgICB2YXIgaGFuZGxlID0gdGhpcztcbiAgICBpZiAoaGFuZGxlIGluc3RhbmNlb2YgTnVtYmVyKSBoYW5kbGUgPSAraGFuZGxlO1xuICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmFpbHVyZUNsZWFyKHJlYXNvbikge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzO1xuICAgIGlmIChoYW5kbGUgaW5zdGFuY2VvZiBOdW1iZXIpIGhhbmRsZSA9ICtoYW5kbGU7XG4gICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgdGhyb3cgcmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgbXMgPSArbXM7XG4gICAgdmFyIHJldCA9IHRoaXMudGhlbigpLmNhbmNlbGxhYmxlKCk7XG4gICAgcmV0Ll9jYW5jZWxsYXRpb25QYXJlbnQgPSB0aGlzO1xuICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRUaW1lb3V0KCkge1xuICAgICAgICBhZnRlclRpbWVvdXQocmV0LCBtZXNzYWdlKTtcbiAgICB9LCBtcyk7XG4gICAgcmV0dXJuIHJldC5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhciwgdW5kZWZpbmVkLCBoYW5kbGUsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuXG59LHtcIi4vdXRpbC5qc1wiOjM4fV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgY3JlYXRlQ29udGV4dCkge1xuICAgIHZhciBUeXBlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnMuanNcIikuVHlwZUVycm9yO1xuICAgIHZhciBpbmhlcml0cyA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIikuaW5oZXJpdHM7XG4gICAgdmFyIFByb21pc2VJbnNwZWN0aW9uID0gUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbjtcblxuICAgIGZ1bmN0aW9uIGluc3BlY3Rpb25NYXBwZXIoaW5zcGVjdGlvbnMpIHtcbiAgICAgICAgdmFyIGxlbiA9IGluc3BlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBpbnNwZWN0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0aW9uLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChpbnNwZWN0aW9uLmVycm9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zcGVjdGlvbnNbaV0gPSBpbnNwZWN0aW9uLl9zZXR0bGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3BlY3Rpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZTt9LCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYXN0UHJlc2VydmluZ0Rpc3Bvc2FibGUodGhlbmFibGUpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhlbmFibGUpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9nZXREaXNwb3NlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0aGVuYWJsZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fc2V0RGlzcG9zYWJsZSh0aGVuYWJsZS5fZ2V0RGlzcG9zZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcmVzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IFByb21pc2UuZGVmZXIoKTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHJldHVybiByZXQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZShyZXNvdXJjZXNbaSsrXSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9nZXREaXNwb3NlcigpLnRyeURpc3Bvc2UoaW5zcGVjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dlcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihpdGVyYXRvciwgdGhyb3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiByZXQucHJvbWlzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwb3NlclN1Y2Nlc3ModmFsdWUpIHtcbiAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICAgICAgaW5zcGVjdGlvbi5fc2V0dGxlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGluc3BlY3Rpb24uX2JpdEZpZWxkID0gMjY4NDM1NDU2O1xuICAgICAgICByZXR1cm4gZGlzcG9zZSh0aGlzLCBpbnNwZWN0aW9uKS50aGVuUmV0dXJuKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwb3NlckZhaWwocmVhc29uKSB7XG4gICAgICAgIHZhciBpbnNwZWN0aW9uID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgICAgIGluc3BlY3Rpb24uX3NldHRsZWRWYWx1ZSA9IHJlYXNvbjtcbiAgICAgICAgaW5zcGVjdGlvbi5fYml0RmllbGQgPSAxMzQyMTc3Mjg7XG4gICAgICAgIHJldHVybiBkaXNwb3NlKHRoaXMsIGluc3BlY3Rpb24pLnRoZW5UaHJvdyhyZWFzb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERpc3Bvc2VyKGRhdGEsIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlKCkuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS50cnlEaXNwb3NlID0gZnVuY3Rpb24oaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlKCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJldCA9IHJlc291cmNlICE9PSBudWxsXG4gICAgICAgICAgICA/IHRoaXMuZG9EaXNwb3NlKHJlc291cmNlLCBpbnNwZWN0aW9uKSA6IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fdW5zZXREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5pc0Rpc3Bvc2VyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIChkICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC5yZXNvdXJjZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQudHJ5RGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25EaXNwb3NlcihmbiwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJChmbiwgcHJvbWlzZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGluaGVyaXRzKEZ1bmN0aW9uRGlzcG9zZXIsIERpc3Bvc2VyKTtcblxuICAgIEZ1bmN0aW9uRGlzcG9zZXIucHJvdG90eXBlLmRvRGlzcG9zZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgZm4gPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwocmVzb3VyY2UsIHJlc291cmNlLCBpbnNwZWN0aW9uKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVVbndyYXBEaXNwb3Nlcih2YWx1ZSkge1xuICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3Nlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzW3RoaXMuaW5kZXhdLl9zZXREaXNwb3NhYmxlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIFByb21pc2UudXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgMikgcmV0dXJuIGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieW91IG11c3QgcGFzcyBhdCBsZWFzdCAyIGFyZ3VtZW50cyB0byBQcm9taXNlLnVzaW5nXCIpO1xuICAgICAgICB2YXIgZm4gPSBhcmd1bWVudHNbbGVuIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGFwaVJlamVjdGlvbihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICB2YXIgcmVzb3VyY2VzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHJlc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNwb3NlciA9IHJlc291cmNlO1xuICAgICAgICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2UucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLl9zZXREaXNwb3NhYmxlKGRpc3Bvc2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihtYXliZVVud3JhcERpc3Bvc2VyLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvdXJjZXNbaV0gPSByZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5zZXR0bGUocmVzb3VyY2VzKVxuICAgICAgICAgICAgLnRoZW4oaW5zcGVjdGlvbk1hcHBlcilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZm4uYXBwbHkodW5kZWZpbmVkLCB2YWxzKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLl90aGVuKFxuICAgICAgICAgICAgICAgIGRpc3Bvc2VyU3VjY2VzcywgZGlzcG9zZXJGYWlsLCB1bmRlZmluZWQsIHJlc291cmNlcywgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzb3VyY2VzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2MjE0NDtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSBkaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2MjE0NCkgPiAwO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fZ2V0RGlzcG9zZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjYyMTQ0KTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLmRpc3Bvc2VyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkRpc3Bvc2VyKGZuLCB0aGlzLCBjcmVhdGVDb250ZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9O1xuXG59O1xuXG59LHtcIi4vZXJyb3JzLmpzXCI6MTMsXCIuL3V0aWwuanNcIjozOH1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNS5qc1wiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBoYXZlR2V0dGVycyA9IChmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge307XG4gICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShvLCBcImZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gby5mID09PSAzO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59KSgpO1xuXG52YXIgZXJyb3JPYmogPSB7ZToge319O1xudmFyIHRyeUNhdGNoVGFyZ2V0O1xuZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdHJ5Q2F0Y2hUYXJnZXQ7XG4gICAgICAgIHRyeUNhdGNoVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uKENoaWxkLCBQYXJlbnQpIHtcbiAgICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gVCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJCA9IFBhcmVudDtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIFBhcmVudC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoUGFyZW50LnByb3RvdHlwZSwgcHJvcGVydHlOYW1lKSAmJlxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZS5jaGFyQXQocHJvcGVydHlOYW1lLmxlbmd0aC0xKSAhPT0gXCIkXCJcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWUgKyBcIiRcIl0gPSBQYXJlbnQucHJvdG90eXBlW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVC5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgIENoaWxkLnByb3RvdHlwZSA9IG5ldyBUKCk7XG4gICAgcmV0dXJuIENoaWxkLnByb3RvdHlwZTtcbn07XG5cblxuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlIHx8XG4gICAgICAgIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIjtcblxufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAhaXNQcmltaXRpdmUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXliZVdyYXBBc0Vycm9yKG1heWJlRXJyb3IpIHtcbiAgICBpZiAoIWlzUHJpbWl0aXZlKG1heWJlRXJyb3IpKSByZXR1cm4gbWF5YmVFcnJvcjtcblxuICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKG1heWJlRXJyb3IpKTtcbn1cblxuZnVuY3Rpb24gd2l0aEFwcGVuZGVkKHRhcmdldCwgYXBwZW5kZWUpIHtcbiAgICB2YXIgbGVuID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByZXRbaV0gPSB0YXJnZXRbaV07XG4gICAgfVxuICAgIHJldFtpXSA9IGFwcGVuZGVlO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGVzNS5pc0VTNSkge1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuXG4gICAgICAgIGlmIChkZXNjICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBkZXNjLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpID8gb2JqW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3RFbnVtZXJhYmxlUHJvcChvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKG9iaikpIHJldHVybiBvYmo7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9O1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHRocm93ZXIocikge1xuICAgIHRocm93IHI7XG59XG5cbnZhciBpbmhlcml0ZWREYXRhS2V5cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZXhjbHVkZWRQcm90b3R5cGVzID0gW1xuICAgICAgICBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZVxuICAgIF07XG5cbiAgICB2YXIgaXNFeGNsdWRlZFByb3RvID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWRQcm90b3R5cGVzW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGdldEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWRLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHdoaWxlIChvYmogIT0gbnVsbCAmJiAhaXNFeGNsdWRlZFByb3RvKG9iaikpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gZ2V0S2V5cyhvYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZEtleXNba2V5XSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAhPSBudWxsICYmIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmogPSBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKGlzRXhjbHVkZWRQcm90byhvYmopKSByZXR1cm4gW107XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgICAgIC8qanNoaW50IGZvcmluOmZhbHNlICovXG4gICAgICAgICAgICBlbnVtZXJhdGlvbjogZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGNsdWRlZFByb3RvdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoZXhjbHVkZWRQcm90b3R5cGVzW2ldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZW51bWVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH1cblxufSkoKTtcblxudmFyIHRoaXNBc3NpZ25tZW50UGF0dGVybiA9IC90aGlzXFxzKlxcLlxccypcXFMrXFxzKj0vO1xuZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBlczUubmFtZXMoZm4ucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgdmFyIGhhc01ldGhvZHMgPSBlczUuaXNFUzUgJiYga2V5cy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgdmFyIGhhc01ldGhvZHNPdGhlclRoYW5Db25zdHJ1Y3RvciA9IGtleXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICEoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgIHZhciBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMgPVxuICAgICAgICAgICAgICAgIHRoaXNBc3NpZ25tZW50UGF0dGVybi50ZXN0KGZuICsgXCJcIikgJiYgZXM1Lm5hbWVzKGZuKS5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgICBpZiAoaGFzTWV0aG9kcyB8fCBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgfHxcbiAgICAgICAgICAgICAgICBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b0Zhc3RQcm9wZXJ0aWVzKG9iaikge1xuICAgIC8qanNoaW50IC1XMDI3LC1XMDU1LC1XMDMxKi9cbiAgICBmdW5jdGlvbiBmKCkge31cbiAgICBmLnByb3RvdHlwZSA9IG9iajtcbiAgICB2YXIgbCA9IDg7XG4gICAgd2hpbGUgKGwtLSkgbmV3IGYoKTtcbiAgICByZXR1cm4gb2JqO1xuICAgIGV2YWwob2JqKTtcbn1cblxudmFyIHJpZGVudCA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyKHN0cikge1xuICAgIHJldHVybiByaWRlbnQudGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiBmaWxsZWRSYW5nZShjb3VudCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICByZXRbaV0gPSBwcmVmaXggKyBpICsgc3VmZml4O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9iaiArIFwiXCI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gXCJbbm8gc3RyaW5nIHJlcHJlc2VudGF0aW9uXVwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICB0cnkge1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChlLCBcImlzT3BlcmF0aW9uYWxcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGNhdGNoKGlnbm9yZSkge31cbn1cblxuZnVuY3Rpb24gb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24oZSkge1xuICAgIGlmIChlID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKChlIGluc3RhbmNlb2YgRXJyb3JbXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCJdLk9wZXJhdGlvbmFsRXJyb3IpIHx8XG4gICAgICAgIGVbXCJpc09wZXJhdGlvbmFsXCJdID09PSB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY2FuQXR0YWNoVHJhY2Uob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yICYmIGVzNS5wcm9wZXJ0eUlzV3JpdGFibGUob2JqLCBcInN0YWNrXCIpO1xufVxuXG52YXIgZW5zdXJlRXJyb3JPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIG5ldyBFcnJvcigpKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7dGhyb3cgbmV3IEVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkpO31cbiAgICAgICAgICAgIGNhdGNoKGVycikge3JldHVybiBlcnI7fVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBjbGFzc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBjb3B5RGVzY3JpcHRvcnMoZnJvbSwgdG8sIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZyb20pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGZpbHRlcihrZXkpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eSh0bywga2V5LCBlczUuZ2V0RGVzY3JpcHRvcihmcm9tLCBrZXkpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHJldCA9IHtcbiAgICBpc0NsYXNzOiBpc0NsYXNzLFxuICAgIGlzSWRlbnRpZmllcjogaXNJZGVudGlmaWVyLFxuICAgIGluaGVyaXRlZERhdGFLZXlzOiBpbmhlcml0ZWREYXRhS2V5cyxcbiAgICBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQ6IGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdCxcbiAgICB0aHJvd2VyOiB0aHJvd2VyLFxuICAgIGlzQXJyYXk6IGVzNS5pc0FycmF5LFxuICAgIGhhdmVHZXR0ZXJzOiBoYXZlR2V0dGVycyxcbiAgICBub3RFbnVtZXJhYmxlUHJvcDogbm90RW51bWVyYWJsZVByb3AsXG4gICAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBjYW5FdmFsdWF0ZTogY2FuRXZhbHVhdGUsXG4gICAgZXJyb3JPYmo6IGVycm9yT2JqLFxuICAgIHRyeUNhdGNoOiB0cnlDYXRjaCxcbiAgICBpbmhlcml0czogaW5oZXJpdHMsXG4gICAgd2l0aEFwcGVuZGVkOiB3aXRoQXBwZW5kZWQsXG4gICAgbWF5YmVXcmFwQXNFcnJvcjogbWF5YmVXcmFwQXNFcnJvcixcbiAgICB0b0Zhc3RQcm9wZXJ0aWVzOiB0b0Zhc3RQcm9wZXJ0aWVzLFxuICAgIGZpbGxlZFJhbmdlOiBmaWxsZWRSYW5nZSxcbiAgICB0b1N0cmluZzogc2FmZVRvU3RyaW5nLFxuICAgIGNhbkF0dGFjaFRyYWNlOiBjYW5BdHRhY2hUcmFjZSxcbiAgICBlbnN1cmVFcnJvck9iamVjdDogZW5zdXJlRXJyb3JPYmplY3QsXG4gICAgb3JpZ2luYXRlc0Zyb21SZWplY3Rpb246IG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLFxuICAgIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbjogbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uLFxuICAgIGNsYXNzU3RyaW5nOiBjbGFzc1N0cmluZyxcbiAgICBjb3B5RGVzY3JpcHRvcnM6IGNvcHlEZXNjcmlwdG9ycyxcbiAgICBoYXNEZXZUb29sczogdHlwZW9mIGNocm9tZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjaHJvbWUgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIGNocm9tZS5sb2FkVGltZXMgPT09IFwiZnVuY3Rpb25cIixcbiAgICBpc05vZGU6IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIGNsYXNzU3RyaW5nKHByb2Nlc3MpLnRvTG93ZXJDYXNlKCkgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiXG59O1xucmV0LmlzUmVjZW50Tm9kZSA9IHJldC5pc05vZGUgJiYgKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICByZXR1cm4gKHZlcnNpb25bMF0gPT09IDAgJiYgdmVyc2lvblsxXSA+IDEwKSB8fCAodmVyc2lvblswXSA+IDApO1xufSkoKTtcblxuaWYgKHJldC5pc05vZGUpIHJldC50b0Zhc3RQcm9wZXJ0aWVzKHByb2Nlc3MpO1xuXG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7cmV0Lmxhc3RMaW5lRXJyb3IgPSBlO31cbm1vZHVsZS5leHBvcnRzID0gcmV0O1xuXG59LHtcIi4vZXM1LmpzXCI6MTR9XX0se30sWzRdKSg0KVxufSk7ICAgICAgICAgICAgICAgICAgICA7aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAhPT0gbnVsbCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuUCA9IHdpbmRvdy5Qcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiAhPT0gbnVsbCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5QID0gc2VsZi5Qcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIl19
