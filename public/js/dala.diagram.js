(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
require('./ui/jqueryPlugins');
require('./svg/draggable');

if(!window.dala) {
    dala = {};
}

dala_env = window.dala_env || {};
dala_env.initial_templates = {};


var event = require('./core/event');

//TODO: better namespace handling... export to module
var globalModules =  {
    'templateManager': require('./diagram/templateManager'),
    'diagramManager': require('./diagram/diagramManager'),
    'additions': require('./diagram/additions'),
    'config': require('./core/config'),
    'fileManager': require('./core/fileManager'),
    'event' : require('./core/event')
};

dala.require = function(id) {
    return globalModules[id];
};



if(!window.dala.SVG) {
    window.dala.SVG = require('./svg/svg');
}

if(!window.dala.Diagram) {
    window.dala.Diagram = require('./diagram/diagram');
}


//TODO: move this to a controller !
$(window).bind('mousewheel DOMMouseScroll', function(evt){
    if(!evt.ctrlKey) {
        return;
    }

    evt.preventDefault();

    if (evt.originalEvent.wheelDelta > 0 || evt.originalEvent.detail < 0) {
        event.trigger('view_zoomIn');
    }
    else {
        event.trigger('view_zoomOut');
    }
});

var stageFocus = false;

$('html').on('mousedown', function() {
    stageFocus = false;
});

//TODO: Check redundancy with client.all...

//TODO: check other key events for stageFocus
$(document).on('click', '.svgStage', function(evt) {
    stageFocus = true;
    evt.stopPropagation();
});

event.on(document, 'keydown', function(e) {
    e.mouse = event.mouse();
    //console.log('keypress: '+e.keyCode);
    switch(e.keyCode) {
        case 13: //ENTER
            event.trigger('key_enter_press', {}, e);
            break;
        case 38: //UP
            event.trigger('key_up_press', {}, e);
            break;
        case 40: //DOWN
            event.trigger('key_down_press', {}, e);
            break;
        case 46: //DELETE
            event.trigger('key_del_press', {}, e);
            break;
        case 67: //c
            if(e.ctrlKey && !isTextSelected()) {
                event.trigger('key_copy_press', {}, e);
            }
            break;
        case 83: //s
            if(e.ctrlKey) {
                e.preventDefault();
                event.trigger('key_save_press', {}, e);
            }
            break;
        case 86: //v
            if(e.ctrlKey && stageFocus) {
                e.preventDefault();
                event.trigger('key_paste_press', {}, e);
            }
            break;
        case 89: //y
            if(e.ctrlKey) {
                event.trigger('key_redo_press', {}, e);
            }
            break;
        case 90: //z
            if(e.ctrlKey) {
                event.trigger('key_undo_press', {}, e);
            }
            break;
        case 187:
            if(e.ctrlKey) {
                e.preventDefault();
                event.trigger('view_zoomIn');
            }
            break;
        case 189:
            if(e.ctrlKey) {
                e.preventDefault();
                event.trigger('view_zoomOut');
            }
            break;
    }
});


},{"./core/config":6,"./core/event":7,"./core/fileManager":8,"./diagram/additions":14,"./diagram/diagram":17,"./diagram/diagramManager":18,"./diagram/templateManager":39,"./svg/draggable":54,"./svg/svg":63,"./ui/jqueryPlugins":71}],2:[function(require,module,exports){
var object = require('../util/object');
var dom = require('../dom/dom');
var string = require('../util/string');

var Cache = function() {
    this.queryCache = {};
    this.svgCache = {};
};

Cache.prototype.clearBySuffix = function(suffix) {
    for(key in this.queryCache) {
        if(this.queryCache.hasOwnProperty(key) && string.endsWith(key, suffix)) {
            delete this.queryCache[key];
        };
    }

    for(key in this.svgCache) {
        if(this.svgCache.hasOwnProperty(key) && string.endsWith(key, suffix)) {
            delete this.svgCache[key];
        };
    }
};

Cache.prototype.$ = function(obj, preventCache) {
    if(!obj) {
        return;
    }

    if(this.queryCache[obj]) {
        return this.queryCache[obj];
    }

    var settings = this.getCacheSettings(obj, this.queryCache);
    return this.cacheCheck(settings.key, settings.$node, this.queryCache, preventCache);
};

Cache.prototype.svg = function(obj, preventCache) {
    if(!obj) {
        return;
    }

    if(this.svgCache[obj]) {
        return this.svgCache[obj];
    }

    var settings = this.getCacheSettings(obj, this.svgCache);
    return this.cacheCheck(settings.key, $.svg(settings.$node), this.svgCache, preventCache);
};

Cache.prototype.getCacheSettings = function(obj, cache) {
    var settings = {};

    if(object.isString(obj)){
        settings.$node = this.queryCache[obj] || $(obj);
        settings.key = obj;
    } else if(obj.jQuery) {
        settings.$node = obj;
        settings.key = dom.getIdSelector(obj.attr('id'));
    } else {
            settings.$node = $(obj);
            settings.key = dom.getIdSelector(settings.$node.attr('id'));
    }

    return settings;
}

Cache.prototype.cacheCheck = function(key, obj, cache, preventCache) {
    preventCache = preventCache || false;
    if(key && obj) {
        return (!preventCache) ? cache[key] = obj : obj;
    } else {
        return obj;
    }
}

Cache.prototype.remove = function(obj) {
    if(object.isString(obj)) {
        delete this.queryCache[obj];
    }
};

Cache.prototype.exists = function(selector) {
    return object.isDefined(queryCach[selector]);
};

Cache.prototype.sub = function() {
    return new Cache();
};

module.exports = new Cache();
},{"../dom/dom":47,"../util/object":77,"../util/string":78}],3:[function(require,module,exports){
var event = require('./event');
var object = require('../util/object');
var string = require('../util/string');

var Response = function(data) {
    this.data = data;
};

Response.prototype.isConfirmation = function() {
    return this.data && (this.data.status === 0);
};

Response.prototype.isError = function() {
    return this.data && this.data.status && (this.data.status > 0);
};

Response.prototype.getError = function() {
    return this.data.error;
};

Response.prototype.getErrorCode = function() {
    return this.data.errorCode;
};

Response.prototype.toString = function() {
    return "{ status: "+this.data.status+" error: "+this.data.error+" data: "+this.data.data+" }";
};

var config = {
    host : 'localhost',
    port : 3000
};

var errorHandler = function(cfg, xhr,type,errorThrown, errorCode) {
    errorCode = (xhr) ? xhr.status : parseInt(errorCode);
    console.warn("ajaxError: "+type+" "+errorThrown+" - "+errorCode);

    if(cfg.errorMessage) {
        if(object.isString(cfg.errorMessage)) {
            event.trigger('error', cfg.errorMessage);
        } else if(object.isObject(cfg.errorMessage, errorCode)) {
            var msg = cfg.errorMessage[errorCode] || cfg.errorMessage['default'];
            if(object.isDefined(msg)) {
                event.trigger('error', msg);
            }
        }
    }

    if(cfg.error && object.isFunction(cfg.error)) {
        // "timeout", "error", "abort", "parsererror" or "application"
        cfg.error(errorThrown, errorCode, type);
    } else if(cfg.error) {
        var msg = cfg.error[errorCode] || cfg.error['default'];
        if(object.isDefined(msg)) {
            event.trigger('error', msg);
        }
    }

    if(!cfg.error && !cfg.errorMessage) {
        console.warn('Unhandled ajax error: '+path+" type"+type+" error: "+errorThrown);
    }
};

module.exports = {
    test: function(settings) {
        this.ping(settings);
    },
    ping: function(settings) {
        settings = settings || config;
        var result = false;
        $.ajax({
            url: "http://"+settings.host+":"+settings.port+"/service/ping",
            //crossDomain: true,
            type : "GET",
            data: {'ping':true},
            async : false,
            dataType: "json",
            success: function (response) {
                result = true;
            },
            error: function (xhr, status, msg) {
                result = false;
            }
        });

        return result;
    },
    ajax: function(path, data, cfg) {
        var cfg = cfg || {};
        var async = cfg.async || true;
        var dataType = cfg.dataType || "json";
        var error = function(xhr,type,errorThrown, errorCode) {
            errorHandler(cfg, xhr,type,errorThrown, errorCode);
        };

        var success = function(response) {
            var responseWrapper = new Response(response);

            if(responseWrapper.isError()) { //Application errors
                return error(undefined,"application",responseWrapper.getError(), responseWrapper.getErrorCode());
            } else if(cfg.success) {
                if(object.isString(cfg.success)) {
                    event.trigger('info', cfg.success);
                } else {
                    cfg.success(responseWrapper);
                }
            }

            if (cfg.successMessage) {
                event.trigger('info', cfg.successMessage);
            }
        };

        var that = this;
        $.ajax({
            url: path,
            //crossDomain: true, //TODO: read from config
            type : cfg.type,
            processData : cfg.processData,
            contentType: cfg.contentType,
            data: data,
            async : async,
            dataType: dataType,
            success: success,
            error: error
        });
    },
    post: function(path, data, cfg) {
        cfg = cfg || {};
        cfg.type = 'POST';
        this.ajax(path, data, cfg);
    },
    get: function(path, cfg) {
        cfg = cfg || {};
        cfg.type = 'GET';
        this.ajax(path, cfg.data, cfg);
    },
    xml: function(path, cfg) {
        cfg = cfg || {};
        cfg.dataType = 'xml';
        return this.get(path,cfg);
    },
    text : function(path, cfg) {
        cfg = cfg || {};
        cfg.dataType = 'text';
        return this.get(path,cfg);
    },
    getScript: function(path, cfg) {
        cfg = cfg || {};

        return $.getScript(path)
            .done(function(s, Status) {
                if(cfg.success) {
                    cfg.success(s, Status);
                }
            }).fail(function(xhr, settings, exception) {
                errorHandler(cfg, xhr,'error',exception);
            });
    },
    restGet: function(path, id, cfg) {
        var path = string.endsWith(path, '/')? path+id : path+'/'+id;
        this.get(path, cfg);
    },
    getUrl: function(addition) {
        var url = "http://"+config.host+":"+config.port;
        if(addition) {
            url += addition;
        }
        return url;
    },
    set: function(settings) {
        config = settings;
    },
    getSettings: function() {
        return config;
    }
}
},{"../util/object":77,"../util/string":78,"./event":7}],4:[function(require,module,exports){
var object = require('../util/object');

var CommandAction = function(client, action) {
    this.client = client;
    this.action = action;
};

CommandAction.prototype.exec = function(args) {
    return this.action.apply(this.client, args);
};

var Command = function(client, doAction, undoAction) {
    if(arguments.length > 0) {
        //Call the exec setter
        this.exec(client,doAction);
        this.undo(client,undoAction);
    }
    this.timestamp = Date.now();
};

Command.prototype.exec = function(client, action, args) {
    return this.action('do', client, action, args);
};

Command.prototype.undo = function(client, action, args) {
    return this.action('undo', client, action, args);
};

Command.prototype.instance = function(doArgs, undoArgs) {
    var instance = $.extend(true, {}, this);

    //If given, we overwrite the argument settings for the actions
    if(doArgs) {
        instance.doArgs = doArgs;
    }

    if(undoArgs) {
        instance.undoArgs = undoArgs;
    }

    instance.id = this.id+'_'+Date.now();

    return instance;
};

/**
 * Just a helper to unify the logic for doAction and undoAction.
 *
 * - if just the type is given we assume all necessary action data is given for this type (do/undo) and call the action
 * - if a there is another argument beside the type we assume an args array and call the action with the given array
 * - if there are more args given, we assume a setter call to set the action data (do/undo)
 *
 * @param type do or undo
 * @param client client object used as this
 * @param action the function to call
 * @param args arguments
 * @returns {Command}
 */
Command.prototype.action = function(type, client, action, args) {
    if(args) {
        this[type + 'Args'] = args;
    }

    if(client && action) {
        this[type + 'Action'] = new CommandAction(client, action);
    } else {
        //Execute either with args settings from this or from argument list
        this[type + 'Args'] = arguments[1] || this[type + 'Args'];
        var action = this[type + 'Action'];
        if(action) {
            return action.exec(this[type + 'Args']);
        }
    }

    return this;
};

module.exports = Command;


},{"../util/object":77}],5:[function(require,module,exports){
var util = require('../util/util');
var object = util.object;
var dom = util.dom;
var event = require('./event');
var Command = require('./command');

//Command instances for diagrams
var instances = {};

var sub = function(subId, updateHandler) {
    return instances[subId] = new CommandManager(subId, updateHandler);
};

var CommandManager = function(subId, updateHandler) {
    this.subId = subId;
    this.commands = {};
    this.undoCommands = [];
    this.redoCommands = [];
    this.updateHandler = updateHandler;
    this.register('cmd_group', new Command(this, function(commands) {
        var that = this;
        $.each(commands, function(index, cmd) {
            that.commands[cmd[0]].instance(cmd[1], cmd[2]).exec();
        });
    }, function(commands) {
        var that = this;
        $.each(commands, function(index, cmd) {
            that.commands[cmd[0]].instance(cmd[1], cmd[2]).undo();
        });
    }));
};

/**
 * We can register a new command for this given command instance (mostly a command for a specific diagram instance)
 * which is identified by its string id.
 *
 * The client and action attribute for the do and undo action should be set for the given actions.
 *
 * @param cmdId string id
 * @param cmd command instance
 */
CommandManager.prototype.register = function(cmdId, cmd) {
    this.commands[cmdId] = cmd;
    cmd.id = cmdId;
};

CommandManager.prototype.addGroup = function(commands) {
    this.add('cmd_group', commands, commands);
};

CommandManager.prototype.execGroup = function(commands) {
    this.exec('cmd_group', commands, commands);
};

CommandManager.prototype.exec = function(cmdId, doArgs, undoArgs) {
    var cmdInstance = this.add(cmdId, doArgs, undoArgs);
    if(cmdInstance) {
        console.log('Execute command '+cmdInstance.id);
        return cmdInstance.exec();
    }
};

CommandManager.prototype.add = function(cmdId, doArgs, undoArgs) {
    var command = this.commands[cmdId];
    if(command) {
        this.updated(command);
        var cmdInstance = command.instance(doArgs,undoArgs);
        if(cmdInstance) {
            console.log('Add command '+cmdInstance.id);
            this.undoCommands.push(cmdInstance);
            if(!this.lockRedo) {
                this.redoCommands = [];
            }
        }
        return cmdInstance
    } else {
        console.warn('Unregistered command '+cmdId+' was called.');
    }
};

CommandManager.prototype.undo = function() {
    var command = this.undoCommands.pop();
    if(object.isDefined(command) && object.isDefined(command.undo)) {
        console.log('Undo command '+command.id);
        command.undo.apply(command);
        this.redoCommands.push(command);
        this.updated(command);
    }
};

CommandManager.prototype.redo = function() {
    var command = this.redoCommands.pop();
    if(object.isDefined(command) && object.isDefined(command.exec)) {
        console.log('Redo command '+command.id);
        this.lockRedo = true;
        command.exec.apply(command);
        this.lockRedo = false;
        this.undoCommands.push(command);
        this.updated(command);
    }
};

CommandManager.prototype.updated = function(command) {
    this.lastChange = Date.now();
    if(this.updateHandler) {
        this.updateHandler(command);
    }
}

module.exports = {
    sub : sub
};


},{"../util/util":79,"./command":4,"./event":7}],6:[function(require,module,exports){
var object = require('../util/object');

var values = {};

module.exports = {
    val : function(key, defaultVal) {
        if(object.isDefined(key)) {
            var result = values[key];
            return (object.isDefined(result)) ? result : defaultVal;
        }
    },

    is : function(key, defaultVal) {
        return this.val(key,defaultVal) === true;
    },

    debug : function(val) {
        if(object.isBoolean(val)) {
            this.setVal('debug', val);
        }
        return this.val('debug', false);
    },

    setVal : function(key, value) {
        if(object.isDefined(key) && object.isDefined(value)) {
            values[key] = value;
            var val = this.val(key);
        }
    },

    replaceConfigValues : function(text, config) {
        var result = text;
        object.each(config, function(key, value) {
            var regExp = new RegExp("{" + key + "}", "g");
            result = result.replace(regExp, value);
        });
        return result;
    }
};
},{"../util/object":77}],7:[function(require,module,exports){
var events = {};

var object = require('../util/object');
var config = require('../core/config');
var SubEvent = require('./subEvent');

var Promise = require('bluebird');

var hasHandler = function(type) {
    return events[type];
};

mouse = {};

$(document).on( 'mousemove', function(e) {
    mouse = e;
});


module.exports = {
    mouse : function() {
        return mouse;
    },
    listen:  function(type, handler, module) {
        if(!object.isFunction(handler)) {
            return;
        }

        var eventConfig = {
            handler : handler,
            module : module
        };

        if(!events[type]) {
            events[type] = [eventConfig];
        } else {
            events[type].push(eventConfig);
        }
    },

    unlisten: function(type, func) {
        if(events[type]) {
            var index = events[type].indexOf(func);
            if(index > -1) {
                events[type].splice(index, 1);
            }
        }
    },

    sub: function(context) {
        return new SubEvent(context, this);
    },

    command: function(command, execute) {
        if(execute) {
            this.trigger('command_execute', command);
        } else {
            this.trigger('command_add', command);
        }
    },

    trigger: function(type, data, rootEvt) {
        var that = this;
        return new Promise(function(resolve, reject) {
            var event = rootEvt || {};

            event.data = data;
            event.type = type;

            if(hasHandler(event.type)) {
                var handlerArr = events[event.type];
                object.each(handlerArr, function(index, eventConfig) {
                    var handler = eventConfig.handler;
                    var module;
                    try {
                        module = eventConfig.module;
                        if(eventConfig.module) {
                            handler.call(eventConfig.module, event);
                        } else {
                            handler(event);
                        }
                    } catch(err) {
                        var modText = (module && module.constructor && module.constructor.name)?module.constructor.name:'unknown';
                        if(modText === 'unknown' && config.debug()) {
                            console.error('Event handler error - module: '+modText+' event: '+event.type, handler, err);
                        } else {
                            console.error('Event handler error - module: '+modText+' event: '+event.type, err);
                        }
                        that.trigger('error', 'An error occured while executing the last action !');
                    }
                });
            }

            //We just resolve in all cases since the caller of trigger should remain independent of handler modules
            resolve();
        });
    },

    on: function(node, event, selector, data, handler) {
        $(node).on(event,selector,data, handler);
    },

    off: function(node, event, selector, handler) {
        $(node).off(event, selector, handler);
    },

    once: function(node, event, selector, data, handler) {
        $(node).one(event,selector,data, handler);
    },

    triggerDom: function(node, event) {
       $(node).trigger(event);
    }
};
},{"../core/config":6,"../util/object":77,"./subEvent":9,"bluebird":83}],8:[function(require,module,exports){
var string = require('../util/string');
var Promise = require('bluebird');
var currentUrl;

var suffixMapping = {
    'image/jpeg': 'jpg' ,
    'image/gif': 'gif',
    'image/png' : 'png',
    'image/svg+xml' : 'svg'
};

var getFileNameWithSuffix = function(fileName, mime) {
    var suffix = suffixMapping[mime];
    if(suffix) {
        return (string.endsWith(fileName, suffix)) ? fileName : fileName + '.'+suffix;
    }
    return fileName;
}

module.exports = {
    downloadSVG: function(data, fileName) {
        if(currentUrl) {
            window.URL.revokeObjectURL(currentUrl);
        }

        fileName = getFileNameWithSuffix(fileName, 'image/svg+xml');

        window.URL = window.URL || window.webkitURL;
        var blob = new Blob([data], {type: 'image/svg+xml'});

        currentUrl = window.URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = currentUrl;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        link.remove();
    },
    downloadAs : function(data, fileName, width, height, mime) {
        if(mime === 'image/svg+xml') {
            this.downloadSVG(data, fileName);
            return;
        }

        fileName = getFileNameWithSuffix(fileName, mime);

        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        document.body.appendChild(canvas);
        canvas.width  = width;
        canvas.height = height;

        var img = new Image();
        img.src = "data:image/svg+xml;base64," + btoa(data);
        img.width = width;
        img.height = height;
        img.onload = function() {
            // after this, Canvasï¿½ origin-clean is DIRTY
            context.drawImage(img, 0, 0, width, height);
            var a = document.createElement('a');
            a.download = fileName;
            a.href = canvas.toDataURL(mime);
            document.body.appendChild(a);
            a.click();
            canvas.remove();
            a.remove();
        }
    },
    makeScreenShot : function(container, svgStr, width, height) {
        var img = new Image();
        img.src = "data:image/svg+xml;base64," + btoa(svgStr);
        if(width && height) {
            img.width = width;
            img.height = height;
        }
        $(container).append(img);
    },
    handleOpenSVG: function(file) {
        //var files = evt.target.files; // FileList object
        var that = this;
        // Loop through the FileList and render image files as thumbnails.
        for (var i = 0, f; f = files[i]; i++) {

            // Only process image files.
            if (!f.type.match('image.*')) {
                continue;
            }

            var reader = new FileReader();

            // Closure to capture the file information.
            reader.onload = (function (theFile) {
                return function (e) {
                    // Render thumbnail.
                    that.diagram.loadDiagram(e.target.result);
                };
            })(f);

            // Read in the image file as a data URL.
            reader.readAsText(f);
        }
    },
    readAsText: function(f) {
        return new Promise(function(resolve, reject) {
            var reader = new FileReader();

            reader.onload = (function (theFile) {
                return function (e) {
                    resolve(e.target.result);
                };
            })(f);

            reader.readAsText(f);
        });
    },
    readAsDataUrl: function(f) {
        return new Promise(function(resolve, reject) {
            var reader = new FileReader();

            reader.onload = (function (theFile) {
                return function (e) {
                    resolve(e.target.result);
                };
            })(f);

            reader.readAsDataURL(f);
        });
    }
};
},{"../util/string":78,"bluebird":83}],9:[function(require,module,exports){
var object = require('../util/object');

var SubEvent = function(context, event) {
    this.context = context;
    this.event = event;
};

SubEvent.prototype.mouse = function() {
    return this.event.mouse();
};

SubEvent.prototype.getSubType = function(type) {
    return this.context+':'+type;
};

SubEvent.prototype.listen = function(type, handler, module) {
    //TODO: implement bubble
    this.event.listen(this.getSubType(type), handler, module);
};

SubEvent.prototype.unlisten = function(type, func) {
    this.event.unlisten(this.getSubType(type), func);
};

SubEvent.prototype.trigger = function(type, data, rootEvt, preventBubble) {
    this.event.trigger(this.getSubType(type), data, rootEvt);
    if(!preventBubble) {
        this.event.trigger(type, data, rootEvt);
    }
};

SubEvent.prototype.command = function(command, execute) {
    this.event.command(command, execute);
};

SubEvent.prototype.on = function(node, event, selector, data, handler) {
    this.event.on(node, event, selector, data, handler);
};

SubEvent.prototype.off = function(node, event, selector, handler) {
    this.event.off(node, event, selector, handler);
};

SubEvent.prototype.once = function(node, event, selector, data, handler) {
    this.event.once(node, event, selector, data, handler);
};

SubEvent.prototype.triggerDom = function(node, event) {
    this.event.triggerDom(node,event);
}

SubEvent.prototype.sub = function(context) {
    return new SubEvent(context, this);
}

module.exports = SubEvent;
},{"../util/object":77}],10:[function(require,module,exports){
var object = require('../util/object');
var util = require('../util/util');
var app = require('../util/app');
var dom = require('../dom/dom');
var Transform = require('../svg/transform');

var Eventable = require('./../dom/eventableNode');

var DEFAULT_OPACITY = 0.5;
var DEFAULT_KNOB_RADIUS = 5;

var Knob = function(diagram, p, cfg, group) {
    this.diagram = diagram;
    this.event = diagram.event;
    this.group = group;
    this.init(p, cfg);
};

Knob.activate = function(node, cfg) {
    
    this.config = object.extend({radius : DEFAULT_KNOB_RADIUS}, cfg);
    this.diagram.nodeMgr.activateNode(node);
};

util.inherits(Knob, Eventable);

Knob.prototype.clearRelativeOrientation = function() {
    delete this.relativePosition;
};

Knob.prototype.isSelected = function() {
    return this.node.selected;
};

Knob.prototype.relativeOrientation = function(position) {
    if(position) {
        this.relativePosition = {
            x : position.x,
            y : position.y
        };
    }
    return this.relativePosition;
};

Knob.prototype.init = function(position, cfg) {
    this.config = object.extend({radius : DEFAULT_KNOB_RADIUS}, cfg);
    this.config.cssClass = this.config.cssClass || 'knob';

    if(cfg.activate){
        this.node = this.diagram.activateKnobNode(cfg.activate, this.config);
    } else {
        this.node = this.diagram.createKnobNode(position, this.group, this.config);
    }

    this.eventBase = this.node.eventBase;
    this.config = this.node.config;
    this.root = this.node.root;
    this.node.knob = this;

    var that = this;
    var select = cfg.select || function() {
            that.activeStyle();
        };

    var deselect = cfg.deselect || function() {
            that.inactiveStyle();
        };


    this.activeStyle();
    this.on('select', select).on('deselect', deselect);
    this.event.trigger('knob_added', this);
};

Knob.prototype.x = function() {
    return this.node.x();
};

Knob.prototype.y = function() {
    return this.node.y();
};

Knob.prototype.position = function() {
    return this.node.getCenter();
};

Knob.prototype.draggable = function(handler) {
    this.node.draggable(handler);
    this.triggerDrag = function(dx,dy) {
        this.node.triggerDrag(dx,dy);
    };
    return this;
};

Knob.prototype.initDrag = function() {
    this.node.initDrag();
};

Knob.prototype.hide = function() {
    this.node.root.hide();
    this.node.root.attr('r', 0); //TODO: perhaps not wanted for all knob types.
};

Knob.prototype.show = function(opacity) {
    opacity = object.isDefined(opacity) ? opacity : this.config['fill-opacity'];
    opacity = object.isDefined(opacity) ? opacity : DEFAULT_OPACITY;
    this.node.root.show(opacity);
    this.node.root.attr('r', this.config['radius']);
};

Knob.prototype.select = function(shifted) {
    this.activeStyle();
    this.node.select(shifted);
    return this;
};

Knob.prototype.deselect = function() {
    this.node.deselect();
    return this;
};

Knob.prototype.fill = function(color) {
    this.node.root.fill(color);
};

Knob.prototype.stroke = function(color) {
    this.node.root.stroke(color);
    this.node.root.strokeWidth(1);
};

Knob.prototype.activeStyle = function() {
    this.fill(this.config['fill-active']);
    this.show();
    return this;
};

Knob.prototype.deselect = function() {
    this.inactiveStyle();
    return this;
};

Knob.prototype.inactiveStyle = function() {
    this.fill(this.config['fill']);
    this.show();
    return this;
};

Knob.prototype.hoverable = function(handler) {
    var that = this;
    this.node.root.hoverable(handler);
    return this;
};

Knob.prototype.remove = function() {
    this.node.trigger('remove');
};

Knob.prototype.move = function(dx,dy) {
    this.node.root.move(dx,dy);
    this.node.trigger('move', [dx,dy]);
};

Knob.prototype.moveTo = function(x,y) {
    this.node.root.moveTo(x,y);
    this.node.trigger('moveTo', [x,y]);
};

Knob.prototype.toString = function() {
    return '('+this.x()+'/'+this.y()+')';
};

module.exports = Knob;
},{"../dom/dom":47,"../svg/transform":68,"../util/app":74,"../util/object":77,"../util/util":79,"./../dom/eventableNode":49}],11:[function(require,module,exports){
var dom = require('../dom/dom');
var object = require('../util/object');
var EditPanel = require('../ui/editPanel');

var editPanel = new EditPanel();

var AbstractEditAddition = function(editable, editFunctions, config) {
    this.editable = editable;
    this.editFunctions = editFunctions;
    this.config = config;
    this.initEditTrigger();
};

AbstractEditAddition.prototype.initEditTrigger = function() {
    var that = this;
    object.each(this.config, function(key, editItem) {
        if(object.isDefined(editItem.trigger)) {
            that.addEditTextTrigger(key);
        }
    });
};

AbstractEditAddition.prototype.addEditTrigger = function(key) {
    switch(type) {
        case 'text':
        case 'textarea':
            this.addEditTextTrigger(key);
            break;
    }
};

AbstractEditAddition.prototype.addEditTextTrigger = function(key) {
    var editItem = this.getEditItem(key);
    var that = this;

    var selector = this.editable.selector(editItem.trigger);
    $(selector).css('cursor', 'pointer');

    //TODO: evtl move this to text.editable();
    this.editable.root.$().on('click', selector,  function(evt) {
        if(that.isTriggerAllowed()) {
            //TODO: remove UI dependency and handle it trough trigger event
            switch(editItem.type) {
                case 'textarea':
                    editPanel.createTextAreaEdit(evt.pageX, evt.pageY,
                        function() {
                            return that.getValue(key).trim();
                        },
                        function(value) {
                            that.setValue(key, value);
                        });
                    break;
                case 'text':
                    editPanel.createTextEdit(evt.pageX, evt.pageY, function() {
                            return that.getValue(key).trim();
                        },
                        function(value) {
                            that.setValue(key, value);
                        });
                    break;
            }
        }
    });
};

AbstractEditAddition.prototype.getValue = function(key) {
    var editItem = this.getEditItem(key);
    var editFunction = this.editFunctions[editItem.type];
    if(editFunction && !object.isString(editFunction)) {
        return this.editFunctions[editItem.type].get.call(this, editItem, key);
    } else if(editFunction && object.isString(editFunction)) {
        return this.editable.getInnerSVG(editItem.bind)[editFunction]();
    }
};

AbstractEditAddition.prototype.setValue = function(key, value) {
    var editItem = this.getEditItem(key);
    var oldValue = this.getValue(key);
    var editFunction = this.editFunctions[editItem.type];
    if(editFunction && !object.isString(editFunction)) {
        this.editFunctions[editItem.type].set.call(this, editItem, value);
        this.onSetValue(editItem, value);
    } else if(editFunction && object.isString(editFunction)) {
        this.editable.getInnerSVG(editItem.bind)[editFunction](value);
        this.onSetValue(editItem, value);
    }

    if(this.editable.exec) {
        this.editable.exec('edit', [key, value, oldValue]);
    }
};

/**
 * This method either returns a clone of the editItem for normal keys like 'title', or
 * creates a new editItem out of a combined key like 'title_text-size' with key title and type text-size
 */
AbstractEditAddition.prototype.getEditItem = function(key) {
    var type;
    var editItem;
    if(key.indexOf(':') > -1) {
        var splitted = key.split(':');
        editItem = object.cloneObject(this.config[splitted[0]]);
        editItem.type = splitted[1];
    } else {
        editItem = this.config[key];
    }
    return editItem;
};

AbstractEditAddition.prototype.isTriggerAllowed = function() {
    return !this.lastSelect || (Date.now() - this.lastSelect > 200);
};

AbstractEditAddition.prototype.setTextAreaContent = function($textAreaNode, txtAreaContent) {
    this.editable.diagram.svg.get($textAreaNode).content(txtAreaContent);
};

AbstractEditAddition.prototype.getTextAreaContent = function($textAreaNode) {
    return this.editable.diagram.svg.get($textAreaNode).content();
};

AbstractEditAddition.prototype.deselect = function() {
    this.remove();
};

AbstractEditAddition.prototype.select = function() {
    this.lastSelect = Date.now();
};

AbstractEditAddition.prototype.remove = function() {
    editPanel.close();
};

AbstractEditAddition.prototype.update = function() {
    this.remove();
};

AbstractEditAddition.prototype.activate = function() {
    this.remove();
};

AbstractEditAddition.prototype.onSetValue = function(editItem, value) { };

module.exports = AbstractEditAddition;
},{"../dom/dom":47,"../ui/editPanel":70,"../util/object":77}],12:[function(require,module,exports){
var util = require('../util/util');
var event = require('../core/event');
var Command = require('../core/command');

var Manager = function(diagram) {
    this.diagram = diagram;
    this.event = diagram.event;
};

Manager.prototype.command = function(cmdId, doAction, undoAction) {
    this.diagram.registerCommand(cmdId, new Command(this, doAction, undoAction));
};

Manager.prototype.exec = function(cmdId, doArgs, undoArgs) {
    return this.diagram.executeCommand(cmdId, doArgs, undoArgs);
};

Manager.prototype.addCmd = function(cmdId, doArgs, undoArgs) {
    this.diagram.addCommand(cmdId, doArgs, undoArgs);
};

Manager.prototype.listen = function(eventId, handler) {
    this.event.listen(eventId, handler, this);
};

Manager.prototype.getNodeById = function(id) {
    return this.diagram.getNodeById(id);
};

Manager.prototype.getTransitionById = function(id) {
    return this.diagram.getTransitionById(id);
};

Manager.prototype.getSVG = function(id) {
    return $.svg(id);
};

Manager.prototype.getNodeMgr = function(command) {
    return this.diagram.nodeMgr;
};

Manager.prototype.getTransitionMgr = function(command) {
    return this.diagram.transitionMgr;
};

Manager.prototype.getSelectionMgr = function(command) {
    return this.diagram.selectionMgr;
};

module.exports = Manager;
},{"../core/command":4,"../core/event":7,"../util/util":79}],13:[function(require,module,exports){
var PathData = require('../svg/pathData');
var object = require('../util/object');

var AbstractPathManager = function(transition) {
    this.transition = transition;
};

AbstractPathManager.prototype.activate = function() {
    this.path = this.transition.getLine().d();
    return this;
};

AbstractPathManager.prototype.fromString = function(pathDataStr) {
    this.path = new PathData().loadFromString(pathDataStr);
};

AbstractPathManager.prototype.dragLine = function(position) {
    // Init path if no path was created yet
    if(!this.path) {
        this.init(position)
    }

    // Create full path if the path only consist of the start path part yet or update the end position of the path
    if(this.path.length() === 1) {
        this.create(position);
    } else {
        this.path.end(position);
    }

    this.update();
};

AbstractPathManager.prototype.init = function(position) {
    this.path = new PathData().start(position);
};

AbstractPathManager.prototype.updatePart = function(index, position) {
    this.path.setTo(index, position);
    this.update();
};

AbstractPathManager.prototype.addPathPart = function(index, position) {
    if(!this.path) {
        this.init(position);
    } else {
        this.add(index,position);
        this.update();
    }
};

AbstractPathManager.prototype.removePathPart = function(index) {
    if(this.path) {
        this.path.removePath(index);
    }
};

AbstractPathManager.prototype.replace = function(old, positions) {
    this.buildPath(positions);

    //We set our created path data to the existing path, since the transition line and linearea are dependent on this path instance
    old.path.data = this.path.data;
    this.path = old.path;

    this.transition.pathManager = this;
    return this;
};

AbstractPathManager.prototype.buildPath = function(positions) {
    this.init(positions[0]);

    for(var i  = 1; i < positions.length; i++) {
        this.add(i, positions[i]);
    }

    this.update();
};

AbstractPathManager.prototype.getNearestPoint = function(position) {
    return this.path.getNearestPoint(position);
};

AbstractPathManager.prototype.getIndexForPosition = function(position) {
    return this.path.getPathIndexForPosition(position);
};

AbstractPathManager.prototype.dump = function() {
    return '<b>Path:</b> '+this.path.toString()+'<br />';
};

AbstractPathManager.prototype.create = function(position) {/*Abstract*/};
AbstractPathManager.prototype.update = function(position) {/*Abstract*/};
AbstractPathManager.prototype.add = function(index, position) {/*Abstract*/};

module.exports = AbstractPathManager;
},{"../svg/pathData":60,"../util/object":77}],14:[function(require,module,exports){
var additions = {};
var event = require('../core/event');

var AdditionFactory = function() {
    this.additions = {};
};

AdditionFactory.prototype.register = function(key, addition) {
    this.additions[key] = addition;
};

AdditionFactory.prototype.initAddition = function(key, host) {
    if (!host.additions) {
        host.additions = {};
    }

    var addition = this.additions[key];

    if(addition && host && _checkConfigRequirement(addition, host, key)) {
        host.additions[key] = new addition(host);
    } else if(!addition){
        event.trigger('warn', 'Tried to initiate an unknown addition '+key+' some functionality may not available.');
    }
};

var nodeAdditions = new AdditionFactory();
var transitionAdditions = new AdditionFactory();

var _checkConfigRequirement = function(addition, host, key) {
    return !addition.requireConfig || (addition.requireConfig && (host.config && host.config[key]));
};

module.exports = {
    registerNodeAddition : function(key, addition) {nodeAdditions.register(key,addition)},
    initNodeAddition : function(key, host) {nodeAdditions.initAddition(key, host)},
    registerTransitionAddition : function(key, addition) {transitionAdditions.register(key,addition)},
    initTransitionAddition : function(key, host) {transitionAdditions.initAddition(key, host)},
    initTransitionAdditions : function(host) {
        $.each(transitionAdditions.additions, function(key, addition) {
            transitionAdditions.initAddition(key, host);
        });
    }
};
},{"../core/event":7}],15:[function(require,module,exports){
var Promise = require('bluebird');

var DiagramAPI = function(diagram) {
    this.diagram = diagram;
};

DiagramAPI.prototype.createNode = function(tmplId, position) {
    var that = this;
    return new Promise(function(resolve, reject) {
        that.loadTemplate(tmplId)
            .then(function(template) {
                resolve(that.diagram.nodeMgr.createNodeCommand(template, position));
            }, function(err) {
                reject(err);
            });
    });

};

DiagramAPI.prototype.getSelectedTransition = function(tmpl, position) {
    return this.diagram.selectionMgr.selectedTransition;
};

DiagramAPI.prototype.loadTemplate = function(tmpl) {
    var that = this;
    return new Promise(function(resolve, reject) {
        that.diagram.templateMgr.getTemplate(tmpl)
            .then(function(template) {
                resolve(template);
            }, function(err) {
                reject(err);
            });
    });
};

DiagramAPI.prototype.getSelectedNodes = function(tmpl, position) {
    return this.diagram.selectionMgr.getSelectedNodes();
};

DiagramAPI.prototype.getNodeById = function(id) {
    return this.diagram.nodeMgr.getNode(id);
};

DiagramAPI.prototype.createTransition = function(node1, node2) {
    return node1.additions.transition.startNewTransition(node2);
};

DiagramAPI.prototype.getTransitionById = function(id) {
    return this.diagram.transitionMgr.getTransition(id);
};

module.exports = DiagramAPI;
},{"bluebird":83}],16:[function(require,module,exports){
var AbstractPathManager = require('./abstractPathManager');
var util = require('../util/util');

var CurvedPathManager = function(transition) {
    AbstractPathManager.call(this, transition);
    this.type = CurvedPathManager.type;
};

util.inherits(CurvedPathManager, AbstractPathManager);

CurvedPathManager.type = 'curved';

CurvedPathManager.prototype.create = function(position) {
    //Control points are calculated by calling update
    this.path.cBezier(undefined, undefined, position);
};

CurvedPathManager.prototype.add = function(index, position) {
    this.path.insertCBezier(index,undefined, undefined, position);
};

CurvedPathManager.prototype.update = function() {
    this.path.smoothen();
};

module.exports = CurvedPathManager;

},{"../util/util":79,"./abstractPathManager":13}],17:[function(require,module,exports){
/**
 * This class represents an instance of a diagram and is responsible for initializing and
 * building the stage. Furthermore it contains diagram related utility functionality.
 *
 * An instance of this class offers the access to all nodes/transitions and templates of the
 * diagram.
 *
 * This class is designed to be able to manage multiple diagrams within one
 * application instance.
 */
var util = require('../util/util');
var event = require('../core/event');
var SVG = require('../svg/svg');
var PathData = require('../svg/pathData'); //Rather implement svg.createpath().start().line()...
var templateManager = require('./templateManager').init();
var commandManager = require('../core/commandManager');
var SelectionManager = require('./selectionManager');
var NodeManager = require('./nodeManager');
var TransitionManager = require('./transitionManager');
var DiagramAPI = require('./api');

var fileManager = require('../core/fileManager');

var Eventable = require('./../dom/eventableNode');

var Knob = require('./knob');

var KnobManager = require('./knobManager');
require('./knobTemplate');
require('./imageTemplate');
var xml = require('../util/xml');

var Promise = require('bluebird');

var Helper = require('./../svg/helper');

var config = require('../core/config');

var object = util.object;
var dom = util.dom;

var CONTAINER_SELECTOR = '#svgStage';
// Contains the parent dom node (div) of the SVG element
var $CONTAINER_NODE = $(CONTAINER_SELECTOR);

/**
 * Constructor for initiating a new diagram instance within the containerID.
 *
 * @param {type} containerID The parent of the new SVG diagram
 * @param {type} cfg
 */
var Diagram = function (cfg) {
    cfg = cfg || {};

    if (!cfg.id) {
        console.warn('Created diagram without id');
    }

    this.uniqueIds = [];

    this.id = cfg.id || 'not specified';
    this.projectId = cfg.projectId || 'default';
    this.title = cfg.title || 'new';
    this.config = config;

    //Diagram intern event context
    this.event = event.sub(this.id);

    if (cfg.container) {
        this.$container = $(cfg.container);
    } else {
        this.$container = $CONTAINER_NODE;
    }

    // Build the SVG stage within the container
    this.svg = new SVG(this.$container.attr('id'), this.ns());
    this.eventBase = this.svg.root;

    var that = this;
    this.commandMgr = commandManager.sub(this.id, function (cmd) {
        that.triggerUpdate();
    });

    // Handles the loading and creation of templates
    this.templateMgr = templateManager;
    // This helper class manages the selection of nodes/transitions
    this.selectionMgr = new SelectionManager(this);
    // Responsible for creating and maintaining nodes
    this.nodeMgr = new NodeManager(this);
    // Responsible for creating and maintaining transitions
    this.transitionMgr = new TransitionManager(this);
    // Responsible for tracking and accessing all dockings on the diagram
    this.knobMgr = new KnobManager(this);

    // Init stage related and key events
    this.initEvents();

    this.scale = 1;

    //This is used by the eventable addition in case there are event restrictions (move mode...)
    this.excludeEventRestrictions = true;

    this.background = this.svg.createPart('background');
    this.svg.rect({width: '100%', height: '100%', fill: '#FFFFFF'}, 'background');

    var that = this;
    this.initDefs()
        .then(function () {
            that.initialized = true;
            that.mainPart = that.svg.createPart('main', true);
            that.mainPart.excludeEventRestrictions = true;
            that.helper = that.svg.helper();
            that.trigger('initialized');
        }, function (err) {
            console.error('Could not load defs initialisation failed!');
        });
};

util.inherits(Diagram, Eventable);

Diagram.prototype.ns = function () {
    return {"xmlns:dala": "http://www.dala.com"};
};

Diagram.prototype.getRootSVG = function () {
    return this.svg.root;
};

Diagram.prototype.triggerUpdate = function () {
    this.trigger('diagram_updated', this.id);
};

Diagram.prototype.getNodes = function (filter) {
    return this.nodeMgr.getNodes(filter);
};

Diagram.prototype.trigger = function (evt, args) {
    //perhaps also listen to diagram intern events not only dom events.
    this.svg.root.trigger(evt, args);
    this.event.trigger(event, args);
};

/*
 * Initializes Stage Mouse and Key events.
 */
Diagram.prototype.initEvents = function () {
    var that = this;
    // Double clicks on the stage area will create new nodes of the selected
    // template type. Only if we do not dbclick another node in this case
    // we start a transition drag.
    this.on('dblclick', function (evt) {
        debugger;
        if (config.is('diagram_mode_draw_transition')) {
            var position = that.getStagePosition(evt);
            that.createFreeTransition(position, position, true);
        } else if (!that.selectionMgr.isElementHover() && !config.is('diagram_mode_move')) {
            that.event.trigger('node_create', that.templateMgr.getSelectedTemplate(), evt);
        }
    }).on('mousedown', function (evt) {
        var startPosition = that.getStagePosition(evt);

        if (evt.ctrlKey || config.is('diagram_mode_move')) {
            //Move main part
            that.mainPart.draggable({
                once: true,
                cursor: 'all-scroll',
                dragMove: function (event, dx, dy) {
                    that.event.trigger('viewport_update', this.position());
                },
                dragEnd: function (event) {
                    that.event.trigger('viewport_updated', this.position());
                },
                restrictionX: function (event, dx, dy) {
                    return (this.x() + dx <= 0) ? dx : 0;
                },
                restrictionY: function (event, dx, dy) {
                    return (this.y() + dy <= 0) ? dy : 0;
                },
                getScale: function () {
                    return that.scale;
                }
            });
            that.mainPart.trigger('mousedown');
        } else {
            that.selectionMgr.dragSelectionStart(evt, startPosition);
        }

    });

    this.on('mouseup', function () {
        that.selectionMgr.dragSelectionEnd();
    });

    event.on(document, "dragstart", function (e) {
        if (e.target.nodeName.toUpperCase() === "POLYLINE" || e.target.nodeName.toUpperCase() === 'PATH' || e.target.nodeName.toUpperCase() === 'CIRCLE') {
            e.preventDefault();
            return false;
        }
    });
};

Diagram.prototype.createFreeTransition = function (start, end, initDrag, group) {
    var startKnob = new Knob(this, start, {radius: 10}, group).draggable();
    var endKnob = new Knob(this, end, {radius: 10}, group).draggable();
    var transition = this.createTransition(startKnob.node, endKnob.node);

    if (group) {
        group.append(transition);
    }

    if (initDrag) {
        endKnob.initDrag();
    }

    transition.on('remove', function () {
        startKnob.remove();
        endKnob.remove();
    });

    startKnob.on('remove', function () {
        transition.remove();
    });

    endKnob.on('remove', function () {
        transition.remove();
    });

    return {
        startKnob: startKnob,
        endKnob: endKnob,
        transition: transition
    }
};

Diagram.prototype.part = function (id) {
    return this.svg.part(id);
};

Diagram.prototype.height = function () {
    return (this.nodeMgr.size()) ? this.nodeMgr.getBottomNode().getBottomY(true) : 0;
};

Diagram.prototype.width = function () {
    return (this.nodeMgr.size()) ? this.nodeMgr.getRightNode().getRightX(true) : 0;
};

Diagram.prototype.dimensions = function (id) {
    if (this.nodeMgr.size()) {
        var leftNode = this.nodeMgr.getLeftNode();
        var topNode = this.nodeMgr.getTopNode();
        var rightNode = this.nodeMgr.getRightNode();
        var bottomNode = this.nodeMgr.getBottomNode();
        return {
            width: rightNode.getRightX(),
            height: bottomNode.getBottomY(),
            x: leftNode.x(),
            y: bottomNode.y(),
        }
    } else {
        return {
            width: 0,
            height: 0,
            x: 0,
            y: 0,
        }
    }
};

Diagram.prototype.import = function (svg, part, prepend) {
    return this.svg.import(svg, part, prepend);
};

Diagram.prototype.part = function (id) {
    return this.svg.part(id);
};

Diagram.prototype.initDefs = function () {
    var that = this;
    return new Promise(function (resolve, reject) {
        that.templateMgr.getTemplate('defs_marker')
            .then(function (tmpl) {
                if (tmpl) {
                    tmpl.createNode({diagramId: that.id}, that).init('root', true);
                    resolve();
                } else {
                    reject('Could initialize defs template result undefined');
                }
            }, function (err) {
                reject(err);
            });
    });
};

Diagram.prototype.createKnobNode = function (p, group, cfg) {
    return this.knobMgr.createKnobNode(p, group, cfg);
};

Diagram.prototype.activateKnobNode = function (svgNode, cfg) {
    return this.knobMgr.activateKnobNode(svgNode, cfg);
};

Diagram.prototype.uniqueId = function () {
    var newId = this.checkId(Date.now() + '');
    this.uniqueIds.push(newId);
    return newId;
};

/**
 * Prevent duplicates
 */
Diagram.prototype.checkId = function (id) {
    return ($.inArray(id, this.uniqueIds) > -1) ? this.checkId('u' + id) : id;
};

Diagram.prototype.isMultiSelection = function () {
    return this.selectionMgr.isMultiSelection();
};


Diagram.prototype.newDiagram = function () {
    //TODO: we should unify this with the constructor svg creation technique
    this.loadDiagram('<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="svgStage_svg" xmlns:dala="http://www.dala.com" height="100%" width="100%"></svg>');
    this.initDefs();
};
Diagram.prototype.loadDiagram = function (svgString, callback) {
    //TODO: rather handle this per event or in constructor
    this.clear();
    this.svg.setRoot(dom.importSVG(this.svg.$container, svgString));
    this.getRootSVG().height('100%');
    this.getRootSVG().width('100%');
    var that = this;
    this.activateNodes().then(function () {
        that.activateTransitions();
        that.initEvents();
        if (object.isFunction(callback)) {
            callback(that);
        }
        that.selectionMgr.clear();
    });
};

Diagram.prototype.clear = function () {
    this.$container.empty();
    this.nodeMgr.clear();
    this.selectionMgr.clear();
};

Diagram.prototype.triggerDockingVisibility = function () {
    if (this.knobMgr.hideDocking) {
        this.knobMgr.showKnobs();
    } else {
        this.knobMgr.hideKnobs();
    }
};

Diagram.prototype.activateNodes = function () {
    var that = this;
    var promises = [];
    this.getRootSVG().$().find('.element_root').each(function () {
        promises.push(that.nodeMgr.activateNode(this));
    });
    return Promise.all(promises);
};

//TODO: move to transitionmgr
Diagram.prototype.activateTransitions = function () {
    this.transitionMgr.activateTransition($('.transition'));
};

Diagram.prototype.getNodeById = function (nodeId) {
    var result =  this.nodeMgr.getNode(nodeId);
    if(!result) {
        result = this.knobMgr.getKnobNode(nodeId);
    }
    return result;
};

Diagram.prototype.getTransitionById = function (id) {
    return this.transitionMgr.getNode(id);
};

Diagram.prototype.zoomIn = function () {
    this.scale += 0.1;
    this.part('main').scale(this.scale);
    this.exec('zoomIn', [this.scale]);
};

Diagram.prototype.zoomOut = function () {
    if (this.scale > 0) {
        this.scale -= 0.1;
        this.part('main').scale(this.scale);
        this.exec('zoomOut', [this.scale]);
    }
};

/**
 * This method determines the relative stage coordinates for a given
 * window position either by providing the x and y position or an event
 * object with given pageX and pageY attributes or an point with x,y attributes.
 *
 * @param {type} x either an event object with pageX, pageY or an point with x,y
 *                 or just the plain x coordinate.
 * @param {type} y the y coordinate is just mandatory if the fisrst arg is the plain x
 * @returns {Diagram_L13.Diagram.prototype.getStagePosition.DiagramAnonym$2}
 */
Diagram.prototype.getStagePosition = function (x, y) {
    if (object.isDefined(x.pageX)) {
        y = x.pageY;
        x = x.pageX;
    } else if (object.isDefined(x.x)) {
        y = x.y;
        x = x.x;
    }

    var stagePosition = this.$container.offset();
    var viewPointAlignment = this.mainPart.position();

    //TODO: viewbox alignement ?
    return {
        x: parseInt((x - stagePosition.left - viewPointAlignment.x) / this.scale),
        y: parseInt((y - stagePosition.top - viewPointAlignment.y) / this.scale)
    };
};

/**
 * Checks if a given position is within the boundaries of a diagram node.
 * TODO: either return all overlay nodes or just the one with the biggest index...
 * @param {type} position
 * @returns {Boolean}
 */
Diagram.prototype.getNodeByPosition = function (position) {
    var result;
    object.each(this.nodeMgr.nodes, function () {
        if (this.overlays(position)) {
            result = this;
            return false;
        }
    });

    return result;
};

Diagram.prototype.createNode = function (tmplId, position) {
    var that = this;
    return new Promise(function (resolve, reject) {
        that.loadTemplate(tmplId)
            .then(function (template) {
                resolve(that.nodeMgr.createNodeCommand(template, position));
            }, function (err) {
                reject(err);
            });
    });
};

Diagram.prototype.getSelectedTransition = function (tmpl, position) {
    return this.selectionMgr.selectedTransition;
};

Diagram.prototype.loadTemplate = function (tmpl) {
    var that = this;
    return new Promise(function (resolve, reject) {
        that.templateMgr.getTemplate(tmpl)
            .then(function (template) {
                resolve(template);
            }, function (err) {
                reject(err);
            });
    });
};

Diagram.prototype.screenShot = function (container, withadditions) {
    var stringVal = (withadditions) ? this.asString() : this.asPlainString();
    fileManager.makeScreenShot(container, stringVal, this.width(), this.height());
};

Diagram.prototype.getSelectedNodes = function (tmpl, position) {
    return this.selectionMgr.getSelectedNodes();
};

Diagram.prototype.createTransition = function (node1, node2) {
    return node1.additions.transition.startNewTransition(node2);
};

Diagram.prototype.getTransitionById = function (id) {
    return this.transitionMgr.getTransition(id);
};

Diagram.prototype.asString = function () {
    return this.svg.asString();
};

Diagram.prototype.asPlainString = function () {
    var $diagramXml = this.clone();
    $diagramXml.find('.knob').remove();
    //TODO: Diagram dimension settings
    $diagramXml.attr('height', this.height() + 10);
    $diagramXml.attr('width', this.width() + 10);
    $diagramXml.find('.orientationKnob').hide();
    $diagramXml.find('#' + this.mainPart.attr('id')).attr('transform', '');
    return util.xml.serializeToString($diagramXml[0]);
};

Diagram.prototype.clone = function () {
    return this.svg.clone();
};

Diagram.prototype.undoCommand = function () {
    this.commandMgr.undo();
};

Diagram.prototype.redoCommand = function () {
    this.commandMgr.redo();
};

Diagram.prototype.registerCommand = function (cmdId, cmd) {
    this.commandMgr.register(cmdId, cmd);
};

Diagram.prototype.executeCommand = function (cmdId, doArgs, undoArgs) {
    return this.commandMgr.exec(cmdId, doArgs, undoArgs);
};

Diagram.prototype.addCommand = function (cmdId, doArgs, undoArgs) {
    this.commandMgr.add(cmdId, doArgs, undoArgs);
};

Diagram.prototype.dump = function() {
    var result = '<hr />';
    result += 'Diagram: '+this.id+'<br />';
    result += this.nodeMgr.dump();
    result += this.transitionMgr.dump()+'<br />';
    result += '<hr />';
    return result;
};

Diagram.prototype.validate = function() {
    var result = {};
    result['transitionManager'] = this.transitionMgr.validate();
    return result;
};

module.exports = Diagram;


},{"../core/commandManager":5,"../core/config":6,"../core/event":7,"../core/fileManager":8,"../svg/pathData":60,"../svg/svg":63,"../util/util":79,"../util/xml":80,"./../dom/eventableNode":49,"./../svg/helper":58,"./api":15,"./imageTemplate":25,"./knob":26,"./knobManager":27,"./knobTemplate":28,"./nodeManager":31,"./selectionManager":36,"./templateManager":39,"./transitionManager":45,"bluebird":83}],18:[function(require,module,exports){
var Diagram = require('./diagram');
var event = require('../core/event');
var client = require('../core/client');
var util = require('../util/util');

var userManager = require('../user/userManager');
var fileManager = require('../core/fileManager');

var config = require('../core/config');

var diagrams = {};
var activeDiagramId;

//TODO: load from remote/local storage

config.setVal('transition_settings', {
    type: 'straight',
    stroke: '#474747',
    'stroke-width': '1',
    'marker-start': 'none',
    'marker-end' : 'trianglefill',
    'stroke-dasharray' : 'none'
});

config.setVal('node_settings', {
    stroke: '#474747',
    'stroke-width': '1',
    'stroke-dasharray' : 'none',
    fill: '#f2f2f2'
});

var initListener = function() {
    event.listen('diagram_download_as', downloadDiagramAsListener);

    event.listen('diagram_new', newDiagramListener);
    event.listen('tab_activated', activeTabListener);
    event.listen('key_save_press', saveDiagram);
    event.listen('key_paste_press', pasteDiagramDataListener);
    event.listen('key_copy_press', copyDiagramDataListener)

    event.listen('view_zoomIn', zoomIn);
    event.listen('view_zoomOut', zoomOut);
    event.listen('view_toggle_mode_move', toggleModeMove);
    event.listen('view_toggle_setting_align', toggleSettingAlign);

    event.listen('key_redo_press', redoCommand);
    event.listen('key_undo_press', undoCommand);
};

var downloadDiagramAsListener = function(evt) {
    var diagram = getActiveDiagram();
    var content = diagram.asPlainString();
    var fileName = evt.data.fileName || diagram.title;
    var mime = evt.data.mime || 'image/svg+xml';
    fileManager.downloadAs(content, fileName, diagram.width(), diagram.height(), mime);
};

var toggleModeMove = function() {
    var  val = config.is('diagram_mode_move', false);
    config.setVal('diagram_mode_move', !val);
    config.setVal('events_restricted', !val);
};

var toggleSettingAlign = function() {
    var  val = config.is('dragAlign', true);
    config.setVal('dragAlign', !val);
};

var undoCommand = function(evt) {
    getActiveDiagram().undoCommand();
};

var redoCommand = function(evt) {
    getActiveDiagram().redoCommand();
};

var copyDiagramDataListener = function(evt) {
    var activeDiagram = getActiveDiagram();
    if(activeDiagram) {
        activeDiagram.trigger('copy',[evt.mouse]);
    };
};

var pasteDiagramDataListener = function(evt) {
    var activeDiagram = getActiveDiagram();
    if(activeDiagram) {
        activeDiagram.trigger('paste',[evt.mouse]);
    };
};

var saveDiagram = function(evt) {
    var activeDiagram = getActiveDiagram();
    if(activeDiagram && userManager.isLoggedIn()){
        //TODO: Remove Dockings.....
        //TODO: check if loggedIn, if not login first dialog... or save via browser cache ?
        var data = {
            "diagram" : activeDiagram.asString(),
            "diagramId" : activeDiagram.id,
            "projectId" : activeDiagram.projectId,
            "title" : activeDiagram.title
        };
        client.post('/project/saveDiagram', data, {
            success : function(response) {},
            error : function(status, error, errorcode) {},
            errorMessage : {
                'default': 'Could not save diagram, please try again later or backup via download!',
                '401':  'Could not save diagram. Please login or create an account first!'
            },
            successMessage : 'Diagram was saved !'
        });
    }

};

var createDiagramId = function() {
    return (userManager.isLoggedIn()) ? Date.now() + '_' +userManager.getUserId() : Date.now()+'';
};

var newDiagramListener = function(evt) {
    var diagramId = evt.data.diagramId;
    var stageId = evt.data.stageId;
    var projectId = evt.data.projectId;
    var title = evt.data.title;
    evt.data.diagramId = diagramId;
    var diagram = register(new Diagram({id:diagramId, container:'#'+stageId, projectId: projectId, title: title}));
    event.trigger('diagram_initialized', evt.data);
    return diagram;
};

var register = function(diagram, activate) {
    diagrams[diagram.id] = diagram;
    diagrams[diagram.id].on('activate', function() {
        activeDiagramId = diagram.id;
    });
    if(activate) {
        diagram.trigger('activate');
    }
    return diagram;
};

var activeTabListener = function(evt) {
    activeDiagramId = evt.data;
};

var zoomIn = function() {
    getActiveDiagram().zoomIn();
    event.trigger('view_zoomedIn');
};

var zoomOut = function() {
    getActiveDiagram().zoomOut();
    event.trigger('view_zoomedOut');
};

var getActiveDiagram = function() {
    return diagrams[activeDiagramId];
}

initListener();

module.exports = {
    getActiveDiagram: getActiveDiagram,
    createDiagramId : createDiagramId,
    register : register
};
},{"../core/client":3,"../core/config":6,"../core/event":7,"../core/fileManager":8,"../user/userManager":72,"../util/util":79,"./diagram":17}],19:[function(require,module,exports){
/**
 * This utility module provies build-in docking techniques for transitions and other
 * dockable elements. The docking type can be configured within the template
 * with the config key "dockingType".
 *
 * Example:
 *  <config>
 *      {
 *          "nodeID" : "eer_entityDefault",
 *          "docking" : {type: 'RECT', orientation:'center', ...}
 *          ...
 *      }
 * </config>
 */

var util = require('../util/util');
var dom = util.dom;
var math = util.math;

var checkOrientationBoundary = function(node, p) {
    var dockingType = (node.config.docking && node.config.docking.type) ? node.config.docking.type : 'RECT';
    switch(dockingType.toUpperCase()) {
        case 'CENTER':
            return false;
        case 'CIRCLE':
            return CIRCLE_BOUNDARY.call(node, p);
        case 'ELLIPSE':
            return ELLIPSE_BOUNDARY.call(node, p);
        case 'SQUARE':
        case 'RECT':
            return RECT_BOUNDARY.call(node, p);
    };
};

var calculateDockingPosition = function(node, orientationOut, orientationIn) {
    var dockingType = (node.config.docking && node.config.docking.type) ? node.config.docking.type : 'RECT';
    var result;
    switch(dockingType.toUpperCase()) {
        case 'SIMPLE':
            result = SIMPLE.call(node, orientationOut, orientationIn);
            break;
        case 'CENTER':
            result = CENTER.call(node, orientationOut, orientationIn);
            break;
        case 'CIRCLE':
            result = CIRCLE.call(node, orientationOut, orientationIn);
            break;
        case 'ELLIPSE':
            result = ELLIPSE.call(node, orientationOut, orientationIn);
            break;
        case 'SQUARE':
        case 'RECT':
            result = RECT.call(node,orientationOut, orientationIn);
            break;
        case 'FREE':
            result = FREE.call(node,orientationOut, orientationIn);
            break;
        default:
            result = CENTER.call(node, orientationOut, orientationIn);
            break;

    };

    var rotation = node.root.rotate();
    if(rotation) {
        result = math.rotate(result, node.position(), rotation);
    }

    return result;
};

var FREE = function(position , orientationIn) {
    return orientationIn;
};

var ELLIPSE = function(position , orientationIn) {
    var rx = this.width() / 2;
    var ry = this.height() / 2;
    var ellipse = new math.Ellipse(this.getCenter(), rx, ry);
    var result = ellipse.calcLineIntercept(position, orientationIn);
    return (result.length > 0)?result[0]:orientationIn;

};

var ELLIPSE_BOUNDARY = function(position) {
    var rx = this.width() / 2;
    var ry = this.height() / 2;
    return new math.Ellipse(this.getCenter(), rx, ry).overlays(position);
};

var CIRCLE = function(position, orientationIn) {
    //Note the stroke is not included in some browsers...
    var radius = this.width() / 2;
    var circle = new math.Circle(this.getCenter(), radius);
    var result = circle.calcLineIntercept(position, orientationIn);

    return (result.length > 0)?result[0]:orientationIn;
};

var CIRCLE_BOUNDARY = function(position) {
    var center = this.getCenter();
    var radius = this.width() / 2;
    return new math.Circle(this.getCenter(), radius).overlays(position);
};

/**
 * This technique uses the center of the node as orientation point and
 * returns the intersection of the node boundary and the line from the outer
 * orientation point to the center of the node as result.
 *
 * __________
 * |        |
 * |        |
 * |    x   |<----------------x
 * |        |
 * |        |
 * ----------
 *
 * @param {type} position the outer orientation point
 * @returns {DockingType_L20@call;getCenter}
 */
var RECT = function(position, orientation) {
    if(this.overlays(position)) {
        return orientation;
    }

    var transition = new math.Line(position, orientation);

    if(this.isRightOf(position)) {
        var result = transition.calcFX(this.x());
        if(this.overlays(result)) {
            return result;
        }
    }

    if(this.isLeftOf(position)) {
        var result = transition.calcFX(this.getRightX());
        if(this.overlays(result)) {
            return result;
        }
    }

    if(this.isOver(position)) {
        var bottomY = this.getBottomY();

        if(transition.isVertical()) {
            return {x: orientation.x, y: bottomY};
        }

        if(orientation.x === position.x) {
            return {x:orientation.x, y:bottomY};
        }
        var bottomLine = new math.Line({x:1,y:bottomY}, {x:2,y:bottomY});
        var result = transition.calcLineIntercept(bottomLine);
        //We explicitly set this because of possible calculation deviations
        result.y = bottomY;
        return result;
    } else {
        if(transition.isHorizontal()) {
            return {x:orientation.x, y: this.y()};
        }

        if(orientation.x === position.x) {
            return {x:orientation.x, y:this.y()};
        }
        var topLine = new math.Line({x:1,y:this.y()}, {x:2,y:this.y()});
        var result = transition.calcLineIntercept(topLine);
        //We explicitly set this because of possible calculation deviations
        result.y = this.y();

        return result;
    }
};

var RECT_BOUNDARY = function(p) {
    return this.overl
};

/**
 * This technique just returns the center of the node as result.
 * Note that line will start or end within the node.
 *
 * @param {type} position
 * @returns {DockingType_L20.CENTER@call;getCenter}
 */
var CENTER = function(position) {
    return this.getCenter();
};

/**
 * This technique provides 4 different docking points (top/right/bottom/left)
 * and returns the most suitable docking point for the given outer position.
 *
 * @param {type} position
 */
var SIMPLE = function(position, orientationIn) {
    //The position is within the node
    if(this.overlays(position)) {
        return orientationIn;
    }

    if(this.isLeftOf(position)) {
        return {
            x: this.getRightX(),
            y: orientationIn.y
        };
    } else if(this.isRightOf(position)) {
        return {
            x: this.root.x(),
            y: orientationIn.y
        };
    } else if(this.isOver(position)) {
        return {
            x: orientationIn.x,
            y: this.getBottomY()
        };
    } else if(this.isUnder(position)) {
        return {
            x: orientationIn.x,
            y: this.root.y()
        };
    } else {
        //The position is not outside of the element itself
    }
};

module.exports = {
    CENTER : CENTER ,
    SIMPLE : SIMPLE ,
    DEFAULT : CENTER,
    calculateDockingPosition : calculateDockingPosition,
    checkOrientationBoundary : checkOrientationBoundary
};
},{"../util/util":79}],20:[function(require,module,exports){
var util = require('../util/util');
var config = require('../core/config');

var object = util.object;
var DEF_TOLERANCE = 10;

var Alignment = function(tolerance, dimension) {
    this.dimension = dimension;
    this.tolerance = tolerance;
    this.actualD = 0;
};

Alignment.prototype.check = function(source, sourceIndexArr,target, d) {
    if(this.checkRange(source, target, d)) {
        // We keep the source position for the realignment
        if(!this.wasAligned) {
            this.source = source;
            this.sourceIndex = sourceIndexArr;
        }
        // Calculate d between target and source before drag
        this.d = (target[this.dimension] - (source[this.dimension]));
        this.target = target;
        // Keep track of the actual drag while beeing aligned for the realign
        this.actualD += d;
    }
};

Alignment.prototype.checkRange = function(source, target, d) {
    //Check if the difference between source (after drag) and target is within the tolerane
    return util.math.checkRangeDiff(target[this.dimension], (source[this.dimension] + this.actualD + d), this.tolerance);
};

Alignment.prototype.realign = function(alignConfig, d) {
    // We just have to calculate the realignment if an alignment was set
    var result;
    if(this.wasAligned) {
        //Now we retrieve the current position of the aligned source by our sourceIndex
        var currentSourcePosition = alignConfig[this.sourceIndex[0]].source[this.sourceIndex[1]];
        result = (this.source[this.dimension] + this.actualD + d) - currentSourcePosition[this.dimension];
    } else {
        result = d;

    }
    this.actualD = 0;
    return result;
};

Alignment.prototype.reset = function(initialize) {
    if(!initialize) {
        this.wasAligned = this.isAligned();
    } else {
        this.wasAligned = false;
    }

    delete this.target;
    delete this.d;
};

Alignment.prototype.isAligned = function() {
    return object.isDefined(this.target);
};

var DragAlignment = function(diagram, getConfig, tolerance) {
    this.diagram = diagram;
    this.tolerance = tolerance || DEF_TOLERANCE;
    this.getConfig = getConfig;
    this.alignX = new Alignment(this.tolerance, 'x');
    this.alignY = new Alignment(this.tolerance, 'y');
    this.actualDrag = {x:0, y:0};
};

DragAlignment.prototype.check = function(dx, dy) {
    var result;
    if(config.is('dragAlign', true) && !this.diagram.isMultiSelection()) {
        var that = this;

        // Reset the alignments to notify a new search loop
        this.alignX.reset();
        this.alignY.reset();

        var alignmentConfig = this.getConfig(dx, dy);
        object.each(alignmentConfig, function(configIndex, value) {
            var sourceArr = value.source;
            var targetArr = value.target;
            object.each(sourceArr, function(sourceIndex, value) {
                that.checkAlignment(value, targetArr, [configIndex, sourceIndex], dx, dy);

                if(that.alignX.isAligned() && that.alignY.isAligned()) {
                    return false; //Escape the each loop since we found both alingments
                }
            })
        });

        result = {
            dx : (this.alignX.isAligned()) ? this.alignX.d : this.alignX.realign(alignmentConfig, dx),
            dy : (this.alignY.isAligned()) ? this.alignY.d : this.alignY.realign(alignmentConfig, dy)
        };
    } else {
        this.alignX.reset(true);
        this.alignY.reset(true);
        result = {dx : dx, dy : dy};
    }

    return result;
};

DragAlignment.prototype.checkAlignment = function(source, targets, sourceIndexArr, dx, dy) {
    var that = this;
    object.each(targets, function(index, target) {
        if(!that.alignX.isAligned()) {
            that.alignX.check(source,sourceIndexArr, target, dx);
        }

        if(!that.alignY.isAligned()) {
            that.alignY.check(source,sourceIndexArr, target, dy);
        }

        if(that.alignX.isAligned() && that.alignY.isAligned()) {
            return false; //Escape the each loop since we found both alingments
        }
    });
}

DragAlignment.prototype.reset = function() {
    this.alignX.reset(true);
    this.alignY.reset(true);
};

DragAlignment.prototype.isAligned = function() {
    return this.alignX.isAligned || this.alignY.isAligned();
};

module.exports = DragAlignment;


},{"../core/config":6,"../util/util":79}],21:[function(require,module,exports){
require('../svg/draggable');
var util = require('../util/util');
var DragAlignment = require('./dragAlignment');
var Node = require('./node');

var dom = util.dom;
var object = util.object;

var lastDrag;

var DragContext = function(node, cfg) {
    this.cfg = cfg || {};
    this.node = node;
    this.dxSum = 0;
    this.dySum = 0;
};

DragContext.prototype.dragStart = function(evt) {
    this.dxSum = 0;
    this.dySum = 0;
    this.from = this.node.position();
    delete this.to;
    if(this.cfg.dragStart) {
        this.cfg.dragStart(evt);
    }
};

DragContext.prototype.wasMoved = function(evt) {
    return this.dxSum !== 0 || this.dySum !== 0;
};

DragContext.prototype.dragMove = function(evt, dx, dy) {
    this.dxSum += dx;
    this.dySum += dy;
    if(this.cfg.dragMove) {
        this.cfg.dragMove(evt, dx,dy);
    }
};

DragContext.prototype.dragEnd = function(evt) {
    if(this.dxSum != 0 || this.dySum != 0) {
        this.to = this.node.position();
        if (this.cfg.dragEnd) {
            this.cfg.dragEnd(evt);
        }
    }
};

DragContext.prototype.clone = function() {
    return {
        dxSum : this.dxSum,
        dySum : this.dySum,
        from : this.from,
        to : this.to
    }
};

Node.prototype.draggable = function(cfg) {
    cfg = cfg || {};
    var that = this;
    this.dragContext = new DragContext(this, cfg);

    var dragConfig = {
        cursor: 'all-scroll',
        dragStart: function(evt) {
            that.dragContext.dragStart(evt);
            lastDrag = that.dragContext;
            that.exec('dragStart', [evt]);
        },
        dragMove : function(evt, dx , dy) {
            that.dragContext.dragMove(evt, dx, dy);
            //that.exec('dragMove', [dx,dy, evt]);
            //We skip the the domEvent dragMove here cause of performance...
            that.exec('dragMove', [dx,dy, evt], true);

        },
        dragEnd : function(evt) {
            if(that.dragContext.wasMoved()) {
                that.dragContext.dragEnd(evt);
                that.exec('dragEnd', [evt]);
            }
        },
        getScale: function() {
            return that.diagram.scale;
        },
        restrictionX : cfg.restrictionX,
        restrictionY : cfg.restrictionY,
        cursor : cfg.cursor
    };

    if(!cfg.preventAlignment) {
        var dragAlignment;
        if(cfg.dragAlignment) {
            dragAlignment = (cfg.dragAlignment instanceof DragAlignment)
                ? cfg.dragAlignment : new DragAlignment(this.diagram, cfg.dragAlignment);
        } else {
            dragAlignment = new DragAlignment(that.diagram,
                function() {
                    var alignments = that.getTransitionAlignmentTargets();
                    alignments.push({source:[that.getCenter()], target:that.getNodeAlignmentTargets()});
                    return alignments;
                });
        }
        dragConfig.dragAlignment = dragAlignment;
    }


    this.root.draggable(dragConfig, this.getDragElement());

    //Simulates an drag start event
    this.initDrag = this.root.initDrag;

    //For manual dragging a svg element the triggerEvent is used to identify this event was triggered manually
    this.triggerDrag = this.root.triggerDrag;

    return this;
};

Node.prototype.getTransitionAlignmentTargets = function() {
    return this.additions.transition.getTransitionAlignmentTargets();
};

Node.prototype.getNodeAlignmentTargets = function() {
    var result = [];
    var that = this;

    object.each(this.diagram.getNodes(), function(key, node) {
        if(node.id !== that.id && !node.knob && !node.prevAlign) {
            result.push(node.getCenter());
        }
    });

    return result;
};

Node.prototype.getDragElement = function() { 
    return this.getRootSVG().instance();
    //return dom.findIncludeSelf(this.getRootSVG().instance(), '[class~='+this.getNodeSelector('dragRoute_')+']');

    //TODO: we have to use the [class~=bla] selector since ie, edge (who else) throwing errors for .class selectors in jquery
    //this may change in following jqery versions.
    //return dom.findIncludeSelf(this.getRootSVG().instance(), '[class~='+this.getNodeSelector('dragRoute_')+']');
};

module.exports = {
    getLastDrag : function() {
        return lastDrag;
    }
}


},{"../svg/draggable":54,"../util/util":79,"./dragAlignment":20,"./node":29}],22:[function(require,module,exports){
var util = require('../util/util');
var AbstractEditAddition = require('./abstractEditAddition');

var editFunctions = {
    stroke : 'stroke',
    'stroke-width' : 'strokeWidth',
    'stroke-dash' : 'strokeDasharray',
    fill : 'fill',
    color : 'fill',
    text : {
        get : function(editItem) {
            return $(this.node.getNodeSelector(editItem.bind)).text();
        },
        set : function(editItem, value) {
            $(this.node.getNodeSelector(editItem.bind)).text(value);
        }
    },
    textarea : {
        get : function(editItem) {
            return this.getTextAreaContent(this.node.getNodeSelector(editItem.bind));
        },
        set : function(editItem, value) {
            var $editSVGNode = $(this.node.getNodeSelector(editItem.bind));
            this.setTextAreaContent($editSVGNode,value);
        }
    },
    'text-size' : {
        get : function(editItem) {
            return this.node.getInnerSVG(editItem.bind).fontSize();
        },
        set : function(editItem, value) {
            this.node.getInnerSVG(editItem.bind).fontSize(value);
        }
    }
};

var EditNodeAddition = function(node) {
    AbstractEditAddition.call(this, node, editFunctions, node.config.edit);
    this.node = node;
};

util.inherits(EditNodeAddition, AbstractEditAddition);

EditNodeAddition.prototype.onSetValue = function() {
    this.node.event.trigger('node_edit', this.node);
};

EditNodeAddition.requireConfig = true;

module.exports = EditNodeAddition;
},{"../util/util":79,"./abstractEditAddition":11}],23:[function(require,module,exports){
var util = require('../util/util');
var AbstractEditAddition = require('./abstractEditAddition');

var EditTransitionAddition = function(transition) {
    AbstractEditAddition.call(this, transition, editFunctions, config);
    this.transition = transition;
};

util.inherits(EditTransitionAddition, AbstractEditAddition );

var editFunctions = {
    stroke : {
        get : function(editItem) {
            return this.transition.stroke();
        },
        set : function(binding, value) {
            this.transition.stroke(value);
        }
    },
    'stroke-width' : {
        get : function(editItem) {
            return this.transition.strokeWidth();
        },
        set : function(binding, value) {
            this.transition.strokeWidth(value);
        }
    },
    'stroke-dash' : {
        get : function(editItem) {
            return this.transition.line.strokeDasharray();
        },
        set : function(editItem, value) {
            this.transition.line.strokeDasharray(value);
        }
    },
    text : {
        get : function(editItem) {
            return $(this.transition.getTransitionSelector(editItem.bind)).text();
        },
        set : function(editItem, value) {
            $(this.transition.getTransitionSelector(editItem.bind)).text(value);
        }
    },
    textarea : {
        get : function(editItem) {
            return this.getTextAreaContent(this.transition.getTransitionSelector(editItem.bind));
        },
        set : function(editItem, value) {
            var $editSVGNode = $(this.transition.getTransitionSelector(editItem.bind));
            this.setTextAreaContent($editSVGNode,value);
        }
    },
    'text-size' : {
        get : function(editItem) {
            var definition = this.transition.getInnerSVG(editItem.bind).style('font-size');
            if(definition) {
                return definition.substring(0, definition.length - 2);
            }
        },
        set : function(editItem, value) {
            this.transition.getInnerSVG(editItem.bind).style('font-size', value+'px');
        }
    },
    'type' : {
        get : function(editItem) {
            return this.transition.type();
        },
        set : function(editItem, value) {
            this.transition.type(value);
            this.transition.group.dala('transitionType', value);
        }
    },
    'startMarker' : {
        get : function(editItem) {
            return this.transition.startMarkerValue();
        },
        set : function(editItem, value) {
            value = value || '';
            this.transition.startMarker(value);
        }
    },
    'endMarker' : {
        get : function(editItem) {
            return this.transition.endMarkerValue();
        },
        set : function(editItem, value) {
            value = value || '';
            this.transition.endMarker(value);
        }
    }
};

var config = {
    'text0' : {type : 'text', bind : 'text0', trigger : 'text0'},
    'text1' : {type : 'text', bind : 'text1', trigger : 'text1'},
    'text2' : {type : 'text', bind : 'text2', trigger : 'text2'},
    'text3' : {type : 'text', bind : 'text3', trigger : 'text3'},
    'text4' : {type : 'text', bind : 'text4', trigger : 'text4'},
    'text5' : {type : 'text', bind : 'text5', trigger : 'text5'},
    'type'  : {type : 'type', bind : 'line'},
    'stroke' : { type : 'stroke', bind : 'line'},
    'stroke-dash' : { type : 'stroke-dash', bind : 'line'},
    'startMarker' : { type : 'startMarker', bind : 'line'},
    'endMarker' : { type : 'endMarker', bind : 'line'}
};

module.exports = EditTransitionAddition;
},{"../util/util":79,"./abstractEditAddition":11}],24:[function(require,module,exports){
var object = require('../util/object');
var SVGShape = require('../svg/svgShape');
var event = require('../core/event');

SVGShape.prototype.hoverable = function(handler) {
    if(object.isBoolean(handler)) {
        this.hoverFlag = handler;
        return;
    } else {
        handler = handler || {};
        this.hoverFlag = true;
    }

    handler = handler || {};
    var that = this;

    this.on('mouseenter', function(evt) {

        if(that.hoverFlag) {
            that.hovered = true;
            event.trigger('element_hoverIn', that);
            if (handler.in) {
                handler.in.apply(that, [evt]);
            }
        }
    });

    this.on('mouseleave', function(evt) {

        if(evt.originalEvent && evt.originalEvent.buttons) {
            return;
        }

        var test = document.elementFromPoint(evt.clientX, evt.clientY);

        if(that.hoverFlag) {
            that.hovered = false;
            event.trigger('element_hoverOut', that);
            if (handler.out) {
                handler.out.apply(that, [evt]);
            }
        }
    });

    return this;
};
},{"../core/event":7,"../svg/svgShape":66,"../util/object":77}],25:[function(require,module,exports){
require('./template');
require('./node');

require('./templateManager').registerTemplate('image', {
    svg :'<g id="{node_id}" class="{cssClass}"><image x="0" y="0" width="{width}" height="{height}" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="{data}"></image></g>',
    data: "data:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAWb0lEQVR4Xu1dW2xkyVn+/jrn9MV2u92+jj2edea6M0l2doHNCgiCiICCgHB7450nxCYhD7zwhsRjEmkJ4oHH8EAQbFAkECFKFnLPbDY7s5PdJLMzOzvj+/3Wtrv79Kmf2qJL1fbpcXvax33Oek7Jn+q0W7Ja/r7/Un/9VY10pEiRIsWTCjrxv5cOPu0CII12AkhFwEkUBEVAvmjA0WglgpR4qRDoWQN8GgRACs6f/tUXh9xMbnRrdSFb3S17MvAFs6QnlnFDLREcx+Ol6Tvrr7/ylTUAFYWqgq8QJEUELjofQoGe/fU/+LN8YeDTLDlgZiJiEoQndki2IiAisbm+8nqtHnzuzW9/9T6ADYWyQi0pIqDjWL9C9m///d7f9A+NfzbjMDyHIAgghSfZA0gFPwBqAcOXwML0O997+XMvvnT39f/5KYBlhS2FqhHB+9kDeH6t6jGAp0cEnhsXkJwGfkHAzXmJW/MMyYyhifO/+kef+bz7b5978Yv33/jubQBIighcHG84QVAXkoGMA/Rl0BBAKoCMo1nFQJZQrjFGzj39wp989qVPvfz5T/2dEsEbSRGBe9zlH0sWDMAiHdxAwMBwD2Gyn/DTFYnRp64+r0TwYpJEIHC8QQyGJj5lPrwaYP2DM32Eq8MCGYehRfCXL714/vpHrwMYU+hXyMa1hHajULvRLTMrICW/xeszvQRA4GfveYKp/xfBy1+I3xOIKJTOUEiZD9HOYRFYTzAVmSeIXwAp+a3rAYFkNSdbBCKqeJdq4ADYgIEEewI3qsoXt84B0hyAFBKcE4gohC5b5gBpBsAhNSTPE7hR+H+WDIBSD9BsFAzUJSBhRjSeIIFJYJoIHr46ghmJ9AQiihxAAmAQ0mFBFGIrMhEkSwBQeKQHSD0AESVaBG50ISBdBRgwQjUAi4TlBG5U+998IlbEoeeTBBGFnjuFIwBBAJBsEbjRhIDoPYCU0sKQf5IiaBAuiCCEMDhWHYCMcEGJFYEbWbYLBkCRkV+vVODv7aFWq6FerxsRnBgM+eR58PJ5ZLNZZDKZzkXAzbpKridwIyl4aBVE5/Z9Rbg3O4v+5WVIIboWAoSUmHYcLAwOYnhoSJPveV4H4SBEfNdEEF8SGA352vp93wcp63dqNTiOg64NKbGxsoKH5TIynodcLgfHcbQQiKgDDxCPCLosgChzAOsBhO9rQiBEd3aaiDRrm5ubWFACGBsdRalU0qHgcT0Q79sEoCgCo24qIQj81IjAdhbdAsANVE1lvrtJYEQ5ADMbLwAOAi0AhS6280pUlOfZAbQX0p+DWYOIOrBdQl0y9upkNYzO+ycKGeCpIuHuGmP43NPP/+FnXvqLl7/w6Zce3v5OAKDe8AB+VwXAkhvERbgMawhBkx8EXa3eyCBA3RB0rCUh6Wl6izG/HeyrnFbrjIpCpw20tTprhr2RKx/5hU/++SeVAOYArdtKQwikwF1rCZMR5gB6thYJEHW5fMchC+3EA2QcRiFLoY/PjUYRVxxFAK1p9DJQIgJq2kEGQwBGGucNNkwY6F4IsDkAEFEOAOZYBQCi5pD02DlAwMC1YeBiiR/JKTMdOSk+OBwCvjdD+P4sEPjVfKNMnG/wSd1KAi3Y7H9TVJW/JAjgmB4AyDrHNS4Gc9gLCGH+NoFl4ADINrgUXReAbAAcFVHxCyCqwSf0cfbbCQsABhRDQ4iGnlIBRAsiah16wodwKNZzATKqywaIzENsAmDmlkR0ebTNO9jqNSFNoXxKcgCTdLXJAWKHtg+OVQA2U1VgRLcK0IhJAAa8HyGBxikIshVYyOQ0hDBwCjyAEbSUEkEQQO9EShna4iMA1NgjMOiWMNgYXuwhIPoTwfEL4D3SfR/VvT2UyzvQxRYbcwGWEAA8YniuA8dx4bouHAWzcaRgxHBieYAEJUQA3MApEQBlcqj2D2OubwIbYgi1II86OWASYADEAVxZR17WkK3U0Bvsokh19HkCPbksMtmc7iNo2kXUiHxwwnoCwadAAFJi8Llfw9CVj2BPEVkV1HJ1U1PYVZCSQUEdTm0XfZUNDJY3MeJsotjbg57eXr2T6HmeEUKkqwBQMgRgRYDTIQAv34NMTx7ikE1VQ6VDBHY9BG4R6/ki1vwqZsorGFlbxMTWFkr9/egrFLQQXNeNzBuwAqz7T0gOwBRF4SN2ATAzAiNoPvoVW5rXTBZ7pbN40DuE5fUZnF1YwMTODkqDg+jt7Q15g+N4AgYpxJ4DWCUyTmwV0L3qHEtI087d4U4dATqPKI9exJ3NIjZW7uIDe7MYHRlBob9fewPHcdqJoN0mlF0FxO0BmjNkjq4OEJsAtAeIIMkSIMjiCOYyeezO/gSVmVlMjAcYGBgIiaDzbfhEeACN6M8BxCgAydFdwCjyfVibfBa1BzdRn54BS6lDQnsRtN+CJiQoB4iaIopLAJIhASBKEeTy2HrqWdy99ypodlbnAQOlkhFBR5tBjiBkXMDzRGBuHjUO+XQUgmL2AMTRLtUp14MNJYJ7d74Db35eF45MQqjmxzY6VwBZl9RMx6oMuEjuiG0VICP3Zo25MICViQ/j3Qc3kMvbglEny0NS0NyzFA0enVgaQnCaSsGyyQOcQNGOWWHkHOaXH6J/bh69vX3m9JEWQmfehckQf6pyAMScAxDjRAY5DirnPoiZN2ZQWl46Tn0g/mWgVcDp8wDgk9vKo8IQ1oqTmF+cRmlwCD09PdoDKHSwC5uEUnC0ccBafRB0etCuM68hA7CUkF24Tbo2fgmLN+9gfG0NxWLRhILHulBCciIaQqIln4jgCAF2Xeyp2Q8CBAr8WIQyKNsDJ9/7eLzIABU3e5IewLLXP4KNXAmrqysYHRvToeBgXYCZ27SMJ8gDcDTka7hCYO3iRdwG8HB6GmvKSmq+314E2n1L+H4A8aGPoeeZjz7W0TJSqHhZQJ7wtfcEUMZDpTiO1cXbKJfLukKovMDR9wI4Kf0A0XfC6qSop1RC6fx5BIUCiuUy/CMIgJm1t9j2A0xf+DAq+T5zRgr0ODG6I7OiI/9vqJG8BaVxbD54DeXtbXMW0YSBI+wFGMNLkAdgRHNG0HEcnRiNCoH+QsG0ZR0pDPi1KmZ2Asz1D8HnZjL4hEXNhwqDW/T0oX8Q5TprD1CtVrV4Q4lg0vsBeJ8kI/UCWgj5fN5sEB3pZpFatYp5L0BduHaXMtbBIdakEYHjoeLmsbuzo29CMSInog6S7jg9gNV1VAIwMBZxJAFoocgANSEQYH8dnWKlP/yKQZDChXSzqFQqJgSEQtqjXrO1uaSsAjjuW7u0BYEBHwKBDfwtpUldILzd7yUJMDna+lusdNqKQSapDsAcRQ4QRS+BBEuCdFpX84yOOGIh8GHn9x7hA1ghkBIB26WuQfulIEWSBIpIZR8L+WErIQ5Ql4x6aH/0aAfqGHS8NcA+8i1k80XSIFTrEkG1ApAl+33XEMIGCTlMCYUc17UY6hJwSAGAIKt2apmjk/nBMK1gmwuoIAsCH1JoZGuNNtS0Jp/tLI0I6nVkKjtwesJVwPaFoOTsBSRqEAkUyEcGElVNur24mcyzpc2KgFg/XXTewe9lvoYf+C/gRv2XQIc0/zG3dO/W0kPEk+3oJQB+Fc7uJjJnJh67RYyRoK5gycnJAYgIvSTRF+yh7mQhiCHQLAT7DJARBhiE8867+OPsf2JMLEDgBu7LC1jjwZYBgQ+xciJ7AwjB/k5wQxwNEfL6MjJBFdlcztxHeOQlLyFRdQAj6/hDgHAEel3C0F4Z65mBfcmfaIQCMrMlH1POND6pLH/MWQUji3F3BS/Im/im/7FQTvAoN89kLH0/yHiAAyLgxfvIC6CnR28JP5YXYHCy6gBstJ6AEJDzPIyWt3Gf6yByIcgKwCFDPkNAP+CcmMXvZ/8b42IZQEaBIMD4xcybeIev4GEwCbGPdGva8sDevCRuiIARNDyMTRCaBFGrgubeRn9vD/r6dGPI0VvFFZBEDxD3MP11XiaDCVpDn7+D3VwRgjTxWu3mWZAmR5G+hN/NvqLmVQA5BTKRGv1UwS9nbmK9NgafPeN3m+K4jcXS7GCDNMmBJV5PsOFBQ67MIrs6jYFLU3onsN12MDMn82wgGOBE5AAWjuuilBEY31vCu7l+OERwG6sBPWsSoC3+E5lXcNZZBpA1aaJljhiXaRr35X38LLgCapa6Jd+4fgQNFx+YGH1AKMIkbpJR/9mPMOwwBgeHzFawIbo9+Un0APZF/F7AdV305vP4wPYaFqtlBD0FQz5coQWAEbGG3858W5G/tJ/8AxbokVSh4C0s1c5ih3utAIzLp/3xPbC8a8FJ2LgPBRJAfXEWzr3XMDo+jKEh3RFkzg6GiO+I/PibQuMPAzklgDO5LYxvPcRc7hocR5j4j1Gxjt/KfAvnnAWAMrankqhlfn3GWceH3Lu4Wb8ONgGCTNy3DfnBAeIlA8ImghpcD1D98SsYJR9nxid0H0AulzvM/SdNAMmHuea9WCjgQnkJ29uLqJXGNb/DYhO/qSz/KWceIE/BgVkcWuunUNH1mvcO5vgcVuQgCPutn4DGgVJLuDhYc2D9GpW7t5C5+yOcvXAOY2Nj6O/vN02h6HTEvxmUmBzAwniBsUIPJlfv4EG2F0MF4OOZ/8UHnBlLPhRINInABvhmHRRoT3mBt/FD/3n4cMAHkjxqRqt1ogCqi3OofecrmCr2YnLyHIaHh431t4/1yQ8BDHCyvIDKrPWJ3InNLciFH+JXBsq44MweIF8BwojAegBCiMUpZxYzchIP5VkjdEv+gXJIM0BAbWsD5Vf+BcP+Fs5ffQYTExPa+jv+VhLSOPYQOKXDJoQeBosOPj7+c1z2Huy/VJOEJR8a1iOQns3vNDLk45p7B3lULAmhHVH7rEFArbyFzW98Gf2Ld3Hx0iVMTU3p5C+fz3d+Sth63lQAj+4PlOD6FqYG72JyuAISzUS3IJ/s6+a8QAMaGBXLOO88ACzJkAbQsM8EVNZXsP5fX0Lfw9u4fOkiLl68qGO/Kv4cKfYT0ePe0p4KQEqJej1ArbKKQe81lPIrhlhDqHX5Gpbk1jATQSDAFUdV8GhTk2wQcBP0a8b2/TtY++o/orjwc1y9fAlXrlzRrt+cAwiTe3QRMBukAmhJfnVvDQP0Kgay8yAKWb4hvQ35sLPNdlCkDSWCnwMs95EuFeoKlfI2lr//NWx99R8wVl3DB69dw9NXr2JycrLVBREdi0Ai9QCtya+so0g3MJCbBZHTHNst+RqiJekW1Hq5A4mL4p7eNQxgLB7YU8Sv/eRVLPzr34Nu/Acuj5Zw/fp1XG2QXyqVdNZvye+8V5LtR4pfAJSMmN+w/A0U8UOUsg9BJpnTOBDn6fDijwW3zLzytINnxC3wzio25mYw94NvYPqfX0Ll6/+Es1zGsx+6huvPPmfcfhvL7wSUjKZQorgVYL9prFrZRD9uKPIfgMgFoECOBYw3EGGrP/quvxEBzomH8L77A9z8+l2MFAuYGB3GxNUrGDtzBiMjI9riVbIX9TVxVoyUpEogxWv5tb0tFPg98u+D9pFuYa0/RH773a7mGVLDFT4+8Qxw9w0PhdIZZe2XtbUPDg42Ex+V1YeviBGAKxIgAIICx+j2K1vo41cxmL0HIRyAXAsbAlokgejI/YOlEQMuTBXwO78xgdvv9unLn1R1Txd4FPlRXBXbWjgEeALIZ4CME3cIsA8xkb+NXvke+W9DCGFItzNc4wFC1n808vnRzyxBBLzwTB6LGzVU9irmfJ9BZOciwu+xtn4h4k4CCaAYye8JXsNQ9g6EIACHuf3Wsd+CW4P1fOj7AwWB5y5XsbmxhM3NreZjXiel/uRcEEGxuf1yg/y3oLmHdvlWBBaPIL4dOWGiw+/BzLjyFHB/bhmLi4sqBBTadPhEknkn52QQaXST/B1k6z/GUO5NOAJNbl+0zfYtaXayCQw1vdfK2mWIfDNls1BeYBffvDmLldVSc5NH5CKgJJ0Opq7W9jX5yCnLH87e0uQD3gHCw/X71kdYDjbtUZhcS3zz8q91gsjA5CgwNbKCuYV5FG0iGME3oCf8dDBRdzZ2KpVdZOo3Ffk34QoG4B4gW4R9UtiKQyuAkIxDXkAaEdhnPiAohs5Drl+sYu7GHJaW9A3h2gt0GAoOOSrOVgSxC4DMfNKWv4eM/zpGMz+CK4JGvCcLOkAqM0DcNMv9/pNDZd9Dln4y5AnsknC/1oaKwLWn1nB7es60e5kbwCL+0giGRBKSQAM+OcuvVipwa7cwmn1VF1+0bplaGy7tr9pZMYgGaS1PB7Y/9sEtPIF9zwLAtaka3l2Yw8LiEAqFvhNJCJkpIWcDrVFFT76UqFb34PqK/Mz34YoagHA8tSRLAEKTBCJr/SDr+jXsFH7BoUAbCgMc6NmC92kmnwOevbCBb701g9XVkmn8iDQhZCRoGUikEDH5UmrLh1O7jVHvu/BEZb9eiR8d40k/WhGEWr3oaKbDBwXAtv+Xg3BIgAk3wNSZOs7OzWNhYdgsCztNCJP9hRHWpiha8qtVuIr8Effb8MRuw/K5pbu3Fq9AzfGfNEHW6snw1L4KSIeJwJKv5parBNclPHepjK+9NoPl5UG9LAxdCXssECTiF0B4v/rYe/qs7wR0am8p8r+FjCgDcMKkox351uVb4h/DVfFBkcGQ3DoUcLhwNFKSuDKxhLeXF1AqDehQEEVtgML5avwCIIoq6fPhKfIHnW8i42zbVm3rYu1MhmRpPoB93+71d56oEKyNEVuSSVv9/rnZHplNtMGHz+9iYXMe6+tndCuYqQ0caySqEERRkG+tH/VVZIPb2KtLlANPLwElB2CGXetTYAs+ONjWbaxLI4K1arg4xHywQGRDgplZSvg+g0EYLZaxXNtFreaHroJLyBdHxg/zT61zH2b3PoqF+XnMz89hbW0VOzs7+joV5lYFEENCiOOTvQaKEa4owtEw1i+Ei7yK/cPDozgzkYMQhJhG8gVg4qJwsvCyg+grEka4Bz2FcdR8vbt2iOrjvxCSQCHdOcLR2X9foQ+DJb0cjH6DKBGrgEgPcjjo7e3R88BAsc01sckGEZlziloIpkPodHkAIg2KSACmYOJ5XjTExw9j9WY+pR6ACIhQBMys59M0iE5zDsDvx39WOkScewEp4q8DiGi6k1L+47mG/Ik+GZTyz+nZwCcbzE+0AFLyZRKOhxNppKPL4GR5gBhEkCImD5AirQOkiB8sbUNKQnYDGUTdOCWcDiIAQRWoVUBBjQBQXAJg81CpE9YrgGTqSp2An9g6BEMQUKn5oCAAccAAOA4BMBSIhBQCeHXOwe0lEaJEtFklEA57P3zew/Rd1iUgOcq/n9wiGO97YMggwNZOBtmshHC9OoCauaq42x5AyqC+HVT3NrcCH5tSOmBJJiLAdMa0IUDPhxFEFMp+A8lqjvTvJ18AsALwa1VIJuIg2ACwpVA1IuiWACQUbnzpr7/seNlbla3Vybq/N8RB0AOwE6kVUdgk+OT+fvLBTMwMCHe3ur02DWBJYVvBV5DdErCjkFEoKAwpDCv0K2TT1UVXQA2r31BYUVhV2DLhoFsewFcoN57LDUE4XbkyIB1k7qVU2FPY7a4HsCp0LCC6SnwqAFYIDoC7ncOQRpejaYrWN1p0L4lNWwMY79+RIkWKFCnS8X8NSN4Y/JWOFgAAAABJRU5ErkJggg==",
    width:'128',
    height:'128'
});
},{"./node":29,"./template":38,"./templateManager":39}],26:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"../dom/dom":47,"../svg/transform":68,"../util/app":74,"../util/object":77,"../util/util":79,"./../dom/eventableNode":49,"dup":10}],27:[function(require,module,exports){
var object = require('../util/object');

var KnobManager = function(diagram) {
    this.knobs = [];
    this.hideDocking = false;
    this.diagram = diagram;
    this.templateMgr = diagram.templateMgr;
    diagram.event.listen('knob_added', this.addKnobListener, this);
    diagram.event.listen('knob_delete', this.deleteKnobListener, this);
};

KnobManager.prototype.getKnobNode = function(id) {
    var result;
    $.each(this.knobs, function(i, knob) {
        if(knob.node.id == id) {
            result = knob.node;
            return false; //Leave loop
        }
    });
    return result;
};

KnobManager.prototype.addKnobListener = function(evt) {
    if(evt.data) {
        this.knobs.push(evt.data);
    }
};

KnobManager.prototype.activateKnobNode = function(svgNode, cfg) {
    var tmplId = svgNode.dala('tmpl');
    return this.templateMgr.getTemplateSync(tmplId).createNode(cfg, this.diagram).activate(svgNode.attr('id'));
};

KnobManager.prototype.createKnobNode = function(p, group, cfg) {
    var knobId = this.diagram.uniqueId();
    var config = object.extend({node_id:'docking_'+knobId, x: p.x, y: p.y, type:'circle'}, cfg);
    var tmpl_id = 'knob_'+config.type.toLowerCase();
    var node = this.templateMgr.getTemplateSync(tmpl_id).createNode(config, this.diagram).init();
    if(group) {
        this.diagram.svg.addToGroup(group, node.root);
    }
    return node;
};

KnobManager.prototype.deleteKnobListener = function(evt) {
    if(object.isDefined(evt.data)) {
        var index = this.knobs.indexOf(evt.data);
        if(index > -1) {
            this.knobs.splice(index, 1);
        }
        evt.data.remove();
    }
};

KnobManager.prototype.hideKnobs = function() {
    this.hideDocking = true;
    this.executeOnAllKnobs(function(knob) {
        knob.hide();
    });
};

KnobManager.prototype.showKnobs = function() {
    this.hideDocking = false;
    this.executeOnAllKnobs(function(knob) {
        knob.show();
    });
};

KnobManager.prototype.executeOnAllKnobs = function(func) {
    object.each(this.knobs, function(index, knob) {
        func(knob);
    });
};

module.exports = KnobManager;

},{"../util/object":77}],28:[function(require,module,exports){
require('./template');
require('./node');
var object = require('../util/object');

var templateMgr = require('./templateManager');

var defaultConfig = {
    dockingType: "CENTER",
    fill: "silver",
    'fill-active': 'green',
    'fill-opacity': '0.5',
    radius: 5,
    stroke: '#7C7C7C',
    'stroke-width': '1',
    'cssClass': 'knob',
    preventSelection: true
};

var circleConfig = object.extend({}, defaultConfig,
    {
        svg :'<circle cx="0" cy="0" r="{radius}" id="{node_id}" class="{cssClass}" style="stroke-width:{stroke-width};stroke:{stroke};fill:{fill};fill-opacity:{fill-opacity};" transform="translate({x} {y})"></circle>'
    });

templateMgr.registerTemplate('knob_circle', circleConfig);

var rectConfig = object.extend({}, defaultConfig,
    {
        svg :'<rect x="0" y="0" id="{node_id}" height="{size}" width="{size}" class="{cssClass}" style="stroke-width:{stroke-width};stroke:{stroke};fill:{fill};fill-opacity:{fill-opacity};" transform="translate({x} {y})"></rect>'
    });

templateMgr.registerTemplate('knob_rect', rectConfig);
},{"../util/object":77,"./node":29,"./template":38,"./templateManager":39}],29:[function(require,module,exports){
/**
 * This class represents the nodes of a diagram. Every note has a unique ID and
 * a template defining the type of the node.
 */
var Eventable = require('./../dom/eventableNode');
var util = require('../util/util');
var dockingType = require('./docking');
var SVG = require('../svg/svg');
var nodeAdditions = require('./nodeAdditions');

var object = util.object;
var dom = util.dom;

var ROOT_CLASS = 'element_root';

/**
 * The constructor does not render a node to the stage. To render a node
 * the init method has to be called.
 */
var Node = function(tmpl, config, diagram) {
    this.config = config || {};
    this.data = {};
    this.diagram = diagram;
    this.isNode = true;
    this.event = diagram.event;
    this.id = config.node_id;
    this.template = tmpl;
    this.selectable = object.isDefined(this.config.selectable) ? this.config.selectable : true;
    this.visible = true;
};

util.inherits(Node, Eventable);

/**
 * This method renders the node to the stage and initializes all event handlers
 * With the part argument we can import the node to another svg part than the default which is the main stage.
 * This is used for example for the defs (which is technically not a real node)
 *
 * @returns {Node_L7.Node.prototype}
 */
Node.prototype.init = function(part, prepend) {
    //ADD Element to stage
    this._setRoot(this.diagram.import(this.template.getSVGString(this.config), part, prepend));
    this.activate();
    this.exec('init');
    return this;
};

Node.prototype.getCorners = function() {
    var x = this.x();
    var y = this.y();
    var bottomy = this.getBottomY();
    var rightx = this.getRightX();
    return [
        {x:x,y:y},
        {x:rightx, y:y},
        {x:rightx, y:bottomy},
        {x:x,y:bottomy}
    ];
};

/**
 * Activates the the node and handler functions by means of the given config
 *
 * @returns itself
 */
Node.prototype.activate = function(nodeID) {

    var cssClass = this.config['cssClass'] || ROOT_CLASS;
    if(nodeID) {
        this.id = this.config.node_id = nodeID;
    }

    if(!this.root) {
        //Activation
        this._setRoot(this.diagram.svg.get(this.id));
    }

    nodeAdditions.init(this);

    if(this.root && this.id) {
        this.initEventFunctions(this.config);
        this.root.dala('tmpl' , this.template.id);
        //We set the dala namespace because in case the nodes are imported/exported/parsed...
        this.root.attr('id', this.id);
        this.root.attr(this.diagram.ns());
        this.root.attr('class', cssClass);
        if(this.config.x && this.config.y) {
            this.moveTo(this.config);
        }
    }

    if(nodeID) {
        this.exec('activate');
    }
    return this;
};

Node.prototype._setRoot = function(root) {
    this.root = this.eventBase = root;
};

Node.prototype.initEventFunctions = function() {
    var that = this;

    if(this.root.hoverable) {
        this.root.hoverable();
    }

    debugger;

    this.on('dblclick', function(evt) {
        debugger;
        evt.stopPropagation();
        that.exec('dblclick', [evt], true);
    }).on('mousedown', function(evt) {
        if(!evt.ctrlKey && that.isVisible()) {

            evt.stopPropagation();
            that.exec('mousedown', [evt], true);
            if(!that.selected) {
                that.select();
            }
        }
    });
};

Node.prototype.isVisible = function() {
    return this.root.isVisible();
};

Node.prototype.hide = function() {
    this.root.hide();
};

Node.prototype.show = function(opacity) {
    this.root.show(opacity);
};

Node.prototype.index = function() {
    return this.$().index();
};

Node.prototype.firstChild = function() {
    return this.root.firstChild();
};

Node.prototype.$ = function() {
    return this.root.$();
}

Node.prototype.moveUp = function() {
    var selector = '.'+ROOT_CLASS;
    this.root.moveUp(selector);
    this.exec('moveUp');
};

Node.prototype.moveDown = function() {
    var selector = '.'+ROOT_CLASS;
    this.root.moveDown(selector);
    this.exec('moveDown');
};

Node.prototype.remove = function() {
    //Note: jquery triggers a remove dom event itself...
    this.exec('remove', undefined, true);
    this.root.remove();
};

Node.prototype.rotate = function(a) {
    return this.root.rotate(a);
};

Node.prototype.move = function(dx, dy) {
    this.root.move(dx, dy);
    this.exec('move', [dx,dy]);
};

Node.prototype.moveTo = function(x, y) {
    this.root.moveTo(x, y);
    this.exec('moveTo', [x,y]);
};

Node.prototype.position = function() {
    return {
        x : this.x(),
        y : this.y()
    };
};

Node.prototype.getInnerSVG = function(prefix) {
    return $.svg(this.getNodeSelector(prefix));
};

Node.prototype.updateAdditions = function(type) {
    this.exec('update');
};

Node.prototype.addOutgoingTransition = function(value) {
    return this.additions.transition.addOutgoingTransition(value);
};

Node.prototype.removeOutgoingTransition = function(transition) {
    this.additions.transition.removeOutgoingTransition(transition);
};

Node.prototype.addIncomingTransition = function(transition) {
    this.additions.transition.addIncomingTransition(transition);
};

Node.prototype.removeIncomingTransition = function(transition) {
    this.additions.transition.removeIncomingTransition(transition);
};

Node.prototype.getRootSVG = function() {
    return this.root;
};

Node.prototype.instance = function() {
    if(object.isDefined(this.root)) {
        return this.root.instance();
    }
};

Node.prototype.selector = function(prefix) {
    if(object.isArray(prefix)) {
        var stringSelector = [];
        var that = this;
        object.each(prefix, function(index, val) {
            stringSelector.push(that.selector(val));
        });
        return stringSelector.join(', ');
    } else {
        return this.getNodeSelector(prefix);
    }
};

Node.prototype.getNodeSelector = function(prefix) {
    var result = '';

    if(!prefix || prefix.length === 0) {
        return '#'+this.id;
    }


    if(!util.string.startsWith(prefix, '#') && !util.string.startsWith(prefix, '.')) {
        result = '#'+prefix;
    } else {
        result = prefix;
    }

    return util.string.endsWith(prefix, '_')
        ? result + this.id
        : result + '_' + this.id;
};

Node.prototype.getRootNode = function() {
    return this.root.getRootNode();
};

Node.prototype.executeTemplateHook = function(hook, args) {
    if(this.template.config && this.template.config.on) {
        var hook = this.template.config.on[hook];
        if(hook) {
            hook.apply(this, args);
        }
    }
};

Node.prototype.select = function(shifted) {
    this.selected = true;
    console.log('select');
    this.exec('select', [shifted]);
};

Node.prototype.deselect = function() {
    this.selected = false;
    this.exec('deselect');
};

Node.prototype.extractNodeId = function(rawId) {
    var splitted = rawId.split('_');
    return splitted[splitted.length - 1];
};

Node.prototype.x = function(withStroke) {
    return this.root.x(withStroke);
};

Node.prototype.y = function(withStroke) {
    return this.root.y(withStroke);
};

Node.prototype.height = function() {
    return this.root.height();
};

Node.prototype.width = function() {
    return this.root.width();
};

Node.prototype.getRightX = function(withStroke) {
    return this.root.getRightX(withStroke);
};

Node.prototype.getBottomY = function(withStroke) {
    return this.root.getBottomY(withStroke);
};

Node.prototype.isLeftOf = function(mousePosition) {
    return mousePosition.x > (this.getRightX());
};

Node.prototype.isRightOf = function(mousePosition) {
    return mousePosition.x < (this.x());
};

Node.prototype.isOver = function(mousePosition) {
    return mousePosition.y > (this.getBottomY());
};

Node.prototype.overlays = function() {
    return this.root.overlays.apply(this.root, arguments);
};

Node.prototype.isUnder = function(mousePosition) {
    return mousePosition.y < (this.getBottomY());
};

Node.prototype.getCenter = function() {
    return this.root.getCenter();
};

/**
 * Determines the location of a given position relative to the node node.
 *
 * @param node
 * @param position
 * @returns {*}
 */
Node.prototype.getRelativeLocation = function(position) {
    return this.root.getRelativeLocation(position);
};

Node.prototype.dump = function() {
    var result = '<b>Node</b> - <b>'+this.id+'</b><br />';
    result += 'Template: '+this.template.id+'<br />';
    $.each(this.additions, function(key, value) {
        if(value.dump) {
            result += value.dump()+'<br />';
        }
    });
    return result;
};

Node.prototype.toString = function(position) {
    return this.root.toString();
};

module.exports = Node;
},{"../svg/svg":63,"../util/util":79,"./../dom/eventableNode":49,"./docking":19,"./nodeAdditions":30}],30:[function(require,module,exports){
var additions = require('./additions');

//Init default additions
additions.registerNodeAddition('resize', require('./resizeAddition'));
additions.registerNodeAddition('edit', require('./editNodeAddition'));
additions.registerNodeAddition('transition', require('./transitionAddition'));

module.exports = {
    init : function(node) {
        additions.initNodeAddition('transition', node);
        additions.initNodeAddition('edit', node);
        additions.initNodeAddition('resize', node);
    }
}
},{"./additions":14,"./editNodeAddition":22,"./resizeAddition":34,"./transitionAddition":41}],31:[function(require,module,exports){
require('./draggable');
require('./hoverable');

var util = require('../util/util');
var event = require('../core/event');
var Node = require('./node');
var AbstractManager = require('./abstractManager');

var cache = require('../core/cache');
var object = util.object;
var dom = util.dom;
var config = require('../core/config');

var EVT_CREATE = 'node_create';
//TODO: implement like copy paste by diagram event
var EVT_DELETE = 'node_delete';

var EVT_RESIZED = 'node_resized';
var EVT_ADDED = 'node_added';
var EVT_SELECTED = 'node_selected';
var EVT_DESELECTED = 'node_deselected';
var EVT_REMOVED = 'node_removed';

var CMD_ADD = 'node_add';
var CMD_DELETE = 'node_delete';
var CMD_COPY = 'node_copy';
var CMD_DROP = 'node_drop';
var CMD_RESIZE = 'node_resize';
var CMD_EDIT = 'node_edit';

var NodeManager = function(diagram) {
    // Contains all nodes added to the diagram
    AbstractManager.call(this, diagram);
    this.nodes = {};

    this.selectionMgr = diagram.selectionMgr;
    this.templateMgr = diagram.templateMgr;

    this.listen(EVT_CREATE, this.createNodeListener);
    this.listen(EVT_DELETE, this.deleteNodeListener);
    this.listen(EVT_RESIZED, this.resizeNodeListener);

    this.command(CMD_ADD, this.createNode, this.deleteNode);
    this.command(CMD_DELETE, this.deleteNode, this.importNode);
    this.command(CMD_COPY, this.importNode, this.deleteNode);
    this.command(CMD_DROP, this.moveNode, this.moveNode);
    this.command(CMD_RESIZE, this.resizeNode, this.resizeNode);
    this.command(CMD_EDIT, this.editNode, this.undoEdit);

    this.initCopyPasteHandler();
};

util.inherits(NodeManager, AbstractManager);

NodeManager.prototype.initCopyPasteHandler = function() {
    var that = this;

    this.diagram.on('copy', function(evt) {
        var copyNodes = {};
        var copyTransitions = {};
        var nodeCount = 0;

        if(!that.selectionMgr.selectedNodes.length) {
            that.lastCopy = null;
            return;
        }

        $.each(that.selectionMgr.selectedNodes, function(index, node) {
            if(!node.knob) {
                nodeCount++;
                copyNodes[node.id] =  {svg : node.toString(), position: node.position()};
                $.each(node.additions.transition.outgoingTransitions, function(index, transition) {
                    if(transition.getEndNode().selected) {
                        copyTransitions[transition.id] ={svg : transition.toString(), start: transition.getStartNode().id, end: transition.getEndNode().id};
                    }
                });

                $.each(node.additions.transition.incomingTransitions, function(index, transition) {
                    if(!copyTransitions[transition.id] && transition.getStartNode().selected) {
                        copyTransitions[transition.id] = {svg : transition.toString(), start: transition.getStartNode().id, end: transition.getEndNode().id};
                    }
                })
            }
        });


        var topNode = that.getTopNode(that.selectionMgr.selectedNodes);
        var leftNode = that.getLeftNode(that.selectionMgr.selectedNodes);

        that.lastCopy = {
            x : leftNode.x(),
            y: topNode.y(),
            nodes : copyNodes,
            count : nodeCount,
            transitions : copyTransitions
        };
    });

    this.diagram.on('paste', function(evt) {
        if(!that.lastCopy || !that.lastCopy.count) {
            return;
        }

        var mouse = that.diagram.getStagePosition(event.mouse());
        var d = {x:(mouse.x - that.lastCopy.x), y:(mouse.y - that.lastCopy.y)};

        that.importCopyNodes().then(function(result) {
            var ids = [];
            var svgStrings = [];
            var nodeIdMapping = {};
            var nodes = [];
            that.selectionMgr.clear();

            $.each(result, function(index, node) {
                nodes.push(node);
                node.select(true);
                nodeIdMapping[node.config.oldId] = node.config.newId;
                ids.push(node.id);
                svgStrings.push(node.toString());
            });

            that.importCopyTransitions(nodeIdMapping).then(function(transitions) {
                //that.addCmd('cmd_group', [[CMD_COPY, [svgStrings], [ids]], []])
                $.each(nodes, function(index, node) {
                    node.triggerDrag(d.x, d.y);
                    //We have to deselect because its already selected after creation and we shift select it
                    //for multiple node copies. If not deselected this would deselect the node in selectionmgr
                    node.deselect();
                    node.select(true);
                });
                $.each(transitions, function(index, transition) {
                    transition.moveInnerKnobs(d);
                    transition.selectInnerKnobs();
                });

                that.addCmd(CMD_COPY, [svgStrings], [ids]);
            });

        }, function(err) {});
    });
};

NodeManager.prototype.size = function() {
    return object.size(this.nodes);
};

NodeManager.prototype.getTopNode = function(nodes) {
    return this.sorted(nodes, function(a,b) {
        return (a.y() > b.y()) ? 1 : -1;
    })[0];
};

NodeManager.prototype.getLeftNode = function(nodes) {
    return this.sorted(nodes, function(a,b) {
        return (a.x() > b.x()) ? 1 : -1;
    })[0];
};

NodeManager.prototype.getBottomNode = function(nodes) {
    return this.sorted(nodes, function(a,b) {
        return (a.getBottomY() < b.getBottomY()) ? 1 : -1;
    })[0];
};

NodeManager.prototype.getRightNode = function(nodes) {
    return this.sorted(nodes, function(a,b) {
        return (a.getRightX() < b.getRightX()) ? 1 : -1;
    })[0];
};

NodeManager.prototype.sorted = function(nodes, compare) {
    if(object.isFunction(nodes)) {
        compare = nodes;
        nodes = undefined;
    }
    nodes = this.getNodesAsArray(nodes);
    return nodes.sort(compare);
};

NodeManager.prototype.getNodesAsArray = function(nodes) {
    nodes = nodes || this.nodes;
    if(!object.isArray(nodes)) {
        return $.map(nodes, function(val) {
            return val;
        })
    } else {
        return nodes;
    }
};

NodeManager.prototype.importCopyNodes = function() {
    var promises = [];
    var that = this;
    $.each(that.lastCopy.nodes, function(key, value) {
        promises.push(that.importNode(value.svg, {
            oldId : key,
            x : value.position.x,
            y : value.position.y,
            newId : that.diagram.uniqueId()
        }));
    });
    return Promise.all(promises);
};

NodeManager.prototype.importCopyTransitions = function(nodeIdMapping) {
    var that = this;
    return new Promise(function(resolve, reject) {
        var result = [];
        $.each(that.lastCopy.transitions, function(key, value) {
            var svg = value.svg;
            svg = svg.replace(new RegExp(value.start, 'g'), nodeIdMapping[value.start]);
            svg = svg.replace(new RegExp(value.end, 'g'), nodeIdMapping[value.end]);
            var transition = that.diagram.transitionMgr.importTransition(svg, {oldId:key, newId:that.diagram.uniqueId()});
            transition.update();
            result.push(transition);
        });
        resolve(result);
    });
};

NodeManager.prototype.createNodeListener = function(evt) {
    try {
        var stagePosition = this.diagram.getStagePosition(evt);
        this.createNodeCommand(evt.data, stagePosition);
    } catch(err) {
        console.error(err);
        event.trigger('error', 'Error occured while creating node !');
    }
};

NodeManager.prototype.createNodeCommand = function(tmpl, cfg) {
    cfg = cfg || {};
    cfg = $.extend({}, cfg, config.val('node_settings', {}));

    if(!tmpl) {
        event.trigger('warn', 'Could not create Node: No template selected!');
        return;
    }

    cfg.node_id = this.diagram.uniqueId();
    cfg.diagramId = this.diagram.id;
    return this.exec(CMD_ADD, [tmpl, cfg], [cfg.node_id]);
};

NodeManager.prototype.createNode = function(tmpl, cfg) {
    var that = this;
    var node = tmpl.createNode(cfg, this.diagram).init();
    if(!cfg.preventDrag) {
        node.draggable();
        node.on('dblclick', function() {
           console.log('yeessssss');
        });
        node.on('select', function() {
            that.event.trigger(EVT_SELECTED, node);
        }).on('deselect', function() {
            that.event.trigger(EVT_DESELECTED, node);
        }).on('remove', function() {
            that.event.trigger(EVT_REMOVED, node);
        }).on('edit', function(evt, key, value, oldValue) {
            that.addCmd(CMD_EDIT, [node.id, key, value], [node.id, key, oldValue]);
        }).on('dragEnd', function() {
            var selection = that.selectionMgr.getSelectedNodes();
            //We just add the command since we don't want to execute the drag twice

            //For API calls where the node is not necessarily selected
            if($(selection).filter(function(i) { return this.id === node.id;}).length < 1) {
                selection.push(node);
            }


            that.addCmd(CMD_DROP,
                [selection, node.dragContext.dxSum, node.dragContext.dySum],
                [selection, (-1 * node.dragContext.dxSum), (-1 * node.dragContext.dySum)]);
        });
    }
    this.addNode(node);
    return node;
};

NodeManager.prototype.addNode = function(node) {
    this.nodes[node.id] = node;
    this.event.trigger(EVT_ADDED, node);
};


NodeManager.prototype.activateNode = function(node, cfg) {
    var domNode;
    if(node.SVGElement) {
        domNode = node.instance();
    } else if(object.isString(node)) {
        domNode = this.diagram.svg.get(node);
    } else {
        domNode = node;
    }

    var attributes = dom.getAttributes(domNode);
    var that = this;
    return new Promise(function(resolve, reject) {
        that.templateMgr.getTemplate(attributes['dala:tmpl'])
            .then(function (tmpl) {
                resolve(that.activate(attributes['id'], tmpl, cfg));
            }, reject);
    });
};

NodeManager.prototype.activate = function(nodeId, tmpl, cfg) {
    //Create Node instance and set nodeId
    cfg = cfg || {};
    var node = tmpl.createNode(cfg, this.diagram)
        .activate(nodeId)
        .draggable();

    this.addNode(node);
    return node;
};

NodeManager.prototype.deleteNodeListener = function(evt) {
    try {
        var node = this.getNode(evt.data);
        if(node.knob) {
            //CMD is handled by transitionMgr
            node.remove();
        } else if(node) {
            return this.exec(CMD_DELETE, [node.id], [node.toString()]);
        }
    } catch(err) {
        console.error(err);
        event.trigger('error', 'Could not delete node('+node.id+')');
    }
};

NodeManager.prototype.clear = function(nodes) {
    $.each(this.nodes, function(id, node) {
        node.remove();
    });
};

NodeManager.prototype.deleteNode = function(node) {
    if(object.isArray(node)) {
        var that = this;
        $.each(node, function(index, value) {
            that.deleteNode(value);
        });
        return;
    }

    node = this.getNode(node);
    if(node) {
        node.remove();
        delete this.nodes[node.id];
        cache.clearBySuffix(node.id);
    } else {
        console.warn('delete node was called for unknown node');
    }
};

NodeManager.prototype.importNode = function(nodeStr, cfg) {
    if(object.isArray(nodeStr)) {
        var promises = [];
        var that = this;
        $.each(nodeStr, function(index, value) {
            promises.push(that.importNode(value, cfg));
        });

        return new Promise(function(resolve, reject) {
            Promise.all(promises).then(function(nodes) {
                resolve(nodes);
            });
        });

    }

    cfg = cfg || {};

    //If set we replace the old node id with a new one e.g. when we copy a node
    if(cfg.newId && cfg.oldId) {
        nodeStr = nodeStr.replace(new RegExp(cfg.oldId, 'g'), cfg.newId);
    }

    //Insert to dom and activate the new node
    var targetInstance = this.diagram.import(nodeStr);
    return this.activateNode(targetInstance, cfg);
};

NodeManager.prototype.getNodeAsString = function(node) {
    node = this.getNode(node);
    return node.toString();
};

NodeManager.prototype.moveNode = function(node, dxSum, dySum) {
    if(object.isArray(node)) {
        var that = this;
        $.each(node, function(index, value) {
            that.moveNode(value, dxSum, dySum);
        });
    } else {
        node = this.getNode(node);
        if(node) {
            node.triggerDrag(dxSum, dySum);
        }
    }
};

/**
 * TODO: listen through node event !
 * @param evt
 */
NodeManager.prototype.resizeNodeListener = function(evt) {
    try {
        var node = evt.data;
        if(node) {
            var resizeInstance = node.additions.resize.get();
            this.addCmd(CMD_RESIZE,
                [node.id, resizeInstance.dx, resizeInstance.dy, resizeInstance.knob],
                [node.id, (-1*resizeInstance.dx), (-1*resizeInstance.dy), resizeInstance.knob]);
        }
    } catch(err) {
        console.log(err);
    }
};

NodeManager.prototype.resizeNode = function(node, dx, dy, knob) {
    node = this.getNode(node);
    if(node) {
        node.additions.resize.get().resize(dx,dy,knob);
    } else {
        console.warn('resizeNode was for unknown node :'+node.toString());
    }
};

NodeManager.prototype.getNode = function(id) {
    if(object.isString(id) && !isNaN(id)) {
        return this.nodes[parseInt(id)];
    } else if(!isNaN(id)) {
        return this.nodes[id];
    } else if(id instanceof Node) {
        //We assume a node instance
        return id;
    } else {
        console.warn('getNode call with no result for :'+id);
    }
};

NodeManager.prototype.getNodes = function(filter) {
    if(!filter) {
        return object.toArray(this.nodes);
    } else {
        var result = [];
        object.each(this.nodes, function(key, value) {
            if(filter(value)) {
                result.push[value];
            }
        });
        return result;
    }
};

NodeManager.prototype.editNode = function(node, editKey, newValue) {
    node = this.getNode(node);
    node.additions.edit.setValue(editKey, newValue);
};

NodeManager.prototype.undoEdit = function(node, editKey, newValue) {
    node = this.getNode(node);
    node.additions.edit.setValue(editKey, newValue);
};

NodeManager.prototype.dump = function() {
    var result = '<b>Nodemanager</b> - '+this.size()+' Nodes<br /><br />';
    $.each(this.nodes, function(index, node) {
        result += node.dump()+'<br />';
    });
    return result;
};

NodeManager.prototype.validateNode = function(node) {
    if(!node) {
        return ['Error: Undefined Node!'];
    }

    var result = {};
    if(!node.id) {
        result['NodeId'] = 'Error: Node has no Id!';
    } else {
        if(!this.getNode(node.id)) {
            result['NodeId'] = 'Error: Node '+node.id+' not registered!';
        }
        if(!this.diagram.svg.get('#'+node.id).length) {
            result['NodeId'] = 'Error: Node'+node.id+' not part of SVG!';
        }
    }
    return result;
};

module.exports = NodeManager;
},{"../core/cache":2,"../core/config":6,"../core/event":7,"../util/util":79,"./abstractManager":12,"./draggable":21,"./hoverable":24,"./node":29}],32:[function(require,module,exports){
var config = require('../core/config');
var CurvePathManager = require('./curvedPathManager');
var StraightPathManager = require('./straightPathManager');
var RoundPathManager = require('./roundPathManager');
var pathManager = {};

var register =   function(constructor) {
    pathManager[constructor.type] = constructor;
};

register(CurvePathManager);
register(StraightPathManager);
register(RoundPathManager);

module.exports =  {
    register : register,
    get : function(transition, id) {
        id = id || config.val('transition_type', StraightPathManager.type);
        if(pathManager[id]) {
            return new pathManager[id](transition);
        }
    }
};
},{"../core/config":6,"./curvedPathManager":16,"./roundPathManager":35,"./straightPathManager":37}],33:[function(require,module,exports){
var util = require('../util/util');
var event = require('../core/event');
var Command = require('../core/command');
var Transform = require('../svg/transform');
var SVG = require('../svg/svg');
var DragConfig = require('../svg/dragConfig');
var Knob = require('./knob');

var object = util.object;
var dom = util.dom;

// Used to identify the different knobs from north west clockwise
var KNOB_NW = 0;
var KNOB_N = 1;
var KNOB_NE = 2;
var KNOB_E = 3;
var KNOB_SE = 4;
var KNOB_S = 5;
var KNOB_SW = 6;
var KNOB_W = 7;


// specifies the space between node and resize knob
var DIF = 3;

// specifies the size of a knob
var SIZE = 5;

// used for calculating the position of the knobs
var DIF_REL = DIF + SIZE;

var Resize = function(node, diagram) {
    this.diagram = diagram;
    this.event = diagram.event;
    this.knobs = [];
    this.node = node;
    this.config = this.node.template.config.resize;
};

/**
 * Renders the knobs around the node.
 */
Resize.prototype.activateKnobs = function() {
    var positions = this.calculateKnobPosition();


    if(!$('#resize_group_'+this.node.id).length) {
        this.group = this.diagram.svg.g({id: 'resize_group_' + this.node.id}).translate(this.node.position()).rotate(this.node.rotate());

        //Initialize the different knobs with different drag restricitons
        this.createKnob(KNOB_NW, positions[KNOB_NW], new DragConfig());
        this.createKnob(KNOB_N, positions[KNOB_N], new DragConfig().yOnly());
        this.createKnob(KNOB_NE, positions[KNOB_NE], new DragConfig());
        this.createKnob(KNOB_E, positions[KNOB_E], new DragConfig().xOnly());
        this.createKnob(KNOB_SE, positions[KNOB_SE], new DragConfig());
        this.createKnob(KNOB_S, positions[KNOB_S], new DragConfig().yOnly());
        this.createKnob(KNOB_SW, positions[KNOB_SW], new DragConfig());
        this.createKnob(KNOB_W, positions[KNOB_W], new DragConfig().xOnly());

    }
};

/**
 * Renders a knob to the given position and configures the drag and hover
 * logic. The total drag amount of one drag is can be acessed through
 * this.dx and this.dy.
 */
Resize.prototype.createKnob = function(knob, p, dragCfg) {
    var that = this;
    // Initialize draglogic
    var dragHook = dragCfg
        .dragStart(function(evt) {
            that.dx = 0;
            that.dy = 0;
            that.dragKnob = knob;
            that.knobs[knob].fill('green');
        })
        .dragMove(function(evt, dx, dy) {
            //We keep track of the total drag movement
            dx = object.isOneOf(knob, KNOB_NW, KNOB_W, KNOB_SW) ? -1 * dx : dx;
            dy = object.isOneOf(knob, KNOB_NW, KNOB_N, KNOB_NE) ? -1 * dy : dy;

            that.dx += dx;
            that.dy += dy;

            that.resize(dx,dy);
        })
        .dragEnd(function(evt) {
            that.event.trigger('node_resized', that.node);
            that.knobs[knob].fill('black');
        })
        .getScale(function() {
            return that.diagram.scale;
        }).get();

    dragHook.preventAlignment = true;

    // Render the knob on stage
    this.knobs[knob] = new Knob(this.diagram, p, {type:'rect', fill:'black', 'fill-active':'black', stroke:'none', selectable:false, 'stroke-width':0, size:SIZE, 'fill-opacity':1}, this.group)
        .draggable(dragHook).hoverable();
};

/**
 * Determines all svg elements participating in the resize process, which
 * are configured in the resize config bind attribute
 */
Resize.prototype.getResizeElements = function() {
    var result = [];
    var that = this;
    object.each(this.config, function(index, value) {
        if(value.bind === 'root') {
            result[index] = that.node.root;
        } else {
            var svgSelector = that.node.getNodeSelector(value.bind);
            result[index] = $.qCache().svg(svgSelector);
        }
    });
    return result;
};

/**
 * Updates the resize logic
 */
Resize.prototype.update = function() {
    this.resize(0,0);
};

/**
 * Resizes the node by applying the configured resize logic to the inner
 * svg elements of the nodes. The dx and dy values specifie the resize
 * amount of the x- and y-axis. After the actual resize process the knobs
 * are aligned to the new node dimension.
 */
Resize.prototype.resize = function(dx, dy) {
    this.updateNodes(dx,dy);
    this.updateKnobs(true);
};

/**
 * Aligns a single knob to the
 * @param {type} resizeKnob
 * @returns {undefined}
 */
Resize.prototype.updateKnobs = function(resizeKnob) {
    if(object.isDefined(this.group)) {
        if(object.isDefined(resizeKnob) && resizeKnob) {
            var positions = this.calculateKnobPosition();
            this.knobs[KNOB_NW].moveTo(positions[KNOB_NW]);
            this.knobs[KNOB_N].moveTo(positions[KNOB_N]);
            this.knobs[KNOB_NE].moveTo(positions[KNOB_NE]);
            this.knobs[KNOB_E].moveTo(positions[KNOB_E]);
            this.knobs[KNOB_SE].moveTo(positions[KNOB_SE]);
            this.knobs[KNOB_S].moveTo(positions[KNOB_S]);
            this.knobs[KNOB_SW].moveTo(positions[KNOB_SW]);
            this.knobs[KNOB_W].moveTo(positions[KNOB_W]);
            this.node.exec('resize');
        } else {
            //If the flag is not set we just do an update probably from simple node drag/drop
            this.group.translate(this.node.position());
        }
    }
};

Resize.prototype.calculateKnobPosition = function() {
    var sizeDifsum = (SIZE + DIF)
    var left = -1 * sizeDifsum;
    var top = left;
    var right = this.node.width() + DIF;
    var centerX = right / 2 - (sizeDifsum / 2);
    var bottom = this.node.height() + DIF;
    var centerY = bottom / 2 - (sizeDifsum / 2);

    var result = [];
    result[KNOB_NW] = {x:left, y:top};
    result[KNOB_N] = {x:centerX, y:top};
    result[KNOB_NE] = {x:right, y:top};
    result[KNOB_E] = {x:right, y:centerY};
    result[KNOB_SE] = {x:right, y:bottom};
    result[KNOB_S] = {x:centerX, y:bottom};
    result[KNOB_SW] = {x:left, y:bottom};
    result[KNOB_W] = {x:left, y:centerY};
    return result;

};

Resize.prototype.removeKnobs = function() {
    if(object.isDefined(this.group)) {
        this.group.remove();
    } else if($('#resize_group_'+this.node.id).length) {
        $('#resize_group_'+this.node.id).remove();
    }
    delete this.group;
};

Resize.prototype.updateNodes = function(dx,dy) {

    if(!object.isDefined(this.resizeElements)) {
        this.resizeElements = this.getResizeElements();
    }

    var that = this;
    object.each(this.resizeElements, function(index, element) {
        that.updateNode(index,element,dx,dy);
    });

    if(!object.isDefined(dx)) {
        return;
    }

    var alignX = object.isOneOf(this.dragKnob, KNOB_NW, KNOB_W, KNOB_SW) ? dx * -1 : 0;
    var alignY = object.isOneOf(this.dragKnob, KNOB_NW, KNOB_N, KNOB_NE) ? dy * -1 : 0;
    this.node.root.move(alignX, alignY);

    //For API calls the group was not rendered if the node is not selected
    if(this.group) {
        this.group.move(alignX, alignY);
    }
};

Resize.prototype.updateNode = function(index, element, dx, dy) {
    dx = (!object.isDefined(dx))? 0 : dx;
    dy = (!object.isDefined(dy))? 0 : dy;

    var elementConfig = this.config[index];
    if(object.isDefined(elementConfig.value)) {
        //TODO: cleaner implementation
        //Scale with even alignment (default for type scale)
        if(elementConfig.value[0].type === 'scale' && elementConfig.even) {
            var d = util.math.minMax(dx,dy).max;
            this.setResize(element, elementConfig, elementConfig.value[0], d, 'width');
        } else {
            if(elementConfig.value[0].type !== 'vertical') {
                this.setResize(element, elementConfig, elementConfig.value[0], dx, 'width');
            }
            //We just set one dimension for a circle
            if(elementConfig.value[0].type !== 'circle' || this.dragKnob === KNOB_S || this.dragKnob === KNOB_N) {
                this.setResize(element,elementConfig, elementConfig.value[1], dy, 'height');
            }
        }
    }

    if(object.isDefined(elementConfig.min)) {
        this.alignValueLimit(element, elementConfig.min[0], 'width', 'min');
        this.alignValueLimit(element, elementConfig.min[1], 'height', 'min');
    }

    if(object.isDefined(elementConfig.max)) {
        this.alignValueLimit(element, elementConfig.max[0], 'width', 'max');
        this.alignValueLimit(element, elementConfig.max[1], 'height', 'max');
    }

    if(object.isDefined(elementConfig.position)) {
        this.alignPosition(element, elementConfig);
    }
};

Resize.prototype.setResize = function(svgElement, elementConfig, setting, d, dimension) {
    switch(setting.type) {
        case 'static':
        case 'none':
            break;
        case 'vertical':
            var newY = parseInt(svgElement.attr('y2')) + d;
            svgElement.attr('y2', newY);
            break;
        case 'parent':
            //We could check the resize settings of the parent if this is static
            //we do not have to change anything when resizing.
            svgElement[dimension](1);

            //Get the dimension from parent node
            var parentVal = svgElement.$().parent().get(0).getBBox()[dimension];
            svgElement[dimension](parentVal + setting.value);
            break;
        case 'scale':
            if(elementConfig.even) {
                var scale = svgElement.scale()[0];
                var ratio = d / svgElement.getBBox().width;
                svgElement.scale(scale + ratio);
                $.each(svgElement.find('.alignScale'), function(index, svgToAlign) {
                    svgToAlign.scale(1 / svgElement.scale()[0]);
                });
                $.each(svgElement.find('.alignScaleStroke'), function(index, svgToAlign) {
                    var current = svgToAlign.strokeWidth();
                    var init = current * scale;
                    svgToAlign.strokeWidth(init / svgElement.scale()[0]);
                });
                break;
            } else {
                var scaleOld  = svgElement.scale();
                var scaleIndex = (dimension === 'height') ? 1 : 0;
                var scaleNew = scaleOld.slice();
                //Add the ratio from original size (without scale)
                scaleNew[scaleIndex] += (d / svgElement.getBBox()[dimension]);
                svgElement.scale(scaleNew[0], scaleNew[1]);
            }


            /**
             * TODO: search for inner elements with class .alignScaling and aling e.g. stroke-width, font-size..
             */
            break;
        default:
            var currentVal = svgElement[dimension](false);
            var newValue = (currentVal + d);
            if(newValue > 0) {
                svgElement[dimension]((currentVal + d));
            }
            break;
    }
};

Resize.prototype.alignValueLimit = function(svgElement, setting, dimension, type) {
    var value = setting.type;
    var limit;

    if(value === 'parent') {
        limit = svgElement.$().parent()[0].getBBox()[dimension];
    } else if(!isNaN(value)) {
        limit = parseInt(value);
    } else if(util.string.startsWith(value, '#')) {
        limit = $.qCache(this.node.getNodeSelector(value))[0].getBBox()[dimension];
    } else {
        return;
    }

    if(object.isDefined(setting.value)) {
        limit += setting.value;
    }

    var currentVal = svgElement[dimension](false)
    if((type === 'min' && currentVal < limit) || (type === 'max' && currentVal > limit)) {
        svgElement[dimension](limit);
    }
};

Resize.prototype.alignPosition = function(svgElement, elementConfig) {
    //var setting = elementConfig.
    //TODO: set alignElement id in config !
    var x = this.getAlignedPosition(svgElement,elementConfig.position[0], elementConfig.alignto, 'width' , 'x');
    var y = this.getAlignedPosition(svgElement,elementConfig.position[1], elementConfig.alignto, 'height', 'y');

    if(object.isDefined(x)) {
        svgElement.moveX(x);
    }

    if(object.isDefined(y)) {
        svgElement.moveY(y);
    }
};

Resize.prototype.getAlignedPosition = function(svgElement, settings, alignto, dimension, dimensionCoord) {
    switch(settings.type) {
        case 'none':
            break;
        case 'center':
            var alignSVG = this.getAlignElement(alignto, svgElement);
            if(object.isDefined(alignSVG)) {
                var alignVal = alignSVG.getCenter()[dimensionCoord];
                return alignVal - (svgElement[dimension]() / 2) - settings.value;
            };
            break;
        case 'relative':
            var $prevNode = svgElement.$().prev();
            if($prevNode.length) {
                var prevSVG = $.qCache().svg($prevNode);
                var prevVal = prevSVG[dimension]();
                var prevCoord = prevSVG[dimensionCoord]();
                return (prevCoord + prevVal) + settings.value;
            } else {
                //No prev sibling
                return 0;
            };
            break;
        case 'right':
        case 'bottom':
            var alignSVG = this.getAlignElement(alignto, svgElement);
            if(object.isDefined(alignSVG)) {
                var alignVal = (settings.type === 'right')? alignSVG.getRightX():alignSVG.getBottomY();
                return (alignVal - svgElement[dimension]()) - settings.value;
            };
            break;
        default:
            return;
    }
};

Resize.prototype.getAlignElement = function(alignto, svgElement) {
    var elementToAlign;
    //The alignto setting can be the parent-, root- or an explicit element default is the previous sibling element
    if(!alignto || alignto === 'prev') {
        elementToAlign = $.qCache().svg(svgElement.$().prev());
    }else if(alignto === 'parent') {
        elementToAlign = $.qCache().svg(svgElement.$().parent());;
    } else if(alignto === 'root') {
        elementToAlign = this.node.root;
    } else {
        elementToAlign = $.qCache().svg(this.node.getNodeSelector(alignto));
    }

    if(!elementToAlign) {
        console.warn('Could not determine alignto element "'+alignto+'" for node '+this.node.id);
    }

    return elementToAlign;
};

module.exports = Resize;

},{"../core/command":4,"../core/event":7,"../svg/dragConfig":53,"../svg/svg":63,"../svg/transform":68,"../util/util":79,"./knob":26}],34:[function(require,module,exports){
var object = require('../util/object');
var Resize = require('./resize');

var ResizeAddition = function(node) {
    this.node = node;
    this.resize = new Resize(this.node, this.node.diagram);
};

ResizeAddition.prototype.resizeNode = function(dx, dy) {
    //This is the api way to resize a node we imitate the dragevent.
    this.resize.updateNodes(dx,dy);
    this.resize.dragKnob = 4; //We set the KNOB_SE knob as dragKnob for the redo command
    this.resize.dx = dx;
    this.resize.dy = dy;
    this.node.event.trigger('node_resized', this.node);
};

ResizeAddition.prototype.select = function() {
    this.resize.activateKnobs();
};

ResizeAddition.prototype.deselect = function() {
    this.resize.removeKnobs();
};

ResizeAddition.prototype.remove = function() {
    this.deselect();
};

ResizeAddition.prototype.dragMove = function() {
    this.resize.updateKnobs();
};

ResizeAddition.prototype.edit = function() {
    this.resize.update();
};

ResizeAddition.prototype.update = function() {
    //TODO: Through EVENTS !
    this.resize.updateKnobs();
};

ResizeAddition.prototype.init = function() {
    this.resize.updateNodes();
};

ResizeAddition.prototype.activate = function() {
    this.resize.updateNodes();
};

ResizeAddition.prototype.get = function() {
    return this.resize;
};

ResizeAddition.requireConfig = true;

module.exports = ResizeAddition;
},{"../util/object":77,"./resize":33}],35:[function(require,module,exports){
var StraightPathManager = require('./straightPathManager');
var util = require('../util/util');

var RoundPathManager = function(transition) {
    StraightPathManager.call(this, transition);
    this.type = RoundPathManager.type;
};

util.inherits(RoundPathManager, StraightPathManager);

RoundPathManager.type = 'round';

RoundPathManager.prototype.buildPath = function(positions) {
    this.init(positions[0]);
    this.create(positions[positions.length -1]);

    for(var i  = 1; i < positions.length - 1; i++) {
        this.add(i, positions[i]);
    }
};

RoundPathManager.prototype.add = function(index, position) {
    var corners = this.path.valuesByType('Q');
    if(this.path.length() == 1) { // Initial Add
        this.path.insertLine(index, position);
    } else if(index - 1 <= corners.length) { //Add innser Knob
        //Get the endIndex/position of the line before the new corner
        var prevEndIndex = (index == 1) ? 1 : corners[index - 2].index + 1;
        this.path.insertQBezier(prevEndIndex + 1,position);
        this.path.insertLine(prevEndIndex + 2, this.path.value(prevEndIndex).to());
        this.updatePart(index);
    } else { // Append knob
        var end = this.path.end();
        this.path.qBezier(position, undefined);
        this.path.line(end);
        this.updateCorner(index);
    }
};

RoundPathManager.prototype.updatePart = function(index, position, prevUpdateNeighbors) {
    var corners = this.path.valuesByType('Q');
    if(index == 0) { // First Knob
        this.path.start(position);
        if(corners.length > 0) {
            this.updatePart(1, undefined, true);
        }
    } else if(index > corners.length) { // Last Knob

        this.path.end(position);
        if(corners.length > 0) {
            this.updatePart(corners.length, undefined, true);
        }
    } else { // Inner Knobs
        this.updateCorner(index, position, prevUpdateNeighbors);
    }
};

RoundPathManager.prototype.updateCorner = function(index, position, prevUpdateNeighbors) {
    var corners = this.path.valuesByType('Q');
    var cornerIndex = index - 1;
    this.updateCornerStart(cornerIndex, corners, position);
    this.updateCornerEnd(cornerIndex, corners, position);

    if(!prevUpdateNeighbors) {
        this.updatePart(index + 1, undefined, true);
        this.updatePart(index - 1, undefined, true);
    }
};

RoundPathManager.prototype.updateCornerStart = function(cornerIndex, corners, position) {
    var updateCorner = corners[cornerIndex];

    if(!updateCorner) {
        return;
    }

    position = position || updateCorner.value.control();
    var startOrientation = (cornerIndex > 0) ? corners[cornerIndex - 1].value.to() : this.path.start();
    var curveStart = util.math.Line.moveAlong(startOrientation, position, -20);
    this.path.setTo(updateCorner.index - 1, curveStart);
};

RoundPathManager.prototype.updateCornerEnd = function(cornerIndex, corners, position) {
    var updateCorner = corners[cornerIndex];

    if(!updateCorner) {
        return;
    }

    position = position || updateCorner.value.control();
    var endOrientation = (cornerIndex == corners.length - 1) ? this.path.end() : corners[cornerIndex + 1].value.to();
    var curveEnd = util.math.Line.moveAlong(position, endOrientation, 20);
    updateCorner.value.control(position).to(curveEnd);
};

RoundPathManager.prototype.getIndexForPosition = function(position) {
    //The round path is divided like the this: M L - Q L - Q L - Q L where the first M L can be seen as index 1...
    var pathIndex = this.path.getPathIndexForPosition(position);
    var evenPathIndex = (pathIndex % 2 == 0) ? pathIndex : pathIndex - 1;
    return (evenPathIndex / 2) + 1;
};

RoundPathManager.prototype.removePathPart = function(index) {
    if(this.path && index > 0) {
        var corner = this.path.valuesByType('Q')[index - 1];
        if(corner) {
            var curveEnd = this.path.value(corner.index + 1).to();
            this.path.value(corner.index - 1).to(curveEnd);
            this.path.removePath(corner.index + 1);
            this.path.removePath(corner.index);
        }
    }
};

RoundPathManager.prototype.update = function() {/** nothing **/};

module.exports = RoundPathManager;

},{"../util/util":79,"./straightPathManager":37}],36:[function(require,module,exports){
var util = require('../util/Util');
var event = require('../core/event');
var PathData = require('../svg/PathData');

var object = util.object;
var dom = util.dom;

var SelectionManager = function (diagram) {
    this.diagram = diagram;
    this.event = diagram.event;
    this.selectedNodes = [];
    this.selectedTransition;
    this.hoverElement;

    event.listen('key_up_press', this.upListener, this);
    event.listen('node_moveup', this.moveUpListener, this);
    event.listen('node_movedown', this.moveDownListener, this);
    event.listen('key_down_press', this.downListener, this);
    event.listen('key_del_press', this.deleteListener, this);
    event.listen('tab_activated', this.clear, this);

    this.event.listen('transition_added', this.transitionAddedListener, this);
    this.event.listen('node_added', this.nodeAddedListener, this);
    this.event.listen('knob_added', this.knobAddedListener, this);

    //These are currently global events not diagram context events
    event.listen('element_hoverIn', this.hoverInElementListener, this);
    event.listen('element_hoverOut', this.hoverOutElementListener, this);
};

SelectionManager.prototype.getSelectedNodes = function () {
    return this.selectedNodes.slice();
};

SelectionManager.prototype.getSelectedNodeIds = function () {
    var result = [];
    $.each(this.selectedNodes, function (index, value) {
        result.push(value.id);
    });
    return result;
};

SelectionManager.prototype.knobAddedListener = function (evt) {
    var knob = evt.data;
    var that = this;
    this.addNodeEvents(knob.node);
    if (knob.node.selectable) {
        knob.node.on('select', function (selectEvt, shifted) {
            if (that.dragSelection || evt.shiftKey || shifted && (knob.transition && knob.transition.selected)) {
                knob.transition.deselect();
            } else if (knob.transition && !knob.transition.selected) {
                knob.transition.select();
            }
        });
    }
};

SelectionManager.prototype.nodeAddedListener = function (evt) {
    this.addNodeEvents(evt.data);
};

SelectionManager.prototype.addNodeEvents = function (node, shifted) {
    if (node.selectable) {
        var that = this;
        node.on('select', function (evt, shifted) {
            that.setNodeSelection(node, shifted);
        }).on('deselect', function () {
            that.removeSelectedNode(node);
        }).on('remove', function () {
            that.removeSelectedNode(node);
        }).select();
    }
    return node;
};

SelectionManager.prototype.transitionAddedListener = function (evt) {
    var that = this;
    var transition = evt.data;
    transition.on('select', function (evt, shifted) {
        that.setTransitionSelection(transition);
    }).on('deselect', function () {
        that.removeSelectedTransition(transition);
    }).on('remove', function () {
        that.removeSelectedTransition(transition);
    }).select(evt.shiftKey);
};

//TODO: COMMANDS + Move to NodeManager!
SelectionManager.prototype.moveUpListener = function () {
    var selection = this.selectedNodes.slice(0);
    selection.sort(function (a, b) {
        return (a.index() < b.index()) ? 1 : -1;
    });

    object.each(selection, function (index, node) {
        if (object.isDefined(node)) {
            node.moveUp();
        }
    });
};

SelectionManager.prototype.upListener = function (evt) {
    if (evt.ctrlKey) {
        evt.preventDefault();
        this.moveUpListener();
    }
};

SelectionManager.prototype.downListener = function (evt) {
    if (evt.ctrlKey) {
        evt.preventDefault();
        this.moveDownListener();
    }
};

SelectionManager.prototype.moveDownListener = function () {
    var selection = this.selectedNodes.slice(0);
    selection.sort(function (a, b) {
        return (a.index() < b.index()) ? -1 : 1;
    });

    object.each(selection, function (index, node) {
        if (object.isDefined(node)) {
            node.moveDown();
        }
    });
};

SelectionManager.prototype.hoverInElementListener = function (evt) {
    this.hoverElement = evt.data;
};

SelectionManager.prototype.hoverOutElementListener = function (evt) {
    debugger;
    delete this.hoverElement;
};

SelectionManager.prototype.removedTransitionListener = function (evt) {
    if (object.isDefined(evt.data)) {
        if (evt.data === this.selectedTransition) {
            delete this.selectedTransition;
        }
    }
};

SelectionManager.prototype.removedNodeListener = function (evt) {
    if (object.isDefined(evt.data)) {
        //Remove the node from the selection
        object.removeFromArray(this.selectedNodes, evt.data);

        //Check if we have to remove the hoverElement too
        if (evt.data.root === this.hoverElement) {
            this.hoverOutElementListener();
        }
    }
};

SelectionManager.prototype.deleteListener = function (evt) {
    //Remove selected transition
    if (object.isDefined(this.selectedTransition) && !this.selectedTransition.getSelectedKnobs().length) {
        this.event.trigger('transition_delete', this.selectedTransition);
        return;
    }
    ;

    this.deleteSelectionNodes();
    this.clear();
};

SelectionManager.prototype.deleteSelectionNodes = function () {
    var arrClone = this.selectedNodes.slice(0);
    var that = this;
    object.each(arrClone, function (index, node) {
        if (object.isDefined(node)) {
            that.event.trigger('node_delete', node);
        } else {
            //If there is a undefined value we remove it from the selection
            that.selectedNodes.splice(0, 1);
        }
    });
};

SelectionManager.prototype.transitionCreatedListener = function (evt) {
    this.selectedTransition = evt.data;
};

SelectionManager.prototype.isElementHover = function () {
    return object.isDefined(this.hoverElement);
};

SelectionManager.prototype.setTransitionSelection = function (transition) {
    //We do not call this.clear because we would hide the edit fields trough the triggered event
    this.clearNodes(function (node) {
        return !transition.ownsKnobNode(node)
    });
    if (transition !== this.selectedTransition) {
        this.clearTransition();
        this.selectedTransition = transition;
    }
};

SelectionManager.prototype.setNodeSelection = function (selectedNode, shifted) {
    //some templates or nodes are should not affect the selection (e.g. resize knobs)
    if (!selectedNode.selectable) {
        return;
    }
    ;

    if (!this.containsNode(selectedNode)) {
        var that = this;

        //Clear the current selection if not shifted or dragSelection
        if (!shifted && !this.dragSelection) {
            this.clearNodes(function (node) {
                return selectedNode.id !== node.id
            });
        }

        this.selectedTemplate = selectedNode.template;
        this.addSelectedNode(selectedNode);
        this.clearTransition(selectedNode, object.isDefined(this.dragSelection));

        //Trigger drag for all selected nodes if one selection is dragged
        //We use additon style instead of on event for a performance gain (on.dragMove is deactivated see draggable.js)
        //We don't have to remove this addition after reselect because only selected nodes can be dragged anyways.
        var that = this;
        if (!selectedNode.additions['multiSelectionDrag']) {
            selectedNode.additions['multiSelectionDrag'] = {
                dragMove: function (dx, dy, evt) {
                    if (!evt.triggerEvent) {
                        object.each(that.selectedNodes, function (index, node) {
                            if (selectedNode.id !== node.id) {
                                node.triggerDrag(dx, dy);
                            }
                        });
                    }
                }
            }
        }
    } else if (shifted && !this.dragSelection) {
        this.removeSelectedNode(selectedNode);
    }
};

SelectionManager.prototype.dragSelectionStart = function (evt, startPosition) {
    var that = this;
    // INIT drag selection
    if (!this.isElementHover()) {
        this.clear();
        evt.preventDefault();
        this.diagram.on('mousemove', function (evt) {
            var stagePosition = that.diagram.getStagePosition(evt);
            if (!that.dragSelection) {
                that.dragSelection = that.diagram.svg.path({style: 'stroke:gray;stroke-width:1px;stroke-dasharray:5,5;fill:none;'});
                that.dragSelection.d().start(startPosition)
                    .line(startPosition)
                    .line(stagePosition)
                    .line(stagePosition)
                    .complete();
            } else {
                //Move selection away from mouse pointer
                var alignedMouseX = stagePosition.x - 1;
                var alignedMouseY = stagePosition.y - 1;

                //Update pathdata
                that.dragSelection.d().clear().start(startPosition)
                    .line({x: startPosition.x, y: alignedMouseY})
                    .line({x: alignedMouseX, y: alignedMouseY})
                    .line({x: alignedMouseX, y: startPosition.y})
                    .complete();

                //Check for hovered elements to select
                object.each(that.diagram.nodeMgr.nodes, function (id, node) {
                    that.dragSelect(node);
                });

                object.each(that.diagram.knobMgr.knobs, function (id, knob) {
                    that.dragSelect(knob.node);
                });
            }

            //Trigger attribute update
            that.dragSelection.update();
        });
    }
    ;
};

SelectionManager.prototype.dragSelect = function (node) {
    if (!node.selectable) {
        return;
    }
    if (this.dragSelection.overlays(node.getCenter())) {
        if (!node.selected) {
            node.select();
        }
    } else if (node.selected) {
        node.deselect();
    }
};

SelectionManager.prototype.dragSelectionEnd = function () {
    this.diagram.off('mousemove');
    if (this.dragSelection) {
        this.dragSelection.remove();
        delete this.dragSelection;
    }
};

/**
 * This method just adds new nodes to the selection if it have not been
 * added yet without any additional restrictions.
 *
 * All selected transitions are deselected since the mixed selection
 * is not implemented yet.
 *
 * @param {type} selectedNode
 * @returns {undefined}
 */
SelectionManager.prototype.addSelectedNode = function (selectedNode) {
    this.selectedNodes.push(selectedNode);
};

SelectionManager.prototype.removeSelectedTransition = function (transition) {
    if (this.selectedTransition === transition) {
        delete this.selectedTransition;
    }
};

SelectionManager.prototype.removeSelectedNode = function (node) {
    var index = this.selectedNodes.indexOf(node);
    if (index >= 0) {
        this.selectedNodes.splice(index, 1);
    }
};

SelectionManager.prototype.containsNode = function (node) {
    return this.selectedNodes.indexOf(node) > -1;
};

SelectionManager.prototype.clear = function () {
    this.clearNodes();
    this.clearTransition();
    this.event.trigger('selection_clear');
};

SelectionManager.prototype.clearNodes = function (filter) {
    var that = this;
    filter = filter || function () {
            return true;
        };
    //We clone the array since the original array can be manipulated while deselection.
    var selectedNodesArr = object.cloneArray(this.selectedNodes);
    object.each(selectedNodesArr, function (index, node) {
        if (node.selectable && filter(node)) {
            node.deselect();
        }
    });
    this.selectedNodes = [];
};

SelectionManager.prototype.clearTransition = function (node, force) {
    if (!this.selectedTransition) {
        return;
    }
    if (force || !node || !node.knob || !this.selectedTransitionOwnsKnobNode(node)) {
        this.selectedTransition.deselect();
    }
};

SelectionManager.prototype.selectedTransitionOwnsKnobNode = function (node) {
    return this.selectedTransition && this.selectedTransition.ownsKnobNode(node);
};

SelectionManager.prototype.isMultiSelection = function () {
    var count = 0;
    count += this.selectedNodes.length;
    return count > 1;
};

module.exports = SelectionManager;

},{"../core/event":7,"../svg/PathData":50,"../util/Util":73}],37:[function(require,module,exports){
/**
 * Simple implementation of path manager
 * @type {PathData|exports|module.exports}
 */
var AbstractPathManager = require('./abstractPathManager');
var util = require('../util/util');

var LinePathManager = function(transition) {
    AbstractPathManager.call(this, transition);
    this.type = LinePathManager.type;
};

util.inherits(LinePathManager, AbstractPathManager);

LinePathManager.type = 'straight';

LinePathManager.prototype.create = function(position) {
    this.path.line(position);
};

LinePathManager.prototype.add = function(index, position) {
    this.path.insertLine(index, position);
};

LinePathManager.prototype.update = function(position) {/* Nothing to do here */};

module.exports = LinePathManager;

},{"../util/util":79,"./abstractPathManager":13}],38:[function(require,module,exports){
var util = require('../util/util');
var xml = require('../util/xml');
var Node = require('./node');
var config = require('../core/config');

var object = util.object;
var dom = util.dom;

var Template = function(id, cfg) {
    this.config = cfg || {};
    this.id = id;

    //Templates can define the svgString within the config, so the svg doesn't have to be loaded in addition
    if(this.config.svg) {
        this.init(this.config.svg);
    }

    //TODO: implement a more generic way...
    if(object.isDefined(this.config.resize)) {
        this.initResizeConfig();
    }
};

Template.prototype.init = function(tmplStr) {
    this.svg = tmplStr;
};

Template.prototype.isInitialized = function() {
    return !!this.svg;
};


/**
 * The resize addition allows to configure a resize behaviour for svg elements
 * by means of defining the logic for changes of x (width) and y (height)
 * in the following form:
 * e.g.:
 *
 * parent(5) default
 *
 * where the x value is
 * @param {type} resizeConfig
 * @returns {undefined}
 */
Template.prototype.initResizeConfig = function() {
    var that = this;
    object.each(this.config.resize, function(index, resizeItem) {
        // Here we just parse the raw string to an array of feature settings
        that.setupSettings(index, resizeItem, 'value');
        that.setupSettings(index, resizeItem, 'position');
        that.setupSettings(index, resizeItem, 'max');
        that.setupSettings(index, resizeItem, 'min');
    });
};

Template.prototype.setupSettings = function(index, item, setting) {
    if(object.isDefined(item[setting])) {
        var values = util.app.parseFeatureStrings(item[setting], 0);

        //If ther is just one value given we use it for both x and y
        if(values.length === 1) {
            values[1] = values[0];
        }

        this.config.resize[index][setting] = values;
    }
};

Template.prototype.createNode = function(config, diagram) {
    var resultConfig = this.getConfig(config);
    return new Node(this, resultConfig, diagram);
};

Template.prototype.getSVGString = function(cfg) {
    return config.replaceConfigValues(this.svg, cfg);
};

Template.prototype.getConfig = function(cfg) {
    return object.extend({}, this.config, cfg);
};

module.exports = Template;
},{"../core/config":6,"../util/util":79,"../util/xml":80,"./node":29}],39:[function(require,module,exports){
var object = require('../util/object');
var Template = require('./template');
var event = require('../core/event');
var client = require('../core/client');

var Promise = require('bluebird');

var PATH_PANELS = '/template/panel';
var PATH_TEMPLATES = '/templates';

var EVENT_PANEL_LOADED = 'template_panel_loaded';

var panels = {};
var templates = {};
var selectedTemplate;

/**
 * Initializes listeners and loads the initial template panels set in dala_env.initial_templates array.
 */
var init = function() {
    event.listen('node_selected', nodeSelectionListener);
    event.listen('template_select', templateSelectListener);

    if(dala_env.initial_templates && dala_env.initial_templates.panels) {
        $.each(dala_env.initial_templates.panels, function(index, panelId) {
            _loadPanel(panelId);
        });
    }
};

var nodeSelectionListener = function(evt) {
    _setSelectedTemplate(evt.data.template);
};

var templateSelectListener = function(evt) {
    if(evt.data) {
        _setSelectedTemplate(evt.data);
    }
};

var _setSelectedTemplate = function(tmplId) {
    if(!object.isDefined(tmplId)) {
        return;
    };

    var instance;

    if(!object.isString(tmplId)) {
        if(!tmplId.config.preventSelection) {
            selectedTemplate = tmplId;
        }
    } else {
        getTemplate(tmplId)
            .then(function(template) {
                if(template && !template.config.preventSelection) {
                    selectedTemplate = template;
                } else {
                    console.warn('Coult not determine template: '+tmplId);
                }
            }, function(err) {
                console.warn('Error while determining template: '+tmplId+' - '+err);
            });
    }
};

/**
 * Returns a templateinstance, the template will be loaded and initialized if not loaded yet.
 *
 * @param tmplId
 * @param tmplRootEl
 * @returns {bluebird|exports|module.exports}
 */
var getTemplate = function(tmplId) {
    var panelId = tmplId.substring(0, tmplId.indexOf('_'));
    return new Promise(function(resolve, reject) {
        if(templates[tmplId]) { //Template is loaded
            var tmpl = templates[tmplId];
            if(!tmpl.isInitialized()) { //Template is not initialized yet so load svg
                _loadRemoteTemplateSVG(tmplId, panelId).
                    then(function() {
                        resolve(tmpl);
                    }, function(err) {
                        reject(err);
                    });
            } else {
                resolve(templates[tmplId]);
            }
        } else { //Template not loaded yet
            if(panelId) { //Load and initialize template
                //TODO: here we have to consider other loading mechanism as dom loading / browser cache first
                _loadRemoteTemplate(panelId, tmplId)
                    .then(function(tmpl) {
                        resolve(tmpl);
                    }, function(err) {
                        reject(err);
                    });
            } else {
                resolve(_createTemplate(tmplId));
            }
        }
    });
};

/**
 * This simply returns a template if its already loaded. This should only be used for templates which are registered
 * on startup and already loaded.
 *
 * @param tmplId
 * @returns {*}
 */
var getTemplateSync = function(tmplId) {
    return templates[tmplId];
};

/**
 * Loads a panel definition from the server. When loaded the panel will register itself to the templateManager.
 * The function returns a Promise.
 *
 * @param panelId
 * @returns {bluebird|exports|module.exports}
 * @private
 */
var _loadPanel = function(panelId) {
    return new Promise(function(resolve, reject) {
        client.getScript(PATH_TEMPLATES+'/'+panelId+'/'+panelId+'.js', {
            success : function() {
                resolve();
            },
            error : function() {
                reject();
            },
            errorMessage : {
                404: 'Could not load panel '+panelId+' file was not found on the server !',
                'default': 'Could not load panel '+panelId+' something went wrong !'
            }
        });
    });
};

/**
 * Loads a remote tamplate from the server. When loaded the template will register itself to the templateManager
 * This function returns a Promise without result.
 *
 * @param panelId
 * @param tmplId
 * @returns {bluebird|exports|module.exports}
 * @private
 */
var _loadRemoteTemplate = function(panelId, tmplId) {
    return new Promise(function(resolve, reject) {
        var that = this;
        client.getScript(PATH_TEMPLATES+'/'+panelId+'/'+tmplId+'.js', {
            success : function(response) {
                //Now that we have loaded and initialized the template script we can get the template
                getTemplate(tmplId).then(resolve, reject);
            },
            error: function(errorMsg) {
                reject(errorMsg);
            },
            errorMessage : {
                404: 'Could not load template "'+tmplId+'" file was not found on the server !',
                'default': 'Could not load template "'+tmplId+'" something went wrong !'
            }
        });
    });
};

/**
 * Registers a template by creating a new Template instance out of the given arguments.
 * @param templateId
 * @param panelId
 * @param config
 */
var registerTemplate = function(templateId, config) {
    _addTemplate(new Template(templateId, config));
};

/**
 * Loads the template svg as xml document for the given tmplId.
 * @param tmplId
 * @param panelId
 * @returns {bluebird|exports|module.exports}
 * @private
 */
var _loadRemoteTemplateSVG = function(tmplId, panelId) {
    return new Promise(function(resolve, reject) {
        client.text('/templates/'+panelId+'/'+tmplId+'.tmpl', {
            success : function(response) {
                _initTemplate(tmplId, response.data);
                resolve(response.data);
            },
            error : function(err) {
                reject(err);
            },
            errorMessage :  {
                404: 'Could not load template "'+tmplId+'" file was not found on the server !',
                'default': 'Could not load template "'+tmplId+'" something went wrong !'
            }
        });
    });

};

var _initTemplate = function(tmplId, tmplStr) {
    templates[tmplId].init(tmplStr);
};

/**
 * Registers a new panel.
 * @param cfg
 */
var registerPanel = function(cfg) {
  if(cfg.id) {
      panels[cfg.id] = cfg;
      event.trigger(EVENT_PANEL_LOADED, cfg);
  }
};

var _createTemplate = function(tmplId, tmplRootEl) {
    return _addTemplate(new Template(tmplId, true, tmplRootEl));
};

var _addTemplate = function(tmpl) {
    templates[tmpl.id] = tmpl;
    return tmpl;
};

var getSelectedTemplate = function() {
    return selectedTemplate;
};

var getPanel = function(panelId) {
    return panels[panelId];
};

module.exports = {
    registerPanel : registerPanel,
    registerTemplate : registerTemplate,
    getPanel: getPanel,
    getTemplate: getTemplate,
    getTemplateSync : getTemplateSync,
    getSelectedTemplate: getSelectedTemplate,
    init : function() {
        init();
        return this;
    }
};

},{"../core/client":3,"../core/event":7,"../util/object":77,"./template":38,"bluebird":83}],40:[function(require,module,exports){
var util = require('../util/util');
var event = require('../core/event');
var config = require('../core/config');

var Eventable = require('./../dom/eventableNode');

var TransitionKnobManager = require('./transitionKnobManager');
var TransitionDockingManager = require('./transitionDockingManager');
var transitionAdditions = require('./transitionAdditions');

var pathManagerFactory = require('./pathManagerFactory');

var COLOR_ACTIVE = "blue";
var COLOR_INACTIVE = "black";
var DEFAULT_ENDMARKER = 'trianglefill';
var STYLE_AREA = "stroke:grey;stroke-opacity:0.0;stroke-width:11;fill:none;";

var DEFAULT_WIDTH = '1';

var object = util.object;
var dom = util.dom;

var Transition = function(node, startPosition, cfg) {
    this.cfg = cfg || {};
    if(node.isNode) {
        this.diagram = node.diagram;
        this.event = this.diagram.event;
        this.svg = this.diagram.svg;
        this.init(node, startPosition);
    } else { //node = diagram, startPosition = domGroup of transition
        this.diagram = node;
        this.event = this.diagram.event;
        this.svg = this.diagram.svg;
        this.activate(startPosition);
    }
};

util.inherits(Transition, Eventable);

Transition.prototype.getPath = function() {
    return this.pathManager.path;
};

Transition.prototype.type = function(value) {
    if(value && value !== this.pathManager.type) {
        var newPathManager = pathManagerFactory.get(this, value);
        if(newPathManager) {
            newPathManager.replace(this.pathManager, this.knobManager.getKnobPositions());
            this.update();
        }
    } else {
        return this.pathManager.type;
    }
};

Transition.prototype.activate = function(domGroup) {
    this.root = this.group = $.svg(domGroup);
    this.id = this.group.attr('id');

    transitionAdditions.init(this);

    //Get line and linearea from dom
    this.getLine();
    this.colorInactive = this.line.stroke();

    this.getLineArea();
    this.lineArea.d(this.line.d());

    //Init Manager
    this.dockingManager = new TransitionDockingManager(this).activate();
    this.pathManager = pathManagerFactory.get(this, this.group.dala('transitionType')).activate();
    this.knobManager = new TransitionKnobManager(this).activate();
    this.initEvents();
    return this;
};

Transition.prototype.children = function(selector) {
    return this.group.children(selector);
};

Transition.prototype.length = function() {
    return this.getPath().getDistance();
};

Transition.prototype.firstChild = function(selector) {
    return this.group.firstChild(selector);
};

Transition.prototype.getLine = function() {
    if(!this.line && this.group) {
        this._setLine(this.getInnerSVG('line'));
    }
    return this.line;
};

Transition.prototype.getLineArea = function() {
    if(!this.lineArea && this.group) {
         this._setLineArea(this.getInnerSVG('lineArea'));
    }
    return this.lineArea;
};

Transition.prototype._setLineArea = function(svgLineArea) {
    this.lineArea = this.eventBase = svgLineArea;
};

Transition.prototype._setLine = function(svgLine) {
    this.line = svgLine;
};

/**
 * Initializes a new transition by creating the svg nodes and startdocking
 *
 * @param {type} mouse
 */
Transition.prototype.init = function(node, mouse) {
    this.id = this.diagram.uniqueId();
    //Initializes the transition group container
    this.initSVGGroup();

    transitionAdditions.init(this);

    //Initialize the transition docking mechanism (start/end) docking to nodes.
    this.dockingManager = new TransitionDockingManager(this, node, mouse);
    //Initialize the path creator which creates the path with the help of the knobs and a given transitiontype.
    this.pathManager = pathManagerFactory.get(this, this.cfg['type']);
    this.group.dala('transitionType', this.pathManager.type);

    //Initialize the transition knob mechanism for (start/end) and inner knobs for manipulating transitions
    this.knobManager = new TransitionKnobManager(this);

    //Calculate start position for outer orientation (mouse position)
    var startDockingPosition = this.dockingManager.calculateStart(mouse);

    //Init knob for startPosition
    this.exec('setStartNode', [node]);

    //Create SVG Elements in dom and transition events
    this.initTransitionSVG();
    this.initEvents();
    this.update(mouse);
    this.group.pointerEvents('none');

    return this;
};

Transition.prototype.initSVGGroup = function() {
    this.root = this.group = this.svg.g({"class":'transition', 'xmlns:dala':"http://www.dala.com", id : this.id});
};

Transition.prototype.getStartAlignment = function() {
    var result = {source:[this.dockingManager.startDocking.position()]};
    if(!this.knobManager.hasInnerKnobs()) {
        result.target = [this.dockingManager.endDocking.position()];
    } else {
        result.target = [this.knobManager.getKnob(1).position()];
    }
    return result;
};

Transition.prototype.getEndAlignment = function() {
    var result = {source:[this.dockingManager.endDocking.position()]};
    if(!this.knobManager.hasInnerKnobs()) {
        result.target = [this.dockingManager.startDocking.position()];
    } else {
        result.target = [this.knobManager.getKnob(-2).position()];
    }
    return result;
};

Transition.prototype.getStartNode = function() {
    return this.dockingManager.startNode;
};

Transition.prototype.getEndNode = function() {
    return this.dockingManager.endNode;
};

Transition.prototype.start = function() {
    return this.knobManager.start();
};

Transition.prototype.end = function() {
    return this.knobManager.end();
};


Transition.prototype.getStartLocation = function() {
    return this.dockingManager.startNode.getRelativeLocation(this.start());
};

Transition.prototype.getEndLocation = function() {
    return this.dockingManager.endNode.getRelativeLocation(this.end());
};

Transition.prototype.dragStartOrientation = function(dx, dy) {
    this.dockingManager.dragStartOrientation(dx, dy);
};

Transition.prototype.dragEndOrientation = function(dx, dy) {
    this.dockingManager.dragEndOrientation(dx, dy);
};

Transition.prototype.getInnerSVG = function(prefix) {
    return $.svg(this.getTransitionSelector(prefix));
};

Transition.prototype.initTransitionSVG = function() {
    var path = this.pathManager.path;

    //Note we share the path between line and lineArea an update
    this._setLine(this.svg.path({
        d : path,
        id : 'line_'+this.id,
    }));

    this._setLineArea(this.svg.path({
        d : path,
        id: 'lineArea_'+this.id,
        style  : STYLE_AREA
    }));

    this._setInitStyle();
    this.group.prepend(this.lineArea, this.line);
};

Transition.prototype._setInitStyle = function() {
    //TODO: set active color from global settings
    this.colorInactive = this.cfg['stroke'] || COLOR_INACTIVE;
    this.colorActive = COLOR_ACTIVE;

    this.line.fill('none');
    this.activeStyle();
    this.strokeWidth(this.cfg['stroke-width'] || DEFAULT_WIDTH);
    this.line.strokeDasharray(this.cfg['stroke-dasharray']);
    this.startMarker(this.cfg['marker-start']);
    this.endMarker(this.cfg['marker-end'] || DEFAULT_ENDMARKER);
};

Transition.prototype.strokeWidth = function(value) {
    this.line.strokeWidth(value);
    if(value > 11) {
        this.lineArea.strokeWidth(value);
    } else {
        this.lineArea.strokeWidth(11);
    }
};

Transition.prototype.initEvents = function() {
    var that = this;
    this.lineArea.hoverable({
        in: function() {
            that.hover();
        },
        out: function() {
            that.hoverOut();
        }
    });
    this.on('click', function(evt) {
        if(evt.shiftKey) {
            that.selectInnerKnobs();
            return;
        }
    }).on('mousedown', function(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        var dragInitiated = false;
        var startPosition = that.diagram.getStagePosition(evt);
        var pathPartIndex = that.pathManager.getIndexForPosition(startPosition);

        if(evt.shiftKey) {
            var knobsByIndex = that.knobManager.getKnobsByIndex(pathPartIndex);
            if(pathPartIndex === 1) {
                knobsByIndex[1].select(true).initDrag();
                that.dockingManager.startDocking.knob.initDrag();
                //TODO: implement same behaviour for last index + check do / undo
            } else {
                knobsByIndex[0].select(true);
                knobsByIndex[1].select(true).initDrag();
            }
            return;
        }

        if(!that.selected) {
            that.select();
        }

        if(that.freezed) {
            return;
        }



        if (pathPartIndex) {
            event.once(document, "mouseup", function(evt) {
                that.diagram.off('mousemove');
            });
            that.diagram.on("mousemove", function(event) {
                var movePosition = that.diagram.getStagePosition(event);

                //We just start the drag event in case we move more thant 5px away
                if(!dragInitiated && util.app.isMinDist(startPosition, movePosition, 5)) {
                    var knob = that.knobManager.addKnob(startPosition, pathPartIndex);
                    knob.initDrag();
                    dragInitiated = true;
                }
            });
        }
    }).on('dblclick', function(evt) {
        var startPosition = that.diagram.getStagePosition(evt);
        var pointOnLine = that.pathManager.getNearestPoint(startPosition);
        var knobIndex = that.pathManager.getIndexForPosition(startPosition);
        that.addKnob(pointOnLine, knobIndex);
    });
};

Transition.prototype.freeze = function() {
    this.freezed = true;
    this.dockingManager.freeze();
    this.knobManager.freeze();
    this.update();
};

Transition.prototype.unfreeze = function() {
    this.freezed = false;
    this.dockingManager.unfreeze();
    this.knobManager.unfreeze();
    this.update();
};

Transition.prototype.addKnob = function(position, index) {
    if(!this.isInitState()) {
        index = index || 1;
        var knob = this.knobManager.addKnob(position, index);
        this.exec('knob_add', [index, position]);
        this.update();
        return knob;
    }
};

Transition.prototype.ownsKnobNode = function(knobNode) {
    return this.knobManager.ownsKnobNode(knobNode);
};

Transition.prototype.update = function(mouse) {
    this.updateEnd(mouse);
    this.updateStart(mouse);
    this.redraw();
    this.exec('update',[], true);
};

Transition.prototype.redraw = function() {
    if(this.line && this.lineArea) {
        this.line.update();
        this.lineArea.update();
    }
};

Transition.prototype.getSelectedKnobs = function() {
    return this.knobManager.getSelectedKnobs();
};

Transition.prototype.updateStart = function(mouse) {
    var outerOrientation = mouse || this.knobManager.getPosition(1);
    this.knobManager.updateStartKnob(this.dockingManager.calculateStart(outerOrientation));
};

Transition.prototype.updateEnd = function(mouse) {
    if(this.isInitState()) {
        mouse = this.alignEndPositionForMouse(mouse);
        this.pathManager.dragLine(mouse);
    } else {
        var outerOrientation = this.knobManager.getPosition(-2);
        this.knobManager.updateEndKnob(this.dockingManager.calculateEnd(outerOrientation));
    }
};

Transition.prototype.isInitState = function() {
    return !this.dockingManager.endNode;
};

Transition.prototype.alignEndPositionForMouse = function(mouse) {
    //This prevents the line rendering to overlap the exact mouse position
    return {
        x : (this.knobManager.startKnob.x() < mouse.x) ? mouse.x - 1 : mouse.x + 1,
        y : (this.knobManager.startKnob.y() < mouse.y) ? mouse.y - 1 : mouse.y + 1
    };
};

Transition.prototype.setStartNode = function(node) {
    this.exec('setStartNode', [node]);
    if(!this.isInitState()) {
        this.checkDomPosition();
    }
    this.update();
};

Transition.prototype.setEndNode = function(node, mousePosition) {
    this.exec('setEndNode', [node, mousePosition]);
    this.checkDomPosition();
    this.update();
    this.group.pointerEvents('all');
};

Transition.prototype.checkDomPosition = function() {
    var maxNodeIndex = Math.max(this.dockingManager.startNode.index(), this.dockingManager.endNode.index());
    var transitionIndex = this.index();

    if(transitionIndex < maxNodeIndex) {
        dom.insertAfterIndex(this.group.instance(), maxNodeIndex);
    }
};

Transition.prototype.moveInnerKnobs = function(distance) {
    this.knobManager.moveInnerKnobs(distance);
};

Transition.prototype.selectInnerKnobs = function() {
    this.knobManager.selectInnerKnobs();
};

Transition.prototype.remove = function() {
    this.removed = true;
    this.group.remove();
    this.dockingManager.remove();
};

Transition.prototype.index = function() {
    return this.group.$().index();
};

Transition.prototype.instance = function() {
    if(this.group) {
        return this.group.instance();
    }
};

Transition.prototype.endMarker = function(marker) {
    return this.marker('end', marker);
};

Transition.prototype.endMarkerValue = function() {
    return this.markerValue('end');
};

Transition.prototype.startMarker = function(marker) {
    return this.marker('start', marker);
};

Transition.prototype.startMarkerValue = function() {
    return this.markerValue('start');
};

Transition.prototype.marker = function(type, marker) {
    var key = 'marker-'+type;
    if(util.object.isDefined(marker)) {
        this.line.attr(key, this.getMarkerValueString(marker));
    } else {
        var markerStr = this.line.attr(key);
        if(markerStr) {
            return markerStr.substring(5, markerStr.length - 1);
        }
    }
};

Transition.prototype.selector = function(prefix) {
    var stringSelector;
    if(object.isArray(prefix)) {
        stringSelector = [];
        var that = this;
        object.each(prefix, function(index, val) {
            stringSelector.push(that.selector(val));
        });
        stringSelector = stringSelector.join(', ');
    } else {
        stringSelector = prefix;
    }
    return this.getTransitionSelector(stringSelector);
};

Transition.prototype.getTransitionSelector = function(prefix) {
    var result = '';

    if(!util.string.startsWith(prefix, '#') && !util.string.startsWith(prefix, '.')) {
        result = '#'+prefix;
    } else {
        result = prefix;
    }

    return util.string.endsWith(prefix, '_')
        ? result + this.id
        : result + '_' + this.id;
};

Transition.prototype.markerValue = function(type, marker) {
    var markerString = this.marker(type, marker);
    if(markerString) { // triangle_s_12312423 --> triangle_s
        return markerString.substring(0, markerString.length - this.diagram.id.length - 1);
    }
};

Transition.prototype.getMarkerValueString = function(markerId) {
    markerId = (util.string.endsWith(markerId, this.diagram.id)) ? markerId : markerId + '_' + this.diagram.id;
    return 'url(#' + markerId + ')';
};

Transition.prototype.select = function() {
    this.selected = true;
    this.activeStyle();
    this.exec('select');
};

Transition.prototype.hover = function() {
    this.exec('hover');
};

Transition.prototype.hoverOut = function() {
    this.exec('hoverOut');
};

Transition.prototype.stroke = function(value) {
    if(value) {
        this.colorInactive = value;
    }
    return this.line.stroke(value);
}

Transition.prototype.activeStyle = function() {
    //this.line.stroke(this.colorActive);
    //active style was removed
    this.inactiveStyle();
};

Transition.prototype.deselect = function() {
    this.inactiveStyle();
    this.selected = false;
    this.exec('deselect');
};

Transition.prototype.inactiveStyle = function() {
    this.line.stroke(this.colorInactive);
};

Transition.prototype.dump = function() {
    var result = '<b>Transition</b> - <b>'+this.id+'</b><br />\n';
    result += this.knobManager.dump();
    result += this.dockingManager.dump();
    result += this.pathManager.dump();
    $.each(this.additions, function(key, value) {
        if(value.dump) {
            result += value.dump()+'<br />\n';
        }
    });
    return result;
};

Transition.prototype.validate = function() {
    var result = {};
    result['knobManager'] = this.knobManager.validate();
    result['dockingManager'] = this.dockingManager.validate();
    //result['pathManager'] = this.pathManager.validate();
};

Transition.prototype.toString = function() {
    return this.group.toString();
};

module.exports = Transition;

},{"../core/config":6,"../core/event":7,"../util/util":79,"./../dom/eventableNode":49,"./pathManagerFactory":32,"./transitionAdditions":42,"./transitionDockingManager":43,"./transitionKnobManager":44}],41:[function(require,module,exports){
var object = require('../util/object');
var event = require('../core/event');
var Transition = require('./transition');

/**
 * The transitionaddition for nodes is responsible for creating and updating/rendering the incoming and outgoing
 * transitions of a node.
 *
 * @param node
 * @constructor
 */
var TransitionAddition = function(node) {
    this.node = node;
    this.event = node.event;
    this.diagram = this.node.diagram;
    this.transitionMgr = this.diagram.transitionMgr;
    this.outgoingTransitions = [];
    this.incomingTransitions = [];
};

TransitionAddition.prototype.dragMove = function(dx, dy) {
    this.updateOrientations(dx ,dy);
    this.update();
};

TransitionAddition.prototype.updateOrientations = function(dx ,dy) {
    this.executeOnOutgoingTransitions(function(transition) {
        transition.dragStartOrientation(dx,dy);
    });

    this.executeOnIncomingTransitions(function(transition) {
        transition.dragEndOrientation(dx,dy);
    });
};

TransitionAddition.prototype.resize = function() {
    this.update();
};

TransitionAddition.prototype.update = function() {
    this.executeOnAllTransitions(function(transition) {
        transition.update();
    });
};

TransitionAddition.prototype.remove = function() {
    this.executeOnAllTransitions(function( transition) {
        transition.remove();
    });
};

TransitionAddition.prototype.moveUp = function() {
    this.executeOnAllTransitions(function(transition) {
        transition.checkDomPosition();
    });
};

/**
 * Node dbclick triggers the creation of a transition.
 */
TransitionAddition.prototype.dblclick = function(evt) {
    this.startNewTransition(undefined, this.diagram.getStagePosition(evt));
};

/**
 * This function starts a new transition either by providing a endNode or by using the transitiondrag
 * @param endNode
 */
TransitionAddition.prototype.startNewTransition = function(endNode, mouse) {
    if(this.transitionMgr.isDragTransition()) {
        return this.diagram.transitionMgr.getDragTransition();
    }

    var transition = this.transitionMgr.startDragTransition(this.node, mouse);

    if(!endNode) {
        //If no endNode was provided we start the mouse listener for the transitiondrag
        var that = this;
        event.on(this.diagram.svg.getRootNode(), "mousemove", function(event) {
            that.transitionDrag(event, true);
        });
    } else {
        //If an endNode was provided we imitate the transitiondrag and set the endNode
        this.transitionDrag(endNode.getCenter());
        endNode.additions.transition.endTransitionDrag();
    }

    return transition;
};

TransitionAddition.prototype.transitionDrag = function(mouse, isEvt) {
    mouse = (isEvt)? this.diagram.getStagePosition(mouse) : mouse;
    //Update the current dragTransition
    this.transitionMgr.getDragTransition().update(mouse);
};

/**
 * Node mousedown ends a transitionDrag even (if there is one) and sets this node as endnode
 */
TransitionAddition.prototype.mousedown = function(evt) {
    // Stop transition drag event and set end node
    if(this.transitionMgr.isDragTransition()) {
        this.endTransitionDrag(evt);
    }
};

TransitionAddition.prototype.endTransitionDrag = function(mouseEvt) {
    mouseEvt = mouseEvt || this.node.getCenter();
    var transition = this.transitionMgr.getDragTransition();
    transition.setEndNode(this.node, this.diagram.getStagePosition(mouseEvt));
    this.transitionMgr.endDragTransition();
    event.off(this.diagram.svg.getRootNode(), 'mousemove');
};

TransitionAddition.prototype.ownsTransition = function(transition) {
    var result = false;
    $.each(this.outgoingTransitions, function(index, value) {
        if(object.isString(transition) && value.id === transition) {
            result = true;
            return false; //exit each loop
        } else if(value.id === transition.id) {
            result = true;
            return false; //exit each loop
        }
    });

    if(!result) {
        $.each(this.incomingTransitions, function(index, value) {
            if(object.isString(transition) && value.id === transition) {
                result = true;
                return false; //exit each loop
            } else if(value.id === transition.id) {
                result = true;
                return false; //exit each loop
            }
        });
    }

    return result;
};

TransitionAddition.prototype.addOutgoingTransition = function(transition) {
    this.outgoingTransitions.push(transition);
    return transition;
};

TransitionAddition.prototype.executeOnAllTransitions = function(handler) {
    this.executeOnOutgoingTransitions(handler);
    this.executeOnIncomingTransitions(handler);
};

TransitionAddition.prototype.executeOnOutgoingTransitions = function(handler) {
    object.each(this.outgoingTransitions, function(index, transition) {
        if(transition) {
            handler(transition);
        }
    });
};

TransitionAddition.prototype.executeOnIncomingTransitions = function(handler) {
    object.each(this.incomingTransitions, function(index, transition) {
        if(transition) {
            handler(transition);
        }
    });
};

TransitionAddition.prototype.getTransitionAlignmentTargets = function() {
    var result = [];
    object.each(this.outgoingTransitions, function(index, transition) {
        if(object.isDefined(transition)) {
            result.push(transition.getStartAlignment());
        }
    });

    object.each(this.incomingTransitions, function(index, transition) {
        if (object.isDefined(transition)) {
            result.push(transition.getEndAlignment());
        }
    });
    return result;
};

TransitionAddition.prototype.removeOutgoingTransition = function(transition) {
    var index = this.outgoingTransitions.indexOf(transition);
    if (index !== -1) {
        this.outgoingTransitions.splice(index, 1);
    }
};

TransitionAddition.prototype.addIncomingTransition = function(transition) {
    this.incomingTransitions.push(transition);
};

TransitionAddition.prototype.removeIncomingTransition = function(transition) {
    var index = this.incomingTransitions.indexOf(transition);
    if (index !== -1) {
        this.incomingTransitions.splice(index, 1);
    }
};

TransitionAddition.prototype.dump = function() {
    var result = '<b>TransitionAddition</b><br />';
    result += this.outgoingTransitions.length+' Outgoing Transitions:<br />';
    this.executeOnOutgoingTransitions(function(transition) {
        result += 'Transition - '+transition.id+'<br />';
    });

    result += this.incomingTransitions.length+' Incoming Transitions:<br />';
    this.executeOnIncomingTransitions(function(transition) {
        result += 'Transition - '+transition.id+'<br />';
    });
    return result;
};

TransitionAddition.requireConfig = false;

module.exports = TransitionAddition;


},{"../core/event":7,"../util/object":77,"./transition":40}],42:[function(require,module,exports){
var additions = require('./additions');

//Init default additions
additions.registerTransitionAddition('text', require('./transitionTextAddition'));
additions.registerTransitionAddition('edit', require('./editTransitionAddition'));

module.exports = {
    init : function(transition) {
        additions.initTransitionAdditions(transition);
    }
};
},{"./additions":14,"./editTransitionAddition":23,"./transitionTextAddition":46}],43:[function(require,module,exports){
var util = require('../util/util');
var Knob = require('./Knob');
var dockingType = require('./docking');

var TransitionDocking = function(dockingManager, node, mouse, type) {
        this.node = node;
        this.type = type;
        this.transition = dockingManager.transition;
        this.dockingManager = dockingManager;
        if(!node.knob) {
            this.initOrientation(mouse, type);
        }
};

TransitionDocking.prototype.freeze = function() {
    if(this.knob) {
        this.knob.freeze();
        this.knob.config['fill-opacity'] = 0;
        this.knob.show();
    }
};

TransitionDocking.prototype.unfreeze = function() {
    if(this.knob) {
        this.knob.unfreeze();
        this.knob.config['fill-opacity'] = 0.5;
        this.knob.show();
    }
};

TransitionDocking.prototype.initOrientation = function(startPosition, type) {
    var orientationPosition = _getStartOrientationPosition(this.node, startPosition);
    this.knob = new Knob(this.transition.diagram, orientationPosition, {'cssClass':'orientationKnob '+type, 'fill-active':'orange', fill:'orange', selectable:false}, this.transition.group);
    this.initKnobEvents();
};

var _getStartOrientationPosition = function(node, mouse) {
    var orientationType = (node.config.docking && node.config.docking.orientation)
                          ? node.config.docking.orientation : 'center';
    switch(orientationType.toUpperCase()) {
        case 'FREE':
            return mouse;
        case  'CENTER':
        default:
            return node.getCenter();
    }

};

TransitionDocking.prototype.initKnobEvents = function() {
    var that = this;
    this.knob.draggable({
        restrictionX : function(evt, dx, dy) {
            var dragCenter = that.knob.position();
            dragCenter.x += dx;
            return that.node.overlays(dragCenter) ? dx : 0;
        },
        restrictionY : function(evt, dx, dy) {
            var dragCenter = that.knob.position();
            dragCenter.y += dy;
            return that.node.overlays(dragCenter) ? dy : 0;
        },
        dragAlignment : function() {
            //We align our knob center to the node center and also to our transition alignment point
            var alignment = (that.type === 'start')
                ? that.transition.getStartAlignment() : that.transition.getEndAlignment();
            alignment.target.push(that.node.getCenter());
            return [alignment];
        },
        dragMove : function(evt, dx ,dy) {
            that.transition.update();
        }
    });
};

TransitionDocking.prototype.position = function(withStroke) {
    if(this.knob) {
        return this.knob.position();
    } else {
        return this.node.getCenter();
    }
};

TransitionDocking.prototype.moveTo = function(p) {
    if(this.knob) {
        return this.knob.moveTo(p);
    }
};

TransitionDocking.prototype.triggerDrag = function(dx, dy) {
    if(this.knob) {
        this.knob.triggerDrag(dx, dy);
    }
};

TransitionDocking.prototype.calculateDockingPosition = function(outerOrientation) {
    if(this.node.knob) {
        return this.node.getCenter();
    }
    return dockingType.calculateDockingPosition(this.node, outerOrientation, this.position());
};

TransitionDocking.prototype.inactiveStyle = function() {
    if(this.knob) {
        this.knob.inactiveStyle();
    }
};

TransitionDocking.prototype.hide = function() {
    if(this.knob) {
        this.knob.hide();
    }
};

TransitionDocking.prototype.remove = function() {
    if(this.knob) {
        this.knob.remove();
    }
};

var TransitionDockingManager = function(transition, startNode, mouse) {
    this.diagram = transition.diagram;
    this.transition = transition;

    if(startNode) {
        this.setStartNode(startNode, mouse);
    }

    var that = this;
    this.transition.additions['dockingManager'] = {
        setEndNode : function(node, mousePosition) {
            that.setEndNode(node, mousePosition);
        },
        setStartNode : function(node) {
            that.setStartNode(node);
        },
        select : function() {
            that.inactiveStyle();
        },
        deselect : function() {
            that.hide();
        },
        hover : function() {
            that.inactiveStyle();
        },
        hoverOut : function() {
            if(!that.transition.selected) {
                that.hide();
            }
        }

    };
};

TransitionDockingManager.prototype.activate = function() {
    this.setStartNode(this.diagram.getNodeById(this.getStartNodeFeature()));
    this.setEndNode(this.diagram.getNodeById(this.getEndNodeFeature()));

    //TODO activate knobs instead of replace !
    var startOrientationSvg = this.transition.group.$().children('.orientationKnob.start').svg()[0];
    if(startOrientationSvg) {
        this.startDocking.moveTo(startOrientationSvg.position());
        startOrientationSvg.remove();
    }

    var endOrientationSvg = this.transition.group.$().children('.orientationKnob.end').svg()[0];
    if(endOrientationSvg) {
        this.endDocking.moveTo(endOrientationSvg.position());
        startOrientationSvg.remove();
    }

    //TODO: add error handler what todo if we cannot activate the transition ? remove ?
    return this;
};

TransitionDockingManager.prototype.freeze = function() {
    if(this.startDocking) {
        this.startDocking.freeze();
    }

    if(this.endDocking) {
        this.endDocking.freeze();
    }
};

TransitionDockingManager.prototype.unfreeze = function() {
    if(this.startDocking) {
        this.startDocking.unfreeze();
    }

    if(this.endDocking) {
        this.endDocking.unfreeze();
    }
};

TransitionDockingManager.prototype.setStartNode = function(node, mousePosition) {
    if(this.startNode && this.startNode.id === node.id) {
        return;
    } else if(this.startNode) {
        this.startNode.removeOutgoingTransition(this.transition);
    }

    if(this.startDocking) {
        this.startDocking.remove();
    }

    this.startNode = node;
    this.startNode.addOutgoingTransition(this.transition);
    this.startDocking = new TransitionDocking(this, node, mousePosition, 'start');
    this.setStartNodeFeature();
};

TransitionDockingManager.prototype.getStartNodeFeature = function() {
    return this.transition.group.dala('start');
};

TransitionDockingManager.prototype.setStartNodeFeature = function() {
    this.transition.group.dala('start', this.startNode.id);
};

TransitionDockingManager.prototype.calculateStart = function(outerOrientation) {
    return this.startDocking.calculateDockingPosition(outerOrientation);
};

TransitionDockingManager.prototype.dragStartOrientation = function(dx,dy) {
    this.startDocking.triggerDrag(dx,dy);
};

TransitionDockingManager.prototype.setEndNode = function(node, mousePosition) {
    if(this.endNode) {
        this.endNode.removeIncomingTransition(this.transition);
    }

    if(this.endDocking) {
        this.endDocking.remove();
    }

    this.endNode = node;
    this.endNode.addIncomingTransition(this.transition);
    this.endDocking = new TransitionDocking(this, node, mousePosition, 'end');
    this.setEndNodeFeature();
};

TransitionDockingManager.prototype.dragEndOrientation = function(dx,dy) {
    this.endDocking.triggerDrag(dx,dy);
};

TransitionDockingManager.prototype.calculateEnd = function(outerOrientation) {
    return this.endDocking.calculateDockingPosition(outerOrientation);
};

TransitionDockingManager.prototype.getEndNodeFeature = function() {
    return this.transition.group.dala('end');
};


TransitionDockingManager.prototype.setEndNodeFeature = function() {
    if(this.endNode) {
        this.transition.group.dala('end', this.endNode.id);
    }
};

TransitionDockingManager.prototype.inactiveStyle = function() {
    this.startDocking.inactiveStyle();
    if(this.endDocking) {
        this.endDocking.inactiveStyle();
    }
};

TransitionDockingManager.prototype.hide = function() {
    this.startDocking.hide();
    if(this.endDocking) {
        this.endDocking.hide();
    }
};

TransitionDockingManager.prototype.remove = function() {
    if(this.startNode) {
        this.startNode.removeOutgoingTransition(this.transition);
        this.startDocking.remove();
    }

    if(this.endNode) {
        this.endNode.removeIncomingTransition(this.transition);
        this.endDocking.remove();
    }
};

TransitionDockingManager.prototype.dump = function() {
    var result = 'DockingManager<br />\n';
    if(this.startNode) {
        result += 'StartNode:'+this.startNode.id+'<br />\n';
    } else {
        result += 'No StartNode<br />\n';
    }

    if(this.startDocking) {
        result += 'StartDocking:'+this.startDocking.position()+'<br />\n';
    } else {
        result += 'No StartDocking<br />\n';
    }

    if(this.endNode) {
        result += 'EndNode:'+this.endNode.id+'<br />\n';
    } else {
        result += 'No EndNode<br />\n';
    }

    if(this.endDocking) {
        result += 'EndDocking:'+this.endDocking.position()+'<br />\n';
    } else {
        result += 'No EndDocking<br />\n';
    }
    return result;
};

TransitionDockingManager.prototype.validate = function() {
    var $transitionGroup = this.transition.group.$();
    var $svgRoot = this.transition.diagram.getRootSVG().$();
    var result = [];

    if(this.startNode) {
        result['startNode'] = this.transition.diagram.nodeMgr.validateNode(this.startNode);
    }
    
    if(!this.startDocking) {
        result['startDocking'] = 'Error: No startDocking set!';
    } else if(this.startDocking.knob) {
        var startDocking = $transitionGroup.find('#'+this.startDocking.knob.node.id);
        if(!startDocking.length) {
            result['startDocking'] = 'Error: startDocking not found in transition group';
        } else if($transitionGroup.children('.orientationKnob.start').length != 1) {
            result['startDocking'] = 'Error: found invalid amount of startdocking nodes';
        }
    }

    if(this.endNode) {
        result['endNode'] = this.transition.diagram.nodeMgr.validateNode(this.endNode);
    }

    if(!this.endDocking) {
        result['endDocking'] = 'Error: No endDocking set!';
    } else if(this.endDocking.knob) {
        var endDocking = $transitionGroup.find('#'+this.endDocking.knob.node.id);
        if(!endDocking.length) {
            result['endDocking'] = 'Error: endDocking not found in transition group';
        } else if($transitionGroup.children('.orientationKnob.start').length != 1) {
            result['endDocking'] = 'Error: found invalid amount of endDocking nodes';
        }
    }
    return result;
};

module.exports = TransitionDockingManager;
},{"../util/util":79,"./Knob":10,"./docking":19}],44:[function(require,module,exports){
/**
 * This module manages the transition data like knobs and pathdata.
 *
 */
var util = require('../util/util');
var Knob = require('./knob');
var DragAlignment = require('./dragAlignment');
var event = require('../core/event');

var dom = util.dom;
var object = util.object;

var TransitionKnobManager = function(transition) {
    this.transition = transition;
    this.dockingManager = transition.dockingManager;
    this.event = transition.event;
    this.init();

    var that = this;
    this.transition.additions['knobManager'] = {
        setEndNode : function(node) {
            var knob = (that.isInitState()) ? that.addKnob(node.getCenter()) : that.getEndKnob();

            if(node.knob) {
                knob.hoverable(false);
            } else {
                knob.hoverable(true);
            }
        },
        setStartNode : function(node) {
            var knob = (that.isInitState()) ? that.addKnob(node.getCenter(), 0) : that.getStartKnob();

            if(node.knob) {
                knob.hoverable(false);
            } else {
                knob.hoverable(true);
            }
        },
        select : function() {
            that.inactiveStyle();
        },
        deselect : function() {
            that.hide();
        },
        hover : function() {
            that.inactiveStyle();
        },
        hoverOut : function() {
            if(!that.transition.selected) {
                that.hide();
            }
        }

    };
};

TransitionKnobManager.prototype.init = function() {
    this.knobs = [];
};

TransitionKnobManager.prototype.activate = function() {
    var that = this;

    var oldStartKnob = this.transition.firstChild('.startKnob');
    this._activateKnob(oldStartKnob, 0, true);

    var oldInnerKnobs = this.transition.children('.innerKnob');
    $.each(oldInnerKnobs, function(i, oldInnerKnob) {
        that._activateKnob(oldInnerKnob, (i + 1));
    });

    var oldEndKnob = this.transition.firstChild('.endKnob');
    this._activateKnob(oldEndKnob, this.knobs.length, true);

    return this;
};

TransitionKnobManager.prototype._activateKnob = function(knobSvg, index, isBoundaryKnob) {
    this.addKnob(knobSvg.getCenter(), index, true, isBoundaryKnob, knobSvg);
};

TransitionKnobManager.prototype.freeze = function() {
    $.each(this.knobs, function(index, knob) {
        knob.freeze();
        knob.config['fill-opacity'] = 0;
        knob.show();
    });
};

TransitionKnobManager.prototype.unfreeze = function() {
    $.each(this.knobs, function(index, knob) {
        knob.unfreeze();
        //TODO: we should use the old config value instead.
        knob.config['fill-opacity'] = 0.5;
        knob.show();
    });
};

TransitionKnobManager.prototype.addKnob = function(position, index, activate, isBoundaryKnob, svgInstance) {
    var index = index || this.size();
    var isBoundaryKnob = (!activate)? this.isInitState() : isBoundaryKnob;
    var knob = this.initKnob(index, position, isBoundaryKnob, svgInstance);
    this.knobs.splice(index, 0, knob);

    if(index === 0) {
        this.startKnob = knob;
    } else if(arguments.length === 1 || isBoundaryKnob) {
        this.endKnob = knob;
    }

    if(!activate && arguments.length !== 1) {
        //We do not need ato add an additional pathpart for the endnode;
        this.getPathManager().addPathPart(index, position);
    }

    if(!activate) {
        this.transition.redraw();
    }
    return knob;
};

TransitionKnobManager.prototype.initKnob = function(knobIndex, position, isBoundaryKnob, svgInstance) {
    var that = this;

    var knobConfig = {
        radius:5,
        activate: svgInstance,
        selectable: !isBoundaryKnob,
        fill: isBoundaryKnob ? 'green' : 'silver',
        cssClass: (knobIndex === 0) ? 'startKnob' : (isBoundaryKnob) ? 'endKnob' : 'innerKnob'
    };

    var knob = new Knob(this.transition.diagram, position, knobConfig, this.transition.group);
    knob.transition = this.transition;
    var initialDrag = true;

    if(!isBoundaryKnob) {
        knob.draggable({
            dragAlignment : new DragAlignment(that.transition.diagram,
                function() { return [{source: [knob.position()], target: that.getJoiningOrientation(knob)}];}),
            dragMove : function() {
                //We just update boundary knobs if they are not in within multiselection
                if(!(that.transition.diagram.isMultiSelection() && that.isBoundaryIndex(knobIndex))) {
                    that.updateKnob(that.getIndexForKnob(knob), knob.position());
                    that.transition.update();
                }
            },
            dragEnd : function() {
                if(initialDrag) {
                    that.transition.exec('knob_add', [knobIndex, knob.position()]);
                    initialDrag = false;
                } else {
                    that.transition.exec('knob_drop', [knobIndex, knob.position()]);
                }
            }
        });
    } else {
        knob.draggable({
            preventAlignment : true,
            dragMove : function() {
                //We just update boundary knobs if they are not in within multiselection
                if(!that.transition.diagram.isMultiSelection()) {
                    that.getPathManager().updatePart(that.getIndexForKnob(knob), knob.position());
                    that.transition.redraw();
                }
            },
            dragEnd : function() {
                //TODO: currently the getNodeByPosition function does return the first node found not the one with the highest index...
                var hoverNode = that.transition.diagram.getNodeByPosition(knob.position());
                if(knobIndex > 0) {
                    that.transition.setEndNode(hoverNode);
                } else {
                    that.transition.setStartNode(hoverNode);
                }
            }
        });
    }

    knob.on('deselect', function(evt) {
        if(that.transition.selected) {
            knob.inactiveStyle();
        } else {
            knob.hide();
        }
    });

    knob.on('remove', function() {
        that.removeKnob(knob);
    });

    //To prevent hiding the hoverknobs we adobt the transition hovering
    knob.hoverable({
        in : function() {
            that.transition.hover();
            if(!knob.isSelected()) {
                knob.fill('#9E9E9E');
            }
        },
        out : function() {
            that.transition.hoverOut();
        }
    });

    return knob;
};

/**
 * Api call for moving transition knobs
 */
TransitionKnobManager.prototype.moveKnob = function(knob, dx, dy) {
    //TODO: prevent redundancy with evt driven appraoch
    var knob = (knob.node) ? knob : this.getKnob(knob);
    var index = this.getIndexForKnob(knob);
    knob.move(dx,dy);
    //TODO: not very clean... is used for tracing api move calls... transitionManager CMD_KNOB_DROP command
    knob.node.root.dxSum = dx;
    knob.node.root.dySum = dy;
    var newPostion = knob.position();
    this.getPathManager().updatePart(index, newPostion);
    this.transition.update();
    this.transition.exec('knob_drop', [index, newPostion]);
};

TransitionKnobManager.prototype.moveInnerKnobs = function(distance) {
    $.each(this.getInnerKnobs(), function(i, knob) {
        knob.triggerDrag(distance.x, distance.y);
    });
};

TransitionKnobManager.prototype.selectInnerKnobs = function() {
    $.each(this.getInnerKnobs(), function(i, knob) {
        knob.select(true);
    });
};

TransitionKnobManager.prototype.getSelectedKnobs = function() {
    var result = [];
    $.each(this.getInnerKnobs(), function(index, knob) {
        if(knob.isSelected()) {
            result.push(knob);
        }
    });
    return result;get
};

TransitionKnobManager.prototype.getInnerKnobs = function() {
    var result = [];
    for(var i = 1; i < this.knobs.length - 1; i++) {
        result.push(this.knobs[i]);
    }
    return result;
};

TransitionKnobManager.prototype.isInitState = function() {
    return this.size() < 2;
}

TransitionKnobManager.prototype.updateStartKnob = function(position) {
    this.updateKnob(0, position);
};

TransitionKnobManager.prototype.updateEndKnob = function(position) {
    this.updateKnob(-1, position);
};

TransitionKnobManager.prototype.updateKnob = function(knobIndex, position) {
    knobIndex = object.getIndex(this.knobs, knobIndex);

    // Note the following is only neccessary for boundary knobs but won't affect other knobs since the given position
    // is the same as the current knob position after drag.
    this.knobs[knobIndex].moveTo(position.x, position.y);

    // update path
    this.getPathManager().updatePart(knobIndex, position);
};

TransitionKnobManager.prototype.removeKnob = function(knob) {
    if(!this.transition.removed) {
        var index = this.getIndexForKnob(knob);
        if(index < 0) {
            return;
        }
        this.knobs.splice(index, 1);
        this.getPathManager().removePathPart(index);
        this.transition.update();
    }
};

TransitionKnobManager.prototype.size = function() {
    return this.knobs.length;
};

TransitionKnobManager.prototype.lastIndex = function() {
    return this.size() - 1;
};

TransitionKnobManager.prototype.hasInnerKnobs = function() {
    return this.knobs.length > 2;
};

TransitionKnobManager.prototype.remove = function() {
    object.each(this.knobs, function(index, value) {
        if(object.isDefined(value)) {
            value.remove();
        }
    });
};

TransitionKnobManager.prototype.removeDockingMarker = function() {
    this.transition.group.$().children('.docking').remove();
};

TransitionKnobManager.prototype.isBoundaryKnob = function(knob) {
    return this.isBoundaryIndex(this.getIndexForKnob(knob));
};

TransitionKnobManager.prototype.isBoundaryIndex = function(knobIndex) {
    return knobIndex === 0 || knobIndex === this.lastIndex();
};

TransitionKnobManager.prototype.getKnobsByIndex = function(index) {
    return [this.knobs[index - 1], this.knobs[index]];
};

TransitionKnobManager.prototype.getJoiningOrientation = function(knob) {
    var index = this.getIndexForKnob(knob);
    var result = [];
    if(index <= 1) { //start or second docking
        result.push(this.transition.dockingManager.startDocking.position());
    } else if(index !== 0){
        var orientation = this.knobs[index - 1].position();
        result.push({x : orientation.x, y : orientation.y});
    }

    if(index >= this.knobs.length -2) { //end or one before end docking
        result.push(this.transition.dockingManager.endDocking.position());
    } else {
        var orientation = this.knobs[index + 1].position();
        result.push({x : orientation.x, y : orientation.y});
    }

    return result;
};

TransitionKnobManager.prototype.getIndexForKnob = function(knob) {
    return this.knobs.indexOf(knob);
};

TransitionKnobManager.prototype.getKnobPositions = function() {
    var result = [];
    object.each(this.knobs, function(index, value) {
        result.push(value.position());
    });
    return result;
};

TransitionKnobManager.prototype.getStartKnob = function() {
    return this.getKnob(0);
};

TransitionKnobManager.prototype.getEndKnob = function() {
    return this.getKnob(-1);
};

TransitionKnobManager.prototype.start = function() {
    return this.getKnob(0).position();
};

TransitionKnobManager.prototype.end = function() {
    return this.getKnob(-1).position();
};

TransitionKnobManager.prototype.getKnob = function(index) {
    return object.valueByIndex(this.knobs, index);
};

TransitionKnobManager.prototype.hide = function() {
    object.each(this.knobs, function(index, knob) {
        if(!knob.isSelected()) {
            knob.hide();
        }
    });
};

TransitionKnobManager.prototype.inactiveStyle = function() {
    object.each(this.knobs, function(index, knob) {
        if(!knob.isSelected()) {
            knob.inactiveStyle();
        }
    });
};

TransitionKnobManager.prototype.ownsKnobNode = function(node) {
    var result = false;
    return node.root.$().parent().attr('id') === this.transition.group.$().attr('id');
};

TransitionKnobManager.prototype.getPosition = function(index) {
    if(index < this.size()) {
        return object.valueByIndex(this.knobs, index).position();
    }
};

TransitionKnobManager.prototype.getPathManager = function() {
    return this.transition.pathManager;
};

TransitionKnobManager.prototype.isInitState = function() {
    return !this.endKnob;
};

TransitionKnobManager.prototype.dump = function() {
    var result = 'KnobManager - '+this.knobs.length+'<br />';
    object.each(this.knobs, function(index, knob) {
        result += '['+index+']('+knob.position().x+'/'+knob.position().y+')<br />';
    });
    return result;
};

TransitionKnobManager.prototype.validate = function() {
    var $transitionGroup = this.transition.group.$();
    var $svgRoot = this.transition.diagram.getRootSVG().$();

    var result = [];
    if(this.isInitState()) {
        return result;
    }

    if(this.knobs < 2) {
        result['knobCount'] = 'Too less knobs found!';
    }

    if(!this.startKnob) {
        result['startKnob'] = 'No startKnob found!';
    } else if(!$transitionGroup.find('#'+this.startKnob.node.id).length) {
        result['startKnob'] = 'No startKnob found in transition group!';
    } else if($transitionGroup.find('.startKnob').length != 1) {
        result['startKnob'] = 'Invalid startKnob amount found in transition group!';
    }

    var innerKnobs = this.getInnerKnobs();
    var $innerKnobs = $transitionGroup.find('.innerKnob');
    if(innerKnobs.length != $innerKnobs.length) {
        result['innerKnobs'] = 'Invalid amount of innerKnobs found in transition group!';
    }

    if(!this.endKnob) {
        result['endKnob'] = 'No endKnob found!';
    } else if(!$transitionGroup.find('#'+this.endKnob.node.id).length) {
        result['endKnob'] = 'No startKnob found in transition group!';
    } else if($transitionGroup.find('.endKnob').length != 1) {
        result['endKnob'] = 'Invalid endKnob amount found in transition group!';
    }

    return result;
};

module.exports = TransitionKnobManager;
},{"../core/event":7,"../util/util":79,"./dragAlignment":20,"./knob":26}],45:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var xml = require('../util/xml');
var event = require('../core/event');
var config = require('../core/config');
var Transition = require('./transition');

var AbstractManager = require('./abstractManager');

var EVT_TRANSITION_ADDED = "transition_added";
var EVT_TRANSITION_SELECTED = 'transition_selected';
var EVT_TRANSITION_DESELECTED = 'transition_deselected';
var EVT_TRANSITION_REMOVED = 'transition_removed';

var CMD_ADD = "transition_add";
var CMD_DEL = "transition_delete";
var CMD_KNOB_ADD = "transition_knob_added";
var CMD_KNOB_DROP = "transition_knob_dropped";
var CMD_EDIT = "transition_edit";

var TransitionManager = function(diagram) {
    // Contains all nodes added to the diagram
    AbstractManager.call(this, diagram);

    this.transitions = {};
    this.diagram = diagram;
    event.listen('transition_delete', this.deleteTransitionListener, this);
    event.listen('transition_edit', this.editTransitionListener, this);

    this.command(CMD_ADD, this.importTransition, this.deleteTransition);
    this.command(CMD_DEL, this.deleteTransition, this.importTransition);
    this.command(CMD_KNOB_ADD, this.addKnob, this.deleteKnob);
    this.command(CMD_KNOB_DROP, this.dropDocking, this.dropDocking);
    this.command(CMD_EDIT, this.editTransition, this.undoEdit);
};

util.inherits(TransitionManager, AbstractManager);


TransitionManager.prototype.size = function() {
    return object.size(this.transitions);
};

TransitionManager.prototype.editTransitionListener = function(evt) {
    var transition = this.getTransition(evt.data.transition);
    var key = evt.data.key;
    var oldValue = transition.additions.edit.getValue(key);
    this.exec(CMD_EDIT, [transition.id, key, evt.data.value], [transition.id, key, oldValue]);
};

TransitionManager.prototype.editTransition = function(transition, key, value) {
    transition = this.getTransition(transition);
    transition.additions.edit.setValue(key, value);
    event.trigger('transition_edited', transition);
};

TransitionManager.prototype.undoEdit = function(transition, key, value) {
    transition = this.getTransition(transition);
    if(!transition) {
        return;
    }
    transition.additions.edit.setValue(key, value);
    event.trigger('transition_edit_undo', transition);
};

TransitionManager.prototype.importTransition = function(transitionStr, cfg) {
    var cfg = cfg || {};

    //If set we replace the old node id with a new one e.g. when we copy a node
    if(cfg.newId && cfg.oldId) {
        transitionStr = transitionStr.replace(new RegExp(cfg.oldId, 'g'), cfg.newId);
    }

    var transitionElement = this.diagram.import(transitionStr);
    return this.activateTransition(transitionElement);
};

var _sortActivationTransition = function(a, b) {
    var $tA = $(a);
    var $tB = $(b);

    var startA = $tA.attr('dala:start');
    var startB = $tB.attr('dala:start');

    var endA = $tA.attr('dala:end');
    var endB = $tB.attr('dala:end');

    if($tA.find('#'+startB).length || $tA.find('#'+endB).length) {
        return -1;
    } else if($tB.find('#'+startA).length || $tB.find('#'+endA).length) {
        return 1;
    }
    return 0;
}

TransitionManager.prototype.activateTransition = function(toActivate) {
    if(object.isArray(toActivate) || object.isJQuery(toActivate)) {
        toActivate.sort(_sortActivationTransition);
        var result = [];
        var that = this;
        object.each(toActivate, function() {
            result.push(that.activateTransition($(this).get(0)));
        });
        return result;
    } else  { //toActivate is domElement
        return this.addTransition(new Transition(this.diagram, toActivate));
    }
};

TransitionManager.prototype.isDragTransition = function(transition) {
    return object.isDefined(this.dragTransition);
};

TransitionManager.prototype.startDragTransition = function(node, mouse) {
    mouse = mouse || node.getCenter();

    var cfg = $.extend({}, config.val('transition_settings', {}));
    //TODO: check for node/template prefered/transition + transitionconfiguration prefer template or settings
    return this.dragTransition = new Transition(node, mouse, cfg);
};

TransitionManager.prototype.getDragTransition = function() {
    return this.dragTransition;
};

TransitionManager.prototype.endDragTransition = function() {
    var that = this;
    this.addTransition(this.dragTransition);
    delete this.dragTransition;
};

TransitionManager.prototype.addTransition = function(transition) {
    var that = this;
    this.event.trigger(EVT_TRANSITION_ADDED, transition);

    transition.on('select', function() {
        that.event.trigger(EVT_TRANSITION_SELECTED, transition);
    }).on('deselect', function() {
        that.event.trigger(EVT_TRANSITION_DESELECTED, transition);
    }).on('remove', function() {
        that.event.trigger(EVT_TRANSITION_REMOVED, transition);
    }).on('knob_add', function(evt , knobIndex, position) {
        that.addCmd(CMD_KNOB_ADD, [transition.id, knobIndex, position], [transition, knobIndex]);
    }).on('knob_drop', function(evt , knobIndex) {
        var knob = transition.knobManager.getKnob(knobIndex);
        //TODO: perhaps rather use dragContext note: api call in transitionknobmanager
        that.addCmd(CMD_KNOB_DROP,
            [transition.id, knobIndex, knob.node.root.dxSum, knob.node.root.dySum],
            [transition.id, knobIndex, (-1 * knob.node.root.dxSum), (-1 * knob.node.root.dySum)]);
    });

    this.addCmd(CMD_ADD, [this.getTransitionString(transition)], [transition.id]);
    return this.transitions[transition.id] = transition;
};

TransitionManager.prototype.addKnob = function(transition, knobIndex, position) {
    this.getTransition(transition).addKnob(position,knobIndex);
};

TransitionManager.prototype.deleteKnob = function(transition, dockingIndex) {
    this.getTransition(transition).knobManager.getKnob(dockingIndex).remove();
};

TransitionManager.prototype.dropDocking = function(transition, dockingIndex, dxSum, dySum) {
    transition = this.getTransition(transition);
    if(transition) {
        var docking = transition.knobManager.getKnob(dockingIndex);
        docking.triggerDrag(dxSum, dySum);
    }
};

TransitionManager.prototype.transitionDockingCreated = function(transition, dockingIndex) {
    var transition = evt.data.transition;
    var dockingIndex = evt.data.dockingIndex;

};

TransitionManager.prototype.getTransitionString = function(transition) {
    transition = this.getTransition(transition);
    return xml.serializeToString(transition.instance());
};

TransitionManager.prototype.deleteTransitionListener = function(evt) {
    if(evt.data) {
        var transition = evt.data;
        this.exec(CMD_DEL, [transition.id], [this.getTransitionString(transition)]);
    }
};

TransitionManager.prototype.deleteTransition = function(id) {
    var transition = this.getTransition(id);
    if(transition) {
        delete this.transitions[id];
        transition.remove();
    }
};

TransitionManager.prototype.getTransition = function(id) {
    if(object.isString(id) && !isNaN(id)) {
        return this.transitions[parseInt(id)];
    } else if(!isNaN(id)) {
        return this.transitions[id];
    } else if(id instanceof Transition) {
        //We assume a node instance
        return id;
    } else {
        console.warn('getTransition call with no result for :'+id);
    }
};

TransitionManager.prototype.dump = function() {
    var result = '<b>TransitionManager</b> - '+this.size()+' Transitions<br />\n';
    $.each(this.transitions, function(index, transition) {
        result += transition.dump()+'<br />\n';
    });
    return result;
};

TransitionManager.prototype.validate = function() {
    var result = {};
    $.each(this.transitions, function(index, transition) {
        result['transition'+transition.id] = transition.validate();
    });
    return result;
};

module.exports = TransitionManager;
},{"../core/config":6,"../core/event":7,"../util/object":77,"../util/util":79,"../util/xml":80,"./abstractManager":12,"./transition":40}],46:[function(require,module,exports){
var util = require('../util/util');
var object = util.object;

var NODE_DISTANCE = 11;
var TRANSITION_DISTANCE = 10;
var DEF_TEXT_HEIGHT = 13;

var TransitionTextAddition = function(transition) {
    this.textNodes = [];
    this.transition = transition;
    this.diagram = this.transition.diagram;
};

/**
 * The update addition function rerenders all containing textnodes by means
 * of the current transition settings. This function is delegated by
 * the transition as addition call.
 */
TransitionTextAddition.prototype.update = function() {
    var that = this;
    object.each(this.textNodes, function(index, textSVG) {
        if(textSVG) {
            that.updateTextPosition(index);
        }
    });
};

TransitionTextAddition.prototype.getText = function(pos) {
    if(this.textNodes[pos]) {
        return this.textNodes[pos].$().text();
    }
};

/**
 * Sets the text for a given position. If the given text position is not
 * occupied yet we create a new textnode.
 */
TransitionTextAddition.prototype.setText = function(pos, text) {
    if(!this.textNodes[pos]) {
        var id = 'text'+pos+'_'+this.transition.id;
        var textNode = this.textNodes[pos] = this.diagram.svg.text(text, {id : id}).hanging(false);
        this.diagram.svg.addToGroup(this.transition.group, textNode);
    } else {
        this.textNodes[pos].content(text);
    }
    this.updateTextPosition(pos);
};

TransitionTextAddition.prototype.setColor = function(value) {
    $.each(this.textNodes, function(index, text) {
        if(text) {
            text.fill(value);
        }
    });
};

TransitionTextAddition.prototype.setSize = function(value) {
    $.each(this.textNodes, function(index, text) {
        if(text) {
            text.fontSize(value);
        }
    });
};

TransitionTextAddition.prototype.setWeight = function(value) {
    $.each(this.textNodes, function(index, text) {
        if(text) {
            text.fontWeight(value);
        }
    });
};
/**
 * Updates the textnode position and anchor for the given position by means of the current
 * transition settings.
 */
TransitionTextAddition.prototype.updateTextPosition = function(pos) {
    var position = this.getTextPosition(pos);

    //For some points the position cannot be determined mainly on the node corner
    if(position) {
        this.textNodes[pos].moveTo(position);
        this.setAnchor(pos);
    }
};

TransitionTextAddition.prototype.getTextPosition = function(pos) {
    var textPosition;

    var textHeight = this.getTextHeight(pos);

    if(isStartPos(pos) || isEndPos(pos)) {
        //Move along the transition in the right direction the index -1 searches the last transitionPart
        var index = isEndPos(pos) ? -1 : 1;
        var distance = isEndPos(pos) ? NODE_DISTANCE * -1 : NODE_DISTANCE;
        textPosition = this.transition.getPath().moveAlong(index, distance);

        switch(this.getLocation(pos)) {
            case 'left':
            case 'right':
                textPosition.y += (isTop(pos)) ? -TRANSITION_DISTANCE : TRANSITION_DISTANCE + (textHeight);
                break;
            case 'top':
            case 'bottom':
                textPosition.x += (isTop(pos)) ? TRANSITION_DISTANCE : -TRANSITION_DISTANCE;
                break;
        }
    } else {
        //Mid Position
        textPosition = this.transition.getPath().getCenter();
        textPosition.y += isTop(pos) ? TRANSITION_DISTANCE * -1 : TRANSITION_DISTANCE + textHeight;
    }

    return textPosition;
};

TransitionTextAddition.prototype.getTextHeight = function(pos) {
    return (this.textNodes[pos]) ? this.textNodes[pos].height() : DEF_TEXT_HEIGHT;
};

TransitionTextAddition.prototype.getAlignPosition = function(pos) {
    if(isStartPos(pos)) {
        return this.transition.start();
    } else if(isEndPos(pos)) {
        return this.transition.end();
    }
};

TransitionTextAddition.prototype.getLocation = function(pos) {
    if(isStartPos(pos)) {
        return this.transition.getStartLocation();
    } else if(isEndPos(pos)) {
        return this.transition.getEndLocation();
    }
};

/**
 * This function determines the text-anchor by means of the current
 * node location to assure the text is not overlapping other texts or the
 * node itself.
 */
TransitionTextAddition.prototype.setAnchor = function(pos) {
    var textSVG = this.textNodes[pos];
    if(!isMidPos(pos)) {
        switch(this.getLocation(pos)) {
            case 'left':
                textSVG.end();
                break;
            case 'right':
                textSVG.start();
                break;
            case 'top':
            case 'bottom':
                if(isBottom(pos)) {
                    textSVG.end();
                } else {
                    textSVG.start();
                }
                break;
        }
    } else {
        textSVG.middle();
    }
};

var isBottom = function(pos) {
    return !isTop(pos);
};

var isTop = function(pos) {
    return pos % 2 === 0;
};

var isStartPos = function(pos) {
    return pos < 2;
};

var isMidPos = function(pos) {
    return !isStartPos(pos) && !isEndPos(pos);
};

var isEndPos = function(pos) {
    return pos > 3;
};

module.exports = TransitionTextAddition;

},{"../util/util":79}],47:[function(require,module,exports){
var xml = require('../util/xml');
var object = require('../util/object');
var string = require('../util/string');

var elementCache = {};

var create = function(element, attributes, text) {
    var $element = $(document.createElement(element));

    if(attributes) {
        $.each(attributes, function (key, value) {
            $element.attr(key, value);
        });
    }

    if(text) {
        $element.text(text);
    }
    return $element;
};

var query = function(selector, cache) {
    var result;
    if(cache) {
        result = $.qCache(selector);
    } else {
        result = $(selector);
    }
    return result;
};

var getJQueryNode = function(node) {
    if(!node) {
        return;
    }
    // The node is either a dom node or a selector
    if(object.isString(node)) {
        return query(node);
    } else if(node.getAttribute){
        var id = node.getAttribute('id');
        if(id) {
            return $.qCache('#'+node.getAttribute('id'), true);
        } else {
            return $(node);
        }
    } else if(node.jQuery) {
        return node;
    } else {
        // e.g. document, window...
        return $(node);
    }
};

var moveDown = function(node, selector) {
    var $node = getJQueryNode(node);
    $node.before($node.next(selector));
};

var moveUp = function(node, selector) {
    var $node = getJQueryNode(node);
    $node.after($node.prev(selector));
};

var insertAfterIndex = function(node, index) {
    var $node = getJQueryNode(node);
    $node.parent().children().eq(index).after($node);
};

var insertSVGAfter = function(container, element, text, insertAfter) {
    text = text || element.text;
    delete element.text;
    return addSVGElement(container,element,text,insertAfter);
};

var prependSVGElement = function(container, element, text) {
    text = text || element.text;
    delete element.text;
    return addSVGElement(container,element,true,text);
};

var appendSVGElement = function(container, element, text) {
    text = text || element.text;
    delete element.text;
    return addSVGElement(container,element,false,text);
};

var prependToRoot = function(element) {
    if(!element.root.hasChildNodes()) {
        element.instance(element.root.appendChild(element.instance()));
    } else {
        element.instance(element.root.insertBefore(element.instance(), element.root.childNodes[0]));
    }
};

var addSVGElement = function(container, element, prepend, text, insertAfter) {
    prepend = (object.isDefined(prepend))? prepend : false;
    // If only the container is given we assume its an SVGElement object with contained root node
    if(object.isDefined(container) && !object.isDefined(element)) {
        element = container;
        container = container.getRootNode();
    } else if(object.isString(container)) {
        container = query(container)[0];
    } else if(container.instance) {
        container = container.instance();
    }

    var instance;

    if(!element.instance || !object.isDefined(element.instance())) {
        instance = document.createElementNS("http://www.w3.org/2000/svg", element.tagName);
        $.each(element.attributes, function(key, value) {
            if(string.startsWith(key, 'xlink:')) {
                instance.setAttributeNS('http://www.w3.org/1999/xlink',string.cutprefix(key, 'xlink:'), value);
            } else {
                instance.setAttribute(key, value.toString());
            }
        });
    } else {
        instance = element.instance();
    }

    if(object.isDefined(text)) {
        var txtNode = document.createTextNode(text);
        instance.appendChild(txtNode);
    }
    if(object.isDefined(insertAfter)) {
        //if the parents lastchild is the targetElement...
        if(container.lastchild == insertAfter) {
            //add the newElement after the target element.
            container.appendChild(instance);
        } else {
            // else the target has siblings, insert the new element between the target and it's next sibling.
            container.insertBefore(instance, insertAfter.nextSibling);
        }
    } else if(!prepend || !container.hasChildNodes() ) {
        instance = container.appendChild(instance);
    } else {
        instance = container.insertBefore(instance,container.childNodes[0]);
    }

    if(object.isFunction(element.instance)) {
        element.instance(instance);
    } else {
        element.instance = instance;
    }

    return element;
};

var importSVG = function(container, svgXML, prepend) {
    var $svgXML, name, attributes;

    if(svgXML.jquery) {
        $svgXML = svgXML;
    } else if(object.isString(svgXML)) {
        $svgXML = $(parseXML(svgXML.trim()));
        $svgXML = $($svgXML.get(0).documentElement);
    } else {
        $svgXML = $(svgXML);
    }

    if($svgXML.nodeName) {
        name = $svgXML.nodeName;
        attributes = getAttributes($svgXML);
    } else {
        name = $svgXML.get(0).tagName;
        attributes = getAttributes($svgXML.get(0));
    }

    //We create a dummy element object
    var element = {
        tagName : name,
        attributes : attributes,
        instance : function(inst) {
            if(object.isDefined(inst)) {
                this.instanceElement = inst;
            } else {
                return this.instanceElement;
            }
        }
    };

    if(!prepend) {
        appendSVGElement(container, element, _getChildText($svgXML));
    } else {
        prependSVGElement(container, element, _getChildText($svgXML));
    }

    $svgXML.children().each(function(index, child) {
        importSVG(element.instance(), child);
    });

    return element.instance();
};

var _getChildText = function(node) {
    if(!node.jquery) {
        node = $(node);
    }

    var childText = node.contents().filter(function(){
        return this.nodeType === 3;
    });

    if(object.isDefined(childText) && childText.length > 0) {
        return childText[0].nodeValue;
    }
};

var getAttributes = function(node) {
    var result = {};
    $(node.attributes).each(function() {
        result[this.nodeName] = this.value;
    });
    return result;
};

var findIncludeSelf = function(node, selector) {
    return $(node).find(selector).andSelf().filter(selector).get(0);
};

var parseNodeXML = function(node) {
    if(!node) {
        return;
    }
    return $.parseXML($(node).text());
};

var parseXML = function(str) {
    return xml.parseXML(str);
};

var parseNodeJSON = function(node) {
    return $.parseJSON($(node).text());
};

var getRawId = function(idSelector) {
    if(!object.isString(idSelector)) {
        return;
    }

    if(idSelector.charAt(0) === '#') {
        return idSelector.substring(1, idSelector.length);
    } else {
        return idSelector;
    }
};

var getIdSelector = function(rawId) {
    if(!object.isString(rawId)) {
        return;
    }

    if (rawId.charAt(0) !== '#') {
        return '#' + rawId;
    } else {
        return rawId;
    }
};

module.exports = {
    appendSVGElement : appendSVGElement,
    prependSVGElement : prependSVGElement,
    insertSVGAfter : insertSVGAfter,
    insertAfterIndex : insertAfterIndex,
    create : create,
    prependToRoot : prependToRoot,
    importSVG : importSVG,
    moveDown : moveDown,
    moveUp : moveUp,
    findIncludeSelf : findIncludeSelf,
    parseNodeXML : parseNodeXML,
    parseNodeJSON : parseNodeJSON,
    getAttributes : getAttributes,
    getRawId : getRawId,
    getIdSelector: getIdSelector
};
},{"../util/object":77,"../util/string":78,"../util/xml":80}],48:[function(require,module,exports){
var util = require('../util/util');
var object = util.object;
var dom = util.dom;

var Eventable = require('./eventableNode');

var Element = function(tagName, cfg, attributeSetter) {
    this.attributeSetter = attributeSetter || {};
    this.attributes = {};

    if(object.isObject(tagName)) {
        cfg = tagName;
        tagName = cfg.tagName;
        delete cfg.tagName;
    }

    this.tagName = tagName;

    if(object.isObject(cfg)) {
        if(cfg.children) {
            this.children = cfg.children;
            delete cfg.children;
        }

        this.single = cfg.single || false;
        delete cfg.single;

        //We assume all remaining cfg entries are attributes
        for(var attributeKey in cfg) {
            if(cfg.hasOwnProperty(attributeKey)) {
                this._setAttribute(attributeKey, cfg[attributeKey]);
            }
        }
    }

    //See eventable
    this.eventBase = this;
};

util.inherits(Element, Eventable);

Element.prototype.instance = function(instance) {
    if(object.isDefined(instance)) {
        this.domInstance = instance;
        this.$domInstance = null;
        this.tagName = instance.tagName;
        this.loadAttributes(instance);
        return this;
    } else {
        return this.domInstance;
    }
};

/**
 * Loads all attributes from the dom instance into our attribute array except already existing attributes.
 * @param instance
 */
Element.prototype.loadAttributes = function(instance) {
    this.attributes = this.attributes || {};
    var attributes = dom.getAttributes(instance);
    for(var key in attributes) {
        if(attributes.hasOwnProperty(key) && !this.attributes[key]) {
            this._setAttribute(key, attributes[key], true);
        }
    }
};

Element.prototype.id = function(newId) {
    if(object.isString(newId)) {
        this._setAttribute('id',newId);
        return this;
    } else {
        return this.attr('id');
    }
};

Element.prototype.update = function() {
    for(attributeKey in this.attributeSetter) {
        if(this.attributeSetter.hasOwnProperty(attributeKey)) {
            this.updateAttribute(attributeKey);
        }
    }
};

Element.prototype.updateAttribute = function(key) {
    this._setAttribute(key, this.attributes[key]);
};

Element.prototype._setAttribute = function(key, value, prevDomSet) {
    // If first arg is object handle its properties as attributes
    if(object.isObject(key)) {
        for(var attribute in key) {
            if(object.isDefined(attribute) && key.hasOwnProperty(attribute)) {
                this._setAttribute(attribute, key[attribute]);
            }
        }
    } else {

        // Some elementtypes can transform specific types of attributes to special objects
        // which are able to render and set the values in a special way.
        if(!this.hasClass('noParse') && object.isString(value) && object.isDefined(this.attributeSetter[key])) {
            value = this.attributeSetter[key](value);
        }

        if(!object.isDefined(value) || value.length === 0) {
            return;
        }

        // Just transform stringlits values to arrays in case its a string list
        this.attributes[key] = value;

        // Directly set it to the SVG instance if already rendered
        if(this.domInstance && !prevDomSet) {
            var val = Element.getAttributeString(value);
            this.domInstance.setAttribute(key,val);
        }
    }
};

Element.prototype.hasClass = function(searchClass) {
    if(this.domInstance) {
        //Jquery hasclass does not work with svg elements
        var elementClass = ' '+ this.attr('class')+' ';
        return elementClass.indexOf(' '+searchClass+' ') > -1;
    }
};

Element.prototype.$ = function(selector) {
    if(!this.$domInstance && this.domInstance) {
        this.$domInstance = $(this.domInstance);
    }

    return (selector) ? this.$domInstance.find(selector) : this.$domInstance;
};

Element.getAttributeString = function(value) {
    var result = '';

    if(!object.isDefined(value)) {
        return '';
    }

    if(object.isArray(value)) {
        object.each(value, function(index, part) {
            result += (++index === value.length) ? part : part+' ';
        });
    } else {
        result = value.toString();
    }
    return result;
};

Element.getAttributeValueFromStringList = function(value) {
    if(object.isString(value) && value.indexOf(' ') > -1) {
        return value.split(/[\s]+/);
    } else {
        return value;
    }
};

Element.prototype.attrNumber = function(key, value) {
    var val = util.app.parseNumberString(this.attr(key, value));
    return (object.isDefined(value)) ? this : val;
};

Element.prototype.pointerEvents = function(value) {
    return this.attr('pointer-events', value);
};
Element.prototype.attr = function(attribute) {
    if(arguments.length > 1 && object.isDefined(arguments[1])) {
        //TODO: implement for mor thant 2
        var obj = {};
        obj[arguments[0]] = arguments[1];
        return this.attr(obj);
    } else if(object.isString(attribute)) {
        var result = this.attributes[attribute];
        if(!result && this.instance()) {
            result = this.attributes[attribute] =  this.$().attr(attribute);
        }
        return result;
    } else {
        this._setAttribute(attribute);
    }
    return this;
};

module.exports =  Element;

},{"../util/util":79,"./eventableNode":49}],49:[function(require,module,exports){
var object = require('../util/object');
var config = require('../core/config');

var Eventable = function(eventBase) {
    this.eventBase = eventBase;
};

Eventable.prototype.exec = function(func, args, prevDomEvent) {
    args = args || this;
    this.executeAddition(func, args);
    if(this.executeTemplateHook) {
        this.executeTemplateHook(func, args);
    }
    if(this.eventBase && !prevDomEvent) {
        this.trigger(func, args);
    }
};

Eventable.prototype.executeAddition = function(func, args) {
    if(!this.additions) {
        return;
    }
    object.each(this.additions, function(key, addition) {
        if(object.isDefined(addition) && object.isFunction(addition[func])) {
            addition[func].apply(addition, args);
        }
    });
};

Eventable.prototype.one = function(evt, handler) {
    if(!this.eventBase) {
        return;
    }
    this.eventBase.$().one(evt, this.wrap(evt, handler));
    return this;
};

Eventable.prototype.on = function(evt, handler) {
    if(!this.eventBase) {
        return;
    }
    this.eventBase.$().on(evt, this.wrap(evt, handler));
    return this;
};

Eventable.prototype.wrap = function(eventType, handler) {
    var that = this;
    return function() {
        if(that.isExecutionAllowed(eventType)) {
            handler.apply(undefined, arguments);
        }
    }
};

Eventable.prototype.isExecutionAllowed = function(eventType) {
    if(this.freezed) {
        return false;
    } else if(config.is('events_restricted', false) && !this.excludeEventRestrictions) {
        return false;
    } else {
        return true;
    }
};

Eventable.prototype.freeze = function() {
    this.freezed = true;
    this.eventBase.freezed = true;
};


Eventable.prototype.unfreeze = function() {
    this.freezed = false;
    this.eventBase.freezed = true;
};

Eventable.prototype.trigger = function(evt, args) {
    if(!this.eventBase) {
        return;
    }
    this.eventBase.$().trigger(evt, args);
    return this;
};

Eventable.prototype.off = function(evt, handler) {
    if(!this.eventBase) {
        return;
    }
    this.eventBase.$().off(evt, handler);
};

module.exports = Eventable;
},{"../core/config":6,"../util/object":77}],50:[function(require,module,exports){
var object = require('../util/object');
var Vector = require('../util/math').Vector;
var math = require('../util/math');
var util = require("../util/util");

var AbstractPathDataType = function(type, absolute) {
    this.vector = new Vector();
    this.vector.add(type);
    this.absolute = absolute || true;
};

AbstractPathDataType.prototype.setAbsolute = function(absolute) {
    this.absolute = absolute || true;
    return this;
};

AbstractPathDataType.prototype.getType = function() {
    var type = this.value(0,0);
    return this.absolute ? type.toUpperCase() : type.toLowerCase();
};

AbstractPathDataType.prototype.value = function() {
    return this.vector.value(Array.prototype.slice.call(arguments));
};

AbstractPathDataType.prototype.setValue = function(pathArr, value) {
    return this.vector.setValue(pathArr, value);
};

AbstractPathDataType.prototype.insert = function(pathArr, values) {
    return this.vector.setValue(pathArr, values);
};

AbstractPathDataType.prototype.is = function(type) {
    return this.getType().toUpperCase() === type.toUpperCase();
};

AbstractPathDataType.prototype.to = function(pathArr, values) {
    //ABSTRACT
};

AbstractPathDataType.prototype.pointToString = function(p) {
    return p.x + ',' + p.y+' ';
};

AbstractPathDataType.prototype.getOrSet = function(index, value) {
    if(value) {
        this.setValue(index, value);
        return this;
    } else {
        return this.value(index);
    }
}

/**
 * Vector = [['l'], {x:x, y:y}]
 */
var LineTo = function(p, absolute) {
    AbstractPathDataType.call(this, 'l', absolute);
    this.to(p);
};

util.inherits(LineTo, AbstractPathDataType);

LineTo.prototype.to = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(1,p);
};

LineTo.prototype.toString = function() {
    return this.getType()+this.pointToString(this.to());
};

LineTo.prototype.x = function(value) {
    if(value) {
        this.value(1).x = value
    }
    return this.value(1).x;
};

LineTo.prototype.y = function(value) {
    if(value) {
        this.value(1).y = value
    }
    return this.value(1).y;
};

LineTo.prototype.moveAlong = function(from, distance) {
    return math.Line.moveAlong(from, this.to(), distance);
};

LineTo.prototype.getNearestPoint = function(from, position) {
    return math.Line.getNearestPoint(from, this.to(), position);
};

var QBezier = function(controlP, toP, absolute) {
    AbstractPathDataType.call(this, 'q', absolute);
    this.control(controlP);
    this.to(toP);
};

util.inherits(QBezier, AbstractPathDataType);

QBezier.prototype.to = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(2,p);
};

QBezier.prototype.control = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(1,p);
};

QBezier.prototype.toString = function() {
    return this.getType()+this.pointToString(this.control())+this.pointToString(this.to());
};

var CBezier = function(controlP1, controlP2, toP, absolute) {
    AbstractPathDataType.call(this, 'c', absolute);
    this.control1(controlP1);
    this.control2(controlP2);
    this.to(toP);
};

util.inherits(CBezier, AbstractPathDataType);

CBezier.prototype.control = function(x,y) {
    return this.control1(x,y);
};

CBezier.prototype.control1 = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(1,p);
};

CBezier.prototype.control2 = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(2,p);
};

CBezier.prototype.to = function(x,y) {
    var p = math.getPoint(x,y);
    return this.getOrSet(3,p);
};

CBezier.prototype.toString = function() {
    return this.getType()+this.pointToString(this.control1())+this.pointToString(this.control2())+this.pointToString(this.to());
};

/**
 * calculates the nearest point of the bezier curve to the given position. since the CBezier does not know its start
 * point, we have to provide the from position as well as the search base position.
 * @param from
 * @param position
 * @returns {{point, location}|*}
 */
CBezier.prototype.getNearestPoint = function(from, position) {
    return math.bezier.nearestPointOnCurve(position, this.getCurve(from)).point;
};

CBezier.prototype.moveAlong = function(from, distance) {
    return math.bezier.moveAlong(this.getCurve(from), distance);
};

CBezier.prototype.getCurve = function(from) {
    return [from, this.control1(), this.control2(), this.to()];
};

var MoveTo = function(toP, absolute) {
    AbstractPathDataType.call(this, 'm', absolute);
    this.to(toP);
};

util.inherits(MoveTo, LineTo);

var Complete = function() {
    AbstractPathDataType.call(this, 'z');
};

util.inherits(Complete, AbstractPathDataType);

Complete.prototype.toString = function() {
    return this.getType();
};

var pathType = {
    z : function() { return new Complete() },
    m : function() { return new MoveTo(arguments[0]); },
    l : function() { return new LineTo(arguments[0]); },
    q : function() { return new QBezier(arguments[0], arguments[1]); },
    c : function() { return new CBezier(arguments[0], arguments[1],  arguments[2]); }
};

var PathData = function(def) {
    this.data = new Vector();
    if(object.isString(def)) {
        this.loadFromString(def);
    }
};

PathData.prototype.loadFromString = function(strVal) {
    var that = this;
    //'M100,100 Q200,200 300,300' --> ['M100,100 ', 'Q200,200 300,300']
    var definitions = strVal.split(/(?=[MmLlHhVvCcSsQqTtAaZz]+)/);
    //Each dType
    $.each(definitions, function(index, value) {
        var type = value.charAt(0);
        //'Q200,200 300,300 -> ['200,200', '300,300']
        var values = value.substring(1,value.length).trim().split(' ');
        //['200,200', '300,300'] -> [{x:200, y:200}, {x:300, y:300}]
        var points = [];
        $.each(values, function(i, coord) {
            var coordVals = coord.split(',');
            points.push(math.getPoint(parseFloat(coordVals[0]), parseFloat(coordVals[1])));
        });
        that.data.add(pathType[type.toLowerCase()].apply(undefined, points).setAbsolute((type == type.toUpperCase())));
    });
    return this;
};

PathData.prototype.getCorners = function() {
    var xMin, xMax, yMin, yMax;
    xMin = yMin = Number.POSITIVE_INFINITY;
    xMax = yMax = Number.NEGATIVE_INFINITY;

    this.data.each(function(index, pathPart) {
        if(pathPart.x && pathPart.y) {
            xMin = (xMin > pathPart.x()) ? pathPart.x() : xMin;
            yMin = (yMin > pathPart.y()) ? pathPart.y() : yMin;

            xMax = (xMax < pathPart.x()) ? pathPart.x() : xMax;
            yMax = (yMax < pathPart.y()) ? pathPart.y() : yMax;
        }
    });

    return [
        {x:xMin, y:yMin},
        {x:xMax, y:yMin},
        {x:xMax, y:yMax},
        {x:xMin, y:yMax}
    ];
};

PathData.prototype.getX = function() {
    return this.getCorners()[0].x;
};

PathData.prototype.getY = function() {
    return this.getCorners()[0].y;
};

PathData.prototype.polynoms = function() {
    var result = [];
    object.each(this.data.vectors, function(index, value) {
        if(value.to) {
            result.push(value.to());
        }
    });
    return result;
};

/**
 * Returns
 * @returns {Array}
 */
PathData.prototype.getPathParts = function() {
    var result = [];

    //We start at index 1 because the 0 index of the vector contains the pathpart type
    for(var i = 1; i <= this.length() - 1; i++) {
        result.push(this.getPathPart(i));
    }

    return result;
};

PathData.prototype.getPathPart = function(index) {
    var pathPart = this.value(index);
    return {
        start: this.value(index - 1).to(),
        end: pathPart.to(),
        value: pathPart
    };
};

PathData.prototype.moveAlong = function(index, distance, direction) {
    var pathPart = this.getPathPart(index);
    if(pathPart.value.moveAlong) {
        return pathPart.value.moveAlong(pathPart.start, distance, direction);
    } else {
        return math.Line.moveAlong(pathPart.start, pathPart.end, distance, direction);
    }
};

/**
 * Calculates the rough center of the path by calculating the total length of the pathparts (as direct lines) and moving
 * along those lines to the center (total length / 2). Note with this method we just get a exact result for simple
 * line paths. If the calculated center position is within a cubic bezier path part, we return the nearest point on the curve
 * to the calculated center.
 * @returns {*}
 */
PathData.prototype.getCenter = function() {
    var resultD = this.getDistance() / 2;
    var currentD = 0;
    var center;
    object.each(this.getPathParts(), function(index, part) {
        var lineD = math.Line.calcDistance(part.start, part.end);
        var nextD = currentD + lineD;
        if(nextD > resultD) {
            var diffD =  resultD - currentD;
            center = math.Line.moveAlong(part.start, part.end, diffD);

            //If we have a cubic bezier path part we calculate the nearest point on the curve
            if(part.value.is('c')) {
                center = part.value.getNearestPoint(part.start, center);
            }
            return false;
        }
        currentD = nextD;
    });
    return center;
};

PathData.prototype.getDistance = function() {
    var distance = 0;
    object.each(this.getPathParts(), function(index, part) {
        distance += math.Line.calcDistance(part.start, part.end);
    });
    return distance;
};

/**
 * Assuming there are only! cubic bezier curved path parts this function recalculates all control points of the curves
 * to smoothen the entire path.
 *
 * @param polynoms
 */
PathData.prototype.smoothen = function(polynoms) {
    if(!polynoms) {
        polynoms = this.polynoms();
    }

    var x = [];
    var y = [];

    object.each(polynoms, function(index, value) {
        x[index] = value.x;
        y[index] = value.y;
    });

    var px = math.bezier.calculateSmoothControlPoints(x);
    var py = math.bezier.calculateSmoothControlPoints(y);

    var that = this;
    object.each(px.p1, function(index, value) {
        that.value(index + 1).control1(px.p1[index], py.p1[index]);
        that.value(index + 1).control2(px.p2[index], py.p2[index]);
    });
    return this;
};

PathData.prototype.getLineByPathIndex = function(index) {
    var p1 = this.value(index - 1).to();
    var p2 = this.value(index).to();
    return new math.Line(p1, p2);
};

PathData.prototype.getNearestPoint = function(point) {
    var index = this.getPathIndexForPosition(point);
    var part = this.getPathPart(index);
    if(part.value.getNearestPoint) {
        return part.value.getNearestPoint(part.start, point);
    };
};

PathData.prototype.getPathIndexForPosition = function(point) {

    if(this.length() === 2) {
        //If there is just the start and end docking we know the new index
        return 1;
    }

    var dockingIndex = 1;
    var candidate = [1,Number.POSITIVE_INFINITY ];

    object.each(this.getPathParts(), function(index, part) {
        //Sort out pathparts which are not within the boundary of start/end points with a little tolerance of 10px
        var p = new util.math.Point(point);
        if(p.isWithinXInterval(part.start, part.end, 10)) {
            var d;
            var line = new math.Line(part.start, part.end);

            if(!line.isVertical()) {
                d = Math.abs(line.calcFX(point.x).y - point.y)
            } else if(p.isWithinYInterval(part.start, part.end)) {
                //Since the point is within x (with tolerance) and y interval we calculate the x distance
                d = Math.abs(part.start.x - p.x);
            }

            if (candidate === undefined || candidate[1] > d) {
                //The pathPartindex is the arrayindex + 1 since we use the end index of the path as identity
                candidate[0] = index + 1;
                candidate[1] = d;
            }
        }
    });

    if (candidate) {
        return candidate[0];
    }
};

/*
 LinePathManager.prototype.getGradien = function(x,y) {
 var position = util.math.getPoint(x,y);
 var index = this.transition.getKnobIndexForPoint(position);
 var p1 = this.data.getDockingByIndex(index).position();
 var p2 = this.data.getDockingByIndex(index + 1).position();
 return util.math.Line.calcGradient(p1, p2);
 };

 LinePathManager.prototype.getGradientByIndex = function(index) {
 var p1 = this.data.getDockingByIndex(index).position();
 var p2 = this.data.getDockingByIndex(index + 1).position();
 return util.math.Line.calcGradient(p1, p2);
 };


 LinePathManager.prototype.getVectorByIndex = function(index, fromEnd) {
 var p1, p2;
 if(fromEnd) {
 p1 = this.data.getDockingByEndIndex(index + 1).position();
 p2 = this.data.getDockingByEndIndex(index).position();
 } else {
 p1 = this.data.getDockingByIndex(index).position();
 p2 = this.data.getDockingByIndex(index + 1).position();
 }
 return util.math.Line.calcNormalizedLineVector(p1, p2);
 };
 */

PathData.prototype.getY = function(value) {
    return this.getCorners()[0].y;
};

PathData.prototype.getRightX = function(value) {
    return this.getCorners()[1].x;
};

PathData.prototype.getBottomY = function(value) {
    return this.getCorners()[2].y;
};

PathData.prototype.setData = function(value) {
    if(object.isArray(value)) {
        this.data = value;
    }
};

PathData.prototype.clear = function() {
    this.data.clear();
    return this;
};

PathData.prototype.length = function() {
    return this.data.length();
};

PathData.prototype.value = function(index) {
    return this.data.value(index);
};

PathData.prototype.lastIndexOfType = function(type) {
    var i;
    for(i = this.length() - 1; i >= 0; i--) {
        var value = this.value(i);
        if(value.is(type)) {
            return i;
        }
    }
    return -1;
};

PathData.prototype.valuesByType = function(type) {
    var result = [];

    object.each(this.data.vectors, function(i, value) {
       if(value.is(type)) {
           result.push({index:i, value:value});
       }
    });

    return result;
};

PathData.prototype.start = function(p, absolute) {
    if(arguments.length === 0) {
        return this.value(0).to();
    } else if(this.length() > 0) {
        this.value(0).to(p);
    } else {
        this.data.setValue(0, new MoveTo(p, absolute));
    }
    return this;
};

PathData.prototype.end = function(value) {
    if(value) {
        return this.data.last().to(value);
    } else {
        return this.data.last().to();
    }
};

/**
 * TODO: refactor to setTo
 * @param index
 * @param value
 * @returns {PathData}
 */
PathData.prototype.setTo = function(index, value) {
    this.data.value(index).to(value);
    return this;
};

PathData.prototype.removePath = function(index) {
    this.data.remove(index);
    return this;
};

PathData.prototype.complete = function() {
    this.data.add(new Complete());
    return this;
};

PathData.prototype.line = function(x,y) {
    var p = math.getPoint(x,y);
    this.data.add(new LineTo(p, true));
    return this;
};

PathData.prototype.cBezier = function(c1, c2, to) {
    this.data.add(new CBezier(c1,c2, to, true));
    return this;
};

/**
 * TODO: Line to
 * @param index
 * @param value
 * @param absolute
 * @returns {PathData}
 */
PathData.prototype.insertLine = function(index, to, absolute) {
    this.data.insert(index, new LineTo(to,absolute));
    return this;
};

PathData.prototype.qBezier = function(controlP,toP) {
    this.data.add(new QBezier(controlP,toP, true));
    return this;
};

PathData.prototype.insertQBezier = function(index,c, to, absolute) {
    this.data.insert(index, new QBezier(c, to, absolute));
    return this;
};

PathData.prototype.insertCBezier = function(index, c1, c2, to, absolute) {
    this.data.insert(index, new CBezier(c1,c2, to,absolute));
    return this;
};

PathData.prototype.toString = function() {
    var result = '';
    var that = this;
    this.data.each(function(index, pathPart) {
       result += pathPart.toString();
    });
    return result.trim();
};

module.exports = PathData;
},{"../util/math":76,"../util/object":77,"../util/util":79}],51:[function(require,module,exports){
var DomElement = require('../dom/domElement');
var Style = require('./style');
var util = require('../util/util');
var dom = util.dom;
var object = util.object;

/*
 * Constructor for SVG Elements
 *
 * @param {type} name the element Name e.g. rect, circle, path...
 * @param {type} cfg attributes and additional configurations
 * @param {type} attributeSetter you can add additional attribute setter
 * for special attributes default attribute setter given by this impelementation
 * are transform and style setter
 */
var SVGElement = function(name, svg, cfg, attributeSetter) {
    this.attributeSetter = attributeSetter || {};
    this.attributeSetter.style = this.styleAttributeSetter;
    this.SVGElement = true;

    // If first attribute is not a string we assume a svg node constructor call.
    if(!object.isString(name)) {
        this.instance(name);
        cfg = dom.getAttributes(name);
        name = name.tagName;
    }

    this.svg = svg;
    this.root = svg.root || this;
    DomElement.call(this, name, cfg, this.attributeSetter);
};

util.inherits(SVGElement, DomElement);

SVGElement.prototype.styleAttributeSetter = function(trnasformationString) {
    return new Style(trnasformationString);
};

SVGElement.prototype.getRootNode = function() {
    return this.root.instance();
};

SVGElement.prototype.getSVGRoot = function() {
    return this.root;
};

SVGElement.prototype.append = function(element) {
    var result;
    if(arguments.length > 1) {
        result = [];
        var that = this;
        object.each(arguments, function(index, val) {
            result.push(that.append(val));
        })
    } else if(arguments.length === 1) {
        result =  util.dom.appendSVGElement(this.instance(), element);
    }
    return result;
};

SVGElement.prototype.prepend = function(element) {
    var result;
    if(arguments.length > 1) {
        result = [];
        var that = this;
        object.each(arguments, function(index, val) {
            result.push(that.prepend(val));
        })
    } else if(arguments.length === 1) {
        result =  util.dom.prependSVGElement(this.instance(), arguments[0]);
    }
    return result;
};

SVGElement.prototype.remove = function() {
    this.$().remove();
};

SVGElement.prototype.find = function(selector) {
    var result = this.svg.get(this.$().find(selector));
    return util.object.isArray(result) ? result : [result];
};

SVGElement.prototype.firstChild = function(selector) {
    return $.svg(this.$().children(selector).first());
};

SVGElement.prototype.children = function(selector) {
    return $.svg(this.$().children(selector));
};

SVGElement.prototype.parent = function() {
    return $.svg(this.$().parent());
};

SVGElement.prototype.moveDown = function(selector) {
    var $node = this.$();
    $node.prevAll(selector).first().before($node);
};

SVGElement.prototype.moveUp = function(selector) {
    var $node = this.$();
    $node.nextAll(selector).first().after($node);
};

SVGElement.prototype.back = function() {
    dom.prependToRoot(this);
    return this;
};

/**
 * SVG Styles
 */

SVGElement.prototype.style = function(key, value) {
    if(!object.isDefined(value) && object.isString(key) && key.indexOf(':') <= 0
        && object.isDefined(this.attributes.style)) {
        //GETTER CALL
        return this.attributes.style.get(key);
    } else if(!object.isDefined(this.attributes.style) && object.isDefined(value)) {
        this.attributes.style = new Style(key, value);
    } else if(object.isDefined(value)) {
        this.attributes.style.set(key, value);
    } else {
        return;
    }
    this.updateAttribute('style');
    return this;
};

SVGElement.prototype.dala = function(key, value) {
    return this.attr('dala:'+key, value);
};

SVGElement.prototype.getBBox = function() {
    return this.instance().getBBox();
};

SVGElement.prototype.getBoundingClientRect = function() {
    return this.instance().getBoundingClientRect();
};

SVGElement.prototype.toString = function() {
    return util.xml.serializeToString(this.instance());
};

SVGElement.prototype.clone = function() {
    return this.$().clone();
};

module.exports = SVGElement;

},{"../dom/domElement":48,"../util/util":79,"./style":62}],52:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGEllipse = require('./ellipse');
var SVGShape = require('./svgShape');

var SVGCircle = function(svgRoot, cfg) {
    cfg = cfg || {};
    SVGShape.call(this, 'circle', svgRoot, cfg);
};

util.inherits(SVGCircle, SVGEllipse);

SVGCircle.prototype.r = function(value, noScale) {
    var scale = (noScale) ? 1 : this.scale()[1];
    if((!object.isDefined(value) || object.isBoolean(value) && !value)) {
        return this.attrNumber('r') * scale;
    } else if(object.isBoolean(value)) {
        return (this.attrNumber('r') + (this.strokeWidth() / 2)) * scale;
    } else {
        this.attrNumber('r', value);
        return this;
    }
};

SVGCircle.prototype._setHeight = function(value) {
    var v = value / 2;
    this.cy(v).cx(v).r(v);
};

SVGCircle.prototype._setWidth = function(value) {
    return this.height(value);
};

SVGCircle.prototype.rx = function(value, noScale) {
    return this.r(value, noScale);
};

SVGCircle.prototype.ry = function(value, noScale) {
    return this.r(value, noScale);
};

SVGCircle.prototype.overlayCheck = function(position) {
    return new util.math.Circle(this.getCenter(), this.r()).overlays(position);
};

module.exports = SVGCircle;
},{"../util/object":77,"../util/util":79,"./ellipse":56,"./svgShape":66}],53:[function(require,module,exports){
var DragConfig = function() {
    this.hooks = {};
};

DragConfig.prototype.xOnly = function() {
    this.hooks.restrictionY = function(event, dx, dy) {
        return 0;
    };
    return this;
};

DragConfig.prototype.yOnly = function() {
    this.hooks.restrictionX = function(event, dx, dy) {
        return 0;
    };
    return this;
};

DragConfig.prototype.getScale = function(gsHook) {
    this.hooks.getScale = gsHook;
    return this;
};

DragConfig.prototype.dragMove = function(drmHook) {
    this.hooks.dragMove = drmHook;
    return this;
};

DragConfig.prototype.dragStart = function(drsHook) {
    this.hooks.dragStart = drsHook;
    return this;
};

DragConfig.prototype.dragEnd = function(dreHook) {
    this.hooks.dragEnd = dreHook;
    return this;
};

DragConfig.prototype.restrictionX = function() {
    return this.hooks.restrictionX;
};

DragConfig.prototype.restrictionY = function() {
    return this.hooks.restrictionY;
};

DragConfig.prototype.get = function() {
    return this.hooks;
};

module.exports = DragConfig;
},{}],54:[function(require,module,exports){
var SVGShape = require('./svgShape');
var util = require('../util/util');
var event = require('../core/event');
var config = require('../core/config');

var object = util.object;
var dom = util.dom;

var ShiftDrag = function(cfg) {
    this.cfg = cfg;
    if(!cfg.restrictionX && !cfg.restrictionY) {
        this.init();
    } else {
        this.disable();
    }
};

ShiftDrag.prototype.init = function() {
    this.state = 'init';
    this.xShift = {
        shiftAlign : 0,
        unshiftAlign : 0
    };

    this.yShift = {
        shiftAlign : 0,
        unshiftAlign : 0
    };
};

ShiftDrag.prototype.disable = function() {
    this.state = 'disabled';
};

ShiftDrag.prototype.update = function(evt, dx ,dy) {
    var that = this;
    switch(this.state) {
        case 'init' :
            this.xShift.shiftAlign += dx;
            this.yShift.shiftAlign += dy;

            if(this.checkShiftHook(evt)) {
                if(Math.abs(this.xShift.shiftAlign) > Math.abs(this.yShift.shiftAlign)) {
                    this.restrictionX = undefined;
                    this.restrictionY = function(evt, dx ,dy) {
                        return that.shiftRestriction(that.yShift, dy);
                    };
                    this.state = 'shiftedX';
                } else {
                    this.restrictionY = undefined;
                    this.restrictionX = function(evt, dx , dy) {
                        return that.shiftRestriction(that.xShift, dx);
                    };
                    this.state = 'shiftedY';
                }
            }
            break;
        case 'shiftedX':
            if(!evt.shiftKey) {
                this.restrictionY = function(evt, dx, dy) {
                    return that.unShiftRestriction(that.yShift, dy);
                };
                this.state = 'init';
            }
            break;
        case 'shiftedY':
            if(!evt.shiftKey) {
                this.restrictionX = function(evt, dx ,dy) {
                    return that.unShiftRestriction(that.xShift, dx);
                };
                this.state = 'init';
            }
            break;
    }
};


ShiftDrag.prototype.shiftRestriction = function(shiftData, d) {
    //Update shifted d
    shiftData.unshiftAlign += d;
    //Align shift drag back to the start position
    var result = (Math.abs(shiftData.shiftAlign) > 0) ? shiftData.shiftAlign * -1 : 0;
    shiftData.shiftAlign = 0;
    return result;
};

ShiftDrag.prototype.unShiftRestriction = function(shiftData, d) {
    //Align shift drag back to the start position
    var result = shiftData.unshiftAlign + d;
    shiftData.unshiftAlign = 0;
    return result;
};

ShiftDrag.prototype.checkShiftHook = function(evt) {
    return evt.shiftKey && (Math.abs(this.xShift.shiftAlign) > 4 || Math.abs(this.yShift.shiftAlign) > 4);
};

//TODO: this would be more elegant to use the alignment align center to center.x if checkShiftHook

ShiftDrag.prototype.getRestrictionX = function() {
    return this.cfg.restrictionX || this.restrictionX;
};

ShiftDrag.prototype.getRestrictionY = function() {
    return this.cfg.restrictionY || this.restrictionY;
};

SVGShape.prototype.draggable = function(cfg, dragElement) {
    var cfg = cfg || {};

    if(dragElement) {
        dragElement = this.svg.get(dragElement);
    } else {
        dragElement = this;
    }

    var that = this;

    var dragMove = function(evt) {
        if(evt.preventDefault) {
            evt.preventDefault();
        }

        if(!evt.triggerEvent) {
            //that.attr('pointer-events', 'none');
        }

        var actualdx = (object.isDefined(evt.dx)) ? evt.dx : evt.clientX - that.dragCurrentX;
        var actualdy = (object.isDefined(evt.dy)) ? evt.dy : evt.clientY - that.dragCurrentY;

        // DRAG BEFORE HOOK
        if(cfg.dragBeforeMove) {
            cfg.dragBeforeMove.apply(that, [evt, actualdx, actualdy]);
        }

        // DRAG ALIGNMENT
        if(cfg.dragAlignment && !evt.triggerEvent) {
            var alignment = cfg.dragAlignment.check(actualdx, actualdy);
            actualdx = alignment.dx;
            actualdy = alignment.dy;
        }

        //Check for shiftDrag restriction, shiftDrag will only hook up if no other restriction is set.
        //Shiftdrag is not given for triggerdrags
        if(that.shiftDrag && !evt.triggerEvent) {
            that.shiftDrag.update(evt, actualdx, actualdy);
            var restrictionX = that.shiftDrag.getRestrictionX();
            var restrictionY = that.shiftDrag.getRestrictionY();
        }

        // DRAG RESTRICTION
        var dx = (restrictionX && !evt.triggerEvent) ? restrictionX.apply(that, [evt, actualdx, actualdy]) : actualdx;
        var dy = (restrictionY && !evt.triggerEvent) ? restrictionY.apply(that, [evt, actualdx, actualdy]) : actualdy;

        //TODO: somehow the scale should be determined in a more elegant way perhaps store it in svg instance...
        if(cfg.getScale && !evt.triggerEvent) {
            var scale = cfg.getScale();
            dx /= scale;
            dy /= scale;
        }

        // EXECUTE DRAG
        if(dx !== 0 || dy !== 0) {
            that.move(dx, dy);
        }

        var evtData = getMouseEventData(evt);
        // Keep track of current mouse position
        that.dragCurrentX = evtData.clientX;
        that.dragCurrentY = evtData.clientY;

        that.dxSum += dx;
        that.dySum += dy;

        // DRAG MOVE HOOK
        if(cfg.dragMove) {
            cfg.dragMove.apply(that, [evt, dx, dy]);
        }
    };

    var dragEnd = function(evt) {
        evt.preventDefault();
        //Turn off drag events
        that.getSVGRoot().off('mousemove');
        event.off(document, 'mouseup', dragEnd);

        if(cfg.dragAlignment) {
            cfg.dragAlignment.reset();
        }

        this.drag = false;

        if(cfg.cursor) {
            $('body').css('cursor','default');
        }

        // DRAG END HOOK
        if(cfg.dragEnd) {
            cfg.dragEnd.apply(that, [evt]);
        }

        //that.attr('pointer-events', 'all');
    };

    if(dragElement) {
        var mouseDownHandler = function(e) {
            if(e.ctrlKey || !that.isVisible()) {
                return;
            }

            e.preventDefault();
            // We stop the event propagation to prevent the document mousedown handler to fire
            e.stopPropagation();

            initDragValues(that, e, cfg);

            // DRAG START HOOK
            if(cfg.dragStart) {
                cfg.dragStart.apply(that, [e]);
            }

            if(cfg.cursor) {
                $('body').css('cursor', cfg.cursor);
            }

            that.drag = true;
            event.on(that.getRootNode(), 'mousemove', dragMove);
            event.on(document, 'mouseup', dragEnd);

        };

        if(cfg.once) {
            dragElement.on('mousedown', mouseDownHandler);
        } else {
            dragElement.on('mousedown', mouseDownHandler);
        }
    }

    //Simulates an drag start event
    this.initDrag = function() {
        dragElement.trigger('mousedown');
    };

    //For manual dragging a svg element the triggerEvent is used to identify this event was triggered manually
    //See Selectionmanager setNodeSelection dragMove handler
    this.triggerDrag = function(dx, dy) {
        dragMove.apply(this,[{dx:dx, dy:dy, triggerEvent:true}]);
    };

    return this;
};

var initDragValues = function(that, evt, cfg) {
    that.dxSum = 0;
    that.dySum = 0;
    that.shiftDrag = new ShiftDrag(cfg);
    var evtData = getMouseEventData(evt);
    that.dragCurrentX = evtData.clientX;
    that.dragCurrentY = evtData.clientY;

    that.drag = true;
};

var getMouseEventData = function(evt) {
    if(!evt.clientX) {
        return event.mouse();
    }
    return evt;
};
},{"../core/config":6,"../core/event":7,"../util/util":79,"./svgShape":66}],55:[function(require,module,exports){
var shapes = {}
shapes.svg = shapes.Svg = require('./svgRoot');
shapes.circle = shapes.Circle = require('./circle');
shapes.ellipse = shapes.Ellipse = require('./ellipse');
shapes.text = shapes.Text = require('./text');
shapes.tspan = shapes.TSpan = require('./tspan');
shapes.path = shapes.Path = require('./path');
shapes.rect = shapes.Rect = require('./rect');
shapes.g = shapes.Group = require('./group');
module.exports = shapes;
},{"./circle":52,"./ellipse":56,"./group":57,"./path":59,"./rect":61,"./svgRoot":65,"./text":67,"./tspan":69}],56:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./svgShape');

var SVGEllipse = function(svgRoot, cfg) {
    cfg = cfg || {};
    SVGShape.call(this, 'ellipse', svgRoot, cfg);
};

util.inherits(SVGEllipse, SVGShape);

SVGEllipse.prototype.x = function() {
    return this._getX();
};

SVGEllipse.prototype.y = function() {
    return this._getY();
};

SVGEllipse.prototype._getHeight = function() {
    return this.ry(false, true) * 2;
};

SVGEllipse.prototype._setHeight = function(value) {
    //When setting the height of an ellipse we move the center to not change the x/y
    var v = value / 2;
    this.cy(v).ry(v);
};

SVGEllipse.prototype._getWidth = function(value) {
    return this.rx(false, true) * 2;
};

SVGEllipse.prototype._setWidth = function(value) {
    //When setting the height of an ellipse we move the center to not change the x/y
    var v = value / 2;
    this.cx(v).rx(v);
};

SVGEllipse.prototype._getX = function() {
    return this.cx() - this.rx();
};

SVGEllipse.prototype._getY = function() {
    return this.cy() - this.ry();
};

SVGEllipse.prototype.getCenter = function() {
    return {
        x : this.cx(),
        y : this.cy()
    };
};

SVGEllipse.prototype.bottomY = function() {
    return this.cy() + this.ry();
};

SVGEllipse.prototype.cx = function(value) {
    if(!value) {
        return this.translatedX(this.attrNumber('cx'));
    } else {
        this.attr('cx', value);
        return this;
    }
};

SVGEllipse.prototype.cy = function(value) {
    if(!value) {
        return this.translatedY(this.attrNumber('cy'));
    } else {
        this.attr('cy', value);
        return this;
    }
};

SVGEllipse.prototype.rx = function(value, noScale) {
    var scale = (noScale) ? 1 : this.scale()[0];
    if((!object.isDefined(value) || object.isBoolean(value) && !value)) {
        return this.attrNumber('rx') * scale;
    } else if(object.isBoolean(value)) {
        return (this.attrNumber('rx') + (this.strokeWidth() / 2)) * scale;
    } else {
        this.attrNumber('rx', value);
        return this;
    }
};

SVGEllipse.prototype.ry = function(value, noScale) {
    var scale = (noScale) ? 1 : this.scale()[1];
    if((!object.isDefined(value) || object.isBoolean(value) && !value)) {
        return this.attrNumber('ry') * scale;
    } else if(object.isBoolean(value)) {
        return (this.attrNumber('ry') + (this.strokeWidth() / 2)) * scale;
    } else {
        this.attrNumber('ry', value);
        return this;
    }
};

SVGEllipse.prototype.overlayCheck = function(position) {
    return new util.math.Ellipse(this.getCenter(), this.rx(), this.ry()).overlays(position);
};

module.exports = SVGEllipse;
},{"../util/object":77,"../util/util":79,"./svgShape":66}],57:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./svgShape');

var SVGGroup = function(svgRoot, cfg) {
    cfg = cfg || {};
    SVGShape.call(this, 'g', svgRoot, cfg);
};

util.inherits(SVGGroup, SVGShape);

module.exports = SVGGroup;
},{"../util/object":77,"../util/util":79,"./svgShape":66}],58:[function(require,module,exports){
var Helper = function(svg) {
    this.svg = svg;
    this.points = {};
};

Helper.prototype.point = function(id, p, color, prevText) {
    color = color || 'red';
    var text = id+'(x:'+p.x + ' y:'+p.y+')';
    if(!this.points[id]) {
        var point = this.svg.circle({
            r:2,
            style:'fill:'+color
        });
        var t = this.svg.text(text).fill(color);
        var group = this.svg.g({id:'helper_'+id}, t, point);
        this.points[id] = {
            group : group,
            text : t,
            point : point
        }

        if(prevText) {
            t.hide();
        }
    }

    this.points[id].point.moveTo(p);
    this.points[id].text.$().text(text);
    this.points[id].text.moveTo(p);
};

module.exports = Helper;

},{}],59:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./svgShape');
var PathData = require('./pathData');

var SVGPath = function(svgRoot, cfg) {
    cfg = cfg || {};
    this.attributeSetter = { d : SVGPath.pathDataAttributeSetter};
    SVGShape.call(this, 'path', svgRoot, cfg, this.attributeSetter);
};

util.inherits(SVGPath, SVGShape);

SVGPath.pathDataAttributeSetter = function(pathDataString) {
    return new PathData(pathDataString);
};

SVGPath.prototype.x = function() {
    return this.d().getX();
};

SVGPath.prototype.y = function() {
    return this.d().getY();
};

SVGPath.prototype.d = function(pathData) {
    if(object.isString(pathData)) {
        this.attributes.d = new PathData(pathData);
        this.updateAttribute('d');
        return this;
    } else if(object.isDefined(pathData)) {
        this.attributes.d = pathData
        this.updateAttribute('d');
        return this;
    } else if(!object.isDefined(this.attributes.d)) {
        this.attributes.d = new PathData();
    }
    return this.attributes.d;
};

module.exports = SVGPath;
},{"../util/object":77,"../util/util":79,"./pathData":60,"./svgShape":66}],60:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"../util/math":76,"../util/object":77,"../util/util":79,"dup":50}],61:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./svgShape');

var SVGRect = function(svgRoot, cfg) {
    cfg = cfg || {};
    SVGShape.call(this, 'rect', svgRoot, cfg);
};

util.inherits(SVGRect, SVGShape);

SVGRect.prototype._getY = function() {
    return this.attrNumber('y') || 0;
};

SVGRect.prototype._getX = function() {
    return this.attrNumber('x') || 0;
};

SVGRect.prototype._getHeight = function(value) {
    return this.attrNumber('height');
};

SVGRect.prototype._setHeight = function(value) {
    this.attr('height',value);
};

SVGRect.prototype._getWidth = function(value) {
    return this.attrNumber('width');
};

SVGRect.prototype._setWidth = function(value) {
    this.attr('width',value);
};

SVGRect.prototype.overlayCheck = function(position) {
    return position.x >= this.x() && position.x <= this.getRightX()
        && position.y >= this.y() && position.y <= this.getBottomY();
};

module.exports = SVGRect;
},{"../util/object":77,"../util/util":79,"./svgShape":66}],62:[function(require,module,exports){
var object = require('../util/object');
var string = require('../util/string');

var REGEXP_PROPERTY_SUFFIX = ':[a-zA-Z0-9#,\.]*(;|$)';

var Style = function(key, value) {
    if(object.isString(key) && !object.isDefined(value)) {
        this.value = key;
    } else {
        this.set(key,value);
    }
};

Style.prototype.set = function(key, value) {
    if(object.isObject(key)) {
        object.each(key, function(objKey, val) {
            if(key.hasOwnProperty(objKey)) {
                this.set(objKey,val);
            }
        });
    } else if(object.isString(key) && object.isDefined(value)) {
        if(!object.isDefined(this.value)) {
            this.value = "";
        }

        if(this.value.indexOf(key+':') >= 0) {
            var regExp = new RegExp(key+REGEXP_PROPERTY_SUFFIX, 'gi');
            this.value = this.value.replace(regExp, this.createValueString(key,value));
        } else {
            this.value += (!string.endsWith(this.value,';') && this.value.length > 0) ? ';' + this.createValueString(key,value) : this.createValueString(key,value);
        }
    } else if(object.isString(key)) {
        this.value = key;
    }
};

Style.prototype.get = function(key) {
    var regExp = new RegExp(key+REGEXP_PROPERTY_SUFFIX, 'gi');
    var result = this.value.match(regExp);
    if(object.isArray(result)) {
        var value = result[0];
        var splitted = value.split(':');
        if(splitted.length > 1) {
            var result = splitted[1];
            return (string.endsWith(result, ';'))? result.substring(0,result.length -1) : result;
        }
    }
};

Style.prototype.createValueString = function(key, value) {
    return key+':'+value+';';
};

Style.prototype.toString = function() {
    return this.value;
};

module.exports = Style;

},{"../util/object":77,"../util/string":78}],63:[function(require,module,exports){
/**
 * This module contains functionality for creating and accessing SVG elements.
 * All SVG elements created with this module can be accessed by ID through the instance object.
 *
 * An SVG element created with this module can be seperated into multiple parts which can be managed speratly.
 * The 'root' part will be created by default. When creating a new svg part you can set it as default part, so all actions
 * like insertions will be executed on the default part if there is no other part as argument.
 */
var SVGGenericShape = require('./svgShape');
require('./draggable');
var shapes = require('./elements');
var util = require('../util/Util');

var dom = util.dom;
var object = util.object;
var Helper = require('./helper');

var NAMESPACE_SVG = 'http://www.w3.org/2000/svg';
var NAMESPACE_XLINK = 'http://www.w3.org/1999/xlink';

var instances = {};

/**
 * The constructor initializes a new SVG element within the given containerId.
 * The constructor accepts the containerId either as selector '#containerId' or as id string 'containerId'.
 *
 * The id of the nw SVG element will be the containerId with the suffix '_svg' -> 'containerId_svg'.
 *
 * Attributes of the new SVG elemnt can be set through the constructor argument 'cfg'.
 *
 * The SVG can be seperated in multiple parts so you can easily append elements to the different part.
 * The constructor creates a 'root' part as default.
 *
 * @param containerId
 * @param cfg
 * @constructor
 */
var SVG = function(containerId, cfg) {
    if(!(this instanceof SVG)) {
        return SVG.get(containerId);
    }

    cfg = cfg || {};

    //Get id from selector if its an selector
    this.containerId = dom.getRawId(containerId);
    this.$container = $.qCache('#'+this.containerId).get(0);

    if(!this.$container) {
        console.error('Attempt to initiate svg stage for invalid containerId: '+this.containerId);
        return;
    }

    this.svgId = this.containerId+'_svg';

    // Create SVG root element with given settings.
    this.root = new shapes.Svg(this, {id : this.svgId});

    cfg.height = cfg.height || '100%';
    cfg.width = cfg.width  || '100%';

    // Set cfg values as svg root attributes
    this.root.attr(cfg);

    // Append the svg root element to the containernode
    dom.appendSVGElement(this.$container, this.root);

    // The root part is the svg element itself
    this.svgParts = {'root':this.root};
    this.defaultPart = this.root;

    instances[this.svgId] = this;
};

/**
 * Returns the svg root domNode.
 * @returns {*} svg root domNode
 */
SVG.prototype.getRootNode = function() {
    return (this.root) ? this.root.instance() : undefined;
};

/**
 * Returns a cached jQuery object of the root node.
 * @returns {*}
 */
SVG.prototype.$ = function() {
    return $.qCache('#'+this.svgId);
};

/**
 * This is used for importing diagrams into the svg instance.
 * @param element
 */
SVG.prototype.setRoot = function(element) {
    var newId = $(element).attr('id');
    this.root.instance(element);
    this.root.attr({id : newId});
    instances[newId] = this;
};

/**
 * Returns the root element as SVGElement
 * @returns {SVGElement|exports|module.exports|*}
 */
SVG.prototype.getRoot = function() {
    return this.root;
};

/**
 * Returns the current defaultPart
 * @returns {SVGElement|exports|module.exports|*} current defaultPart
 */
SVG.prototype.getDefaultPart = function() {
    return this.defaultPart;
};

/**
 * Creates and returns a new svg part which is represented by a new group within the root.
 * The part id is composite of the svg root id and the partId.
 * By setting the isDefault argument as true the new part will be set as default part.
 * @param partId
 * @param isDefault
 * @returns {*}
 */
SVG.prototype.createPart = function(partId, isDefault) {
    //New parts are always added to the root part
    this.svgParts[partId] = this.g({id: this.svgId+'_'+partId, parentPart: 'root'});
    if(isDefault) {
        this.defaultPart = this.svgParts[partId];
    }
    return this.svgParts[partId];
};

SVG.prototype.part = function(id) {
    return this.svgParts[id];
};

/**
 * Adds an svg element to the given part.
 *
 * @param part
 * @param element
 */
SVG.prototype.addToPart = function(part, element) {
    this.addToGroup(this.svgParts[part], element);
};

/**
 * This function can be used to append or prepend elements with text to the svg root.
 *
 * @param element
 * @param prepend
 * @param text
 * @returns {*}
 */
SVG.prototype.addToRoot = function(element, prepend, text) {
    if(prepend) {
        return dom.prependSVGElement(this.getRoot(), element, text);
    } else {
        return dom.appendSVGElement(this.getRoot(), element, text);
    }
};

/**
 * This function can be used to append/prepend elements with text to a given (or default) svg part.
 *
 * @param element
 * @param part
 * @param prepend
 * @param text
 * @returns {*}
 */
SVG.prototype.add = function(element, part, prepend, text) {
    part = part || this.getDefaultPart();
    element.parent = part;
    if(prepend) {
        return dom.prependSVGElement(part, element, text);
    } else {
        return dom.appendSVGElement(part, element, text);
    }
};

/**
 * Imports an xml document to the given svg part.
 * @param elementXML
 * @param part
 * @returns {*}
 */
SVG.prototype.import = function(svgStr, part, prepend) {
    part = this.svgParts[part] || this.getDefaultPart();
    return SVG.get(dom.importSVG(part, svgStr, prepend));
};

/**
 * Adds and returns a newly created svg Rect with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.rect = function(cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Rect(this, cfg), part);
};

SVG.prototype.helper = function(cfg, part) {
    if(!this._helper) {
        this._helper = new Helper(this);
    }
    return this._helper;
};

/**
 * Adds and returns a newly created svg Text with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.text = function(text, cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Text(this, cfg), part, false).content(text);
};

SVG.prototype.tspan = function(text, cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.TSpan(this, cfg), part, false).content(text);
};

/**
 * Adds and returns a newly created svg Circle with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.circle = function(cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Circle(this, cfg), part);
};

/**
 * Adds and returns a newly created svg Circle with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.ellipse = function(cfg, part) {
    part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Ellipse(this, cfg), part);
};

/**
 * Adds and returns a newly created svg Group with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.g = function(cfg) {
    var cfg = cfg ||{};

    var parentPart = this.svgParts[cfg.parentPart] || this.getDefaultPart();

    delete cfg.part;

    var group = this.add(new shapes.Group(this, cfg), parentPart);

    if(arguments.length > 1) {
        for(var i = 1;i < arguments.length; i++) {
            console.log('addToGroup: '+group.attr('id')+' - '+ arguments[i].attr('id'));
            dom.appendSVGElement(group.instance(), arguments[i]);
        }
    }
    return group;
};

/**
 * Adds ands an svg element ot the given group.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.addToGroup = function(group, element) {
    var result;
    if(object.isArray(element)) {
        result = [];
        object.each(element, function(index, val) {
            result.push(dom.appendSVGElement(group.instance(), element));
        })
    } else {
        return dom.appendSVGElement(group.instance(), element);
    }
};

/**
 * Adds and returns a newly created svg Path with the given settings to the given (or default) part.
 * @param cfg
 * @param part
 * @returns {*}
 */
SVG.prototype.path = function(cfg, part) {
    var part = this.svgParts[part] || this.getDefaultPart();
    return this.add(new shapes.Path(this, cfg), part);
};

SVG.prototype.empty = function() {
    $(this.root.instance()).empty();
};

SVG.prototype.asString = function() {
    return this.root.toString();
};

SVG.prototype.clone = function() {
    return this.root.clone();
}

/**
 * This function creates an SVGElement out of the given id selector element.
 * @param selector
 * @returns {SVGElement|exports|module.exports}
 */
SVG.get = function(selector) {
    if(selector.SVGElement) {
        return selector;
    }
    //TODO:
    if(object.isString(selector)) {
        $node = $(dom.getIdSelector(selector));
    } else {
        $node = $(selector);
    }

    if(!$node.length) {
        console.warn('call SVG.get on a non existing node: '+selector);
        return [];
    } else if($node.length > 1) {
        //Return list of SVGElements
        var result = [];
        $node.each(function(index, value) {
            result.push(SVG.get(this));
        });
        return result;
    } else {
        //Return single SVgElement
        var $svgRootNode = $($node.get(0).ownerSVGElement);
        if($svgRootNode.length) {
            var svgInstance = instances[$svgRootNode.attr('id')];
            var result = SVG._svgInstance($node, svgInstance);
            //This enables $.each for single results.
            result[0] = result;
            result.length = 1;
            result.splice = function() {};
            return result;
        } else {
            console.warn('Call SVG.get on node with no svg root');
        }
    }
};

SVG._svgInstance = function($node, svg) {
    var SVGShape = SVG.getShapeByName($node.get(0).nodeName);
    return (SVGShape) ? new SVGShape(svg).instance($node.get(0)) : new SVGGenericShape($node.get(0), svg);
};

SVG.getShapeByName = function(type) {
    var result = shapes[type.toLowerCase()];
    return result;
};

SVG.prototype.get = SVG.get;

module.exports = SVG;

},{"../util/Util":73,"./draggable":54,"./elements":55,"./helper":58,"./svgShape":66}],64:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"../dom/domElement":48,"../util/util":79,"./style":62,"dup":51}],65:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGElement = require('./svgElement');

var NAMESPACE_SVG = 'http://www.w3.org/2000/svg';
var NAMESPACE_XLINK = 'http://www.w3.org/1999/xlink';
var SVG_VERSION = '1.1';

var SVGRoot = function(svg, cfg) {
    cfg = cfg || {};
    cfg['xmlns'] = NAMESPACE_SVG;
    cfg['xmlns:xlink'] = NAMESPACE_XLINK;
    cfg['version'] = SVG_VERSION;
    SVGElement.call(this, 'svg', svg, cfg);
};

util.inherits(SVGRoot, SVGElement);

SVGRoot.prototype.x = function(value) {
    return (value) ? this.attrNumber('x', value) : this.attrNumber('x') || 0 ;
};

SVGRoot.prototype.y = function(value) {
    return (value) ? this.attrNumber('y', value) : this.attrNumber('y') || 0 ;
};

SVGRoot.prototype.getCenter = function() {
    return {
        x: this.x() + Math.floor(this.width() / 2),
        y: this.y() + Math.floor(this.height() / 2)
    };
};

SVGRoot.prototype.height = function(value) {
    if(!value) {
        return this.$().height();
    } else {
        this.attr('height', value);
    }
};

SVGRoot.prototype.width = function(value) {
    if(!value) {
        return this.$().width();
    } else {
        this.attr('width', value);
    }
};

module.exports = SVGRoot;
},{"../util/object":77,"../util/util":79,"./svgElement":64}],66:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var Transform = require('./transform');

var SVGElement = require('./SVGElement');

var SVGShape = function(name, svgRoot, cfg, attributeSetter) {
    cfg = cfg || {};
    this.attributeSetter = attributeSetter || {};
    this.attributeSetter.transform = this.transformationAttributeSetter;
    SVGElement.call(this, name, svgRoot, cfg, attributeSetter);
};

util.inherits(SVGShape, SVGElement);

SVGShape.prototype.transformationAttributeSetter = function(trnasformationString) {
    return new Transform(trnasformationString);
};

SVGShape.prototype.getTransformation = function() {
    if(!this.attributes.transform) {
        this.attributes.transform = new Transform();
    } else if(object.isString(this.attributes.transform)) {
        this.attributes.transform = new Transform(this.attributes.transform);
    }
    return this.attributes.transform;
};

SVGShape.prototype.transformedX = function(px) {
    return this.scaledX(this.translatedX(px));
};

SVGShape.prototype.transformedY = function(px) {
    return this.scaledY(this.translatedY(px));
};

SVGShape.prototype.scaledX = function(px) {
    return px * this.scale()[0]
};

SVGShape.prototype.scaledY = function(py) {
    return py * this.scale()[1]
};

SVGShape.prototype.rotate = function(val) {
    var result = this.getTransformation().rotate(val);

    if(result instanceof Transform) {
        // The scale setter returns the Transform itself object so we reset the scale
        // transform attribute in dom (setter was called)
        this.updateAttribute('transform');
        return this;
    } else {
        // The getter just returns the x,y values of the translate transformation
        return result;
    }
};

SVGShape.prototype.scale = function(sx, sy) {
    var result = this.getTransformation().scale(sx, sy);

    if(result instanceof Transform) {
        // The scale setter returns the Transform itself object so we reset the scale
        // transform attribute in dom (setter was called)
        this.updateAttribute('transform');
        return this;
    } else {
        // The getter just returns the x,y values of the translate transformation
        return result;
    }
};

SVGShape.prototype.translate = function(x, y) {
    var result = this.getTransformation().translate(x,y);

    if(result instanceof Transform) {
        // The trnaslate setter returns the Transform object so we reset the
        // transform attribute in dom (setter was called)
        this.updateAttribute('transform');
        return this;
    } else {
        // The getter just returns the x,y values of the translate transformation
        return result;
    }
};

SVGShape.prototype.translated = function(position) {
    var translate = this.getTransformation().translate();
    return {
        x : translate.x + position.x,
        y : translate.y + position.y
    }
};

SVGShape.prototype.translatedX = function(px) {
    var translate = this.getTransformation().translate();
    px = (object.isDefined(px)) ? px : 0;
    return translate.x + px;
};

SVGShape.prototype.translatedY = function(py) {
    var translate = this.getTransformation().translate();
    py = (object.isDefined(py)) ? py : 0;
    return translate.y + py;
};

SVGShape.prototype.hasTransformation = function(transformation) {
    if(object.isDefined(this.attributes.transform)) {
        return (object.isDefined(this.attributes.transform[transformation]));
    }
};

SVGShape.prototype.fill = function(color) {
    return this.style('fill', color);
};

SVGShape.prototype.fillOpacity = function(opacity) {
    return this.style('fill-opacity', opacity);
};

SVGShape.prototype.strokeOpacity = function(opacity) {
    return this.style('stroke-opacity', opacity);
};

SVGShape.prototype.stroke = function(color, width) {
    if(width) {
        this.strokeWidth(width);
    }
    return this.style('stroke', color);

};

SVGShape.prototype.strokeDasharray = function(type) {
    if(!type) {
        return this.style('stroke-dasharray');
    }
    if(object.isString(type)) {
        this.style('stroke-dasharray', type);
    } else {

    }
};

SVGShape.prototype.strokeDashType = function(type) {
    if(!type) {
        switch(this.strokeDasharray()) {
            case "5,5":
                return 1;
            case "10,10":
                return 2;
            case "20,10,5,5,5,10":
                return 3;
            default:
                return 0;
        }
    } else {
        switch(type) {
            case '1':
            case 1:
                this.strokeDasharray("5,5");
                break;
            case '2':
            case 2:
                this.strokeDasharray("10,10");
                break;
            case '3':
            case 3:
                this.strokeDasharray("20,10,5,5,5,10");
                break;
            default:
                this.strokeDasharray("none");
                break;
        }
    }
};

SVGShape.prototype.strokeWidth = function(width) {
    return util.app.parseNumberString(this.style('stroke-width', width)) || 0;
};

SVGShape.prototype.isVisible = function() {
    return (!this.fillOpacity() || this.fillOpacity() > 0)
        && (!this.strokeOpacity() || this.strokeOpacity() > 0);
};

SVGShape.prototype.hide = function() {
    this.fillOpacity(0);
    this.strokeOpacity(0);
};

SVGShape.prototype.show = function(opacity) {
    opacity = object.isDefined(opacity) ? opacity : 1;
    this.fillOpacity(opacity);
    this.strokeOpacity(opacity);
};

/**
 * Determines the location of a given position relative to the svg element.
 *      _t_
 *    |\   /|
 *  l |  c  | r
 *    |/___\|
 *       b
 * @param node
 * @param position
 * @returns {*}
 */
SVGShape.prototype.getRelativeLocation = function(position) {
    //First we check if the point lies direct on the boundary
    if(position.x === this.x()) {
        return 'left';
    } else if(position.y === this.y()) {
        return 'top';
    } else if(position.x === this.getRightX()) {
        return 'right';
    } else if(position.y === this.getBottomY()) {
        return 'bottom';
    }

    //If its not on the boundary we check the location by means of the line gradient
    var center = this.getCenter();
    var g = util.math.Line.calcGradient(center, position);
    if(position.y < center.y) { //position over elementcenter
        if (position.x >= center.x) { //position right (or eq) of elementcenter
            return (g > -1) ? 'right' : 'top';
        } else if (g < 1) {//position left and over of elementcenter
            return (g < 1) ? 'left' : 'top';
        }
    } else if(position.x >= center.x) { //position under (or eq) and right (or eq) of elementcenter
        return (g < 1) ? 'right' : 'bottom';
    } else { //position under and left of elementcenter
        return (g < -1) ? 'bottom' : 'left';
    }
};

SVGShape.prototype.x = function(withStroke) {
    return (withStroke) ? this.translatedX(this._getX()) - this.scaledX(this.strokeWidth()) / 2 : this.translatedX(this._getX());
};

SVGShape.prototype._getX = function() {
    return 0;
};

SVGShape.prototype.y = function(withStroke) {
    return (withStroke) ? this.translatedY(this._getY()) - this.scaledY(this.strokeWidth()) / 2 : this.translatedY(this._getY());
};

SVGShape.prototype._getY = function() {
    return 0;
};

SVGShape.prototype.position = function(withStroke) {
    var that = this;
    return {
        x : that.x(withStroke),
        y : that.y(withStroke)
    };
};

SVGShape.prototype.topLeft = function(withStroke) {
    return this.position(withStroke);
};

SVGShape.prototype.topRight = function(withStroke) {
    var that = this;
    return {
        x : that.getRightX(withStroke),
        y : that.y(withStroke)
    };
};

SVGShape.prototype.bottomRight = function(withStroke) {
    var that = this;
    return {
        x : that.getRightX(withStroke),
        y : that.getBottomY(withStroke)
    };
};

SVGShape.prototype.bottomLeft = function(withStroke) {
    var that = this;
    return {
        x : that.x(withStroke),
        y : that.getBottomY(withStroke)
    };
};

SVGShape.prototype.getCenter = function() {
    var c = {
        x: this.x() + Math.floor(this.width() / 2),
        y: this.y() + Math.floor(this.height() / 2)
    };
    return util.math.rotate(c, this.position(), this.rotate());
};

SVGShape.prototype.overlays = function() {
    var result = false;
    var that = this;
    object.each(arguments, function(index, position) {
        if(that.overlayCheck(position)) {
            result = true;
            return false; //TO break the each loop
        }
    });
    //console.log('result:'+result);
    return result;
};

/**
 * This is a default implementation for checking if a given position lies within the svgElement.
 * This can be overwritten by shapes like circles and ellipse..
 */
SVGShape.prototype.overlayCheck = function(position) {
    return position.x >= this.x() && position.x <= this.getRightX()
        && position.y >= this.y() && position.y <= this.getBottomY();
};

SVGShape.prototype.move = function(dx, dy) {
    var translate = this.translate();
    this.translate(translate.x + dx, translate.y + dy);
    return this;
};

SVGShape.prototype.moveTo = function(x, y) {
    var p = util.math.getPoint(x,y);

    var translate = this.translate();
    if(this.x() !== p.x || this.y() !== p.y) {
        //TODO: this does not consider x/y attribute settings
        this.translate(p);
    }
    return this;
};

SVGShape.prototype.moveX = function(x) {
    var translate = this.translate();
    if(translate.x !== x) {
        this.translate(x, translate.y);
    }
    return this;
};

SVGShape.prototype.moveY = function(y) {
    var translate = this.translate();
    if(translate.y !== y) {
        return this.translate(translate.x, y);
    }
    return this;
};

/**
 * Note: the implementation of getBBox differs between browsers some add the sroke-width and some do not add stroke-width
 */
SVGShape.prototype.height = function(value) {
    if((object.isBoolean(value) && value)) {
        return this.scaledY(this._getHeight()) + this.scaledY(this.strokeWidth());
    } else if(!object.isDefined(value) || (object.isBoolean(value) && !value)) {
        return this.scaledY(this._getHeight());
    } else {
        this._setHeight(value);
        return this;
    }
};

SVGShape.prototype._getHeight = function() {
    return this.getBBox().height;
};

SVGShape.prototype._setHeight = function() {
    //ABSTRACT
};

SVGShape.prototype.width = function(value) {
    if((object.isBoolean(value) && value)) {
        return this.scaledX(this._getWidth()) + this.scaledX(this.strokeWidth());
    } else if(!object.isDefined(value) || (object.isBoolean(value) && !value)) {
        return this.scaledX(this._getWidth());
    } else {
        this._setWidth(value);
        return this;
    }
};

SVGShape.prototype._getWidth = function() {
    return this.getBBox().width;
};

SVGShape.prototype._setWidth = function() {
   //ABSTRACT
};

SVGShape.prototype.getBottomY = function(withStroke) {
    return this.y(withStroke) + this.height(withStroke);
};

SVGShape.prototype.getRightX = function(withStroke) {
    return this.x(withStroke) + this.width(withStroke);
};

module.exports = SVGShape;
},{"../util/object":77,"../util/util":79,"./SVGElement":51,"./transform":68}],67:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./svgShape');

var DEFAULT_FONT_SIZE = 11;
var DEFAULT_FONT_FAMILY = "Helvetica"; //Verdana, Arial, sans-serif ?
var DEFAULT_TEXT_ANCHOR = "start";
var DEFAULT_DOMINANT_BASELINE = "hanging";

var DEFAULT_SPAN_PADDING = 0;

var SVGText = function(svgRoot, cfg, attributeSetter) {
    cfg = cfg || {};
    cfg['font-family'] = cfg['font-size'] || DEFAULT_FONT_FAMILY;
    cfg['font-size'] = cfg['font-size'] || DEFAULT_FONT_SIZE;
    cfg['text-anchor'] = cfg['text-anchor'] || DEFAULT_TEXT_ANCHOR;
    cfg['dominant-baseline'] = cfg['dominant-baseline'] || DEFAULT_DOMINANT_BASELINE;

    this.spanPadding = cfg['padding'] || DEFAULT_SPAN_PADDING;

    SVGShape.call(this, 'text', svgRoot, cfg, attributeSetter);
    //TODO: Span / multi line text
};

util.inherits(SVGText, SVGShape);

SVGText.prototype.padding = function(value) {
    if(object.isDefined(value)) {
        this.spanPadding = value;
        this.setSpanAttr('x', value);
    } else {
        return this.spanPadding;
    }
};

SVGText.prototype.fontFamily = function(value) {
    return this.attr('font-family', value);
};

SVGText.prototype.fontWeight = function(value) {
    return this.style('font-weight', value);
};

SVGText.prototype.fontSize = function(value) {
    if(value) {
        value = object.isNumber(value) ? value+'px' : value;
    }
    var result = this.attrNumber('font-size', value);
    if(value) {
        this.setSpanAttr('dy', value);
        return this;
    } else {
        return result;
    }
};

SVGText.prototype.setSpanAttr = function(key, value) {
    this.$().children('tspan').attr(key, value);
    return this;
};

SVGText.prototype.x = function(value) {
    return (object.isDefined(value)) ? this.attrNumber('x', value) : this.translatedX(this.attrNumber('x', value)) || 0 ;
};

SVGText.prototype.y = function(value) {
    return (object.isDefined(value)) ? this.attrNumber('y', value) : this.translatedY(this.attrNumber('y', value)) || 0 ;
};

SVGText.prototype.dx = function(value) {
    return this.attrNumber('dx', value);
};

SVGText.prototype.dy = function(value) {
    return this.attrNumber('dy', value);
};

SVGText.prototype.move = function(dx, dy) {
    SVGText.super_.prototype.move.apply(this, [dx, dy]);
    this.alignBackground();
};

SVGText.prototype.moveTo = function(x, y) {
    SVGText.super_.prototype.moveTo.apply(this, [x, y]);
    this.alignBackground();
};

SVGText.prototype.content = function(text) {
    if(!text) {
        return this.getText();
    }

    text = text.toString();

    var that = this;
    var height;
    this.$().empty();
    $.each(text.split('\n'), function(index, value) {
        if(object.isDefined(value) && value.trim().length > 0) {
            var tSpan = that.svg.tspan(value).x(that.spanPadding);
            that.append(tSpan);
            if(index > 0) {
                tSpan.dy(height);
            } else {
                height = tSpan.height();
            }
        }
    });
    return this;
};

SVGText.prototype.getText = function() {
    var result = '';
    var $children = this.$().children('tspan');
    $children.each(function(index, value) {
        result += $(this).text();
        if(index != $children.length -1) {
            result += '\n';
        }
    });
    return result;
};

SVGText.prototype.switchAnchor = function() {
    switch(this.anchor()) {
        case 'start':
            this.end();
        case 'end':
            this.start();
    }
};

SVGText.prototype.getExtentOfChar = function(charNum) {
    return this.instance().getExtentOfChar(charNum);
};

SVGText.prototype.getCharHeight = function(charNum) {
    return this.getExtentOfChar(charNum).height;
};

SVGText.prototype.start = function() {
    return this.anchor('start');
};

SVGText.prototype.end = function() {
    return this.anchor('end');
};

SVGText.prototype.middle = function() {
    return this.anchor('middle');
};

SVGText.prototype.anchor = function(value) {
    return this.attr('text-anchor', value);
};

SVGText.prototype.tSpan = function(index) {
    return this.svg.get(this.$().children('tspan').get(index));
};

SVGText.prototype.hanging = function(hanging) {
    var hanging = object.isDefined(hanging) ? hanging : true;
    var value = hanging ? 'hanging' : 'baseline';
    this.attr('dominant-baseline', value);
    var firstSpan = this.tSpan(0);
    var dy = (hanging) ? 0 : firstSpan.height() + this.getBBox().y;
    firstSpan.dy(dy);
    return this;
};

/**
 * Note: the background won't align when the text is dragged. Perhaps add drag hook
 * @param color
 */
SVGText.prototype.background = function(color) {
    var svgBackground = this.getBackground();
    if(color) {
        if(!svgBackground) {
            svgBackground = this.svg.rect({'class':'textBackground'});
        }
        svgBackground.fill(color);
        svgBackground.$().after(this.$());
        this.alignBackground();
    } else if(svgBackground) {
        svgBackground.fill();
    }
    return this;
};

/**
 *  TODO: probably just works for hanging texts because of the offset...
 */
SVGText.prototype.alignBackground = function() {
    var svgBackground = this.getBackground();
    if(svgBackground) {
        var bgHeight = this.height() + this.getBBox().y; //remove text offset
        svgBackground.height(bgHeight).width(this.width()).translate(this.x(), this.y());
    }
};

SVGText.prototype.getBackground = function() {
    if(this.backgroundSVG) {
        return this.backgroundSVG;
    }

    var prev = this.$().prev();
    if(prev.length > 0) {
        var svgBack = this.svg.get(prev);
        return this.backgroundSVG = (svgBack.hasClass('textBackground')) ? svgBack : undefined;
    }
};

SVGText.prototype.dominantBaseline = function(value) {
    return this.attr('dominant-baseline', value);
};

module.exports = SVGText;
},{"../util/object":77,"../util/util":79,"./svgShape":66}],68:[function(require,module,exports){
var util = require('../util/util');
var object = util.object;
var DomElement = require('../dom/domElement');

var Transform = function(def) {
    if(typeof def !== 'undefined' ) {
        if(object.isString(def)) {
            this.setDefinitionFromString(def);
        } else {
            this.definition = def;
        }
    } else {
        this.definition = {};
    }
};

Transform.prototype.setDefinitionFromString = function(value) {
    if(!this.definition) {
        this.definition = {};
    }

    // extract 'translate(200 200) rotate(45 50 50)' to "translate" "200 200" " rotate" "45 50 50" ""
    var transformations = value.split(/[\(\)]+/);
    for(var i = 0;i < transformations.length; i += 2) {
        var transformation = transformations[i].trim();
        if(transformation.length > 0) {
            var values = DomElement.getAttributeValueFromStringList(transformations[i+1]);
            for(var j = 0; j < values.length; j++) {
                // We prefer float values for calculations
                if(!isNaN(values[j])) {
                    values[j] = parseFloat(values[j]);
                }
            }
            this.definition[transformation] = values;
        }
    }
};

Transform.prototype.toString = function() {
    var values = [];
    for(var key in this.definition) {
        if(this.definition.hasOwnProperty((key))) {
            // first we assamble all transformations in an array ['translate(30)','rotate(45 50 50)']
            var singleTransformation = key+'('+DomElement.getAttributeString(this.definition[key])+')';
            values.push(singleTransformation);
        }
    }
    // merge the transformations to one attributestring
    var valueStr = DomElement.getAttributeString(values);

    if(valueStr.length > 0) {
        return valueStr;
    } else {
        // if we don't have any transormations set we just return an empty string
        return '';
    }
};

Transform.prototype.hasTransformation = function(key) {
    return (typeof this.definition[key] !== 'undefined');
};


Transform.prototype.rotate = function(val) {
    if(object.isDefined(val)) {
        this.definition.rotate = val;
        return this;
    } else {
        return this.definition.rotate || 0;
    }
};

Transform.prototype.scale = function(sx, sy) {
    sy = sy || sx;
    if(object.isDefined(sx)) {
        if(!this.definition.scale) {
            this.definition.scale = [sx, sy];
        } else {
            this.definition.scale[0] = sx;
            this.definition.scale[1] = sy;
        }
        return this;
    } else {
        var result = this.definition.scale;
        if(result && result.length === 1) {
            return [result[0], result[0]];
        } else if(result && result.length === 2) {
            return [result[0], result[1]]
        } else {
            return [1,1];
        }
    }
};

Transform.prototype.setScale = function(index, value) {
    if(index < 2 && this.definition.scale) {
        this.definition.scale[index] = value;
    }
};

Transform.prototype.translate = function(x, y) {
    var p = util.math.getPoint(x,y);

    if(object.isDefined(p)) {
        if(!this.definition.translate) {
            this.definition.translate = [p.x, p.y];
        } else {
            this.definition.translate[0] = p.x;
            this.definition.translate[1] = p.y;
        }
        return this;
    } else {
        if(this.definition.translate) {
            return {
                x : this.definition.translate[0],
                y : this.definition.translate[1]
            };
        } else {
            return {
                x : 0,
                y : 0
            }
        }
    }
}

module.exports = Transform;
},{"../dom/domElement":48,"../util/util":79}],69:[function(require,module,exports){
var util = require('../util/util');
var object = require('../util/object');
var SVGShape = require('./svgShape');
var SVGText = require('./text');

var DEFAULT_DOMINANT_BASELINE = 'inherit'

var SVGTSpan = function(svgRoot, cfg) {
    cfg = cfg || {};
    cfg['dominant-baseline'] = cfg['dominant-baseline'] || DEFAULT_DOMINANT_BASELINE;
    SVGShape.call(this, 'tspan', svgRoot, cfg);
};

util.inherits(SVGTSpan, SVGText);

SVGTSpan.prototype.getContainerText = function() {
    var parent = this.parent();
    if(parent.tagName === 'text') {
        return parent;
    }
};

SVGTSpan.prototype.fontSize = function(value) {
    if(value) {
        return SVGTSpan.super_.prototype.fontSize.apply(this, [value]);
    } else {
        var result = SVGTSpan.super_.prototype.fontSize.apply(this);
        if(!result) {
            var containerText = this.getContainerText();
            return (containerText) ? containerText.fontSize() : 0;
        } else {
            return result;
        }
    }
};

SVGTSpan.prototype.content = function(value) {
    if(value) {
        this.$().text(value);
        return this;
    } else {
        return this.$().text();
    }
};

SVGTSpan.prototype.getBBox = function() {
    //some browser (e.g. firefox) does not implement the getBBox for tspan elements.
    return this.getBoundingClientRect();
};

module.exports = SVGTSpan;
},{"../util/object":77,"../util/util":79,"./svgShape":66,"./text":67}],70:[function(require,module,exports){
var dom = require('../dom/dom');
var object = require('../util/object');

EditPanel = function() {};

EditPanel.prototype.init = function(pageX, pageY, onclose) {
    var that = this;
    this.close();

    this.onclose = onclose;

    //Init Form
    this.$form = dom.create('form', {action : 'javascript:void(0);'})
        .on('submit', function() {
            that.close();
        });

    //Init Container
    this.$editDiv = dom.create('div', {id:'editPanel'})
        .offset({top: pageY, left: (pageX+5)})
        .css('position', 'absolute')
        .css('background-color', 'silver')
        .append(this.$form);

    //Append to body
    $('body').append(this.$editDiv);
    return this;
};

EditPanel.prototype.close = function() {
    if(this.onclose) {
        this.onclose.apply();
    }

    if(this.$editDiv) {
        this.$editDiv.remove();
    }
}

EditPanel.prototype.createTextEdit = function(pageX ,pageY, getter, setter) {
    var that = this;
    var $input = dom.create('input', {type:'text', value : getter()})
        .focus()
        .on('focus', function() {
            this.select();
        })
        .on('blur', function(evt) {
            that.close();
        })
        .on('change', function(evt) {
            setter($input.val());
        });

    this.init(pageX ,pageY);
    this.$form.append($input);
    $input.focus();
};

EditPanel.prototype.createTextAreaEdit = function(pageX ,pageY, getter, setter) {
    var that = this;
    var $input = dom.create('textarea')
        .val(getter())
        .on('change', function() {
            setter($input.val());
        })
        .on('blur', function(evt) {
            that.close();
        })
        .on('focus', function() {
            this.select();
        });

    this.init(pageX ,pageY);
    this.$form.append($input);
    $input.focus();
};

EditPanel.prototype.setTextAreaContent = function($textAreaNode, txtAreaContent) {
    $textAreaNode.empty();
    //TODO: we do not consider the text size for dy !
    var dy = 11;
    $.each(txtAreaContent.split('\n'), function(index, value) {
        if(object.isDefined(value) && value.trim().length > 0) {
            dom.appendSVGElement($textAreaNode.get(0), {
                name : 'tspan',
                attributes : {
                    dy : dy,
                    x : 2
                }
            }, value);
        }
    });
};

EditPanel.prototype.getTextAreaContent = function($textAreaNode) {
    var result = '';
    $textAreaNode.children().each(function() {
        result += $(this).text()+'\n';
    });
    return result;
};

module.exports = EditPanel;
},{"../dom/dom":47,"../util/object":77}],71:[function(require,module,exports){
var SVG = require('../svg/svg');
var string = require('../util/string');
var queryCache = require('../core/cache');

$.fn.svg = function(selector) {
    if(selector && selector.SVGElement) {
        return selector;
    } else if(selector) {
        return $(selector).svg();
    }

    if(!this.length) {
        return [];
    } else if(this.length === 1) {
        return SVG.get(this);
    } else if(this.length > 1) {
        var result =  [];
        this.each(function() {
            result.push(SVG.get(this));
        });
        return result;
    }

    return this;
};

$.svg = $.fn.svg;

$.qCache = function(selector, preventCache) {
    if(selector) {
        return queryCache.$(selector, preventCache);
    } else {
        return queryCache;
    }
};

$.qUncache = function(selector) {
    return queryCache.remove(selector);
};

/**
 * The problem with ui-selectmenu is that it causes a second keydown trigger event when focused.
 * So global keydown events are triggered twiche like do/undo if focused. The following event
 * prevents the propagation if the control key is pressed.
 */
$(document, '.ui-selectmenu-button').on('keydown', function(evt) {
    if(evt.ctrlKey) {
        evt.stopPropagation();
    }
});

$.fn.growl = function(params) {
    var $root = this;

    // tooltip content and styling
    var $content = $(
        '<a class="icon-close" href="#"></a>'+
        '<h1 style="color: white; font-size: 12pt; font-weight: bold; padding-bottom: 5px;">' + params.title + '</h1>' +
        '<p style="margin: 0; padding: 5px 0 5px 0; font-size: 10pt;">' + params.text + '</p>');

    // add 'Close' button functionality
    var $close = $($content[0]);
    $close.click(function(e) {
        $root.uitooltip('close');
    });

    // prevent standard tooltip from closing
    $root.bind('focusout mouseleave', function(e) { e.preventDefault(); e.stopImmediatePropagation(); return false; });

    // build tooltip
    $root.uitooltip({
        content: function() { return $content; },
        items: $root.selector,
        tooltipClass: 'growl ' + params.growlClass,
        position: {
            my: 'right top',
            at: 'right-10 top+10'
        },
        close: function( event, ui ) {
            $root.uitooltip('destroy');
        }
    }).uitooltip('open');

    if(params.closeAfter) {
        setTimeout(function(){ $root.uitooltip('close'); }, params.closeAfter);
    }
};

if($.ui) {
    $.widget( "custom.iconselectmenu", $.ui.selectmenu, {
        _renderItem: function( ul, item ) {
            var li = $( "<li>", { text: item.label } );
            if ( item.disabled ) {
                li.addClass( "ui-state-disabled" );
            }
            $( "<span>", {
                style: item.element.attr( "data-style" ),
                "class": "ui-icon " + item.element.attr( "data-class" )
            })
                .appendTo( li );
            return li.appendTo( ul );
        }
    });
}

},{"../core/cache":2,"../svg/svg":63,"../util/string":78}],72:[function(require,module,exports){
var event = require('../core/event');
var object = require('../util/object');
var client = require('../core/client');
var Promise = require('bluebird');
var DalaError = require('../../common/error');

var PATH_LOGIN = '/user/login';
var SEL_LOGGED_OUT = '.loggedOut';
var SEL_LOGGED_IN = '.loggedIn';
var SEL_USER_LINK_TXT = '#user-link-text';

var user;

var init = function() {
    event.listen('user_loggedin', userLogin);
    event.listen('user_loggedout', userLogout);
    logoutHandler(true);
};

var login = function(email, password) {
    return new Promise(function(resolve, reject) {
        var values = {
            email : email,
            password : password
        };

        client.post(PATH_LOGIN, values, {
            success : function(response) {
                loggedInHandler(response.data.result);
                resolve(response.data.result);
            },
            error : function(error, errorCode) {
                switch(errorCode) {
                    case DalaError.CODES.USER_LOGIN_INCORRECT_PASSWORD:
                        event.trigger('error', 'Login failed: Invalid password!');
                        break;
                    case DalaError.CODES.USER_LOGIN_INVALID_EMAIL:
                        event.trigger('error', 'Login failed: Invalid email address.');
                        break;
                    default:
                        event.trigger('error', 'Login failed: Something went wrong, please try again later.');
                        break;

                }
                reject(error);
            },
            successMessage : 'Login was successful!'
        });
    });
};

var loggedInHandler = function(result) {
    $(SEL_LOGGED_OUT).hide();
    $(SEL_LOGGED_IN).show();
    $(SEL_USER_LINK_TXT).text(result.user.email);
    event.trigger('user_loggedin', result);
};

var logoutHandler = function(prevTrigger) {
    $(SEL_LOGGED_IN).hide();
    $(SEL_LOGGED_OUT).show();
    $(SEL_USER_LINK_TXT).text('');
    if(!prevTrigger) {
        event.trigger('user_loggedout');
    }
};

var userLogin = function(evt) {
    user = evt.data.user;
}

var isLoggedIn = function() {
    return object.isDefined(user);
}

var userLogout = function(evt) {
    delete user;
}

var getUserId = function() {
    if(user) {
        return user.id;
    }
    return '';
}

module.exports = {
    init: init,
    login : login,
    isLoggedIn : isLoggedIn,
    getUserId : getUserId
};
},{"../../common/error":81,"../core/client":3,"../core/event":7,"../util/object":77,"bluebird":83}],73:[function(require,module,exports){
var util = require("util");

module.exports = {
    object: require('./object'),
    string: require('./string'),
    dom: require('./../dom/dom'),
    app: require('./app'),
    math: require('./math'),
    xml : require('./xml'),
    inherits: util.inherits
}
},{"./../dom/dom":47,"./app":74,"./math":76,"./object":77,"./string":78,"./xml":80,"util":88}],74:[function(require,module,exports){
/**
 * This module serves as an wrapper for dom manipulation functionality. It is
 * highly prefered to use this module instead of jquery directly within other
 * modules.
 */
var object = require('./object');

var parseFeatureStrings = function(value, defaultVal) {
    var result = [];
    value = value.split(' ');
    object.each(value, function(index, feature) {
        result[index] = parseFeatureString(feature, defaultVal);
    });
    return result;
};

/**
 * parse a featurestinrg in the form of
 *  'featurename(30,30)' or 'featurename(30.4) or featurename
 *
 * The result is would be
 *      { type : 'featurename', value : [30,30] }
 *      { type : 'featurename', value : 30.4 }
 *      { type : 'featurename', value : undefined }
 * @param {type} feature
 * @returns {App_L6.parseFeatureString.result}
 */
var parseFeatureString = function(feature, defaultVal) {
    var result = {};
    if(feature.indexOf('(') > -1) {
        var splitted = feature.split('(');
        var value = splitted[1].substring(0, splitted[1].indexOf(')'));

        if(value.indexOf(',') > -1) { // multiple args
            value = value.split(',');
            object.each(value, function(index, v) {
                value[index] = parseNumberString(v);
            });
        } else { // single arg
            value = parseNumberString(value);
        }
        result.type = splitted[0];
        result.value = value;
    } else {
        result.type = feature;
        result.value = defaultVal;
    }
    return result;
};

var parseNumberString = function(value) {
    if(!object.isString(value)) {
        return value;
    }

    //Cut units 1.2em -> 1.2
    value = value.split(/(?=[a-z,A-Z]+)/)[0];

    if(!isNaN(value)) {
        if(value.indexOf('.') > -1) { //float
            value = parseFloat(value);
        } else { //int
            value = parseInt(value);
        }
    }
    return value;
};

var createFeatureString = function(feature, value) {
    var result = feature;

    if(object.isDefined(value)) {
        result += '(';
        if(object.isArray(value)) {
            object.each(value, function(index, value) {
                result += (index !== 0) ? ','+value : value;
            });
        } else {
            result += value;
        }
        result += ')';
    }
    return result;
};

var isMinDist = function(from, to, minDist) {
    return Math.abs(to.x - from.x) > minDist || Math.abs(to.y - from.y) > minDist;
};

module.exports = {
    parseFeatureString:parseFeatureString,
    createFeatureString:createFeatureString,
    parseFeatureStrings:parseFeatureStrings,
    parseNumberString : parseNumberString,
    isMinDist : isMinDist
};

},{"./object":77}],75:[function(require,module,exports){
/**
 * most Bezier helpter functions are taken from jsBezier library https://github.com/jsplumb/jsBezier/blob/master/js/0.6/jsBezier-0.6.js
 * check /libs/jsBezier.js for more functions if required.
 *
 *
 */

if (typeof Math.sgn == "undefined") {
    Math.sgn = function (x) {
        return x == 0 ? 0 : x > 0 ? 1 : -1;
    };
}

var Vectors = {
        subtract: function (v1, v2) {
            return {x: v1.x - v2.x, y: v1.y - v2.y};
        },
        dotProduct: function (v1, v2) {
            return (v1.x * v2.x) + (v1.y * v2.y);
        },
        square: function (v) {
            return Math.sqrt((v.x * v.x) + (v.y * v.y));
        },
        scale: function (v, s) {
            return {x: v.x * s, y: v.y * s};
        }
    },

    maxRecursion = 64,
    flatnessTolerance = Math.pow(2.0, -maxRecursion - 1);

/**
 * finds the nearest point on the curve to the given point.
 */
var _nearestPointOnCurve = function (point, curve) {
    var td = _distanceFromCurve(point, curve);
    return {point: _bezier(curve, curve.length - 1, td.location, null, null), location: td.location};
};

/**
 * Calculates the distance that the point lies from the curve.
 *
 * @param point a point in the form {x:567, y:3342}
 * @param curve a Bezier curve in the form [{x:..., y:...}, {x:..., y:...}, {x:..., y:...}, {x:..., y:...}].  note that this is currently
 * hardcoded to assume cubiz beziers, but would be better off supporting any degree.
 * @return a JS object literal containing location and distance, for example: {location:0.35, distance:10}.  Location is analogous to the location
 * argument you pass to the pointOnPath function: it is a ratio of distance travelled along the curve.  Distance is the distance in pixels from
 * the point to the curve.
 */
var _distanceFromCurve = function (point, curve) {
    var candidates = [],
        w = _convertToBezier(point, curve),
        degree = curve.length - 1, higherDegree = (2 * degree) - 1,
        numSolutions = _findRoots(w, higherDegree, candidates, 0),
        v = Vectors.subtract(point, curve[0]), dist = Vectors.square(v), t = 0.0;

    for (var i = 0; i < numSolutions; i++) {
        v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
        var newDist = Vectors.square(v);
        if (newDist < dist) {
            dist = newDist;
            t = candidates[i];
        }
    }
    v = Vectors.subtract(point, curve[degree]);
    newDist = Vectors.square(v);
    if (newDist < dist) {
        dist = newDist;
        t = 1.0;
    }
    return {location: t, distance: dist};
};

var _convertToBezier = function (point, curve) {
    var degree = curve.length - 1, higherDegree = (2 * degree) - 1,
        c = [], d = [], cdTable = [], w = [],
        z = [[1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0]];

    for (var i = 0; i <= degree; i++) c[i] = Vectors.subtract(curve[i], point);
    for (var i = 0; i <= degree - 1; i++) {
        d[i] = Vectors.subtract(curve[i + 1], curve[i]);
        d[i] = Vectors.scale(d[i], 3.0);
    }
    for (var row = 0; row <= degree - 1; row++) {
        for (var column = 0; column <= degree; column++) {
            if (!cdTable[row]) cdTable[row] = [];
            cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
        }
    }
    for (i = 0; i <= higherDegree; i++) {
        if (!w[i]) w[i] = [];
        w[i].y = 0.0;
        w[i].x = parseFloat(i) / higherDegree;
    }
    var n = degree, m = degree - 1;
    for (var k = 0; k <= n + m; k++) {
        var lb = Math.max(0, k - m),
            ub = Math.min(k, n);
        for (i = lb; i <= ub; i++) {
            j = k - i;
            w[i + j].y += cdTable[j][i] * z[j][i];
        }
    }
    return w;
};
/**
 * counts how many roots there are.
 */
var _findRoots = function (w, degree, t, depth) {
    var left = [], right = [],
        left_count, right_count,
        left_t = [], right_t = [];

    switch (_getCrossingCount(w, degree)) {
        case 0 :
        {
            return 0;
        }
        case 1 :
        {
            if (depth >= maxRecursion) {
                t[0] = (w[0].x + w[degree].x) / 2.0;
                return 1;
            }
            if (_isFlatEnough(w, degree)) {
                t[0] = _computeXIntercept(w, degree);
                return 1;
            }
            break;
        }
    }
    _bezier(w, degree, 0.5, left, right);
    left_count = _findRoots(left, degree, left_t, depth + 1);
    right_count = _findRoots(right, degree, right_t, depth + 1);
    for (var i = 0; i < left_count; i++) t[i] = left_t[i];
    for (var i = 0; i < right_count; i++) t[i + left_count] = right_t[i];
    return (left_count + right_count);
};
var _getCrossingCount = function (curve, degree) {
    var n_crossings = 0, sign, old_sign;
    sign = old_sign = Math.sgn(curve[0].y);
    for (var i = 1; i <= degree; i++) {
        sign = Math.sgn(curve[i].y);
        if (sign != old_sign) n_crossings++;
        old_sign = sign;
    }
    return n_crossings;
};
var _isFlatEnough = function (curve, degree) {
    var error,
        intercept_1, intercept_2, left_intercept, right_intercept,
        a, b, c, det, dInv, a1, b1, c1, a2, b2, c2;
    a = curve[0].y - curve[degree].y;
    b = curve[degree].x - curve[0].x;
    c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;

    var max_distance_above = max_distance_below = 0.0;

    for (var i = 1; i < degree; i++) {
        var value = a * curve[i].x + b * curve[i].y + c;
        if (value > max_distance_above)
            max_distance_above = value;
        else if (value < max_distance_below)
            max_distance_below = value;
    }

    a1 = 0.0;
    b1 = 1.0;
    c1 = 0.0;
    a2 = a;
    b2 = b;
    c2 = c - max_distance_above;
    det = a1 * b2 - a2 * b1;
    dInv = 1.0 / det;
    intercept_1 = (b1 * c2 - b2 * c1) * dInv;
    a2 = a;
    b2 = b;
    c2 = c - max_distance_below;
    det = a1 * b2 - a2 * b1;
    dInv = 1.0 / det;
    intercept_2 = (b1 * c2 - b2 * c1) * dInv;
    left_intercept = Math.min(intercept_1, intercept_2);
    right_intercept = Math.max(intercept_1, intercept_2);
    error = right_intercept - left_intercept;
    return (error < flatnessTolerance) ? 1 : 0;
};
var _computeXIntercept = function (curve, degree) {
    var XLK = 1.0, YLK = 0.0,
        XNM = curve[degree].x - curve[0].x, YNM = curve[degree].y - curve[0].y,
        XMK = curve[0].x - 0.0, YMK = curve[0].y - 0.0,
        det = XNM * YLK - YNM * XLK, detInv = 1.0 / det,
        S = (XNM * YMK - YNM * XMK) * detInv;
    return 0.0 + XLK * S;
};

var _bezier = function (curve, degree, t, left, right) {
    var temp = [[]];
    for (var j = 0; j <= degree; j++) temp[0][j] = curve[j];
    for (var i = 1; i <= degree; i++) {
        for (var j = 0; j <= degree - i; j++) {
            if (!temp[i]) temp[i] = [];
            if (!temp[i][j]) temp[i][j] = {};
            temp[i][j].x = (1.0 - t) * temp[i - 1][j].x + t * temp[i - 1][j + 1].x;
            temp[i][j].y = (1.0 - t) * temp[i - 1][j].y + t * temp[i - 1][j + 1].y;
        }
    }
    if (left != null)
        for (j = 0; j <= degree; j++) left[j] = temp[j][0];
    if (right != null)
        for (j = 0; j <= degree; j++) right[j] = temp[degree - j][j];

    return (temp[degree][0]);
};

var _curveFunctionCache = {};
var _getCurveFunctions = function (order) {
    var fns = _curveFunctionCache[order];
    if (!fns) {
        fns = [];
        var f_term = function () {
                return function (t) {
                    return Math.pow(t, order);
                };
            },
            l_term = function () {
                return function (t) {
                    return Math.pow((1 - t), order);
                };
            },
            c_term = function (c) {
                return function (t) {
                    return c;
                };
            },
            t_term = function () {
                return function (t) {
                    return t;
                };
            },
            one_minus_t_term = function () {
                return function (t) {
                    return 1 - t;
                };
            },
            _termFunc = function (terms) {
                return function (t) {
                    var p = 1;
                    for (var i = 0; i < terms.length; i++) p = p * terms[i](t);
                    return p;
                };
            };

        fns.push(new f_term());  // first is t to the power of the curve order
        for (var i = 1; i < order; i++) {
            var terms = [new c_term(order)];
            for (var j = 0; j < (order - i); j++) terms.push(new t_term());
            for (var j = 0; j < i; j++) terms.push(new one_minus_t_term());
            fns.push(new _termFunc(terms));
        }
        fns.push(new l_term());  // last is (1-t) to the power of the curve order

        _curveFunctionCache[order] = fns;
    }

    return fns;
};


/**
 * calculates a point on the curve, for a Bezier of arbitrary order.
 * @param curve an array of control points, eg [{x:10,y:20}, {x:50,y:50}, {x:100,y:100}, {x:120,y:100}].  For a cubic bezier this should have four points.
 * @param location a decimal indicating the distance along the curve the point should be located at.  this is the distance along the curve as it travels, taking the way it bends into account.  should be a number from 0 to 1, inclusive.
 */
var _pointOnPath = function (curve, location) {
    var cc = _getCurveFunctions(curve.length - 1),
        _x = 0, _y = 0;
    for (var i = 0; i < curve.length; i++) {
        _x = _x + (curve[i].x * cc[i](location));
        _y = _y + (curve[i].y * cc[i](location));
    }

    return {x: _x, y: _y};
};

var _dist = function (p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
};

var _isPoint = function (curve) {
    return curve[0].x == curve[1].x && curve[0].y == curve[1].y;
};

/**
 * finds the point that is 'distance' along the path from 'location'.  this method returns both the x,y location of the point and also
 * its 'location' (proportion of travel along the path); the method below - _pointAlongPathFrom - calls this method and just returns the
 * point.
 */
var _pointAlongPath = function (curve, location, distance) {

    if (_isPoint(curve)) {
        return {
            point: curve[0],
            location: location
        };
    }

    var prev = _pointOnPath(curve, location),
        tally = 0,
        curLoc = location,
        direction = distance > 0 ? 1 : -1,
        cur = null;

    while (tally < Math.abs(distance)) {
        curLoc += (0.005 * direction);
        cur = _pointOnPath(curve, curLoc);
        tally += _dist(cur, prev);
        prev = cur;
    }
    return {point: cur, location: curLoc};
};

var _length = function (curve) {
    if (_isPoint(curve)) return 0;

    var prev = _pointOnPath(curve, 0),
        tally = 0,
        curLoc = 0,
        direction = 1,
        cur = null;

    while (curLoc < 1) {
        curLoc += (0.005 * direction);
        cur = _pointOnPath(curve, curLoc);
        tally += _dist(cur, prev);
        prev = cur;
    }
    return tally;
};

/**
 * finds the point that is 'distance' along the path from 'location'.
 */
var _pointAlongPathFrom = function (curve, location, distance) {
    return _pointAlongPath(curve, location, distance).point;
};

/**
 * finds the location that is 'distance' along the path from 'location'.
 */
var _locationAlongPathFrom = function (curve, location, distance) {
    return _pointAlongPath(curve, location, distance).location;
};

/**
 * returns the gradient of the curve at the given location, which is a decimal between 0 and 1 inclusive.
 *
 * thanks // http://bimixual.org/AnimationLibrary/beziertangents.html
 */
var _gradientAtPoint = function (curve, location) {
    var p1 = _pointOnPath(curve, location),
        p2 = _pointOnPath(curve.slice(0, curve.length - 1), location),
        dy = p2.y - p1.y, dx = p2.x - p1.x;
    return dy == 0 ? Infinity : Math.atan(dy / dx);
};

/**
 returns the gradient of the curve at the point which is 'distance' from the given location.
 if this point is greater than location 1, the gradient at location 1 is returned.
 if this point is less than location 0, the gradient at location 0 is returned.
 */
var _gradientAtPointAlongPathFrom = function (curve, location, distance) {
    var p = _pointAlongPath(curve, location, distance);
    if (p.location > 1) p.location = 1;
    if (p.location < 0) p.location = 0;
    return _gradientAtPoint(curve, p.location);
};

/**
 * calculates a line that is 'length' pixels long, perpendicular to, and centered on, the path at 'distance' pixels from the given location.
 * if distance is not supplied, the perpendicular for the given location is computed (ie. we set distance to zero).
 */
var _perpendicularToPathAt = function (curve, location, length, distance) {
    distance = distance == null ? 0 : distance;
    var p = _pointAlongPath(curve, location, distance),
        m = _gradientAtPoint(curve, p.location),
        _theta2 = Math.atan(-1 / m),
        y = length / 2 * Math.sin(_theta2),
        x = length / 2 * Math.cos(_theta2);
    return [{x: p.point.x + x, y: p.point.y + y}, {x: p.point.x - x, y: p.point.y - y}];
};

var _calculateSmoothControlPoints = function(K) {
    var resultP1 = [];
    var resultP2 = [];
    var n = K.length-1;

    /*rhs vector init left most segment*/
    var a = [0];
    var b = [2];
    var c = [1];
    var r = [K[0] + 2 * K[1]];

    /*internal segments*/
    for(i = 1; i < n - 1; i++) {
        a[i] = 1;
        b[i] = 4;
        c[i] = 1;
        r[i] = 4 * K[i] + 2 * K[i+1];
    }

    /*right segment*/
    a[n-1] = 2;
    b[n-1] = 7;
    c[n-1] = 0;
    r[n-1] = 8 * K[n-1] + K[n];

    /*solves Ax=b with the Thomas algorithm*/
    for(i = 1; i < n; i++) {
        m = a[i] / b[i-1];
        b[i] = b[i] - m * c[i - 1];
        r[i] = r[i] - m * r[i-1];
    }

    resultP1[n-1] = r[n-1] / b[n-1];
    for (i = n - 2; i >= 0; --i) {
        resultP1[i] = (r[i] - c[i] * resultP1[i + 1]) / b[i];
    }

    /*we have p1, now compute p2*/
    for (i = 0; i < n - 1; i++) {
        resultP2[i] = 2 * K[i + 1] - resultP1[i + 1];
    }

    resultP2[n-1] = 0.5 * (K[n] + resultP1[n-1]);

    return {p1:resultP1, p2:resultP2};
};

/**
 * Moves a point along the given curve
 * @param curve
 * @param distance
 * @returns {*|{x, y}}
 */
var moveAlong = function(curve, distance) {
    // Somehow the pointAlongPath calculates in the wrong direction so we switch the bahaviour by setting
    // the location to 1 (end) for positive distances.
    // and negotiate the distance value.
    var location = distance > 0 ? 1 : 0;
    var distance = distance * -1;
    return _pointAlongPath(curve,location, distance).point;
};

module.exports = {
    nearestPointOnCurve : _nearestPointOnCurve,
    calculateSmoothControlPoints : _calculateSmoothControlPoints,
    moveAlong : moveAlong,
    length : _length
}


},{}],76:[function(require,module,exports){
var object = require('./object');
var bezier = require('./bezier');

var calcLineIntersection = function(pa1, pa2, pb1, pb2) {
    return new Line(pa1,pa2).calcLineIntercept(new Line(pb1,pb2));
};

var Point = function(x, y) {
    var p = getPoint(x,y);
    this.x = p.x;
    this.y = p.y;
};

Point.prototype.isWithinInterval = function(start, end, tolerance) {
    return isPointInInterval(this, start, end, tolerance);
};

Point.prototype.isWithinXInterval = function(start, end, tolerance) {
    return _inInterval(this, start, end, tolerance, 'x');
};

Point.prototype.isWithinYInterval = function(start, end, tolerance) {
    return _inInterval(this, start, end, tolerance, 'y');
};;

var isPointInInterval = function(point, start, end, tolerance) {
    return _inInterval(point, start, end, tolerance, 'x') && _isPointInInterval(point, start, end, tolerance, 'y');
};

var _inInterval = function(p, start, end, tolerance, dimension) {
    tolerance = tolerance || 0;
    var boundary = minMax(start[dimension], end[dimension]);
    boundary.min -= tolerance;
    boundary.max += tolerance;
    return (p[dimension] <= boundary.max && p[dimension] >= boundary.min);
};

var minMax = function(val1, val2) {
    return {
        min :  Math.min(val1, val2),
        max : Math.max(val1, val2)
    };
};

var Line = function(p1, p2) {
    //y = mx + t
    if(p1.x) {
        this.op1 = p1;
        this.op2 = p2;
        this.p1 = (p1.x <= p2.x)? p1 : p2;
        this.p2 = (p1.x > p2.x)? p1 : p2;
        this.m = this.calcGradient();
        this.t = this.calcYIntercept();
    } else {
        this.m = p1;
        this.t = p2;
    }
};

Line.prototype.calcYIntercept = function() {
    // y = m * x + t => t = -mx + y
    return (-1 * this.m * this.p1.x) + this.p1.y;
};

Line.prototype.getOrthogonal = function(p) {
    //
    var newM = -1 / this.m;
    var t = p.y - (newM * p.x);
    return new Line(newM,t);
};

Line.prototype.calcGradient = function() {
    return Line.calcGradient(this.p1, this.p2);
};

Line.prototype.calcNormalizedLineVector = function() {
    return Line.calcNormalizedLineVector(this.p1, this.p2);
};

Line.prototype.isLtR = function() {
    return this.op1.x < this.op2.x;
};

Line.prototype.isTtB = function() {
    return this.op1.y < this.op2.y;
};


Line.calcNormalizedLineVector = function(p1, p2) {
    var vector = {
        x : p2.x - p1.x,
        y : p2.y - p1.y
    };

    var length = Math.sqrt(vector.x*vector.x + vector.y*vector.y);

    vector.x = vector.x / length;
    vector.y = vector.y / length;
    return vector;
};

/*
 *  TODO: this is working if you provide start/end and distance (negative or positive) but not tested (and presumably not working)
 *  when given start/end dist and direction e.g move from start point -30 back.
 */
Line.moveAlong = function(p1,p2, dist, direction) {
    var vector = Line.calcNormalizedLineVector(p1,p2);

    //If there is no direction given we handle negative distances as direction -1 (from end to start)
    direction = direction || (dist < 0) ? -1 : 1;

    if(direction < 1) {
        dist = Line.calcDistance(p1,p2) + dist;
    }

    return {
        x : p1.x + vector.x * dist,
        y : p1.y + vector.y * dist
    };
};

Line.prototype.moveAlong = function(dist, direction) {
    //TODO: note this is just working if we are initiating the line with two points...
    return Line.moveAlong(this.p1, this.p2, dist, direction);
};

Line.calcGradient = function(p1, p2) {
    return (p2.y - p1.y) / (p2.x - p1.x);
};

Line.prototype.calcFX = function(x) {
    var y = (this.m) * x + this.t;
    return {
        x : x,
        y : y
    };
};

Line.prototype.calcMidPoint = function() {
    return Line.calcMidPoint(this.p1, this.p2);
};

Line.calcMidPoint = function(p1, p2) {
    return {
        x : (p1.x+p2.x) / 2,
        y : (p1.y+p2.y) / 2
    };
};

Line.prototype.isVertical = function(x) {
    return !isFinite(this.m);
};

Line.prototype.isHorizontal = function(x) {
    return this.m === 0;
};

Line.prototype.calcLineIntercept = function(other) {
    //mx(1) + t(1) = mx(2) +t(2)
    var m = other.m + (-1 * this.m);
    var t = this.t + (-1 * other.t);
    var x = (m !== 0) ? t / m : t;
    return this.calcFX(x);
};

Line.prototype.getNearestPoint = function(p) {
    return Line.getNearestPoint(this.p1, this.p2, p);
};

Line.getNearestPoint = function(a, b, p) {
    var AP = [p.x - a.x, p.y - a.y]; // vector A->P
    var AB = [b.x - a.x, b.y - a.y]; // vector A->B
    var magnitude = AB[0] * AB[0] + AB[1] * AB[1] //AB.LengthSquared

    var AP_DOT_AB = AP[0] * AB[0] + AP[1] * AB[1];

    var distance = AP_DOT_AB / magnitude;

    if(distance < 0) {
        return a;
    } else if (distance > 1) {
        return b;
    } else {
        return {
            x: a.x + AB[0] * distance,
            y: a.y + AB[1] * distance
        }
    }
};

Line.calcDistance = function(p1, p2) {
    return Math.sqrt(Math.pow((p2.y - p1.y),2) + Math.pow((p2.x - p1.x),2));
}

var SimpleVector = function(x, y) {
    this.x = x;
    this.y = y;
};

SimpleVector.prototype.dot = function(that) {
    return this.x*that.x + this.y*that.y;
};

SimpleVector.fromPoints = function(p1, p2) {
    return new SimpleVector(
        p2.x - p1.x,
        p2.y - p1.y
    );
};

SimpleVector.prototype.subtract = function(that) {
    return new SimpleVector(this.x - that.x, this.y - that.y);
};

var Ellipse = function(cx, cy, rx, ry) {
    switch(arguments.length) {
        case 4:
            this.c = {x:cx,y:cy};
            this.rx = rx;
            this.ry = ry;
            break;
        case 3:
            this.c = cx;
            this.rx = cy;
            this.ry = rx;
            break;
    }
};

Ellipse.prototype.calcLineIntercept = function(p1,p2) {
    var result = [];

    if(arguments.length === 1) {
        p2 = p1.p2;
        p1 = p1.p1;
    }

    var origin = new SimpleVector(p1.x, p1.y);
    var dir = SimpleVector.fromPoints(p1, p2);
    var center = new SimpleVector(this.c.x, this.c.y);
    var diff = origin.subtract(center);
    var mDir = new SimpleVector(dir.x/(this.rx*this.rx),  dir.y/(this.ry*this.ry));
    var mDiff = new SimpleVector(diff.x/(this.rx*this.rx), diff.y/(this.ry*this.ry));

    var aDiff = dir.dot(mDir);
    var bDiff = dir.dot(mDiff);
    var cDiff = diff.dot(mDiff) - 1.0;
    var dDiff = bDiff*bDiff - aDiff*cDiff;

    if (dDiff > 0) {
        var root = Math.sqrt(dDiff);
        var tA  = (-bDiff - root) / aDiff;
        var tB  = (-bDiff + root) / aDiff;

        if (!((tA < 0 || 1 < tA) && (tB < 0 || 1 < tB))) {
            if (0 <= tA && tA <= 1) {
                result.push(lerp(p1, p2, tA));
            }
            if ( 0 <= tB && tB <= 1 ) {
                result.push(lerp(p1, p2, tB));
            }
        }
    } else {
        var t = -bDiff/aDiff;
        if (0 <= t && t <= 1) {
            result.push(lerp(p1. a2, t));
        }
    }

    return result;
};

Ellipse.prototype.overlays = function(p) {
    var bx = Math.pow((p.x - this.c.x), 2) / Math.pow(this.rx, 2);
    var by = Math.pow((p.y - this.c.y), 2) / Math.pow(this.ry, 2);
    return bx + by <= 1
};

var Circle = function(cx, cy, r) {
    if(arguments.length === 2) {
        this.c = cx;
        this.r = cy;
    } else {
        this.c = {x: cx, y : cy};
        this.r = r;
    }
};

Circle.prototype.overlays = function(p) {
    var bx = Math.pow((p.x - this.c.x), 2);
    var by = Math.pow((p.y - this.c.y), 2);
    return bx + by < Math.pow(this.r, 2);
};

Circle.prototype.calcLineIntercept = function(p1, p2) {
    var result = [];

    if(arguments.length === 1) {
        p2 = p1.p2;
        p1 = p1.p1;
    }

    var a = (p2.x - p1.x) * (p2.x - p1.x)
        + (p2.y - p1.y) * (p2.y - p1.y);
    var b  = 2 * ((p2.x - p1.x) * (p1.x - this.c.x)
        + (p2.y - p1.y) * (p1.y - this.c.y)   );
    var cc = this.c.x*this.c.x + this.c.y*this.c.y + p1.x*p1.x + p1.y*p1.y -
        2 * (this.c.x * p1.x + this.c.y * p1.y) - this.r*this.r;
    var deter = b*b - 4*a*cc;

    if(deter > 0) {
        var root  = Math.sqrt(deter);
        var tA = (-b + root) / (2*a);
        var tB = (-b - root) / (2*a);

        if (!((tA < 0 || tA > 1) && (tB < 0 || tB > 1))) {
            if (0 <= tA && tA <= 1) {
                result.push(lerp(p1, p2, tA));
            }

            if (0 <= tB && tB <= 1) {
                result.push(lerp(p1, p2, tB));
            }
        }
    }
    return result;
};

var lerp = function(a, b, t) {
    return {
        x : a.x + (b.x - a.x) * t,
        y : a.y + (b.y - a.y) * t
    };
};

var Vector = function() {
    this.vectors = [];
    var currentArr;
    for(var i = 0; i < arguments.length; i++) {
        if(object.isArray(arguments[i])) {
            if(currentArr) {
                this.add(currentArr);
                currentArr = undefined;
            }
            this.add(arguments[i]);
        } else {
            currentArr = currentArr || [];
            currentArr.push(arguments[i]);
        }
    };

    if(currentArr) {
        this.add(currentArr);
        delete currentArr;
    }
};

/**
 * Adds a vector value either by providing seperated arguments or an array of values
 */
Vector.prototype.add = function() {
    var value;
    if(arguments.length > 1) {
        value = [];
        for(var i = 0; i < arguments.length; i++) {
            value.push(arguments[i]);
        }
    } else if(arguments.length === 1) {
        value = arguments[0];
    }
    this.vectors.push(value);
};

Vector.prototype.value = function() {
    try {
        var path = object.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
        return getVectorValue(this.vectors, path);
    } catch(e) {
        console.error('get value vector failed - '+this.vectors+' args: '+arguments);
    }
};

Vector.prototype.clear = function() {
    this.vectors = [];
};

Vector.prototype.setValue = function(pathArr, value) {
    try {
        pathArr = !object.isArray(pathArr) ? [pathArr] : pathArr;
        var parentPath = pathArr.splice(0, pathArr.length -1);
        this.value(parentPath)[pathArr[pathArr.length -1]] = value;
    } catch(e) {
        console.error('set value vector failed - '+this.vectors+' args: '+arguments);
    }
};

Vector.prototype.insert = function(pathArr, value) {
    try {
        pathArr = !object.isArray(pathArr) ? [pathArr] : pathArr;
        var parentPath = pathArr.splice(0, pathArr.length -1);
        this.value(parentPath).splice(pathArr[pathArr.length -1], 0, value);
    } catch(e) {
        console.error('set value vector failed - '+this.vectors+' args: '+arguments);
    }
};

Vector.prototype.length = function() {
    return this.vectors.length;
}

Vector.prototype.remove = function(pathArr) {
    pathArr = !object.isArray(pathArr) ? [pathArr] : pathArr;
    var parentPath = pathArr.splice(0, pathArr.length -1);
    this.value(parentPath).splice(pathArr[pathArr.length -1], 1);
};

Vector.prototype.last = function() {
    return this.vectors[this.vectors.length -1];
};

Vector.prototype.each = function(handler) {
    object.each(this.vectors, function(index, value) {
        handler(index,value);
    });
};

/**
 * Note the indexes can be negative to retrieve values from the end of the vector e.g. -1 is the last
 * @param vectorArr
 * @param args
 * @returns {*}
 */
var getVectorValue = function(vectorArr, args) {
    if(!args) {
        return vectorArr;
    }else if(object.isArray(args)) {
        switch(args.length) {
            case 0:
                return vectorArr;
            case 1:
                return object.valueByIndex(vectorArr, args[0]);
            default:
                var index = args[0];
                return getVectorValue(vectorArr[index], args.splice(1));
        }
    } else {
        return object.valueByIndex(vectorArr, args);
    }
};

/**
 * Checks if the difference between source and target value is lower than the given range value
 */
var checkRangeDiff = function(source, target, range) {
    return isInDiffRange(target, source, range);
};

var isInDiffRange = function(p1, p2, range) {
    return Math.abs(p1 - p2) < range;
};

var getPoint = function(x, y) {
    var result;
    if(x && object.isDefined(x.x) && object.isDefined(x.y)) {
        result = x;
    } else if(!isNaN(x) && !isNaN(y)) {
        result = {
            x : x,
            y : y
        };
    } else if(object.isDefined(x) && object.isDefined(y)) {
        result = toPoint(x,y);
    }
    return result;
};

var toPoint = function(x,y) {
    x = (object.isString(x)) ? parseFloat(x) : x;
    y = (object.isString(y)) ? parseFloat(y) : y;

    return {x:x,y:y};
};

var toRadians = function (angle) {
    return angle * (Math.PI / 180);
};

var toDegrees = function(angle) {
    return angle * (180 / Math.PI);
};

var rotate = function(p, rotCenter, angle) {
    if(angle === 0 || (p.x === rotCenter.x && p.y === rotCenter.y)) {
        return p;
    }

    var rotated = {};
    var rad = toRadians(angle);
    rotated.x = (p.x - rotCenter.x) * Math.cos(rad) - (p.y - rotCenter.y) * Math.sin(rad) + rotCenter.x;
    rotated.y = (p.y - rotCenter.y) * Math.cos(rad) + (p.x - rotCenter.x) * Math.sin(rad) + rotCenter.y;
    p.x = rotated.x;
    p.y = rotated.y;
    return p;
};


module.exports = {
    calcLineIntersection : calcLineIntersection,
    Line : Line,
    Circle : Circle,
    Ellipse : Ellipse,
    Vector : Vector,
    Point : Point,
    isPointInInterval : isPointInInterval,
    minMax : minMax,
    checkRangeDiff : checkRangeDiff,
    getPoint : getPoint,
    bezier : bezier,
    toRadians : toRadians,
    toDegrees : toDegrees,
    rotate : rotate
};
},{"./bezier":75,"./object":77}],77:[function(require,module,exports){
module.exports = {
    each: function() {
        return $.each(arguments[0], arguments[1], arguments[2]);
    },

    grep: function(arr, filter, invert) {
        return $.grep(arr, filter, invert);
    },

    isOneOf: function(search) {
        var i;
        for(i = 1;i < arguments.length;i++) {
          if(search === arguments[i]) {
              return true;
          }
        }
        return false;
    },

    isArray: function(obj) {
        return $.isArray(obj);
    },

    toArray : function(obj) {
        return $.map(obj, function(value, index) {
            return [value];
        });
    },

    removeFromArray: function(arr, item) {
        var index = arr.indexOf(item);
        if(index >= 0) {
            arr.splice(index, 1);
            return true;
        }
        return false;
    },

    size: function(obj) {
        var size = 0, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) size++;
        }
        return size;
    },

    sort: function(obj, sort) {
        var arr;
        if(!obj) {
            return;
        } else if(this.isArray(obj)) {
            arr = obj;
        } else if(this.isObject(obj)) {
            arr = $.map(obj, function (index, val) {
                return obj[val];
            });
        }

        return arr.sort(sort);
    },

    valueByIndex: function(arr, index) {
        var index = this.getIndex(arr,index);
        return arr[index];
    },

    getIndex: function(arr, index) {
        var result = index;
        // for negative indexes we return values counted from the other side so -1 is the last index
        // if the negative index is out of range we return the last index.
        if(index < 0) {
            result = arr.length + index;
            result = (result > arr.length -1 || result < 0) ? arr.length -1 : result;
        }
        return result;
    },

    isFunction: function(obj) {
        return Object.prototype.toString.call(obj) === '[object Function]';
    },

    isObject: function(obj) {
        return $.isPlainObject(obj);
    },

    isJQuery: function(obj) {
        return obj.jquery;
    },

    isString: function(obj) {
        return typeof obj === 'string';
    },

    isNumber: function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    },

    isBoolean: function(obj) {
        return typeof obj === 'boolean';
    },

    isDefined: function(obj) {
        if(arguments.length > 1) {
            var result = true;
            var that = this;
            this.each(arguments, function(index, value) {
                if(!that.isDefined(value)) {
                    result = false;
                    return false;
                }
            });

            return result;
        }
        return typeof obj !== 'undefined';
    },

    merge: function(target, toMerge) {
        return $.merge(target, toMerge);
    },


    addValue: function(target, newVal) {
        if(isArray(newVal)) {
            merge(target);
        } else {
            target.push(newVal);
        }
    },

    extend: function(target, obj1, obj2) {
        return $.extend(target,obj1,obj2);
    },

    cloneArray: function(arr) {
        return arr.slice(0);
    },

    cloneObject: function(oldObject, deep) {
        deep = deep || false;
        return $.extend(deep, {}, oldObject);
    }
    
};
},{}],78:[function(require,module,exports){
var object = require('./object');

exports.endsWith = function(val, suffix) {
    if(!object.isDefined(val) || !object.isDefined(suffix)) {
        return false;
    }
    return val.indexOf(suffix, val.length - suffix.length) !== -1;
};

exports.cutprefix = function(val, prefix) {
   return val.substring(prefix.length, val.length);
};

exports.cutsuffix = function(val, suffix) {
    return val.slice(0, suffix.length * -1);
};

exports.startsWith = function(val, prefix) {
    if(!object.isDefined(val) || !object.isDefined(prefix)) {
        return false;
    }
    return val.indexOf(prefix) === 0;
};
},{"./object":77}],79:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"./../dom/dom":47,"./app":74,"./math":76,"./object":77,"./string":78,"./xml":80,"dup":73,"util":88}],80:[function(require,module,exports){
var string = require('./string');

var serializeToString = function(node) {
    var s = new XMLSerializer();
    node = (node.jQuery) ? node[0] : node;
    return s.serializeToString(node);
};

var parseXML = function(strData) {
    return $.parseXML(strData);
};

var format = function (xml) {
    var intend = -1;
    var result = '';
    xml = xml.replace(/(\r\n|\n|\r)/gm,"");
    var lastWasClose = false;
    var lastHadText = false;
    $.each(xml.split('<'), function(index, node) {
        node = node.trim();
        if(node) {
            if(node.indexOf('/') !== 0) {
                if(!lastWasClose) {
                    intend++;
                }

                lastHadText = !string.endsWith(node, '>');
                lastWasClose = string.endsWith(node, '/>');
            } else {
                if(!lastHadText) {
                    lastWasClose = true;
                    intend--;
                }
                lastHadText = !string.endsWith(node, '>');
            }

            var padding = '';
            for (var i = 0; i < intend; i++) {
                padding += '  ';
            }

            var text;
            if(lastHadText) {
                var splitted = node.split('>');
                node = splitted[0] + '>';
                text = splitted[1];
            }
            result += padding + '<'+node+'\r\n';

            if(text) {
                result += padding + '  ' + text+'\r\n';
            }

        }
    });
    return result;
};

module.exports = {
    serializeToString : serializeToString,
    parseXML : parseXML,
    format: format
};
},{"./string":78}],81:[function(require,module,exports){
var ERROR_CODES = require('./errorCodes');

var DalaError = function(message, code, triggerError) {
    this.name = 'DalaError';
    this.dalaError = true;
    this.error = triggerError
    Error.call(this, message);
    this.message = message;
    this.code = code || ERROR_CODES.UNKNOWN_APP_ERROR;
};

DalaError.CODES = ERROR_CODES;
DalaError.prototype = Object.create(Error.prototype);
DalaError.prototype.constructor = DalaError;

DalaError.prototype.log = function() {

};

module.exports = DalaError;
},{"./errorCodes":82}],82:[function(require,module,exports){
module.exports = {
    UNKNOWN_APP_ERROR : 1,
    UNKNOWN_DB_ERROR : 2,
    FILESYSTEM_ERROR: 3,
    LOGIN_REQUIRED : 100,
    ACCESS_DENIED : 101,
    USER_LOGIN_INCORRECT_PASSWORD : 1000,
    USER_LOGIN_INVALID_EMAIL : 1001,
    DB_DUPLICATE : 11000 //We just adopt the mongoose duplicate errorcode
};
},{}],83:[function(require,module,exports){
(function (process,global,setImmediate){
/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2018 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 3.5.2
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};

},{}],2:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule");
var Queue = _dereq_("./queue");
var util = _dereq_("./util");

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};


Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
            "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

function _drainQueue(queue) {
    while (queue.length() > 0) {
        _drainQueueStep(queue);
    }
}

function _drainQueueStep(queue) {
    var fn = queue.shift();
    if (typeof fn !== "function") {
        fn._settlePromises();
    } else {
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
}

Async.prototype._drainQueues = function () {
    _drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    _drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
var calledBind = false;
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (((this._bitField & 50397184) === 0)) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    if (!calledBind) {
        calledBind = true;
        Promise.prototype._propagateFrom = debug.propagateFromFunction();
        Promise.prototype._boundValue = debug.boundValueFunction();
    }
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~2097152);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 2097152) === 2097152;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};
};

},{}],4:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise":22}],5:[function(_dereq_,module,exports){
"use strict";
var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function(Promise) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (!true) {
var makeMethodCaller = function (methodName) {
    return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
};

var makeGetter = function (propertyName) {
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
};

var getCompiled = function(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== "function") {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        }
    }
    return ret;
};

getMethodCaller = function(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
};

getGetter = function(name) {
    return getCompiled(name, makeGetter, getterCache);
};
}

function ensureMethod(obj, methodName) {
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj) + " has no method '" +
            util.toString(methodName) + "'";
        throw new Promise.TypeError(message);
    }
    return fn;
}

function caller(obj) {
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var args = [].slice.call(arguments, 1);;
    if (!true) {
        if (canEvaluate) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            }
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};

},{"./util":36}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype["break"] = Promise.prototype.cancel = function() {
    if (!debug.cancellation()) return this._warn("cancellation is disabled");

    var promise = this;
    var child = promise;
    while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
                child._followee().cancel();
            } else {
                child._cancelBranched();
            }
            break;
        }

        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
                promise._followee().cancel();
            } else {
                promise._cancelBranched();
            }
            break;
        } else {
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
        }
    }
};

Promise.prototype._branchHasCancelled = function() {
    this._branchesRemainingToCancel--;
};

Promise.prototype._enoughBranchesHaveCancelled = function() {
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel <= 0;
};

Promise.prototype._cancelBy = function(canceller) {
    if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
        }
    }
    return false;
};

Promise.prototype._cancelBranched = function() {
    if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
    }
};

Promise.prototype._cancel = function() {
    if (!this._isCancellable()) return;
    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
};

Promise.prototype._cancelPromises = function() {
    if (this._length() > 0) this._settlePromises();
};

Promise.prototype._unsetOnCancel = function() {
    this._onCancelField = undefined;
};

Promise.prototype._isCancellable = function() {
    return this.isPending() && !this._isCancelled();
};

Promise.prototype.isCancellable = function() {
    return this.isPending() && !this.isCancelled();
};

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
    if (util.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
    } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                }
            }
        } else {
            onCancelCallback._resultCancelled(this);
        }
    }
};

Promise.prototype._invokeOnCancel = function() {
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
};

Promise.prototype._invokeInternalOnCancel = function() {
    if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    }
};

Promise.prototype._resultCancelled = function() {
    this.cancel();
};

};

},{"./util":36}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util");
var getKeys = _dereq_("./es5").keys;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function catchFilter(instances, cb, promise) {
    return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];

            if (item === Error ||
                (item != null && item.prototype instanceof Error)) {
                if (e instanceof item) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (typeof item === "function") {
                var matchesPredicate = tryCatch(item).call(boundTo, e);
                if (matchesPredicate === errorObj) {
                    return matchesPredicate;
                } else if (matchesPredicate) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                    var key = keys[j];
                    if (item[key] != e[key]) {
                        continue predicateLoop;
                    }
                }
                return tryCatch(cb).call(boundTo, e);
            }
        }
        return NEXT_FILTER;
    };
}

return catchFilter;
};

},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var longStackTraces = false;
var contextStack = [];

Promise.prototype._promiseCreated = function() {};
Promise.prototype._pushContext = function() {};
Promise.prototype._popContext = function() {return null;};
Promise._peekContext = Promise.prototype._peekContext = function() {};

function Context() {
    this._trace = new Context.CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
    }
    return null;
};

function createContext() {
    if (longStackTraces) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}
Context.CapturedTrace = null;
Context.create = createContext;
Context.deactivateLongStackTraces = function() {};
Context.activateLongStackTraces = function() {
    var Promise_pushContext = Promise.prototype._pushContext;
    var Promise_popContext = Promise.prototype._popContext;
    var Promise_PeekContext = Promise._peekContext;
    var Promise_peekContext = Promise.prototype._peekContext;
    var Promise_promiseCreated = Promise.prototype._promiseCreated;
    Context.deactivateLongStackTraces = function() {
        Promise.prototype._pushContext = Promise_pushContext;
        Promise.prototype._popContext = Promise_popContext;
        Promise._peekContext = Promise_PeekContext;
        Promise.prototype._peekContext = Promise_peekContext;
        Promise.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
    };
    longStackTraces = true;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    Promise._peekContext = Promise.prototype._peekContext = peekContext;
    Promise.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
    };
};
return Context;
};

},{}],9:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, Context) {
var getDomain = Promise._getDomain;
var async = Promise._async;
var Warning = _dereq_("./errors").Warning;
var util = _dereq_("./util");
var es5 = _dereq_("./es5");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var printWarning;
var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
                        (true ||
                         util.env("BLUEBIRD_DEBUG") ||
                         util.env("NODE_ENV") === "development"));

var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
    (debugging || util.env("BLUEBIRD_WARNINGS")));

var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

Promise.prototype.suppressUnhandledRejections = function() {
    var target = this._target();
    target._bitField = ((target._bitField & (~1048576)) |
                      524288);
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 524288) !== 0) return;
    this._setRejectionIsUnhandled();
    var self = this;
    setTimeout(function() {
        self._notifyUnhandledRejection();
    }, 1);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._setReturnedNonUndefined = function() {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._returnedNonUndefined = function() {
    return (this._bitField & 268435456) !== 0;
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 262144;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~262144);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 262144) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 1048576;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~1048576);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
    return warn(message, shouldUseOwnTrace, promise || this);
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

var disableLongStackTraces = function() {};
Promise.longStackTraces = function () {
    if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
        var Promise_dereferenceTrace = Promise.prototype._dereferenceTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            }
            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Promise.prototype._dereferenceTrace = Promise_dereferenceTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
        };
        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Promise.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return config.longStackTraces && longStackTracesIsSupported();
};

var fireDomEvent = (function() {
    try {
        if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var eventData = {
                    detail: event,
                    cancelable: true
                };
                es5.defineProperty(
                    eventData, "promise", {value: event.promise});
                es5.defineProperty(eventData, "reason", {value: event.reason});
                var domEvent = new CustomEvent(name.toLowerCase(), eventData);
                return !util.global.dispatchEvent(domEvent);
            };
        } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new Event(name.toLowerCase(), {
                    cancelable: true
                });
                domEvent.detail = event;
                es5.defineProperty(domEvent, "promise", {value: event.promise});
                es5.defineProperty(domEvent, "reason", {value: event.reason});
                return !util.global.dispatchEvent(domEvent);
            };
        } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = document.createEvent("CustomEvent");
                domEvent.initCustomEvent(name.toLowerCase(), false, true,
                    event);
                return !util.global.dispatchEvent(domEvent);
            };
        }
    } catch (e) {}
    return function() {
        return false;
    };
})();

var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function() {
            return process.emit.apply(process, arguments);
        };
    } else {
        if (!util.global) {
            return function() {
                return false;
            };
        }
        return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method) return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
        };
    }
})();

function generatePromiseLifecycleEventObject(name, promise) {
    return {promise: promise};
}

var eventToObjectGenerator = {
    promiseCreated: generatePromiseLifecycleEventObject,
    promiseFulfilled: generatePromiseLifecycleEventObject,
    promiseRejected: generatePromiseLifecycleEventObject,
    promiseResolved: generatePromiseLifecycleEventObject,
    promiseCancelled: generatePromiseLifecycleEventObject,
    promiseChained: function(name, promise, child) {
        return {promise: promise, child: child};
    },
    warning: function(name, warning) {
        return {warning: warning};
    },
    unhandledRejection: function (name, reason, promise) {
        return {reason: reason, promise: promise};
    },
    rejectionHandled: generatePromiseLifecycleEventObject
};

var activeFireEvent = function (name) {
    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
    } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
    }

    var domEventFired = false;
    try {
        domEventFired = fireDomEvent(name,
                    eventToObjectGenerator[name].apply(null, arguments));
    } catch (e) {
        async.throwLater(e);
        domEventFired = true;
    }

    return domEventFired || globalEventFired;
};

Promise.config = function(opts) {
    opts = Object(opts);
    if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
            Promise.longStackTraces();
        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;

        if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
        }
    }
    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
            throw new Error(
                "cannot enable cancellation after promises are in use");
        }
        Promise.prototype._clearCancellationData =
            cancellationClearCancellationData;
        Promise.prototype._propagateFrom = cancellationPropagateFrom;
        Promise.prototype._onCancel = cancellationOnCancel;
        Promise.prototype._setOnCancel = cancellationSetOnCancel;
        Promise.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        Promise.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
    }
    if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise.prototype._fireEvent = defaultFireEvent;
        }
    }
    return Promise;
};

function defaultFireEvent() { return false; }

Promise.prototype._fireEvent = defaultFireEvent;
Promise.prototype._execute = function(executor, resolve, reject) {
    try {
        executor(resolve, reject);
    } catch (e) {
        return e;
    }
};
Promise.prototype._onCancel = function () {};
Promise.prototype._setOnCancel = function (handler) { ; };
Promise.prototype._attachCancellationCallback = function(onCancel) {
    ;
};
Promise.prototype._captureStackTrace = function () {};
Promise.prototype._attachExtraTrace = function () {};
Promise.prototype._dereferenceTrace = function () {};
Promise.prototype._clearCancellationData = function() {};
Promise.prototype._propagateFrom = function (parent, flags) {
    ;
    ;
};

function cancellationExecute(executor, resolve, reject) {
    var promise = this;
    try {
        executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } catch (e) {
        return e;
    }
}

function cancellationAttachCancellationCallback(onCancel) {
    if (!this._isCancellable()) return this;

    var previousOnCancel = this._onCancel();
    if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } else {
            this._setOnCancel([previousOnCancel, onCancel]);
        }
    } else {
        this._setOnCancel(onCancel);
    }
}

function cancellationOnCancel() {
    return this._onCancelField;
}

function cancellationSetOnCancel(onCancel) {
    this._onCancelField = onCancel;
}

function cancellationClearCancellationData() {
    this._cancellationParent = undefined;
    this._onCancelField = undefined;
}

function cancellationPropagateFrom(parent, flags) {
    if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
            branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
    }
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}

function bindingPropagateFrom(parent, flags) {
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}
var propagateFromFunction = bindingPropagateFrom;

function boundValueFunction() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
}

function longStackTracesCaptureStackTrace() {
    this._trace = new CapturedTrace(this._peekContext());
}

function longStackTracesAttachExtraTrace(error, ignoreSelf) {
    if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
}

function longStackTracesDereferenceTrace() {
    this._trace = undefined;
}

function checkForgottenReturns(returnValue, promiseCreated, name, promise,
                               parent) {
    if (returnValue === undefined && promiseCreated !== null &&
        wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined()) return;
        if ((promise._bitField & 65535) === 0) return;

        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
                var line = stack[i];
                if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                        handlerLine  = "at " + lineMatches[1] +
                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                }
            }

            if (stack.length > 0) {
                var firstUserLine = stack[0];
                for (var i = 0; i < traceLines.length; ++i) {

                    if (traceLines[i] === firstUserLine) {
                        if (i > 0) {
                            creatorLine = "\n" + traceLines[i - 1];
                        }
                        break;
                    }
                }

            }
        }
        var msg = "a promise was created in a " + name +
            "handler " + handlerLine + "but was not returned from it, " +
            "see http://goo.gl/rRqMUw" +
            creatorLine;
        promise._warn(msg, true, promiseCreated);
    }
}

function deprecated(name, replacement) {
    var message = name +
        " is deprecated and will be removed in a future version.";
    if (replacement) message += " Use " + replacement + " instead.";
    return warn(message);
}

function warn(message, shouldUseOwnTrace, promise) {
    if (!config.warnings) return;
    var warning = new Warning(message);
    var ctx;
    if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }

    if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
    }
}

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line ||
            stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
    }
    return stack;
}

function parseStackAndMessage(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
    };
}

function formatAndLogError(error, title, isSoft) {
    if (typeof console !== "undefined") {
        var message;
        if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof printWarning === "function") {
            printWarning(message, isSoft);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
}

function fireRejectionEvent(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
        }
    } else {
        activeFireEvent(name, promise);
    }
}

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj && typeof obj.toString === "function"
            ? obj.toString() : util.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

function longStackTracesIsSupported() {
    return typeof captureStackTrace === "function";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}

function setBounds(firstLineError, lastLineError) {
    if (!longStackTracesIsSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
}

function CapturedTrace(parent) {
    this._parent = parent;
    this._promisesCreated = 0;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit += 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit -= 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    printWarning = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
            console.warn(color + message + "\u001b[0m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        printWarning = function(message, isSoft) {
            console.warn("%c" + message,
                        isSoft ? "color: darkorange" : "color: red");
        };
    }
}

var config = {
    warnings: warnings,
    longStackTraces: false,
    cancellation: false,
    monitoring: false
};

if (longStackTraces) Promise.longStackTraces();

return {
    longStackTraces: function() {
        return config.longStackTraces;
    },
    warnings: function() {
        return config.warnings;
    },
    cancellation: function() {
        return config.cancellation;
    },
    monitoring: function() {
        return config.monitoring;
    },
    propagateFromFunction: function() {
        return propagateFromFunction;
    },
    boundValueFunction: function() {
        return boundValueFunction;
    },
    checkForgottenReturns: checkForgottenReturns,
    setBounds: setBounds,
    warn: warn,
    deprecated: deprecated,
    CapturedTrace: CapturedTrace,
    fireDomEvent: fireDomEvent,
    fireGlobalEvent: fireGlobalEvent
};
};

},{"./errors":12,"./es5":13,"./util":36}],10:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function returner() {
    return this.value;
}
function thrower() {
    throw this.reason;
}

Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value instanceof Promise) value.suppressUnhandledRejections();
    return this._then(
        returner, undefined, undefined, {value: value}, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    return this._then(
        thrower, undefined, undefined, {reason: reason}, undefined);
};

Promise.prototype.catchThrow = function (reason) {
    if (arguments.length <= 1) {
        return this._then(
            undefined, thrower, undefined, {reason: reason}, undefined);
    } else {
        var _reason = arguments[1];
        var handler = function() {throw _reason;};
        return this.caught(reason, handler);
    }
};

Promise.prototype.catchReturn = function (value) {
    if (arguments.length <= 1) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(
            undefined, returner, undefined, {value: value}, undefined);
    } else {
        var _value = arguments[1];
        if (_value instanceof Promise) _value.suppressUnhandledRejections();
        var handler = function() {return _value;};
        return this.caught(value, handler);
    }
};
};

},{}],11:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;
var PromiseAll = Promise.all;

function promiseAllThis() {
    return PromiseAll(this);
}

function PromiseMapSeries(promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
}

Promise.prototype.each = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, 0)
              ._then(promiseAllThis, undefined, undefined, this, undefined);
};

Promise.prototype.mapSeries = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, 0)
              ._then(promiseAllThis, undefined, undefined, promises, undefined);
};

Promise.mapSeries = PromiseMapSeries;
};


},{}],12:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],14:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};

},{}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
var util = _dereq_("./util");
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

function PassThroughHandlerContext(promise, type, handler) {
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
}

PassThroughHandlerContext.prototype.isFinallyHandler = function() {
    return this.type === 0;
};

function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
            return ret;
        } else if (ret !== undefined) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== "function") return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};


Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

Promise.prototype.tapCatch = function (handlerOrPredicate) {
    var len = arguments.length;
    if(len === 1) {
        return this._passThrough(handlerOrPredicate,
                                 1,
                                 undefined,
                                 finallyHandler);
    } else {
         var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(new TypeError(
                    "tapCatch statement predicate: "
                    + "expecting an object but got " + util.classString(item)
                ));
            }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this),
                                 1,
                                 undefined,
                                 finallyHandler);
    }

};

return PassThroughHandlerContext;
};

},{"./catch_filter":7,"./util":36}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise,
                          Proxyable,
                          debug) {
var errors = _dereq_("./errors");
var TypeError = errors.TypeError;
var util = _dereq_("./util");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    for (var i = 0; i < yieldHandlers.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
            traceParent._pushContext();
            var ret = Promise.reject(errorObj.e);
            traceParent._popContext();
            return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    if (debug.cancellation()) {
        var internal = new Promise(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
        this._promise = internal.lastly(function() {
            return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
    } else {
        var promise = this._promise = new Promise(INTERNAL);
        promise._captureStackTrace();
    }
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === "function"
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
    this._yieldedPromise = null;
    this._cancellationPhase = false;
}
util.inherits(PromiseSpawn, Proxyable);

PromiseSpawn.prototype._isResolved = function() {
    return this._promise === null;
};

PromiseSpawn.prototype._cleanup = function() {
    this._promise = this._generator = null;
    if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
    }
};

PromiseSpawn.prototype._promiseCancelled = function() {
    if (this._isResolved()) return;
    var implementsReturn = typeof this._generator["return"] !== "undefined";

    var result;
    if (!implementsReturn) {
        var reason = new Promise.CancellationError(
            "generator .return() sentinel");
        Promise.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(this._generator,
                                                         reason);
        this._promise._popContext();
    } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(this._generator,
                                                          undefined);
        this._promise._popContext();
    }
    this._cancellationPhase = true;
    this._yieldedPromise = null;
    this._continue(result);
};

PromiseSpawn.prototype._promiseFulfilled = function(value) {
    this._yieldedPromise = null;
    this._promise._pushContext();
    var result = tryCatch(this._generator.next).call(this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._promiseRejected = function(reason) {
    this._yieldedPromise = null;
    this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch(this._generator["throw"])
        .call(this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._resultCancelled = function() {
    if (this._yieldedPromise instanceof Promise) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
    }
};

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._promiseFulfilled(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    var promise = this._promise;
    if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
            return promise.cancel();
        } else {
            return promise._rejectCallback(result.e, false);
        }
    }

    var value = result.value;
    if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
            return promise.cancel();
        } else {
            return promise._resolveCallback(value);
        }
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._promiseRejected(
                    new TypeError(
                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", String(value)) +
                        "From coroutine:\u000a" +
                        this._stack.split("\n").slice(1, -7).join("\n")
                    )
                );
                return;
            }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        ;
        if (((bitField & 50397184) === 0)) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
        } else if (((bitField & 33554432) !== 0)) {
            Promise._async.invoke(
                this._promiseFulfilled, this, maybePromise._value()
            );
        } else if (((bitField & 16777216) !== 0)) {
            Promise._async.invoke(
                this._promiseRejected, this, maybePromise._reason()
            );
        } else {
            this._promiseCancelled();
        }
    }
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== "function") {
        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(undefined);
        return ret;
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
    if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};

},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
         getDomain) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var promiseSetter = function(i) {
        return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
    };

    var generateHolderClass = function(total) {
        var props = new Array(total);
        for (var i = 0; i < props.length; ++i) {
            props[i] = "this.p" + (i+1);
        }
        var assignment = props.join(" = ") + " = null;";
        var cancellationCode= "var promise;\n" + props.map(function(prop) {
            return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
        }).join("\n");
        var passedArguments = props.join(", ");
        var name = "Holder$" + total;


        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

        code = code.replace(/\[TheName\]/g, name)
            .replace(/\[TheTotal\]/g, total)
            .replace(/\[ThePassedArguments\]/g, passedArguments)
            .replace(/\[TheProperties\]/g, assignment)
            .replace(/\[CancellationCode\]/g, cancellationCode);

        return new Function("tryCatch", "errorObj", "Promise", "async", code)
                           (tryCatch, errorObj, Promise, async);
    };

    var holderClasses = [];
    var thenCallbacks = [];
    var promiseSetters = [];

    for (var i = 0; i < 8; ++i) {
        holderClasses.push(generateHolderClass(i + 1));
        thenCallbacks.push(thenCallback(i + 1));
        promiseSetters.push(promiseSetter(i + 1));
    }

    reject = function (reason) {
        this._reject(reason);
    };
}}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last <= 8 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var HolderClass = holderClasses[last - 1];
                var holder = new HolderClass(fn);
                var callbacks = thenCallbacks;

                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField & 50397184) === 0)) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                            promiseSetters[i](maybePromise, holder);
                            holder.asyncNeeded = false;
                        } else if (((bitField & 33554432) !== 0)) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else if (((bitField & 16777216) !== 0)) {
                            ret._reject(maybePromise._reason());
                        } else {
                            ret._cancel();
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }

                if (!ret._isFateSealed()) {
                    if (holder.asyncNeeded) {
                        var domain = getDomain();
                        if (domain !== null) {
                            holder.fn = util.domainBind(domain, holder.fn);
                        }
                    }
                    ret._setAsyncGuaranteed();
                    ret._setOnCancel(holder);
                }
                return ret;
            }
        }
    }
    var args = [].slice.call(arguments);;
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util":36}],18:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    var domain = getDomain();
    this._callback = domain === null ? fn : util.domainBind(domain, fn);
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = [];
    async.invoke(this._asyncInit, this, undefined);
}
util.inherits(MappingPromiseArray, PromiseArray);

MappingPromiseArray.prototype._asyncInit = function() {
    this._init$(undefined, -2);
};

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;

    if (index < 0) {
        index = (index * -1) - 1;
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return true;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var promise = this._promise;
        var callback = this._callback;
        var receiver = promise._boundValue();
        promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(
            ret,
            promiseCreated,
            preservedValues !== null ? "Promise.filter" : "Promise.map",
            promise
        );
        if (ret === errorObj) {
            this._reject(ret.e);
            return true;
        }

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if (((bitField & 50397184) === 0)) {
                if (limit >= 1) this._inFlight++;
                values[index] = maybePromise;
                maybePromise._proxy(this, (index + 1) * -1);
                return false;
            } else if (((bitField & 33554432) !== 0)) {
                ret = maybePromise._value();
            } else if (((bitField & 16777216) !== 0)) {
                this._reject(maybePromise._reason());
                return true;
            } else {
                this._cancel();
                return true;
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }
        return true;
    }
    return false;
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }

    var limit = 0;
    if (options !== undefined) {
        if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
                return Promise.reject(
                    new TypeError("'concurrency' must be a number but it is " +
                                    util.classString(options.concurrency)));
            }
            limit = options.concurrency;
        } else {
            return Promise.reject(new TypeError(
                            "options argument must be an object but it is " +
                             util.classString(options)));
        }
    }
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
}

Promise.prototype.map = function (fn, options) {
    return map(this, fn, options, null);
};

Promise.map = function (promises, fn, options, _filter) {
    return map(promises, fn, options, _filter);
};


};

},{"./util":36}],19:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    } else {
        value = tryCatch(fn)();
    }
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, "Promise.try", ret);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util":36}],20:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors");
var OperationalError = errors.OperationalError;
var es5 = _dereq_("./es5");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var args = [].slice.call(arguments, 1);;
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var util = _dereq_("./util");
var async = Promise._async;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret =
        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundValue();
    var ret = val === undefined
        ? tryCatch(nodeback).call(receiver, null)
        : tryCatch(nodeback).call(receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
                                                                     options) {
    if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};

},{"./util":36}],22:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var reflectHandler = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
function Proxyable() {}
var UNDEFINED_BINDING = {};
var util = _dereq_("./util");

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var es5 = _dereq_("./es5");
var Async = _dereq_("./async");
var async = new Async();
es5.defineProperty(Promise, "_async", {value: async});
var errors = _dereq_("./errors");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
var CancellationError = Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {};
var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array")(Promise, INTERNAL,
                               tryConvertToPromise, apiRejection, Proxyable);
var Context = _dereq_("./context")(Promise);
 /*jshint unused:false*/
var createContext = Context.create;
var debug = _dereq_("./debuggability")(Promise, Context);
var CapturedTrace = debug.CapturedTrace;
var PassThroughHandlerContext =
    _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER);
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
var nodebackForPromise = _dereq_("./nodeback");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function check(self, executor) {
    if (self == null || self.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (typeof executor !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(executor));
    }

}

function Promise(executor) {
    if (executor !== INTERNAL) {
        check(this, executor);
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._resolveFromExecutor(executor);
    this._promiseCreated();
    this._fireEvent("promiseCreated", this);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return apiRejection("Catch statement predicate: " +
                    "expecting an object but got " + util.classString(item));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
    }
    return this.then(undefined, fn);
};

Promise.prototype.reflect = function () {
    return this._then(reflectHandler,
        reflectHandler, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject) {
    if (debug.warnings() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, undefined, undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject) {
    var promise =
        this._then(didFulfill, didReject, undefined, undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
    }
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.getNewLibraryCopy = module.exports;

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = Promise.fromCallback = function(fn) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
                                         : false;
    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true);
    }
    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    return async.setScheduler(fn);
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    _,    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
    var target = this._target();
    var bitField = target._bitField;

    if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined &&
            ((this._bitField & 2097152) !== 0)) {
            if (!((bitField & 50397184) === 0)) {
                receiver = this._boundValue();
            } else {
                receiver = target === this ? undefined : this._boundTo;
            }
        }
        this._fireEvent("promiseChained", this, promise);
    }

    var domain = getDomain();
    if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if (((bitField & 33554432) !== 0)) {
            value = target._rejectionHandler0;
            handler = didFulfill;
        } else if (((bitField & 16777216) !== 0)) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
        } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
        }

        async.invoke(settler, target, {
            handler: domain === null ? handler
                : (typeof handler === "function" &&
                    util.domainBind(domain, handler)),
            promise: promise,
            receiver: receiver,
            value: value
        });
    } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
    }

    return promise;
};

Promise.prototype._length = function () {
    return this._bitField & 65535;
};

Promise.prototype._isFateSealed = function () {
    return (this._bitField & 117506048) !== 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 67108864) === 67108864;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -65536) |
        (len & 65535);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 33554432;
    this._fireEvent("promiseFulfilled", this);
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 16777216;
    this._fireEvent("promiseRejected", this);
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 67108864;
    this._fireEvent("promiseResolved", this);
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._unsetCancelled = function() {
    this._bitField = this._bitField & (~65536);
};

Promise.prototype._setCancelled = function() {
    this._bitField = this._bitField | 65536;
    this._fireEvent("promiseCancelled", this);
};

Promise.prototype._setWillBeCancelled = function() {
    this._bitField = this._bitField | 8388608;
};

Promise.prototype._setAsyncGuaranteed = function() {
    if (async.hasCustomScheduler()) return;
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0 ? this._receiver0 : this[
            index * 4 - 4 + 3];
    if (ret === UNDEFINED_BINDING) {
        return undefined;
    } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return this[
            index * 4 - 4 + 2];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 1];
};

Promise.prototype._boundValue = function() {};

Promise.prototype._migrateCallback0 = function (follower) {
    var bitField = follower._bitField;
    var fulfill = follower._fulfillmentHandler0;
    var reject = follower._rejectionHandler0;
    var promise = follower._promise0;
    var receiver = follower._receiverAt(0);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._migrateCallbackAt = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._proxy = function (proxyable, arg) {
    this._addCallbacks(undefined, undefined, arg, proxyable, null);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (((this._bitField & 117506048) !== 0)) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    if (shouldBind) this._propagateFrom(maybePromise, 2);

    var promise = maybePromise._target();

    if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
    }

    var bitField = promise._bitField;
    if (((bitField & 50397184) === 0)) {
        var len = this._length();
        if (len > 0) promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (((bitField & 33554432) !== 0)) {
        this._fulfill(promise._value());
    } else if (((bitField & 16777216) !== 0)) {
        this._reject(promise._reason());
    } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, ignoreNonErrorWarnings) {
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " +
            util.classString(reason);
        this._warn(message, true);
    }
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason);
};

Promise.prototype._resolveFromExecutor = function (executor) {
    if (executor === INTERNAL) return;
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
    }, function (reason) {
        promise._rejectCallback(reason, synchronous);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined) {
        promise._rejectCallback(r, true);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    var bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError("cannot .spread() a non-array: " +
                                    util.classString(value));
        } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
        }
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    var promiseCreated = promise._popContext();
    bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;

    if (x === NEXT_FILTER) {
        promise._reject(value);
    } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
    } else {
        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
    var isPromise = promise instanceof Promise;
    var bitField = this._bitField;
    var asyncGuaranteed = ((bitField & 134217728) !== 0);
    if (((bitField & 65536) !== 0)) {
        if (isPromise) promise._invokeInternalOnCancel();

        if (receiver instanceof PassThroughHandlerContext &&
            receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
            }
        } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
        } else {
            receiver.cancel();
        }
    } else if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
            if (((bitField & 33554432) !== 0)) {
                receiver._promiseFulfilled(value, promise);
            } else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (asyncGuaranteed) promise._setAsyncGuaranteed();
        if (((bitField & 33554432) !== 0)) {
            promise._fulfill(value);
        } else {
            promise._reject(value);
        }
    }
};

Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
    var handler = ctx.handler;
    var promise = ctx.promise;
    var receiver = ctx.receiver;
    var value = ctx.value;
    if (typeof handler === "function") {
        if (!(promise instanceof Promise)) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (promise instanceof Promise) {
        promise._reject(value);
    }
};

Promise.prototype._settlePromiseCtx = function(ctx) {
    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
};

Promise.prototype._settlePromise0 = function(handler, value, bitField) {
    var promise = this._promise0;
    var receiver = this._receiverAt(0);
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settlePromise(promise, handler, receiver, value);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    var base = index * 4 - 4;
    this[base + 2] =
    this[base + 3] =
    this[base + 0] =
    this[base + 1] = undefined;
};

Promise.prototype._fulfill = function (value) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
    }
    this._setFulfilled();
    this._rejectionHandler0 = value;

    if ((bitField & 65535) > 0) {
        if (((bitField & 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
        this._dereferenceTrace();
    }
};

Promise.prototype._reject = function (reason) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    this._setRejected();
    this._fulfillmentHandler0 = reason;

    if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
    }

    if ((bitField & 65535) > 0) {
        async.settlePromises(this);
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._fulfillPromises = function (len, value) {
    for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
    }
};

Promise.prototype._rejectPromises = function (len, reason) {
    for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
    }
};

Promise.prototype._settlePromises = function () {
    var bitField = this._bitField;
    var len = (bitField & 65535);

    if (len > 0) {
        if (((bitField & 16842752) !== 0)) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
        } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
        }
        this._setLength(0);
    }
    this._clearCancellationData();
};

Promise.prototype._settledValue = function() {
    var bitField = this._bitField;
    if (((bitField & 33554432) !== 0)) {
        return this._rejectionHandler0;
    } else if (((bitField & 16777216) !== 0)) {
        return this._fulfillmentHandler0;
    }
};

function deferResolve(v) {this.promise._resolveCallback(v);}
function deferReject(v) {this.promise._rejectCallback(v, false);}

Promise.defer = Promise.pending = function() {
    debug.deprecated("Promise.defer", "new Promise");
    var promise = new Promise(INTERNAL);
    return {
        promise: promise,
        resolve: deferResolve,
        reject: deferReject
    };
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
    debug);
_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
_dereq_("./direct_resolve")(Promise);
_dereq_("./synchronous_inspection")(Promise);
_dereq_("./join")(
    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
Promise.Promise = Promise;
Promise.version = "3.5.2";
_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
_dereq_('./call_get.js')(Promise);
_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
_dereq_('./timers.js')(Promise, INTERNAL, debug);
_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
_dereq_('./nodeify.js')(Promise);
_dereq_('./promisify.js')(Promise, INTERNAL);
_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
_dereq_('./settle.js')(Promise, PromiseArray, debug);
_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
_dereq_('./filter.js')(Promise, INTERNAL);
_dereq_('./each.js')(Promise, INTERNAL);
_dereq_('./any.js')(Promise);
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    debug.setBounds(Async.firstLineError, util.lastLineError);               
    return Promise;                                                          

};

},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection, Proxyable) {
var util = _dereq_("./util");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    case -6: return new Map();
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    if (values instanceof Promise) {
        promise._propagateFrom(values, 3);
    }
    promise._setOnCancel(this);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
util.inherits(PromiseArray, Proxyable);

PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;

        if (((bitField & 50397184) === 0)) {
            this._promise._setAsyncGuaranteed();
            return values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
        } else if (((bitField & 33554432) !== 0)) {
            values = values._value();
        } else if (((bitField & 16777216) !== 0)) {
            return this._reject(values._reason());
        } else {
            return this._cancel();
        }
    }
    values = util.asArray(values);
    if (values === null) {
        var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    this._iterate(values);
};

PromiseArray.prototype._iterate = function(values) {
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var result = this._promise;
    var isResolved = false;
    var bitField = null;
    for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);

        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
        } else {
            bitField = null;
        }

        if (isResolved) {
            if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
            }
        } else if (bitField !== null) {
            if (((bitField & 50397184) === 0)) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
            } else if (((bitField & 33554432) !== 0)) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if (((bitField & 16777216) !== 0)) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
                isResolved = this._promiseCancelled(i);
            }
        } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
        }
    }
    if (!isResolved) result._setAsyncGuaranteed();
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype._cancel = function() {
    if (this._isResolved() || !this._promise._isCancellable()) return;
    this._values = null;
    this._promise._cancel();
};

PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false);
};

PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

PromiseArray.prototype._promiseCancelled = function() {
    this._cancel();
    return true;
};

PromiseArray.prototype._promiseRejected = function (reason) {
    this._totalResolved++;
    this._reject(reason);
    return true;
};

PromiseArray.prototype._resultCancelled = function() {
    if (this._isResolved()) return;
    var values = this._values;
    this._cancel();
    if (values instanceof Promise) {
        values.cancel();
    } else {
        for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise) {
                values[i].cancel();
            }
        }
    }
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util":36}],24:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = _dereq_("./util");
var nodebackForPromise = _dereq_("./nodeback");
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = _dereq_("./errors").TypeError;
var defaultSuffix = "Async";
var defaultPromisified = {__isPromisified__: true};
var noCopyProps = [
    "arity",    "length",
    "name",
    "arguments",
    "caller",
    "callee",
    "prototype",
    "__isPromisified__"
];
var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

var defaultFilter = function(name) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        name !== "constructor";
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, "\\$");
};

var makeNodePromisifiedEval;
if (!true) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i >= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, "_arg", "");
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), "_arg", "");
};

var parameterCount = function(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn, _, multiArgs) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(", ");
        var comma = count > 0 ? ", " : "";
        var ret;
        if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
        } else {
            ret = receiver === undefined
                ? "ret = callback({{args}}, nodeback); break;\n"
                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        var ret = "";
        for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis
                                ? "ret = callback.apply(this, args);\n"
                                : "ret = callback.apply(receiver, args);\n"));
        return ret;
    }

    var getFunctionCode = typeof callback === "string"
                                ? ("this != null ? this['"+callback+"'] : fn")
                                : "fn";
    var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
        .replace("[GetFunctionCode]", getFunctionCode);
    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
    return new Function("Promise",
                        "fn",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "tryCatch",
                        "errorObj",
                        "notEnumerableProp",
                        "INTERNAL",
                        body)(
                    Promise,
                    fn,
                    receiver,
                    withAppended,
                    maybeWrapAsError,
                    nodebackForPromise,
                    util.tryCatch,
                    util.errorObj,
                    util.notEnumerableProp,
                    INTERNAL);
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === "string") {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise, multiArgs);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
        return promise;
    }
    util.notEnumerableProp(promisified, "__isPromisified__", true);
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i < len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] =
                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
            var promisified = promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key,
                                           fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj[promisifiedKey] = promisified;
        }
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver, multiArgs) {
    return makeNodePromisified(callback, receiver, undefined,
                                callback, null, multiArgs);
}

Promise.promisify = function (fn, options) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    if (isPromisified(fn)) {
        return fn;
    }
    options = Object(options);
    var receiver = options.context === undefined ? THIS : options.context;
    var multiArgs = !!options.multiArgs;
    var ret = promisify(fn, receiver, multiArgs);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    options = Object(options);
    var multiArgs = !!options.multiArgs;
    var suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier,
                multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
};
};


},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util");
var isObject = util.isObject;
var es5 = _dereq_("./es5");
var Es6Map;
if (typeof Map === "function") Es6Map = Map;

var mapToEntries = (function() {
    var index = 0;
    var size = 0;

    function extractEntry(value, key) {
        this[index] = value;
        this[index + size] = key;
        index++;
    }

    return function mapToEntries(map) {
        size = map.size;
        index = 0;
        var ret = new Array(map.size * 2);
        map.forEach(extractEntry, ret);
        return ret;
    };
})();

var entriesToMap = function(entries) {
    var ret = new Es6Map();
    var length = entries.length / 2 | 0;
    for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
    }
    return ret;
};

function PropertiesPromiseArray(obj) {
    var isMap = false;
    var entries;
    if (Es6Map !== undefined && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
    } else {
        var keys = es5.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj[key];
            entries[i + len] = key;
        }
    }
    this.constructor$(entries);
    this._isMap = isMap;
    this._init$(undefined, isMap ? -6 : -3);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
            val = entriesToMap(this._values);
        } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
        }
        this._resolve(val);
        return true;
    }
    return false;
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len >> 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises);

    if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 2);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};

},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],27:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util");

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else {
        promises = util.asArray(promises);
        if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 3);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];

        if (val === undefined && !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};

},{"./util":36}],28:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

function ReductionPromiseArray(promises, fn, initialValue, _each) {
    this.constructor$(promises);
    var domain = getDomain();
    this._fn = domain === null ? fn : util.domainBind(domain, fn);
    if (initialValue !== undefined) {
        initialValue = Promise.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
    }
    this._initialValue = initialValue;
    this._currentCancellable = null;
    if(_each === INTERNAL) {
        this._eachValues = Array(this._length);
    } else if (_each === 0) {
        this._eachValues = null;
    } else {
        this._eachValues = undefined;
    }
    this._promise._captureStackTrace();
    this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._gotAccum = function(accum) {
    if (this._eachValues !== undefined && 
        this._eachValues !== null && 
        accum !== INTERNAL) {
        this._eachValues.push(accum);
    }
};

ReductionPromiseArray.prototype._eachComplete = function(value) {
    if (this._eachValues !== null) {
        this._eachValues.push(value);
    }
    return this._eachValues;
};

ReductionPromiseArray.prototype._init = function() {};

ReductionPromiseArray.prototype._resolveEmptyArray = function() {
    this._resolve(this._eachValues !== undefined ? this._eachValues
                                                 : this._initialValue);
};

ReductionPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

ReductionPromiseArray.prototype._resolve = function(value) {
    this._promise._resolveCallback(value);
    this._values = null;
};

ReductionPromiseArray.prototype._resultCancelled = function(sender) {
    if (sender === this._initialValue) return this._cancel();
    if (this._isResolved()) return;
    this._resultCancelled$();
    if (this._currentCancellable instanceof Promise) {
        this._currentCancellable.cancel();
    }
    if (this._initialValue instanceof Promise) {
        this._initialValue.cancel();
    }
};

ReductionPromiseArray.prototype._iterate = function (values) {
    this._values = values;
    var value;
    var i;
    var length = values.length;
    if (this._initialValue !== undefined) {
        value = this._initialValue;
        i = 0;
    } else {
        value = Promise.resolve(values[0]);
        i = 1;
    }

    this._currentCancellable = value;

    if (!value.isRejected()) {
        for (; i < length; ++i) {
            var ctx = {
                accum: null,
                value: values[i],
                index: i,
                length: length,
                array: this
            };
            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
        }
    }

    if (this._eachValues !== undefined) {
        value = value
            ._then(this._eachComplete, undefined, undefined, this, undefined);
    }
    value._then(completed, completed, undefined, value, this);
};

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};

function completed(valueOrReason, array) {
    if (this.isFulfilled()) {
        array._resolve(valueOrReason);
    } else {
        array._reject(valueOrReason);
    }
}

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

function gotAccum(accum) {
    this.accum = accum;
    this.array._gotAccum(accum);
    var value = tryConvertToPromise(this.value, this.array._promise);
    if (value instanceof Promise) {
        this.array._currentCancellable = value;
        return value._then(gotValue, undefined, undefined, this, undefined);
    } else {
        return gotValue.call(this, value);
    }
}

function gotValue(value) {
    var array = this.array;
    var promise = array._promise;
    var fn = tryCatch(array._fn);
    promise._pushContext();
    var ret;
    if (array._eachValues !== undefined) {
        ret = fn.call(promise._boundValue(), value, this.index, this.length);
    } else {
        ret = fn.call(promise._boundValue(),
                              this.accum, value, this.index, this.length);
    }
    if (ret instanceof Promise) {
        array._currentCancellable = ret;
    }
    var promiseCreated = promise._popContext();
    debug.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
        promise
    );
    return ret;
}
};

},{"./util":36}],29:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var schedule;
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if (typeof NativePromise === "function" &&
           typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
        nativePromise.then(fn);
    };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
        var div = document.createElement("div");
        var opts = {attributes: true};
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function() {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };

        return function schedule(fn) {
            var o = new MutationObserver(function() {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    })();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{"./util":36}],30:[function(_dereq_,module,exports){
"use strict";
module.exports =
    function(Promise, PromiseArray, debug) {
var PromiseInspection = Promise.PromiseInspection;
var util = _dereq_("./util");

function SettledPromiseArray(values) {
    this.constructor$(values);
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 33554432;
    ret._settledValueField = value;
    return this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 16777216;
    ret._settledValueField = reason;
    return this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    debug.deprecated(".settle()", ".reflect()");
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return Promise.settle(this);
};
};

},{"./util":36}],31:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = _dereq_("./util");
var RangeError = _dereq_("./errors").RangeError;
var AggregateError = _dereq_("./errors").AggregateError;
var isArray = util.isArray;
var CANCELLATION = {};


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &&
        isArrayResolved &&
        this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
        return true;
    }
    return false;

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    return this._checkOutcome();
};

SomePromiseArray.prototype._promiseCancelled = function () {
    if (this._values instanceof Promise || this._values == null) {
        return this._cancel();
    }
    this._addRejected(CANCELLATION);
    return this._checkOutcome();
};

SomePromiseArray.prototype._checkOutcome = function() {
    if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
                e.push(this._values[i]);
            }
        }
        if (e.length > 0) {
            this._reject(e);
        } else {
            this._cancel();
        }
        return true;
    }
    return false;
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = "Input array must contain at least " +
            this._howMany + " items but contains only " + count + " items";
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};

},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed()
            ? promise._settledValue() : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValueField = undefined;
    }
}

PromiseInspection.prototype._settledValue = function() {
    return this._settledValueField;
};

var value = PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var reason = PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
    return (this._bitField & 33554432) !== 0;
};

var isRejected = PromiseInspection.prototype.isRejected = function () {
    return (this._bitField & 16777216) !== 0;
};

var isPending = PromiseInspection.prototype.isPending = function () {
    return (this._bitField & 50397184) === 0;
};

var isResolved = PromiseInspection.prototype.isResolved = function () {
    return (this._bitField & 50331648) !== 0;
};

PromiseInspection.prototype.isCancelled = function() {
    return (this._bitField & 8454144) !== 0;
};

Promise.prototype.__isCancelled = function() {
    return (this._bitField & 65536) === 65536;
};

Promise.prototype._isCancelled = function() {
    return this._target().__isCancelled();
};

Promise.prototype.isCancelled = function() {
    return (this._target()._bitField & 8454144) !== 0;
};

Promise.prototype.isPending = function() {
    return isPending.call(this._target());
};

Promise.prototype.isRejected = function() {
    return isRejected.call(this._target());
};

Promise.prototype.isFulfilled = function() {
    return isFulfilled.call(this._target());
};

Promise.prototype.isResolved = function() {
    return isResolved.call(this._target());
};

Promise.prototype.value = function() {
    return value.call(this._target());
};

Promise.prototype.reason = function() {
    var target = this._target();
    target._unsetRejectionIsUnhandled();
    return reason.call(target);
};

Promise.prototype._value = function() {
    return this._settledValue();
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue();
};

Promise.PromiseInspection = PromiseInspection;
};

},{}],33:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfill,
                    ret._reject,
                    undefined,
                    ret,
                    null
                );
                return ret;
            }
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function doGetThen(obj) {
    return obj.then;
}

function getThen(obj) {
    try {
        return doGetThen(obj);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    try {
        return hasProp.call(obj, "_promise0");
    } catch (e) {
        return false;
    }
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x, resolve, reject);
    synchronous = false;

    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolve(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function reject(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util":36}],34:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, debug) {
var util = _dereq_("./util");
var TimeoutError = Promise.TimeoutError;

function HandleWrapper(handle)  {
    this.handle = handle;
}

HandleWrapper.prototype._resultCancelled = function() {
    clearTimeout(this.handle);
};

var afterValue = function(value) { return delay(+this).thenReturn(value); };
var delay = Promise.delay = function (ms, value) {
    var ret;
    var handle;
    if (value !== undefined) {
        ret = Promise.resolve(value)
                ._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() && value instanceof Promise) {
            ret._setOnCancel(value);
        }
    } else {
        ret = new Promise(INTERNAL);
        handle = setTimeout(function() { ret._fulfill(); }, +ms);
        if (debug.cancellation()) {
            ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
    }
    ret._setAsyncGuaranteed();
    return ret;
};

Promise.prototype.delay = function (ms) {
    return delay(ms, this);
};

var afterTimeout = function (promise, message, parent) {
    var err;
    if (typeof message !== "string") {
        if (message instanceof Error) {
            err = message;
        } else {
            err = new TimeoutError("operation timed out");
        }
    } else {
        err = new TimeoutError(message);
    }
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._reject(err);

    if (parent != null) {
        parent.cancel();
    }
};

function successClear(value) {
    clearTimeout(this.handle);
    return value;
}

function failureClear(reason) {
    clearTimeout(this.handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var ret, parent;

    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
            afterTimeout(ret, message, parent);
        }
    }, ms));

    if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
    } else {
        ret = this._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
    }

    return ret;
};

};

},{"./util":36}],35:[function(_dereq_,module,exports){
"use strict";
module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext, INTERNAL, debug) {
    var util = _dereq_("./util");
    var TypeError = _dereq_("./errors").TypeError;
    var inherits = _dereq_("./util").inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable &&
            typeof thenable._isDisposable === "function" &&
            typeof thenable._getDisposer === "function" &&
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &&
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return NULL;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== NULL
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &&
                typeof d.resource === "function" &&
                typeof d.tryDispose === "function");
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length-1] = null;
    }

    ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection(
                        "you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }

        var resultPromise = Promise.all(reflectedResources)
            .then(function(inspections) {
                for (var i = 0; i < inspections.length; ++i) {
                    var inspection = inspections[i];
                    if (inspection.isRejected()) {
                        errorObj.e = inspection.error();
                        return errorObj;
                    } else if (!inspection.isFulfilled()) {
                        resultPromise.cancel();
                        return;
                    }
                    inspections[i] = inspection.value();
                }
                promise._pushContext();

                fn = tryCatch(fn);
                var ret = spreadArgs
                    ? fn.apply(undefined, inspections) : fn(inspections);
                var promiseCreated = promise._popContext();
                debug.checkForgottenReturns(
                    ret, promiseCreated, "Promise.using", promise);
                return ret;
            });

        var promise = resultPromise.lastly(function() {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 131072) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & (~131072);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};

},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var canEvaluate = typeof navigator == "undefined";

var errorObj = {e: {}};
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    typeof global !== "undefined" ? global :
    this !== undefined ? this : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return typeof value === "function" ||
           typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var receiver = new FakeConstructor();
    function ic() {
        return typeof receiver.foo;
    }
    ic();
    ic();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj instanceof Error ||
        (obj !== null &&
           typeof obj === "object" &&
           typeof obj.message === "string" &&
           typeof obj.name === "string");
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function(v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
    } : function(v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function(v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" &&
    typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function(){});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5":13}]},{},[4])(4)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"_process":85,"timers":86}],84:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],85:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],86:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":85,"timers":86}],87:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],88:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":87,"_process":85,"inherits":84}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnQvY2xpZW50LmRpYWdyYW0uanMiLCJjbGllbnQvY29yZS9jYWNoZS5qcyIsImNsaWVudC9jb3JlL2NsaWVudC5qcyIsImNsaWVudC9jb3JlL2NvbW1hbmQuanMiLCJjbGllbnQvY29yZS9jb21tYW5kTWFuYWdlci5qcyIsImNsaWVudC9jb3JlL2NvbmZpZy5qcyIsImNsaWVudC9jb3JlL2V2ZW50LmpzIiwiY2xpZW50L2NvcmUvZmlsZU1hbmFnZXIuanMiLCJjbGllbnQvY29yZS9zdWJFdmVudC5qcyIsImNsaWVudC9kaWFncmFtL0tub2IuanMiLCJjbGllbnQvZGlhZ3JhbS9hYnN0cmFjdEVkaXRBZGRpdGlvbi5qcyIsImNsaWVudC9kaWFncmFtL2Fic3RyYWN0TWFuYWdlci5qcyIsImNsaWVudC9kaWFncmFtL2Fic3RyYWN0UGF0aE1hbmFnZXIuanMiLCJjbGllbnQvZGlhZ3JhbS9hZGRpdGlvbnMuanMiLCJjbGllbnQvZGlhZ3JhbS9hcGkuanMiLCJjbGllbnQvZGlhZ3JhbS9jdXJ2ZWRQYXRoTWFuYWdlci5qcyIsImNsaWVudC9kaWFncmFtL2RpYWdyYW0uanMiLCJjbGllbnQvZGlhZ3JhbS9kaWFncmFtTWFuYWdlci5qcyIsImNsaWVudC9kaWFncmFtL2RvY2tpbmcuanMiLCJjbGllbnQvZGlhZ3JhbS9kcmFnQWxpZ25tZW50LmpzIiwiY2xpZW50L2RpYWdyYW0vZHJhZ2dhYmxlLmpzIiwiY2xpZW50L2RpYWdyYW0vZWRpdE5vZGVBZGRpdGlvbi5qcyIsImNsaWVudC9kaWFncmFtL2VkaXRUcmFuc2l0aW9uQWRkaXRpb24uanMiLCJjbGllbnQvZGlhZ3JhbS9ob3ZlcmFibGUuanMiLCJjbGllbnQvZGlhZ3JhbS9pbWFnZVRlbXBsYXRlLmpzIiwiY2xpZW50L2RpYWdyYW0va25vYk1hbmFnZXIuanMiLCJjbGllbnQvZGlhZ3JhbS9rbm9iVGVtcGxhdGUuanMiLCJjbGllbnQvZGlhZ3JhbS9ub2RlLmpzIiwiY2xpZW50L2RpYWdyYW0vbm9kZUFkZGl0aW9ucy5qcyIsImNsaWVudC9kaWFncmFtL25vZGVNYW5hZ2VyLmpzIiwiY2xpZW50L2RpYWdyYW0vcGF0aE1hbmFnZXJGYWN0b3J5LmpzIiwiY2xpZW50L2RpYWdyYW0vcmVzaXplLmpzIiwiY2xpZW50L2RpYWdyYW0vcmVzaXplQWRkaXRpb24uanMiLCJjbGllbnQvZGlhZ3JhbS9yb3VuZFBhdGhNYW5hZ2VyLmpzIiwiY2xpZW50L2RpYWdyYW0vc2VsZWN0aW9uTWFuYWdlci5qcyIsImNsaWVudC9kaWFncmFtL3N0cmFpZ2h0UGF0aE1hbmFnZXIuanMiLCJjbGllbnQvZGlhZ3JhbS90ZW1wbGF0ZS5qcyIsImNsaWVudC9kaWFncmFtL3RlbXBsYXRlTWFuYWdlci5qcyIsImNsaWVudC9kaWFncmFtL3RyYW5zaXRpb24uanMiLCJjbGllbnQvZGlhZ3JhbS90cmFuc2l0aW9uQWRkaXRpb24uanMiLCJjbGllbnQvZGlhZ3JhbS90cmFuc2l0aW9uQWRkaXRpb25zLmpzIiwiY2xpZW50L2RpYWdyYW0vdHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLmpzIiwiY2xpZW50L2RpYWdyYW0vdHJhbnNpdGlvbktub2JNYW5hZ2VyLmpzIiwiY2xpZW50L2RpYWdyYW0vdHJhbnNpdGlvbk1hbmFnZXIuanMiLCJjbGllbnQvZGlhZ3JhbS90cmFuc2l0aW9uVGV4dEFkZGl0aW9uLmpzIiwiY2xpZW50L2RvbS9kb20uanMiLCJjbGllbnQvZG9tL2RvbUVsZW1lbnQuanMiLCJjbGllbnQvZG9tL2V2ZW50YWJsZU5vZGUuanMiLCJjbGllbnQvc3ZnL1BhdGhEYXRhLmpzIiwiY2xpZW50L3N2Zy9TVkdFbGVtZW50LmpzIiwiY2xpZW50L3N2Zy9jaXJjbGUuanMiLCJjbGllbnQvc3ZnL2RyYWdDb25maWcuanMiLCJjbGllbnQvc3ZnL2RyYWdnYWJsZS5qcyIsImNsaWVudC9zdmcvZWxlbWVudHMuanMiLCJjbGllbnQvc3ZnL2VsbGlwc2UuanMiLCJjbGllbnQvc3ZnL2dyb3VwLmpzIiwiY2xpZW50L3N2Zy9oZWxwZXIuanMiLCJjbGllbnQvc3ZnL3BhdGguanMiLCJjbGllbnQvc3ZnL3JlY3QuanMiLCJjbGllbnQvc3ZnL3N0eWxlLmpzIiwiY2xpZW50L3N2Zy9zdmcuanMiLCJjbGllbnQvc3ZnL3N2Z1Jvb3QuanMiLCJjbGllbnQvc3ZnL3N2Z1NoYXBlLmpzIiwiY2xpZW50L3N2Zy90ZXh0LmpzIiwiY2xpZW50L3N2Zy90cmFuc2Zvcm0uanMiLCJjbGllbnQvc3ZnL3RzcGFuLmpzIiwiY2xpZW50L3VpL2VkaXRQYW5lbC5qcyIsImNsaWVudC91aS9qcXVlcnlQbHVnaW5zLmpzIiwiY2xpZW50L3VzZXIvdXNlck1hbmFnZXIuanMiLCJjbGllbnQvdXRpbC9VdGlsLmpzIiwiY2xpZW50L3V0aWwvYXBwLmpzIiwiY2xpZW50L3V0aWwvYmV6aWVyLmpzIiwiY2xpZW50L3V0aWwvbWF0aC5qcyIsImNsaWVudC91dGlsL29iamVjdC5qcyIsImNsaWVudC91dGlsL3N0cmluZy5qcyIsImNsaWVudC91dGlsL3htbC5qcyIsImNvbW1vbi9lcnJvci5qcyIsImNvbW1vbi9lcnJvckNvZGVzLmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL2Jyb3dzZXIvYmx1ZWJpcmQuanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9oQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJyZXF1aXJlKCcuL3VpL2pxdWVyeVBsdWdpbnMnKTtcclxucmVxdWlyZSgnLi9zdmcvZHJhZ2dhYmxlJyk7XHJcblxyXG5pZighd2luZG93LmRhbGEpIHtcclxuICAgIGRhbGEgPSB7fTtcclxufVxyXG5cclxuZGFsYV9lbnYgPSB3aW5kb3cuZGFsYV9lbnYgfHwge307XHJcbmRhbGFfZW52LmluaXRpYWxfdGVtcGxhdGVzID0ge307XHJcblxyXG5cclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi9jb3JlL2V2ZW50Jyk7XHJcblxyXG4vL1RPRE86IGJldHRlciBuYW1lc3BhY2UgaGFuZGxpbmcuLi4gZXhwb3J0IHRvIG1vZHVsZVxyXG52YXIgZ2xvYmFsTW9kdWxlcyA9ICB7XHJcbiAgICAndGVtcGxhdGVNYW5hZ2VyJzogcmVxdWlyZSgnLi9kaWFncmFtL3RlbXBsYXRlTWFuYWdlcicpLFxyXG4gICAgJ2RpYWdyYW1NYW5hZ2VyJzogcmVxdWlyZSgnLi9kaWFncmFtL2RpYWdyYW1NYW5hZ2VyJyksXHJcbiAgICAnYWRkaXRpb25zJzogcmVxdWlyZSgnLi9kaWFncmFtL2FkZGl0aW9ucycpLFxyXG4gICAgJ2NvbmZpZyc6IHJlcXVpcmUoJy4vY29yZS9jb25maWcnKSxcclxuICAgICdmaWxlTWFuYWdlcic6IHJlcXVpcmUoJy4vY29yZS9maWxlTWFuYWdlcicpLFxyXG4gICAgJ2V2ZW50JyA6IHJlcXVpcmUoJy4vY29yZS9ldmVudCcpXHJcbn07XHJcblxyXG5kYWxhLnJlcXVpcmUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuIGdsb2JhbE1vZHVsZXNbaWRdO1xyXG59O1xyXG5cclxuXHJcblxyXG5pZighd2luZG93LmRhbGEuU1ZHKSB7XHJcbiAgICB3aW5kb3cuZGFsYS5TVkcgPSByZXF1aXJlKCcuL3N2Zy9zdmcnKTtcclxufVxyXG5cclxuaWYoIXdpbmRvdy5kYWxhLkRpYWdyYW0pIHtcclxuICAgIHdpbmRvdy5kYWxhLkRpYWdyYW0gPSByZXF1aXJlKCcuL2RpYWdyYW0vZGlhZ3JhbScpO1xyXG59XHJcblxyXG5cclxuLy9UT0RPOiBtb3ZlIHRoaXMgdG8gYSBjb250cm9sbGVyICFcclxuJCh3aW5kb3cpLmJpbmQoJ21vdXNld2hlZWwgRE9NTW91c2VTY3JvbGwnLCBmdW5jdGlvbihldnQpe1xyXG4gICAgaWYoIWV2dC5jdHJsS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIGlmIChldnQub3JpZ2luYWxFdmVudC53aGVlbERlbHRhID4gMCB8fCBldnQub3JpZ2luYWxFdmVudC5kZXRhaWwgPCAwKSB7XHJcbiAgICAgICAgZXZlbnQudHJpZ2dlcigndmlld196b29tSW4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50LnRyaWdnZXIoJ3ZpZXdfem9vbU91dCcpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnZhciBzdGFnZUZvY3VzID0gZmFsc2U7XHJcblxyXG4kKCdodG1sJykub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xyXG4gICAgc3RhZ2VGb2N1cyA9IGZhbHNlO1xyXG59KTtcclxuXHJcbi8vVE9ETzogQ2hlY2sgcmVkdW5kYW5jeSB3aXRoIGNsaWVudC5hbGwuLi5cclxuXHJcbi8vVE9ETzogY2hlY2sgb3RoZXIga2V5IGV2ZW50cyBmb3Igc3RhZ2VGb2N1c1xyXG4kKGRvY3VtZW50KS5vbignY2xpY2snLCAnLnN2Z1N0YWdlJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBzdGFnZUZvY3VzID0gdHJ1ZTtcclxuICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxufSk7XHJcblxyXG5ldmVudC5vbihkb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XHJcbiAgICBlLm1vdXNlID0gZXZlbnQubW91c2UoKTtcclxuICAgIC8vY29uc29sZS5sb2coJ2tleXByZXNzOiAnK2Uua2V5Q29kZSk7XHJcbiAgICBzd2l0Y2goZS5rZXlDb2RlKSB7XHJcbiAgICAgICAgY2FzZSAxMzogLy9FTlRFUlxyXG4gICAgICAgICAgICBldmVudC50cmlnZ2VyKCdrZXlfZW50ZXJfcHJlc3MnLCB7fSwgZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzg6IC8vVVBcclxuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcigna2V5X3VwX3ByZXNzJywge30sIGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQwOiAvL0RPV05cclxuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcigna2V5X2Rvd25fcHJlc3MnLCB7fSwgZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNDY6IC8vREVMRVRFXHJcbiAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2tleV9kZWxfcHJlc3MnLCB7fSwgZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNjc6IC8vY1xyXG4gICAgICAgICAgICBpZihlLmN0cmxLZXkgJiYgIWlzVGV4dFNlbGVjdGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2tleV9jb3B5X3ByZXNzJywge30sIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgODM6IC8vc1xyXG4gICAgICAgICAgICBpZihlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2tleV9zYXZlX3ByZXNzJywge30sIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgODY6IC8vdlxyXG4gICAgICAgICAgICBpZihlLmN0cmxLZXkgJiYgc3RhZ2VGb2N1cykge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQudHJpZ2dlcigna2V5X3Bhc3RlX3ByZXNzJywge30sIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgODk6IC8veVxyXG4gICAgICAgICAgICBpZihlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2tleV9yZWRvX3ByZXNzJywge30sIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgOTA6IC8velxyXG4gICAgICAgICAgICBpZihlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2tleV91bmRvX3ByZXNzJywge30sIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTg3OlxyXG4gICAgICAgICAgICBpZihlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ3ZpZXdfem9vbUluJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxODk6XHJcbiAgICAgICAgICAgIGlmKGUuY3RybEtleSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQudHJpZ2dlcigndmlld196b29tT3V0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuIiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBkb20gPSByZXF1aXJlKCcuLi9kb20vZG9tJyk7XHJcbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlsL3N0cmluZycpO1xyXG5cclxudmFyIENhY2hlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnF1ZXJ5Q2FjaGUgPSB7fTtcclxuICAgIHRoaXMuc3ZnQ2FjaGUgPSB7fTtcclxufTtcclxuXHJcbkNhY2hlLnByb3RvdHlwZS5jbGVhckJ5U3VmZml4ID0gZnVuY3Rpb24oc3VmZml4KSB7XHJcbiAgICBmb3Ioa2V5IGluIHRoaXMucXVlcnlDYWNoZSkge1xyXG4gICAgICAgIGlmKHRoaXMucXVlcnlDYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHN0cmluZy5lbmRzV2l0aChrZXksIHN1ZmZpeCkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucXVlcnlDYWNoZVtrZXldO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKGtleSBpbiB0aGlzLnN2Z0NhY2hlKSB7XHJcbiAgICAgICAgaWYodGhpcy5zdmdDYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHN0cmluZy5lbmRzV2l0aChrZXksIHN1ZmZpeCkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3ZnQ2FjaGVba2V5XTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ2FjaGUucHJvdG90eXBlLiQgPSBmdW5jdGlvbihvYmosIHByZXZlbnRDYWNoZSkge1xyXG4gICAgaWYoIW9iaikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLnF1ZXJ5Q2FjaGVbb2JqXSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5Q2FjaGVbb2JqXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLmdldENhY2hlU2V0dGluZ3Mob2JqLCB0aGlzLnF1ZXJ5Q2FjaGUpO1xyXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVDaGVjayhzZXR0aW5ncy5rZXksIHNldHRpbmdzLiRub2RlLCB0aGlzLnF1ZXJ5Q2FjaGUsIHByZXZlbnRDYWNoZSk7XHJcbn07XHJcblxyXG5DYWNoZS5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24ob2JqLCBwcmV2ZW50Q2FjaGUpIHtcclxuICAgIGlmKCFvYmopIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5zdmdDYWNoZVtvYmpdKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnQ2FjaGVbb2JqXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLmdldENhY2hlU2V0dGluZ3Mob2JqLCB0aGlzLnN2Z0NhY2hlKTtcclxuICAgIHJldHVybiB0aGlzLmNhY2hlQ2hlY2soc2V0dGluZ3Mua2V5LCAkLnN2ZyhzZXR0aW5ncy4kbm9kZSksIHRoaXMuc3ZnQ2FjaGUsIHByZXZlbnRDYWNoZSk7XHJcbn07XHJcblxyXG5DYWNoZS5wcm90b3R5cGUuZ2V0Q2FjaGVTZXR0aW5ncyA9IGZ1bmN0aW9uKG9iaiwgY2FjaGUpIHtcclxuICAgIHZhciBzZXR0aW5ncyA9IHt9O1xyXG5cclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhvYmopKXtcclxuICAgICAgICBzZXR0aW5ncy4kbm9kZSA9IHRoaXMucXVlcnlDYWNoZVtvYmpdIHx8ICQob2JqKTtcclxuICAgICAgICBzZXR0aW5ncy5rZXkgPSBvYmo7XHJcbiAgICB9IGVsc2UgaWYob2JqLmpRdWVyeSkge1xyXG4gICAgICAgIHNldHRpbmdzLiRub2RlID0gb2JqO1xyXG4gICAgICAgIHNldHRpbmdzLmtleSA9IGRvbS5nZXRJZFNlbGVjdG9yKG9iai5hdHRyKCdpZCcpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLiRub2RlID0gJChvYmopO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5rZXkgPSBkb20uZ2V0SWRTZWxlY3RvcihzZXR0aW5ncy4kbm9kZS5hdHRyKCdpZCcpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2V0dGluZ3M7XHJcbn1cclxuXHJcbkNhY2hlLnByb3RvdHlwZS5jYWNoZUNoZWNrID0gZnVuY3Rpb24oa2V5LCBvYmosIGNhY2hlLCBwcmV2ZW50Q2FjaGUpIHtcclxuICAgIHByZXZlbnRDYWNoZSA9IHByZXZlbnRDYWNoZSB8fCBmYWxzZTtcclxuICAgIGlmKGtleSAmJiBvYmopIHtcclxuICAgICAgICByZXR1cm4gKCFwcmV2ZW50Q2FjaGUpID8gY2FjaGVba2V5XSA9IG9iaiA6IG9iajtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxufVxyXG5cclxuQ2FjaGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYob2JqZWN0LmlzU3RyaW5nKG9iaikpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5xdWVyeUNhY2hlW29ial07XHJcbiAgICB9XHJcbn07XHJcblxyXG5DYWNoZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiBvYmplY3QuaXNEZWZpbmVkKHF1ZXJ5Q2FjaFtzZWxlY3Rvcl0pO1xyXG59O1xyXG5cclxuQ2FjaGUucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG5ldyBDYWNoZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ2FjaGUoKTsiLCJ2YXIgZXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJpbmcnKTtcclxuXHJcbnZhciBSZXNwb25zZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbn07XHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUuaXNDb25maXJtYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEgJiYgKHRoaXMuZGF0YS5zdGF0dXMgPT09IDApO1xyXG59O1xyXG5cclxuUmVzcG9uc2UucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLnN0YXR1cyAmJiAodGhpcy5kYXRhLnN0YXR1cyA+IDApO1xyXG59O1xyXG5cclxuUmVzcG9uc2UucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmVycm9yO1xyXG59O1xyXG5cclxuUmVzcG9uc2UucHJvdG90eXBlLmdldEVycm9yQ29kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5lcnJvckNvZGU7XHJcbn07XHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBcInsgc3RhdHVzOiBcIit0aGlzLmRhdGEuc3RhdHVzK1wiIGVycm9yOiBcIit0aGlzLmRhdGEuZXJyb3IrXCIgZGF0YTogXCIrdGhpcy5kYXRhLmRhdGErXCIgfVwiO1xyXG59O1xyXG5cclxudmFyIGNvbmZpZyA9IHtcclxuICAgIGhvc3QgOiAnbG9jYWxob3N0JyxcclxuICAgIHBvcnQgOiAzMDAwXHJcbn07XHJcblxyXG52YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oY2ZnLCB4aHIsdHlwZSxlcnJvclRocm93biwgZXJyb3JDb2RlKSB7XHJcbiAgICBlcnJvckNvZGUgPSAoeGhyKSA/IHhoci5zdGF0dXMgOiBwYXJzZUludChlcnJvckNvZGUpO1xyXG4gICAgY29uc29sZS53YXJuKFwiYWpheEVycm9yOiBcIit0eXBlK1wiIFwiK2Vycm9yVGhyb3duK1wiIC0gXCIrZXJyb3JDb2RlKTtcclxuXHJcbiAgICBpZihjZmcuZXJyb3JNZXNzYWdlKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzU3RyaW5nKGNmZy5lcnJvck1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2Vycm9yJywgY2ZnLmVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKG9iamVjdC5pc09iamVjdChjZmcuZXJyb3JNZXNzYWdlLCBlcnJvckNvZGUpKSB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBjZmcuZXJyb3JNZXNzYWdlW2Vycm9yQ29kZV0gfHwgY2ZnLmVycm9yTWVzc2FnZVsnZGVmYXVsdCddO1xyXG4gICAgICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKG1zZykpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2Vycm9yJywgbXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZihjZmcuZXJyb3IgJiYgb2JqZWN0LmlzRnVuY3Rpb24oY2ZnLmVycm9yKSkge1xyXG4gICAgICAgIC8vIFwidGltZW91dFwiLCBcImVycm9yXCIsIFwiYWJvcnRcIiwgXCJwYXJzZXJlcnJvclwiIG9yIFwiYXBwbGljYXRpb25cIlxyXG4gICAgICAgIGNmZy5lcnJvcihlcnJvclRocm93biwgZXJyb3JDb2RlLCB0eXBlKTtcclxuICAgIH0gZWxzZSBpZihjZmcuZXJyb3IpIHtcclxuICAgICAgICB2YXIgbXNnID0gY2ZnLmVycm9yW2Vycm9yQ29kZV0gfHwgY2ZnLmVycm9yWydkZWZhdWx0J107XHJcbiAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChtc2cpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2Vycm9yJywgbXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIWNmZy5lcnJvciAmJiAhY2ZnLmVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignVW5oYW5kbGVkIGFqYXggZXJyb3I6ICcrcGF0aCtcIiB0eXBlXCIrdHlwZStcIiBlcnJvcjogXCIrZXJyb3JUaHJvd24pO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICB0ZXN0OiBmdW5jdGlvbihzZXR0aW5ncykge1xyXG4gICAgICAgIHRoaXMucGluZyhzZXR0aW5ncyk7XHJcbiAgICB9LFxyXG4gICAgcGluZzogZnVuY3Rpb24oc2V0dGluZ3MpIHtcclxuICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IGNvbmZpZztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgICAgdXJsOiBcImh0dHA6Ly9cIitzZXR0aW5ncy5ob3N0K1wiOlwiK3NldHRpbmdzLnBvcnQrXCIvc2VydmljZS9waW5nXCIsXHJcbiAgICAgICAgICAgIC8vY3Jvc3NEb21haW46IHRydWUsXHJcbiAgICAgICAgICAgIHR5cGUgOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICBkYXRhOiB7J3BpbmcnOnRydWV9LFxyXG4gICAgICAgICAgICBhc3luYyA6IGZhbHNlLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgbXNnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIGFqYXg6IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIGNmZykge1xyXG4gICAgICAgIHZhciBjZmcgPSBjZmcgfHwge307XHJcbiAgICAgICAgdmFyIGFzeW5jID0gY2ZnLmFzeW5jIHx8IHRydWU7XHJcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gY2ZnLmRhdGFUeXBlIHx8IFwianNvblwiO1xyXG4gICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uKHhocix0eXBlLGVycm9yVGhyb3duLCBlcnJvckNvZGUpIHtcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGNmZywgeGhyLHR5cGUsZXJyb3JUaHJvd24sIGVycm9yQ29kZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VXcmFwcGVyID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHJlc3BvbnNlV3JhcHBlci5pc0Vycm9yKCkpIHsgLy9BcHBsaWNhdGlvbiBlcnJvcnNcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcih1bmRlZmluZWQsXCJhcHBsaWNhdGlvblwiLHJlc3BvbnNlV3JhcHBlci5nZXRFcnJvcigpLCByZXNwb25zZVdyYXBwZXIuZ2V0RXJyb3JDb2RlKCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoY2ZnLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGlmKG9iamVjdC5pc1N0cmluZyhjZmcuc3VjY2VzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC50cmlnZ2VyKCdpbmZvJywgY2ZnLnN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjZmcuc3VjY2VzcyhyZXNwb25zZVdyYXBwZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2ZnLnN1Y2Nlc3NNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC50cmlnZ2VyKCdpbmZvJywgY2ZnLnN1Y2Nlc3NNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICB1cmw6IHBhdGgsXHJcbiAgICAgICAgICAgIC8vY3Jvc3NEb21haW46IHRydWUsIC8vVE9ETzogcmVhZCBmcm9tIGNvbmZpZ1xyXG4gICAgICAgICAgICB0eXBlIDogY2ZnLnR5cGUsXHJcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhIDogY2ZnLnByb2Nlc3NEYXRhLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogY2ZnLmNvbnRlbnRUeXBlLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBhc3luYyA6IGFzeW5jLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Q6IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIGNmZykge1xyXG4gICAgICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgICAgICBjZmcudHlwZSA9ICdQT1NUJztcclxuICAgICAgICB0aGlzLmFqYXgocGF0aCwgZGF0YSwgY2ZnKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKHBhdGgsIGNmZykge1xyXG4gICAgICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgICAgICBjZmcudHlwZSA9ICdHRVQnO1xyXG4gICAgICAgIHRoaXMuYWpheChwYXRoLCBjZmcuZGF0YSwgY2ZnKTtcclxuICAgIH0sXHJcbiAgICB4bWw6IGZ1bmN0aW9uKHBhdGgsIGNmZykge1xyXG4gICAgICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgICAgICBjZmcuZGF0YVR5cGUgPSAneG1sJztcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQocGF0aCxjZmcpO1xyXG4gICAgfSxcclxuICAgIHRleHQgOiBmdW5jdGlvbihwYXRoLCBjZmcpIHtcclxuICAgICAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICAgICAgY2ZnLmRhdGFUeXBlID0gJ3RleHQnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChwYXRoLGNmZyk7XHJcbiAgICB9LFxyXG4gICAgZ2V0U2NyaXB0OiBmdW5jdGlvbihwYXRoLCBjZmcpIHtcclxuICAgICAgICBjZmcgPSBjZmcgfHwge307XHJcblxyXG4gICAgICAgIHJldHVybiAkLmdldFNjcmlwdChwYXRoKVxyXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbihzLCBTdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIGlmKGNmZy5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2ZnLnN1Y2Nlc3MocywgU3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuZmFpbChmdW5jdGlvbih4aHIsIHNldHRpbmdzLCBleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihjZmcsIHhociwnZXJyb3InLGV4Y2VwdGlvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHJlc3RHZXQ6IGZ1bmN0aW9uKHBhdGgsIGlkLCBjZmcpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHN0cmluZy5lbmRzV2l0aChwYXRoLCAnLycpPyBwYXRoK2lkIDogcGF0aCsnLycraWQ7XHJcbiAgICAgICAgdGhpcy5nZXQocGF0aCwgY2ZnKTtcclxuICAgIH0sXHJcbiAgICBnZXRVcmw6IGZ1bmN0aW9uKGFkZGl0aW9uKSB7XHJcbiAgICAgICAgdmFyIHVybCA9IFwiaHR0cDovL1wiK2NvbmZpZy5ob3N0K1wiOlwiK2NvbmZpZy5wb3J0O1xyXG4gICAgICAgIGlmKGFkZGl0aW9uKSB7XHJcbiAgICAgICAgICAgIHVybCArPSBhZGRpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHNldHRpbmdzKSB7XHJcbiAgICAgICAgY29uZmlnID0gc2V0dGluZ3M7XHJcbiAgICB9LFxyXG4gICAgZ2V0U2V0dGluZ3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbn0iLCJ2YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxuXHJcbnZhciBDb21tYW5kQWN0aW9uID0gZnVuY3Rpb24oY2xpZW50LCBhY3Rpb24pIHtcclxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xyXG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XHJcbn07XHJcblxyXG5Db21tYW5kQWN0aW9uLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMuYWN0aW9uLmFwcGx5KHRoaXMuY2xpZW50LCBhcmdzKTtcclxufTtcclxuXHJcbnZhciBDb21tYW5kID0gZnVuY3Rpb24oY2xpZW50LCBkb0FjdGlvbiwgdW5kb0FjdGlvbikge1xyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvL0NhbGwgdGhlIGV4ZWMgc2V0dGVyXHJcbiAgICAgICAgdGhpcy5leGVjKGNsaWVudCxkb0FjdGlvbik7XHJcbiAgICAgICAgdGhpcy51bmRvKGNsaWVudCx1bmRvQWN0aW9uKTtcclxuICAgIH1cclxuICAgIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcclxufTtcclxuXHJcbkNvbW1hbmQucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjbGllbnQsIGFjdGlvbiwgYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMuYWN0aW9uKCdkbycsIGNsaWVudCwgYWN0aW9uLCBhcmdzKTtcclxufTtcclxuXHJcbkNvbW1hbmQucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbihjbGllbnQsIGFjdGlvbiwgYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMuYWN0aW9uKCd1bmRvJywgY2xpZW50LCBhY3Rpb24sIGFyZ3MpO1xyXG59O1xyXG5cclxuQ29tbWFuZC5wcm90b3R5cGUuaW5zdGFuY2UgPSBmdW5jdGlvbihkb0FyZ3MsIHVuZG9BcmdzKSB7XHJcbiAgICB2YXIgaW5zdGFuY2UgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcyk7XHJcblxyXG4gICAgLy9JZiBnaXZlbiwgd2Ugb3ZlcndyaXRlIHRoZSBhcmd1bWVudCBzZXR0aW5ncyBmb3IgdGhlIGFjdGlvbnNcclxuICAgIGlmKGRvQXJncykge1xyXG4gICAgICAgIGluc3RhbmNlLmRvQXJncyA9IGRvQXJncztcclxuICAgIH1cclxuXHJcbiAgICBpZih1bmRvQXJncykge1xyXG4gICAgICAgIGluc3RhbmNlLnVuZG9BcmdzID0gdW5kb0FyZ3M7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zdGFuY2UuaWQgPSB0aGlzLmlkKydfJytEYXRlLm5vdygpO1xyXG5cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBKdXN0IGEgaGVscGVyIHRvIHVuaWZ5IHRoZSBsb2dpYyBmb3IgZG9BY3Rpb24gYW5kIHVuZG9BY3Rpb24uXHJcbiAqXHJcbiAqIC0gaWYganVzdCB0aGUgdHlwZSBpcyBnaXZlbiB3ZSBhc3N1bWUgYWxsIG5lY2Vzc2FyeSBhY3Rpb24gZGF0YSBpcyBnaXZlbiBmb3IgdGhpcyB0eXBlIChkby91bmRvKSBhbmQgY2FsbCB0aGUgYWN0aW9uXHJcbiAqIC0gaWYgYSB0aGVyZSBpcyBhbm90aGVyIGFyZ3VtZW50IGJlc2lkZSB0aGUgdHlwZSB3ZSBhc3N1bWUgYW4gYXJncyBhcnJheSBhbmQgY2FsbCB0aGUgYWN0aW9uIHdpdGggdGhlIGdpdmVuIGFycmF5XHJcbiAqIC0gaWYgdGhlcmUgYXJlIG1vcmUgYXJncyBnaXZlbiwgd2UgYXNzdW1lIGEgc2V0dGVyIGNhbGwgdG8gc2V0IHRoZSBhY3Rpb24gZGF0YSAoZG8vdW5kbylcclxuICpcclxuICogQHBhcmFtIHR5cGUgZG8gb3IgdW5kb1xyXG4gKiBAcGFyYW0gY2xpZW50IGNsaWVudCBvYmplY3QgdXNlZCBhcyB0aGlzXHJcbiAqIEBwYXJhbSBhY3Rpb24gdGhlIGZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIGFyZ3MgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtDb21tYW5kfVxyXG4gKi9cclxuQ29tbWFuZC5wcm90b3R5cGUuYWN0aW9uID0gZnVuY3Rpb24odHlwZSwgY2xpZW50LCBhY3Rpb24sIGFyZ3MpIHtcclxuICAgIGlmKGFyZ3MpIHtcclxuICAgICAgICB0aGlzW3R5cGUgKyAnQXJncyddID0gYXJncztcclxuICAgIH1cclxuXHJcbiAgICBpZihjbGllbnQgJiYgYWN0aW9uKSB7XHJcbiAgICAgICAgdGhpc1t0eXBlICsgJ0FjdGlvbiddID0gbmV3IENvbW1hbmRBY3Rpb24oY2xpZW50LCBhY3Rpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL0V4ZWN1dGUgZWl0aGVyIHdpdGggYXJncyBzZXR0aW5ncyBmcm9tIHRoaXMgb3IgZnJvbSBhcmd1bWVudCBsaXN0XHJcbiAgICAgICAgdGhpc1t0eXBlICsgJ0FyZ3MnXSA9IGFyZ3VtZW50c1sxXSB8fCB0aGlzW3R5cGUgKyAnQXJncyddO1xyXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzW3R5cGUgKyAnQWN0aW9uJ107XHJcbiAgICAgICAgaWYoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXhlYyh0aGlzW3R5cGUgKyAnQXJncyddKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1hbmQ7XHJcblxyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpO1xyXG52YXIgQ29tbWFuZCA9IHJlcXVpcmUoJy4vY29tbWFuZCcpO1xyXG5cclxuLy9Db21tYW5kIGluc3RhbmNlcyBmb3IgZGlhZ3JhbXNcclxudmFyIGluc3RhbmNlcyA9IHt9O1xyXG5cclxudmFyIHN1YiA9IGZ1bmN0aW9uKHN1YklkLCB1cGRhdGVIYW5kbGVyKSB7XHJcbiAgICByZXR1cm4gaW5zdGFuY2VzW3N1YklkXSA9IG5ldyBDb21tYW5kTWFuYWdlcihzdWJJZCwgdXBkYXRlSGFuZGxlcik7XHJcbn07XHJcblxyXG52YXIgQ29tbWFuZE1hbmFnZXIgPSBmdW5jdGlvbihzdWJJZCwgdXBkYXRlSGFuZGxlcikge1xyXG4gICAgdGhpcy5zdWJJZCA9IHN1YklkO1xyXG4gICAgdGhpcy5jb21tYW5kcyA9IHt9O1xyXG4gICAgdGhpcy51bmRvQ29tbWFuZHMgPSBbXTtcclxuICAgIHRoaXMucmVkb0NvbW1hbmRzID0gW107XHJcbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXIgPSB1cGRhdGVIYW5kbGVyO1xyXG4gICAgdGhpcy5yZWdpc3RlcignY21kX2dyb3VwJywgbmV3IENvbW1hbmQodGhpcywgZnVuY3Rpb24oY29tbWFuZHMpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgJC5lYWNoKGNvbW1hbmRzLCBmdW5jdGlvbihpbmRleCwgY21kKSB7XHJcbiAgICAgICAgICAgIHRoYXQuY29tbWFuZHNbY21kWzBdXS5pbnN0YW5jZShjbWRbMV0sIGNtZFsyXSkuZXhlYygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgZnVuY3Rpb24oY29tbWFuZHMpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgJC5lYWNoKGNvbW1hbmRzLCBmdW5jdGlvbihpbmRleCwgY21kKSB7XHJcbiAgICAgICAgICAgIHRoYXQuY29tbWFuZHNbY21kWzBdXS5pbnN0YW5jZShjbWRbMV0sIGNtZFsyXSkudW5kbygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdlIGNhbiByZWdpc3RlciBhIG5ldyBjb21tYW5kIGZvciB0aGlzIGdpdmVuIGNvbW1hbmQgaW5zdGFuY2UgKG1vc3RseSBhIGNvbW1hbmQgZm9yIGEgc3BlY2lmaWMgZGlhZ3JhbSBpbnN0YW5jZSlcclxuICogd2hpY2ggaXMgaWRlbnRpZmllZCBieSBpdHMgc3RyaW5nIGlkLlxyXG4gKlxyXG4gKiBUaGUgY2xpZW50IGFuZCBhY3Rpb24gYXR0cmlidXRlIGZvciB0aGUgZG8gYW5kIHVuZG8gYWN0aW9uIHNob3VsZCBiZSBzZXQgZm9yIHRoZSBnaXZlbiBhY3Rpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gY21kSWQgc3RyaW5nIGlkXHJcbiAqIEBwYXJhbSBjbWQgY29tbWFuZCBpbnN0YW5jZVxyXG4gKi9cclxuQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oY21kSWQsIGNtZCkge1xyXG4gICAgdGhpcy5jb21tYW5kc1tjbWRJZF0gPSBjbWQ7XHJcbiAgICBjbWQuaWQgPSBjbWRJZDtcclxufTtcclxuXHJcbkNvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5hZGRHcm91cCA9IGZ1bmN0aW9uKGNvbW1hbmRzKSB7XHJcbiAgICB0aGlzLmFkZCgnY21kX2dyb3VwJywgY29tbWFuZHMsIGNvbW1hbmRzKTtcclxufTtcclxuXHJcbkNvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5leGVjR3JvdXAgPSBmdW5jdGlvbihjb21tYW5kcykge1xyXG4gICAgdGhpcy5leGVjKCdjbWRfZ3JvdXAnLCBjb21tYW5kcywgY29tbWFuZHMpO1xyXG59O1xyXG5cclxuQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjbWRJZCwgZG9BcmdzLCB1bmRvQXJncykge1xyXG4gICAgdmFyIGNtZEluc3RhbmNlID0gdGhpcy5hZGQoY21kSWQsIGRvQXJncywgdW5kb0FyZ3MpO1xyXG4gICAgaWYoY21kSW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnRXhlY3V0ZSBjb21tYW5kICcrY21kSW5zdGFuY2UuaWQpO1xyXG4gICAgICAgIHJldHVybiBjbWRJbnN0YW5jZS5leGVjKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Db21tYW5kTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY21kSWQsIGRvQXJncywgdW5kb0FyZ3MpIHtcclxuICAgIHZhciBjb21tYW5kID0gdGhpcy5jb21tYW5kc1tjbWRJZF07XHJcbiAgICBpZihjb21tYW5kKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVkKGNvbW1hbmQpO1xyXG4gICAgICAgIHZhciBjbWRJbnN0YW5jZSA9IGNvbW1hbmQuaW5zdGFuY2UoZG9BcmdzLHVuZG9BcmdzKTtcclxuICAgICAgICBpZihjbWRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkIGNvbW1hbmQgJytjbWRJbnN0YW5jZS5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5kb0NvbW1hbmRzLnB1c2goY21kSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZighdGhpcy5sb2NrUmVkbykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWRvQ29tbWFuZHMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY21kSW5zdGFuY2VcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdVbnJlZ2lzdGVyZWQgY29tbWFuZCAnK2NtZElkKycgd2FzIGNhbGxlZC4nKTtcclxuICAgIH1cclxufTtcclxuXHJcbkNvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY29tbWFuZCA9IHRoaXMudW5kb0NvbW1hbmRzLnBvcCgpO1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChjb21tYW5kKSAmJiBvYmplY3QuaXNEZWZpbmVkKGNvbW1hbmQudW5kbykpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVW5kbyBjb21tYW5kICcrY29tbWFuZC5pZCk7XHJcbiAgICAgICAgY29tbWFuZC51bmRvLmFwcGx5KGNvbW1hbmQpO1xyXG4gICAgICAgIHRoaXMucmVkb0NvbW1hbmRzLnB1c2goY29tbWFuZCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVkKGNvbW1hbmQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjb21tYW5kID0gdGhpcy5yZWRvQ29tbWFuZHMucG9wKCk7XHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGNvbW1hbmQpICYmIG9iamVjdC5pc0RlZmluZWQoY29tbWFuZC5leGVjKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWRvIGNvbW1hbmQgJytjb21tYW5kLmlkKTtcclxuICAgICAgICB0aGlzLmxvY2tSZWRvID0gdHJ1ZTtcclxuICAgICAgICBjb21tYW5kLmV4ZWMuYXBwbHkoY29tbWFuZCk7XHJcbiAgICAgICAgdGhpcy5sb2NrUmVkbyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudW5kb0NvbW1hbmRzLnB1c2goY29tbWFuZCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVkKGNvbW1hbmQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbihjb21tYW5kKSB7XHJcbiAgICB0aGlzLmxhc3RDaGFuZ2UgPSBEYXRlLm5vdygpO1xyXG4gICAgaWYodGhpcy51cGRhdGVIYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVyKGNvbW1hbmQpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHN1YiA6IHN1YlxyXG59O1xyXG5cclxuIiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcblxyXG52YXIgdmFsdWVzID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHZhbCA6IGZ1bmN0aW9uKGtleSwgZGVmYXVsdFZhbCkge1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQoa2V5KSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVzW2tleV07XHJcbiAgICAgICAgICAgIHJldHVybiAob2JqZWN0LmlzRGVmaW5lZChyZXN1bHQpKSA/IHJlc3VsdCA6IGRlZmF1bHRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBpcyA6IGZ1bmN0aW9uKGtleSwgZGVmYXVsdFZhbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbChrZXksZGVmYXVsdFZhbCkgPT09IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlYnVnIDogZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzQm9vbGVhbih2YWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsKCdkZWJ1ZycsIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbCgnZGVidWcnLCBmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFZhbCA6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKGtleSkgJiYgb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMudmFsKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXBsYWNlQ29uZmlnVmFsdWVzIDogZnVuY3Rpb24odGV4dCwgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRleHQ7XHJcbiAgICAgICAgb2JqZWN0LmVhY2goY29uZmlnLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKFwie1wiICsga2V5ICsgXCJ9XCIsIFwiZ1wiKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UocmVnRXhwLCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufTsiLCJ2YXIgZXZlbnRzID0ge307XHJcblxyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvcmUvY29uZmlnJyk7XHJcbnZhciBTdWJFdmVudCA9IHJlcXVpcmUoJy4vc3ViRXZlbnQnKTtcclxuXHJcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcclxuXHJcbnZhciBoYXNIYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgcmV0dXJuIGV2ZW50c1t0eXBlXTtcclxufTtcclxuXHJcbm1vdXNlID0ge307XHJcblxyXG4kKGRvY3VtZW50KS5vbiggJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcclxuICAgIG1vdXNlID0gZTtcclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBtb3VzZSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBtb3VzZTtcclxuICAgIH0sXHJcbiAgICBsaXN0ZW46ICBmdW5jdGlvbih0eXBlLCBoYW5kbGVyLCBtb2R1bGUpIHtcclxuICAgICAgICBpZighb2JqZWN0LmlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGV2ZW50Q29uZmlnID0ge1xyXG4gICAgICAgICAgICBoYW5kbGVyIDogaGFuZGxlcixcclxuICAgICAgICAgICAgbW9kdWxlIDogbW9kdWxlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYoIWV2ZW50c1t0eXBlXSkge1xyXG4gICAgICAgICAgICBldmVudHNbdHlwZV0gPSBbZXZlbnRDb25maWddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50c1t0eXBlXS5wdXNoKGV2ZW50Q29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVubGlzdGVuOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XHJcbiAgICAgICAgaWYoZXZlbnRzW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50c1t0eXBlXS5pbmRleE9mKGZ1bmMpO1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3ViOiBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJFdmVudChjb250ZXh0LCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tbWFuZDogZnVuY3Rpb24oY29tbWFuZCwgZXhlY3V0ZSkge1xyXG4gICAgICAgIGlmKGV4ZWN1dGUpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjb21tYW5kX2V4ZWN1dGUnLCBjb21tYW5kKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbW1hbmRfYWRkJywgY29tbWFuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbih0eXBlLCBkYXRhLCByb290RXZ0KSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gcm9vdEV2dCB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICBldmVudC50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgICAgIGlmKGhhc0hhbmRsZXIoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyQXJyID0gZXZlbnRzW2V2ZW50LnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LmVhY2goaGFuZGxlckFyciwgZnVuY3Rpb24oaW5kZXgsIGV2ZW50Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBldmVudENvbmZpZy5oYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlID0gZXZlbnRDb25maWcubW9kdWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihldmVudENvbmZpZy5tb2R1bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChldmVudENvbmZpZy5tb2R1bGUsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZFRleHQgPSAobW9kdWxlICYmIG1vZHVsZS5jb25zdHJ1Y3RvciAmJiBtb2R1bGUuY29uc3RydWN0b3IubmFtZSk/bW9kdWxlLmNvbnN0cnVjdG9yLm5hbWU6J3Vua25vd24nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtb2RUZXh0ID09PSAndW5rbm93bicgJiYgY29uZmlnLmRlYnVnKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0V2ZW50IGhhbmRsZXIgZXJyb3IgLSBtb2R1bGU6ICcrbW9kVGV4dCsnIGV2ZW50OiAnK2V2ZW50LnR5cGUsIGhhbmRsZXIsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFdmVudCBoYW5kbGVyIGVycm9yIC0gbW9kdWxlOiAnK21vZFRleHQrJyBldmVudDogJytldmVudC50eXBlLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcignZXJyb3InLCAnQW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBleGVjdXRpbmcgdGhlIGxhc3QgYWN0aW9uICEnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9XZSBqdXN0IHJlc29sdmUgaW4gYWxsIGNhc2VzIHNpbmNlIHRoZSBjYWxsZXIgb2YgdHJpZ2dlciBzaG91bGQgcmVtYWluIGluZGVwZW5kZW50IG9mIGhhbmRsZXIgbW9kdWxlc1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uOiBmdW5jdGlvbihub2RlLCBldmVudCwgc2VsZWN0b3IsIGRhdGEsIGhhbmRsZXIpIHtcclxuICAgICAgICAkKG5vZGUpLm9uKGV2ZW50LHNlbGVjdG9yLGRhdGEsIGhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvZmY6IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcikge1xyXG4gICAgICAgICQobm9kZSkub2ZmKGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcik7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uY2U6IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgaGFuZGxlcikge1xyXG4gICAgICAgICQobm9kZSkub25lKGV2ZW50LHNlbGVjdG9yLGRhdGEsIGhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmlnZ2VyRG9tOiBmdW5jdGlvbihub2RlLCBldmVudCkge1xyXG4gICAgICAgJChub2RlKS50cmlnZ2VyKGV2ZW50KTtcclxuICAgIH1cclxufTsiLCJ2YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJpbmcnKTtcclxudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xyXG52YXIgY3VycmVudFVybDtcclxuXHJcbnZhciBzdWZmaXhNYXBwaW5nID0ge1xyXG4gICAgJ2ltYWdlL2pwZWcnOiAnanBnJyAsXHJcbiAgICAnaW1hZ2UvZ2lmJzogJ2dpZicsXHJcbiAgICAnaW1hZ2UvcG5nJyA6ICdwbmcnLFxyXG4gICAgJ2ltYWdlL3N2Zyt4bWwnIDogJ3N2ZydcclxufTtcclxuXHJcbnZhciBnZXRGaWxlTmFtZVdpdGhTdWZmaXggPSBmdW5jdGlvbihmaWxlTmFtZSwgbWltZSkge1xyXG4gICAgdmFyIHN1ZmZpeCA9IHN1ZmZpeE1hcHBpbmdbbWltZV07XHJcbiAgICBpZihzdWZmaXgpIHtcclxuICAgICAgICByZXR1cm4gKHN0cmluZy5lbmRzV2l0aChmaWxlTmFtZSwgc3VmZml4KSkgPyBmaWxlTmFtZSA6IGZpbGVOYW1lICsgJy4nK3N1ZmZpeDtcclxuICAgIH1cclxuICAgIHJldHVybiBmaWxlTmFtZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBkb3dubG9hZFNWRzogZnVuY3Rpb24oZGF0YSwgZmlsZU5hbWUpIHtcclxuICAgICAgICBpZihjdXJyZW50VXJsKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKGN1cnJlbnRVcmwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmlsZU5hbWUgPSBnZXRGaWxlTmFtZVdpdGhTdWZmaXgoZmlsZU5hbWUsICdpbWFnZS9zdmcreG1sJyk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XHJcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHt0eXBlOiAnaW1hZ2Uvc3ZnK3htbCd9KTtcclxuXHJcbiAgICAgICAgY3VycmVudFVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgIGxpbmsuaHJlZiA9IGN1cnJlbnRVcmw7XHJcbiAgICAgICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcbiAgICAgICAgbGluay5jbGljaygpO1xyXG4gICAgICAgIGxpbmsucmVtb3ZlKCk7XHJcbiAgICB9LFxyXG4gICAgZG93bmxvYWRBcyA6IGZ1bmN0aW9uKGRhdGEsIGZpbGVOYW1lLCB3aWR0aCwgaGVpZ2h0LCBtaW1lKSB7XHJcbiAgICAgICAgaWYobWltZSA9PT0gJ2ltYWdlL3N2Zyt4bWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRTVkcoZGF0YSwgZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmaWxlTmFtZSA9IGdldEZpbGVOYW1lV2l0aFN1ZmZpeChmaWxlTmFtZSwgbWltZSk7XHJcblxyXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuICAgICAgICBjYW52YXMud2lkdGggID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltZy5zcmMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsXCIgKyBidG9hKGRhdGEpO1xyXG4gICAgICAgIGltZy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGltZy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBhZnRlciB0aGlzLCBDYW52YXPvv70gb3JpZ2luLWNsZWFuIGlzIERJUlRZXHJcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgICAgICBhLmRvd25sb2FkID0gZmlsZU5hbWU7XHJcbiAgICAgICAgICAgIGEuaHJlZiA9IGNhbnZhcy50b0RhdGFVUkwobWltZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XHJcbiAgICAgICAgICAgIGEuY2xpY2soKTtcclxuICAgICAgICAgICAgY2FudmFzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBhLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtYWtlU2NyZWVuU2hvdCA6IGZ1bmN0aW9uKGNvbnRhaW5lciwgc3ZnU3RyLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltZy5zcmMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsXCIgKyBidG9hKHN2Z1N0cik7XHJcbiAgICAgICAgaWYod2lkdGggJiYgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGltZy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBpbWcuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKGNvbnRhaW5lcikuYXBwZW5kKGltZyk7XHJcbiAgICB9LFxyXG4gICAgaGFuZGxlT3BlblNWRzogZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICAgIC8vdmFyIGZpbGVzID0gZXZ0LnRhcmdldC5maWxlczsgLy8gRmlsZUxpc3Qgb2JqZWN0XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgRmlsZUxpc3QgYW5kIHJlbmRlciBpbWFnZSBmaWxlcyBhcyB0aHVtYm5haWxzLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBmOyBmID0gZmlsZXNbaV07IGkrKykge1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGltYWdlIGZpbGVzLlxyXG4gICAgICAgICAgICBpZiAoIWYudHlwZS5tYXRjaCgnaW1hZ2UuKicpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDbG9zdXJlIHRvIGNhcHR1cmUgdGhlIGZpbGUgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoZnVuY3Rpb24gKHRoZUZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aHVtYm5haWwuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5kaWFncmFtLmxvYWREaWFncmFtKGUudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KShmKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlYWQgaW4gdGhlIGltYWdlIGZpbGUgYXMgYSBkYXRhIFVSTC5cclxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlYWRBc1RleHQ6IGZ1bmN0aW9uKGYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cclxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChmdW5jdGlvbiAodGhlRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkoZik7XHJcblxyXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICByZWFkQXNEYXRhVXJsOiBmdW5jdGlvbihmKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoZnVuY3Rpb24gKHRoZUZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pKGYpO1xyXG5cclxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07IiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcblxyXG52YXIgU3ViRXZlbnQgPSBmdW5jdGlvbihjb250ZXh0LCBldmVudCkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcclxufTtcclxuXHJcblN1YkV2ZW50LnByb3RvdHlwZS5tb3VzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZXZlbnQubW91c2UoKTtcclxufTtcclxuXHJcblN1YkV2ZW50LnByb3RvdHlwZS5nZXRTdWJUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGV4dCsnOicrdHlwZTtcclxufTtcclxuXHJcblN1YkV2ZW50LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyLCBtb2R1bGUpIHtcclxuICAgIC8vVE9ETzogaW1wbGVtZW50IGJ1YmJsZVxyXG4gICAgdGhpcy5ldmVudC5saXN0ZW4odGhpcy5nZXRTdWJUeXBlKHR5cGUpLCBoYW5kbGVyLCBtb2R1bGUpO1xyXG59O1xyXG5cclxuU3ViRXZlbnQucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24odHlwZSwgZnVuYykge1xyXG4gICAgdGhpcy5ldmVudC51bmxpc3Rlbih0aGlzLmdldFN1YlR5cGUodHlwZSksIGZ1bmMpO1xyXG59O1xyXG5cclxuU3ViRXZlbnQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCByb290RXZ0LCBwcmV2ZW50QnViYmxlKSB7XHJcbiAgICB0aGlzLmV2ZW50LnRyaWdnZXIodGhpcy5nZXRTdWJUeXBlKHR5cGUpLCBkYXRhLCByb290RXZ0KTtcclxuICAgIGlmKCFwcmV2ZW50QnViYmxlKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIHJvb3RFdnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU3ViRXZlbnQucHJvdG90eXBlLmNvbW1hbmQgPSBmdW5jdGlvbihjb21tYW5kLCBleGVjdXRlKSB7XHJcbiAgICB0aGlzLmV2ZW50LmNvbW1hbmQoY29tbWFuZCwgZXhlY3V0ZSk7XHJcbn07XHJcblxyXG5TdWJFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihub2RlLCBldmVudCwgc2VsZWN0b3IsIGRhdGEsIGhhbmRsZXIpIHtcclxuICAgIHRoaXMuZXZlbnQub24obm9kZSwgZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBoYW5kbGVyKTtcclxufTtcclxuXHJcblN1YkV2ZW50LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihub2RlLCBldmVudCwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcclxuICAgIHRoaXMuZXZlbnQub2ZmKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcik7XHJcbn07XHJcblxyXG5TdWJFdmVudC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgaGFuZGxlcikge1xyXG4gICAgdGhpcy5ldmVudC5vbmNlKG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgaGFuZGxlcik7XHJcbn07XHJcblxyXG5TdWJFdmVudC5wcm90b3R5cGUudHJpZ2dlckRvbSA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50KSB7XHJcbiAgICB0aGlzLmV2ZW50LnRyaWdnZXJEb20obm9kZSxldmVudCk7XHJcbn1cclxuXHJcblN1YkV2ZW50LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IFN1YkV2ZW50KGNvbnRleHQsIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN1YkV2ZW50OyIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgYXBwID0gcmVxdWlyZSgnLi4vdXRpbC9hcHAnKTtcclxudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2RvbS9kb20nKTtcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL3N2Zy90cmFuc2Zvcm0nKTtcclxuXHJcbnZhciBFdmVudGFibGUgPSByZXF1aXJlKCcuLy4uL2RvbS9ldmVudGFibGVOb2RlJyk7XHJcblxyXG52YXIgREVGQVVMVF9PUEFDSVRZID0gMC41O1xyXG52YXIgREVGQVVMVF9LTk9CX1JBRElVUyA9IDU7XHJcblxyXG52YXIgS25vYiA9IGZ1bmN0aW9uKGRpYWdyYW0sIHAsIGNmZywgZ3JvdXApIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IGRpYWdyYW07XHJcbiAgICB0aGlzLmV2ZW50ID0gZGlhZ3JhbS5ldmVudDtcclxuICAgIHRoaXMuZ3JvdXAgPSBncm91cDtcclxuICAgIHRoaXMuaW5pdChwLCBjZmcpO1xyXG59O1xyXG5cclxuS25vYi5hY3RpdmF0ZSA9IGZ1bmN0aW9uKG5vZGUsIGNmZykge1xyXG4gICAgXHJcbiAgICB0aGlzLmNvbmZpZyA9IG9iamVjdC5leHRlbmQoe3JhZGl1cyA6IERFRkFVTFRfS05PQl9SQURJVVN9LCBjZmcpO1xyXG4gICAgdGhpcy5kaWFncmFtLm5vZGVNZ3IuYWN0aXZhdGVOb2RlKG5vZGUpO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhLbm9iLCBFdmVudGFibGUpO1xyXG5cclxuS25vYi5wcm90b3R5cGUuY2xlYXJSZWxhdGl2ZU9yaWVudGF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkZWxldGUgdGhpcy5yZWxhdGl2ZVBvc2l0aW9uO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZS5zZWxlY3RlZDtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLnJlbGF0aXZlT3JpZW50YXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgaWYocG9zaXRpb24pIHtcclxuICAgICAgICB0aGlzLnJlbGF0aXZlUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHggOiBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5IDogcG9zaXRpb24ueVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5yZWxhdGl2ZVBvc2l0aW9uO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBjZmcpIHtcclxuICAgIHRoaXMuY29uZmlnID0gb2JqZWN0LmV4dGVuZCh7cmFkaXVzIDogREVGQVVMVF9LTk9CX1JBRElVU30sIGNmZyk7XHJcbiAgICB0aGlzLmNvbmZpZy5jc3NDbGFzcyA9IHRoaXMuY29uZmlnLmNzc0NsYXNzIHx8ICdrbm9iJztcclxuXHJcbiAgICBpZihjZmcuYWN0aXZhdGUpe1xyXG4gICAgICAgIHRoaXMubm9kZSA9IHRoaXMuZGlhZ3JhbS5hY3RpdmF0ZUtub2JOb2RlKGNmZy5hY3RpdmF0ZSwgdGhpcy5jb25maWcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLmRpYWdyYW0uY3JlYXRlS25vYk5vZGUocG9zaXRpb24sIHRoaXMuZ3JvdXAsIHRoaXMuY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmV2ZW50QmFzZSA9IHRoaXMubm9kZS5ldmVudEJhc2U7XHJcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMubm9kZS5jb25maWc7XHJcbiAgICB0aGlzLnJvb3QgPSB0aGlzLm5vZGUucm9vdDtcclxuICAgIHRoaXMubm9kZS5rbm9iID0gdGhpcztcclxuXHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB2YXIgc2VsZWN0ID0gY2ZnLnNlbGVjdCB8fCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5hY3RpdmVTdHlsZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgdmFyIGRlc2VsZWN0ID0gY2ZnLmRlc2VsZWN0IHx8IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LmluYWN0aXZlU3R5bGUoKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICB0aGlzLmFjdGl2ZVN0eWxlKCk7XHJcbiAgICB0aGlzLm9uKCdzZWxlY3QnLCBzZWxlY3QpLm9uKCdkZXNlbGVjdCcsIGRlc2VsZWN0KTtcclxuICAgIHRoaXMuZXZlbnQudHJpZ2dlcigna25vYl9hZGRlZCcsIHRoaXMpO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZS54KCk7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS55ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlLnkoKTtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlLmdldENlbnRlcigpO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuZHJhZ2dhYmxlID0gZnVuY3Rpb24oaGFuZGxlcikge1xyXG4gICAgdGhpcy5ub2RlLmRyYWdnYWJsZShoYW5kbGVyKTtcclxuICAgIHRoaXMudHJpZ2dlckRyYWcgPSBmdW5jdGlvbihkeCxkeSkge1xyXG4gICAgICAgIHRoaXMubm9kZS50cmlnZ2VyRHJhZyhkeCxkeSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5pbml0RHJhZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ub2RlLmluaXREcmFnKCk7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5oaWRlKCk7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5hdHRyKCdyJywgMCk7IC8vVE9ETzogcGVyaGFwcyBub3Qgd2FudGVkIGZvciBhbGwga25vYiB0eXBlcy5cclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbihvcGFjaXR5KSB7XHJcbiAgICBvcGFjaXR5ID0gb2JqZWN0LmlzRGVmaW5lZChvcGFjaXR5KSA/IG9wYWNpdHkgOiB0aGlzLmNvbmZpZ1snZmlsbC1vcGFjaXR5J107XHJcbiAgICBvcGFjaXR5ID0gb2JqZWN0LmlzRGVmaW5lZChvcGFjaXR5KSA/IG9wYWNpdHkgOiBERUZBVUxUX09QQUNJVFk7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5zaG93KG9wYWNpdHkpO1xyXG4gICAgdGhpcy5ub2RlLnJvb3QuYXR0cigncicsIHRoaXMuY29uZmlnWydyYWRpdXMnXSk7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzaGlmdGVkKSB7XHJcbiAgICB0aGlzLmFjdGl2ZVN0eWxlKCk7XHJcbiAgICB0aGlzLm5vZGUuc2VsZWN0KHNoaWZ0ZWQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ub2RlLmRlc2VsZWN0KCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbihjb2xvcikge1xyXG4gICAgdGhpcy5ub2RlLnJvb3QuZmlsbChjb2xvcik7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5zdHJva2UgPSBmdW5jdGlvbihjb2xvcikge1xyXG4gICAgdGhpcy5ub2RlLnJvb3Quc3Ryb2tlKGNvbG9yKTtcclxuICAgIHRoaXMubm9kZS5yb290LnN0cm9rZVdpZHRoKDEpO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuYWN0aXZlU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZmlsbCh0aGlzLmNvbmZpZ1snZmlsbC1hY3RpdmUnXSk7XHJcbiAgICB0aGlzLnNob3coKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaW5hY3RpdmVTdHlsZSgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5pbmFjdGl2ZVN0eWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmZpbGwodGhpcy5jb25maWdbJ2ZpbGwnXSk7XHJcbiAgICB0aGlzLnNob3coKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUuaG92ZXJhYmxlID0gZnVuY3Rpb24oaGFuZGxlcikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5ub2RlLnJvb3QuaG92ZXJhYmxlKGhhbmRsZXIpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubm9kZS50cmlnZ2VyKCdyZW1vdmUnKTtcclxufTtcclxuXHJcbktub2IucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihkeCxkeSkge1xyXG4gICAgdGhpcy5ub2RlLnJvb3QubW92ZShkeCxkeSk7XHJcbiAgICB0aGlzLm5vZGUudHJpZ2dlcignbW92ZScsIFtkeCxkeV0pO1xyXG59O1xyXG5cclxuS25vYi5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCx5KSB7XHJcbiAgICB0aGlzLm5vZGUucm9vdC5tb3ZlVG8oeCx5KTtcclxuICAgIHRoaXMubm9kZS50cmlnZ2VyKCdtb3ZlVG8nLCBbeCx5XSk7XHJcbn07XHJcblxyXG5Lbm9iLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICcoJyt0aGlzLngoKSsnLycrdGhpcy55KCkrJyknO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBLbm9iOyIsInZhciBkb20gPSByZXF1aXJlKCcuLi9kb20vZG9tJyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgRWRpdFBhbmVsID0gcmVxdWlyZSgnLi4vdWkvZWRpdFBhbmVsJyk7XHJcblxyXG52YXIgZWRpdFBhbmVsID0gbmV3IEVkaXRQYW5lbCgpO1xyXG5cclxudmFyIEFic3RyYWN0RWRpdEFkZGl0aW9uID0gZnVuY3Rpb24oZWRpdGFibGUsIGVkaXRGdW5jdGlvbnMsIGNvbmZpZykge1xyXG4gICAgdGhpcy5lZGl0YWJsZSA9IGVkaXRhYmxlO1xyXG4gICAgdGhpcy5lZGl0RnVuY3Rpb25zID0gZWRpdEZ1bmN0aW9ucztcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5pbml0RWRpdFRyaWdnZXIoKTtcclxufTtcclxuXHJcbkFic3RyYWN0RWRpdEFkZGl0aW9uLnByb3RvdHlwZS5pbml0RWRpdFRyaWdnZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIG9iamVjdC5lYWNoKHRoaXMuY29uZmlnLCBmdW5jdGlvbihrZXksIGVkaXRJdGVtKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChlZGl0SXRlbS50cmlnZ2VyKSkge1xyXG4gICAgICAgICAgICB0aGF0LmFkZEVkaXRUZXh0VHJpZ2dlcihrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLmFkZEVkaXRUcmlnZ2VyID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBzd2l0Y2godHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICAgICAgdGhpcy5hZGRFZGl0VGV4dFRyaWdnZXIoa2V5KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuYWRkRWRpdFRleHRUcmlnZ2VyID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICB2YXIgZWRpdEl0ZW0gPSB0aGlzLmdldEVkaXRJdGVtKGtleSk7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgdmFyIHNlbGVjdG9yID0gdGhpcy5lZGl0YWJsZS5zZWxlY3RvcihlZGl0SXRlbS50cmlnZ2VyKTtcclxuICAgICQoc2VsZWN0b3IpLmNzcygnY3Vyc29yJywgJ3BvaW50ZXInKTtcclxuXHJcbiAgICAvL1RPRE86IGV2dGwgbW92ZSB0aGlzIHRvIHRleHQuZWRpdGFibGUoKTtcclxuICAgIHRoaXMuZWRpdGFibGUucm9vdC4kKCkub24oJ2NsaWNrJywgc2VsZWN0b3IsICBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZih0aGF0LmlzVHJpZ2dlckFsbG93ZWQoKSkge1xyXG4gICAgICAgICAgICAvL1RPRE86IHJlbW92ZSBVSSBkZXBlbmRlbmN5IGFuZCBoYW5kbGUgaXQgdHJvdWdoIHRyaWdnZXIgZXZlbnRcclxuICAgICAgICAgICAgc3dpdGNoKGVkaXRJdGVtLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICAgICAgICAgICAgICBlZGl0UGFuZWwuY3JlYXRlVGV4dEFyZWFFZGl0KGV2dC5wYWdlWCwgZXZ0LnBhZ2VZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmdldFZhbHVlKGtleSkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRWYWx1ZShrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgICAgICAgICBlZGl0UGFuZWwuY3JlYXRlVGV4dEVkaXQoZXZ0LnBhZ2VYLCBldnQucGFnZVksIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2V0VmFsdWUoa2V5KS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNldFZhbHVlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICB2YXIgZWRpdEl0ZW0gPSB0aGlzLmdldEVkaXRJdGVtKGtleSk7XHJcbiAgICB2YXIgZWRpdEZ1bmN0aW9uID0gdGhpcy5lZGl0RnVuY3Rpb25zW2VkaXRJdGVtLnR5cGVdO1xyXG4gICAgaWYoZWRpdEZ1bmN0aW9uICYmICFvYmplY3QuaXNTdHJpbmcoZWRpdEZ1bmN0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRGdW5jdGlvbnNbZWRpdEl0ZW0udHlwZV0uZ2V0LmNhbGwodGhpcywgZWRpdEl0ZW0sIGtleSk7XHJcbiAgICB9IGVsc2UgaWYoZWRpdEZ1bmN0aW9uICYmIG9iamVjdC5pc1N0cmluZyhlZGl0RnVuY3Rpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGUuZ2V0SW5uZXJTVkcoZWRpdEl0ZW0uYmluZClbZWRpdEZ1bmN0aW9uXSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgdmFyIGVkaXRJdGVtID0gdGhpcy5nZXRFZGl0SXRlbShrZXkpO1xyXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRWYWx1ZShrZXkpO1xyXG4gICAgdmFyIGVkaXRGdW5jdGlvbiA9IHRoaXMuZWRpdEZ1bmN0aW9uc1tlZGl0SXRlbS50eXBlXTtcclxuICAgIGlmKGVkaXRGdW5jdGlvbiAmJiAhb2JqZWN0LmlzU3RyaW5nKGVkaXRGdW5jdGlvbikpIHtcclxuICAgICAgICB0aGlzLmVkaXRGdW5jdGlvbnNbZWRpdEl0ZW0udHlwZV0uc2V0LmNhbGwodGhpcywgZWRpdEl0ZW0sIHZhbHVlKTtcclxuICAgICAgICB0aGlzLm9uU2V0VmFsdWUoZWRpdEl0ZW0sIHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZihlZGl0RnVuY3Rpb24gJiYgb2JqZWN0LmlzU3RyaW5nKGVkaXRGdW5jdGlvbikpIHtcclxuICAgICAgICB0aGlzLmVkaXRhYmxlLmdldElubmVyU1ZHKGVkaXRJdGVtLmJpbmQpW2VkaXRGdW5jdGlvbl0odmFsdWUpO1xyXG4gICAgICAgIHRoaXMub25TZXRWYWx1ZShlZGl0SXRlbSwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuZWRpdGFibGUuZXhlYykge1xyXG4gICAgICAgIHRoaXMuZWRpdGFibGUuZXhlYygnZWRpdCcsIFtrZXksIHZhbHVlLCBvbGRWYWx1ZV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGVpdGhlciByZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGVkaXRJdGVtIGZvciBub3JtYWwga2V5cyBsaWtlICd0aXRsZScsIG9yXHJcbiAqIGNyZWF0ZXMgYSBuZXcgZWRpdEl0ZW0gb3V0IG9mIGEgY29tYmluZWQga2V5IGxpa2UgJ3RpdGxlX3RleHQtc2l6ZScgd2l0aCBrZXkgdGl0bGUgYW5kIHR5cGUgdGV4dC1zaXplXHJcbiAqL1xyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuZ2V0RWRpdEl0ZW0gPSBmdW5jdGlvbihrZXkpIHtcclxuICAgIHZhciB0eXBlO1xyXG4gICAgdmFyIGVkaXRJdGVtO1xyXG4gICAgaWYoa2V5LmluZGV4T2YoJzonKSA+IC0xKSB7XHJcbiAgICAgICAgdmFyIHNwbGl0dGVkID0ga2V5LnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgZWRpdEl0ZW0gPSBvYmplY3QuY2xvbmVPYmplY3QodGhpcy5jb25maWdbc3BsaXR0ZWRbMF1dKTtcclxuICAgICAgICBlZGl0SXRlbS50eXBlID0gc3BsaXR0ZWRbMV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVkaXRJdGVtID0gdGhpcy5jb25maWdba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBlZGl0SXRlbTtcclxufTtcclxuXHJcbkFic3RyYWN0RWRpdEFkZGl0aW9uLnByb3RvdHlwZS5pc1RyaWdnZXJBbGxvd2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gIXRoaXMubGFzdFNlbGVjdCB8fCAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdFNlbGVjdCA+IDIwMCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuc2V0VGV4dEFyZWFDb250ZW50ID0gZnVuY3Rpb24oJHRleHRBcmVhTm9kZSwgdHh0QXJlYUNvbnRlbnQpIHtcclxuICAgIHRoaXMuZWRpdGFibGUuZGlhZ3JhbS5zdmcuZ2V0KCR0ZXh0QXJlYU5vZGUpLmNvbnRlbnQodHh0QXJlYUNvbnRlbnQpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLmdldFRleHRBcmVhQ29udGVudCA9IGZ1bmN0aW9uKCR0ZXh0QXJlYU5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLmVkaXRhYmxlLmRpYWdyYW0uc3ZnLmdldCgkdGV4dEFyZWFOb2RlKS5jb250ZW50KCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmxhc3RTZWxlY3QgPSBEYXRlLm5vdygpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZWRpdFBhbmVsLmNsb3NlKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdEVkaXRBZGRpdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RFZGl0QWRkaXRpb24ucHJvdG90eXBlLm9uU2V0VmFsdWUgPSBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHsgfTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RFZGl0QWRkaXRpb247IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG52YXIgQ29tbWFuZCA9IHJlcXVpcmUoJy4uL2NvcmUvY29tbWFuZCcpO1xyXG5cclxudmFyIE1hbmFnZXIgPSBmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSBkaWFncmFtO1xyXG4gICAgdGhpcy5ldmVudCA9IGRpYWdyYW0uZXZlbnQ7XHJcbn07XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZS5jb21tYW5kID0gZnVuY3Rpb24oY21kSWQsIGRvQWN0aW9uLCB1bmRvQWN0aW9uKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0ucmVnaXN0ZXJDb21tYW5kKGNtZElkLCBuZXcgQ29tbWFuZCh0aGlzLCBkb0FjdGlvbiwgdW5kb0FjdGlvbikpO1xyXG59O1xyXG5cclxuTWFuYWdlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGNtZElkLCBkb0FyZ3MsIHVuZG9BcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLmV4ZWN1dGVDb21tYW5kKGNtZElkLCBkb0FyZ3MsIHVuZG9BcmdzKTtcclxufTtcclxuXHJcbk1hbmFnZXIucHJvdG90eXBlLmFkZENtZCA9IGZ1bmN0aW9uKGNtZElkLCBkb0FyZ3MsIHVuZG9BcmdzKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0uYWRkQ29tbWFuZChjbWRJZCwgZG9BcmdzLCB1bmRvQXJncyk7XHJcbn07XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbihldmVudElkLCBoYW5kbGVyKSB7XHJcbiAgICB0aGlzLmV2ZW50Lmxpc3RlbihldmVudElkLCBoYW5kbGVyLCB0aGlzKTtcclxufTtcclxuXHJcbk1hbmFnZXIucHJvdG90eXBlLmdldE5vZGVCeUlkID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHJldHVybiB0aGlzLmRpYWdyYW0uZ2V0Tm9kZUJ5SWQoaWQpO1xyXG59O1xyXG5cclxuTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkJ5SWQgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlhZ3JhbS5nZXRUcmFuc2l0aW9uQnlJZChpZCk7XHJcbn07XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZS5nZXRTVkcgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuICQuc3ZnKGlkKTtcclxufTtcclxuXHJcbk1hbmFnZXIucHJvdG90eXBlLmdldE5vZGVNZ3IgPSBmdW5jdGlvbihjb21tYW5kKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLm5vZGVNZ3I7XHJcbn07XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uTWdyID0gZnVuY3Rpb24oY29tbWFuZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlhZ3JhbS50cmFuc2l0aW9uTWdyO1xyXG59O1xyXG5cclxuTWFuYWdlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uTWdyID0gZnVuY3Rpb24oY29tbWFuZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlhZ3JhbS5zZWxlY3Rpb25NZ3I7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7IiwidmFyIFBhdGhEYXRhID0gcmVxdWlyZSgnLi4vc3ZnL3BhdGhEYXRhJyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG5cclxudmFyIEFic3RyYWN0UGF0aE1hbmFnZXIgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucGF0aCA9IHRoaXMudHJhbnNpdGlvbi5nZXRMaW5lKCkuZCgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24ocGF0aERhdGFTdHIpIHtcclxuICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoRGF0YSgpLmxvYWRGcm9tU3RyaW5nKHBhdGhEYXRhU3RyKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLmRyYWdMaW5lID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIC8vIEluaXQgcGF0aCBpZiBubyBwYXRoIHdhcyBjcmVhdGVkIHlldFxyXG4gICAgaWYoIXRoaXMucGF0aCkge1xyXG4gICAgICAgIHRoaXMuaW5pdChwb3NpdGlvbilcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgZnVsbCBwYXRoIGlmIHRoZSBwYXRoIG9ubHkgY29uc2lzdCBvZiB0aGUgc3RhcnQgcGF0aCBwYXJ0IHlldCBvciB1cGRhdGUgdGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcGF0aFxyXG4gICAgaWYodGhpcy5wYXRoLmxlbmd0aCgpID09PSAxKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGUocG9zaXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnBhdGguZW5kKHBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLnBhdGggPSBuZXcgUGF0aERhdGEoKS5zdGFydChwb3NpdGlvbik7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVQYXJ0ID0gZnVuY3Rpb24oaW5kZXgsIHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLnBhdGguc2V0VG8oaW5kZXgsIHBvc2l0aW9uKTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5hZGRQYXRoUGFydCA9IGZ1bmN0aW9uKGluZGV4LCBwb3NpdGlvbikge1xyXG4gICAgaWYoIXRoaXMucGF0aCkge1xyXG4gICAgICAgIHRoaXMuaW5pdChwb3NpdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYWRkKGluZGV4LHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlUGF0aFBhcnQgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgaWYodGhpcy5wYXRoKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoLnJlbW92ZVBhdGgoaW5kZXgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKG9sZCwgcG9zaXRpb25zKSB7XHJcbiAgICB0aGlzLmJ1aWxkUGF0aChwb3NpdGlvbnMpO1xyXG5cclxuICAgIC8vV2Ugc2V0IG91ciBjcmVhdGVkIHBhdGggZGF0YSB0byB0aGUgZXhpc3RpbmcgcGF0aCwgc2luY2UgdGhlIHRyYW5zaXRpb24gbGluZSBhbmQgbGluZWFyZWEgYXJlIGRlcGVuZGVudCBvbiB0aGlzIHBhdGggaW5zdGFuY2VcclxuICAgIG9sZC5wYXRoLmRhdGEgPSB0aGlzLnBhdGguZGF0YTtcclxuICAgIHRoaXMucGF0aCA9IG9sZC5wYXRoO1xyXG5cclxuICAgIHRoaXMudHJhbnNpdGlvbi5wYXRoTWFuYWdlciA9IHRoaXM7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xyXG4gICAgdGhpcy5pbml0KHBvc2l0aW9uc1swXSk7XHJcblxyXG4gICAgZm9yKHZhciBpICA9IDE7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLmFkZChpLCBwb3NpdGlvbnNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5nZXROZWFyZXN0UG9pbnQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0aC5nZXROZWFyZXN0UG9pbnQocG9zaXRpb24pO1xyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUuZ2V0SW5kZXhGb3JQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXRoLmdldFBhdGhJbmRleEZvclBvc2l0aW9uKHBvc2l0aW9uKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAnPGI+UGF0aDo8L2I+ICcrdGhpcy5wYXRoLnRvU3RyaW5nKCkrJzxiciAvPic7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihwb3NpdGlvbikgey8qQWJzdHJhY3QqL307XHJcbkFic3RyYWN0UGF0aE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7LypBYnN0cmFjdCovfTtcclxuQWJzdHJhY3RQYXRoTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaW5kZXgsIHBvc2l0aW9uKSB7LypBYnN0cmFjdCovfTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RQYXRoTWFuYWdlcjsiLCJ2YXIgYWRkaXRpb25zID0ge307XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxuXHJcbnZhciBBZGRpdGlvbkZhY3RvcnkgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuYWRkaXRpb25zID0ge307XHJcbn07XHJcblxyXG5BZGRpdGlvbkZhY3RvcnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oa2V5LCBhZGRpdGlvbikge1xyXG4gICAgdGhpcy5hZGRpdGlvbnNba2V5XSA9IGFkZGl0aW9uO1xyXG59O1xyXG5cclxuQWRkaXRpb25GYWN0b3J5LnByb3RvdHlwZS5pbml0QWRkaXRpb24gPSBmdW5jdGlvbihrZXksIGhvc3QpIHtcclxuICAgIGlmICghaG9zdC5hZGRpdGlvbnMpIHtcclxuICAgICAgICBob3N0LmFkZGl0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhZGRpdGlvbiA9IHRoaXMuYWRkaXRpb25zW2tleV07XHJcblxyXG4gICAgaWYoYWRkaXRpb24gJiYgaG9zdCAmJiBfY2hlY2tDb25maWdSZXF1aXJlbWVudChhZGRpdGlvbiwgaG9zdCwga2V5KSkge1xyXG4gICAgICAgIGhvc3QuYWRkaXRpb25zW2tleV0gPSBuZXcgYWRkaXRpb24oaG9zdCk7XHJcbiAgICB9IGVsc2UgaWYoIWFkZGl0aW9uKXtcclxuICAgICAgICBldmVudC50cmlnZ2VyKCd3YXJuJywgJ1RyaWVkIHRvIGluaXRpYXRlIGFuIHVua25vd24gYWRkaXRpb24gJytrZXkrJyBzb21lIGZ1bmN0aW9uYWxpdHkgbWF5IG5vdCBhdmFpbGFibGUuJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgbm9kZUFkZGl0aW9ucyA9IG5ldyBBZGRpdGlvbkZhY3RvcnkoKTtcclxudmFyIHRyYW5zaXRpb25BZGRpdGlvbnMgPSBuZXcgQWRkaXRpb25GYWN0b3J5KCk7XHJcblxyXG52YXIgX2NoZWNrQ29uZmlnUmVxdWlyZW1lbnQgPSBmdW5jdGlvbihhZGRpdGlvbiwgaG9zdCwga2V5KSB7XHJcbiAgICByZXR1cm4gIWFkZGl0aW9uLnJlcXVpcmVDb25maWcgfHwgKGFkZGl0aW9uLnJlcXVpcmVDb25maWcgJiYgKGhvc3QuY29uZmlnICYmIGhvc3QuY29uZmlnW2tleV0pKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcmVnaXN0ZXJOb2RlQWRkaXRpb24gOiBmdW5jdGlvbihrZXksIGFkZGl0aW9uKSB7bm9kZUFkZGl0aW9ucy5yZWdpc3RlcihrZXksYWRkaXRpb24pfSxcclxuICAgIGluaXROb2RlQWRkaXRpb24gOiBmdW5jdGlvbihrZXksIGhvc3QpIHtub2RlQWRkaXRpb25zLmluaXRBZGRpdGlvbihrZXksIGhvc3QpfSxcclxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkFkZGl0aW9uIDogZnVuY3Rpb24oa2V5LCBhZGRpdGlvbikge3RyYW5zaXRpb25BZGRpdGlvbnMucmVnaXN0ZXIoa2V5LGFkZGl0aW9uKX0sXHJcbiAgICBpbml0VHJhbnNpdGlvbkFkZGl0aW9uIDogZnVuY3Rpb24oa2V5LCBob3N0KSB7dHJhbnNpdGlvbkFkZGl0aW9ucy5pbml0QWRkaXRpb24oa2V5LCBob3N0KX0sXHJcbiAgICBpbml0VHJhbnNpdGlvbkFkZGl0aW9ucyA6IGZ1bmN0aW9uKGhvc3QpIHtcclxuICAgICAgICAkLmVhY2godHJhbnNpdGlvbkFkZGl0aW9ucy5hZGRpdGlvbnMsIGZ1bmN0aW9uKGtleSwgYWRkaXRpb24pIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbkFkZGl0aW9ucy5pbml0QWRkaXRpb24oa2V5LCBob3N0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTsiLCJ2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XHJcblxyXG52YXIgRGlhZ3JhbUFQSSA9IGZ1bmN0aW9uKGRpYWdyYW0pIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IGRpYWdyYW07XHJcbn07XHJcblxyXG5EaWFncmFtQVBJLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24odG1wbElkLCBwb3NpdGlvbikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHRoYXQubG9hZFRlbXBsYXRlKHRtcGxJZClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhhdC5kaWFncmFtLm5vZGVNZ3IuY3JlYXRlTm9kZUNvbW1hbmQodGVtcGxhdGUsIHBvc2l0aW9uKSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG59O1xyXG5cclxuRGlhZ3JhbUFQSS5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRUcmFuc2l0aW9uID0gZnVuY3Rpb24odG1wbCwgcG9zaXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLmRpYWdyYW0uc2VsZWN0aW9uTWdyLnNlbGVjdGVkVHJhbnNpdGlvbjtcclxufTtcclxuXHJcbkRpYWdyYW1BUEkucHJvdG90eXBlLmxvYWRUZW1wbGF0ZSA9IGZ1bmN0aW9uKHRtcGwpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB0aGF0LmRpYWdyYW0udGVtcGxhdGVNZ3IuZ2V0VGVtcGxhdGUodG1wbClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuRGlhZ3JhbUFQSS5wcm90b3R5cGUuZ2V0U2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uKHRtcGwsIHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLnNlbGVjdGlvbk1nci5nZXRTZWxlY3RlZE5vZGVzKCk7XHJcbn07XHJcblxyXG5EaWFncmFtQVBJLnByb3RvdHlwZS5nZXROb2RlQnlJZCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWFncmFtLm5vZGVNZ3IuZ2V0Tm9kZShpZCk7XHJcbn07XHJcblxyXG5EaWFncmFtQVBJLnByb3RvdHlwZS5jcmVhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyKSB7XHJcbiAgICByZXR1cm4gbm9kZTEuYWRkaXRpb25zLnRyYW5zaXRpb24uc3RhcnROZXdUcmFuc2l0aW9uKG5vZGUyKTtcclxufTtcclxuXHJcbkRpYWdyYW1BUEkucHJvdG90eXBlLmdldFRyYW5zaXRpb25CeUlkID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHJldHVybiB0aGlzLmRpYWdyYW0udHJhbnNpdGlvbk1nci5nZXRUcmFuc2l0aW9uKGlkKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlhZ3JhbUFQSTsiLCJ2YXIgQWJzdHJhY3RQYXRoTWFuYWdlciA9IHJlcXVpcmUoJy4vYWJzdHJhY3RQYXRoTWFuYWdlcicpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG5cclxudmFyIEN1cnZlZFBhdGhNYW5hZ2VyID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgQWJzdHJhY3RQYXRoTWFuYWdlci5jYWxsKHRoaXMsIHRyYW5zaXRpb24pO1xyXG4gICAgdGhpcy50eXBlID0gQ3VydmVkUGF0aE1hbmFnZXIudHlwZTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoQ3VydmVkUGF0aE1hbmFnZXIsIEFic3RyYWN0UGF0aE1hbmFnZXIpO1xyXG5cclxuQ3VydmVkUGF0aE1hbmFnZXIudHlwZSA9ICdjdXJ2ZWQnO1xyXG5cclxuQ3VydmVkUGF0aE1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAvL0NvbnRyb2wgcG9pbnRzIGFyZSBjYWxjdWxhdGVkIGJ5IGNhbGxpbmcgdXBkYXRlXHJcbiAgICB0aGlzLnBhdGguY0Jlemllcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgcG9zaXRpb24pO1xyXG59O1xyXG5cclxuQ3VydmVkUGF0aE1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGluZGV4LCBwb3NpdGlvbikge1xyXG4gICAgdGhpcy5wYXRoLmluc2VydENCZXppZXIoaW5kZXgsdW5kZWZpbmVkLCB1bmRlZmluZWQsIHBvc2l0aW9uKTtcclxufTtcclxuXHJcbkN1cnZlZFBhdGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucGF0aC5zbW9vdGhlbigpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDdXJ2ZWRQYXRoTWFuYWdlcjtcclxuIiwiLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhIGRpYWdyYW0gYW5kIGlzIHJlc3BvbnNpYmxlIGZvciBpbml0aWFsaXppbmcgYW5kXHJcbiAqIGJ1aWxkaW5nIHRoZSBzdGFnZS4gRnVydGhlcm1vcmUgaXQgY29udGFpbnMgZGlhZ3JhbSByZWxhdGVkIHV0aWxpdHkgZnVuY3Rpb25hbGl0eS5cclxuICpcclxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBvZmZlcnMgdGhlIGFjY2VzcyB0byBhbGwgbm9kZXMvdHJhbnNpdGlvbnMgYW5kIHRlbXBsYXRlcyBvZiB0aGVcclxuICogZGlhZ3JhbS5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byBiZSBhYmxlIHRvIG1hbmFnZSBtdWx0aXBsZSBkaWFncmFtcyB3aXRoaW4gb25lXHJcbiAqIGFwcGxpY2F0aW9uIGluc3RhbmNlLlxyXG4gKi9cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG52YXIgU1ZHID0gcmVxdWlyZSgnLi4vc3ZnL3N2ZycpO1xyXG52YXIgUGF0aERhdGEgPSByZXF1aXJlKCcuLi9zdmcvcGF0aERhdGEnKTsgLy9SYXRoZXIgaW1wbGVtZW50IHN2Zy5jcmVhdGVwYXRoKCkuc3RhcnQoKS5saW5lKCkuLi5cclxudmFyIHRlbXBsYXRlTWFuYWdlciA9IHJlcXVpcmUoJy4vdGVtcGxhdGVNYW5hZ2VyJykuaW5pdCgpO1xyXG52YXIgY29tbWFuZE1hbmFnZXIgPSByZXF1aXJlKCcuLi9jb3JlL2NvbW1hbmRNYW5hZ2VyJyk7XHJcbnZhciBTZWxlY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9zZWxlY3Rpb25NYW5hZ2VyJyk7XHJcbnZhciBOb2RlTWFuYWdlciA9IHJlcXVpcmUoJy4vbm9kZU1hbmFnZXInKTtcclxudmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi90cmFuc2l0aW9uTWFuYWdlcicpO1xyXG52YXIgRGlhZ3JhbUFQSSA9IHJlcXVpcmUoJy4vYXBpJyk7XHJcblxyXG52YXIgZmlsZU1hbmFnZXIgPSByZXF1aXJlKCcuLi9jb3JlL2ZpbGVNYW5hZ2VyJyk7XHJcblxyXG52YXIgRXZlbnRhYmxlID0gcmVxdWlyZSgnLi8uLi9kb20vZXZlbnRhYmxlTm9kZScpO1xyXG5cclxudmFyIEtub2IgPSByZXF1aXJlKCcuL2tub2InKTtcclxuXHJcbnZhciBLbm9iTWFuYWdlciA9IHJlcXVpcmUoJy4va25vYk1hbmFnZXInKTtcclxucmVxdWlyZSgnLi9rbm9iVGVtcGxhdGUnKTtcclxucmVxdWlyZSgnLi9pbWFnZVRlbXBsYXRlJyk7XHJcbnZhciB4bWwgPSByZXF1aXJlKCcuLi91dGlsL3htbCcpO1xyXG5cclxudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xyXG5cclxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4vLi4vc3ZnL2hlbHBlcicpO1xyXG5cclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvcmUvY29uZmlnJyk7XHJcblxyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxuXHJcbnZhciBDT05UQUlORVJfU0VMRUNUT1IgPSAnI3N2Z1N0YWdlJztcclxuLy8gQ29udGFpbnMgdGhlIHBhcmVudCBkb20gbm9kZSAoZGl2KSBvZiB0aGUgU1ZHIGVsZW1lbnRcclxudmFyICRDT05UQUlORVJfTk9ERSA9ICQoQ09OVEFJTkVSX1NFTEVDVE9SKTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RvciBmb3IgaW5pdGlhdGluZyBhIG5ldyBkaWFncmFtIGluc3RhbmNlIHdpdGhpbiB0aGUgY29udGFpbmVySUQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dHlwZX0gY29udGFpbmVySUQgVGhlIHBhcmVudCBvZiB0aGUgbmV3IFNWRyBkaWFncmFtXHJcbiAqIEBwYXJhbSB7dHlwZX0gY2ZnXHJcbiAqL1xyXG52YXIgRGlhZ3JhbSA9IGZ1bmN0aW9uIChjZmcpIHtcclxuICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuXHJcbiAgICBpZiAoIWNmZy5pZCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignQ3JlYXRlZCBkaWFncmFtIHdpdGhvdXQgaWQnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVuaXF1ZUlkcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuaWQgPSBjZmcuaWQgfHwgJ25vdCBzcGVjaWZpZWQnO1xyXG4gICAgdGhpcy5wcm9qZWN0SWQgPSBjZmcucHJvamVjdElkIHx8ICdkZWZhdWx0JztcclxuICAgIHRoaXMudGl0bGUgPSBjZmcudGl0bGUgfHwgJ25ldyc7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHJcbiAgICAvL0RpYWdyYW0gaW50ZXJuIGV2ZW50IGNvbnRleHRcclxuICAgIHRoaXMuZXZlbnQgPSBldmVudC5zdWIodGhpcy5pZCk7XHJcblxyXG4gICAgaWYgKGNmZy5jb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkKGNmZy5jb250YWluZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkQ09OVEFJTkVSX05PREU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnVpbGQgdGhlIFNWRyBzdGFnZSB3aXRoaW4gdGhlIGNvbnRhaW5lclxyXG4gICAgdGhpcy5zdmcgPSBuZXcgU1ZHKHRoaXMuJGNvbnRhaW5lci5hdHRyKCdpZCcpLCB0aGlzLm5zKCkpO1xyXG4gICAgdGhpcy5ldmVudEJhc2UgPSB0aGlzLnN2Zy5yb290O1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuY29tbWFuZE1nciA9IGNvbW1hbmRNYW5hZ2VyLnN1Yih0aGlzLmlkLCBmdW5jdGlvbiAoY21kKSB7XHJcbiAgICAgICAgdGhhdC50cmlnZ2VyVXBkYXRlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIYW5kbGVzIHRoZSBsb2FkaW5nIGFuZCBjcmVhdGlvbiBvZiB0ZW1wbGF0ZXNcclxuICAgIHRoaXMudGVtcGxhdGVNZ3IgPSB0ZW1wbGF0ZU1hbmFnZXI7XHJcbiAgICAvLyBUaGlzIGhlbHBlciBjbGFzcyBtYW5hZ2VzIHRoZSBzZWxlY3Rpb24gb2Ygbm9kZXMvdHJhbnNpdGlvbnNcclxuICAgIHRoaXMuc2VsZWN0aW9uTWdyID0gbmV3IFNlbGVjdGlvbk1hbmFnZXIodGhpcyk7XHJcbiAgICAvLyBSZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIG1haW50YWluaW5nIG5vZGVzXHJcbiAgICB0aGlzLm5vZGVNZ3IgPSBuZXcgTm9kZU1hbmFnZXIodGhpcyk7XHJcbiAgICAvLyBSZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIG1haW50YWluaW5nIHRyYW5zaXRpb25zXHJcbiAgICB0aGlzLnRyYW5zaXRpb25NZ3IgPSBuZXcgVHJhbnNpdGlvbk1hbmFnZXIodGhpcyk7XHJcbiAgICAvLyBSZXNwb25zaWJsZSBmb3IgdHJhY2tpbmcgYW5kIGFjY2Vzc2luZyBhbGwgZG9ja2luZ3Mgb24gdGhlIGRpYWdyYW1cclxuICAgIHRoaXMua25vYk1nciA9IG5ldyBLbm9iTWFuYWdlcih0aGlzKTtcclxuXHJcbiAgICAvLyBJbml0IHN0YWdlIHJlbGF0ZWQgYW5kIGtleSBldmVudHNcclxuICAgIHRoaXMuaW5pdEV2ZW50cygpO1xyXG5cclxuICAgIHRoaXMuc2NhbGUgPSAxO1xyXG5cclxuICAgIC8vVGhpcyBpcyB1c2VkIGJ5IHRoZSBldmVudGFibGUgYWRkaXRpb24gaW4gY2FzZSB0aGVyZSBhcmUgZXZlbnQgcmVzdHJpY3Rpb25zIChtb3ZlIG1vZGUuLi4pXHJcbiAgICB0aGlzLmV4Y2x1ZGVFdmVudFJlc3RyaWN0aW9ucyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdGhpcy5zdmcuY3JlYXRlUGFydCgnYmFja2dyb3VuZCcpO1xyXG4gICAgdGhpcy5zdmcucmVjdCh7d2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIGZpbGw6ICcjRkZGRkZGJ30sICdiYWNrZ3JvdW5kJyk7XHJcblxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5pbml0RGVmcygpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGF0LmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhhdC5tYWluUGFydCA9IHRoYXQuc3ZnLmNyZWF0ZVBhcnQoJ21haW4nLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhhdC5tYWluUGFydC5leGNsdWRlRXZlbnRSZXN0cmljdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGF0LmhlbHBlciA9IHRoYXQuc3ZnLmhlbHBlcigpO1xyXG4gICAgICAgICAgICB0aGF0LnRyaWdnZXIoJ2luaXRpYWxpemVkJyk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgbG9hZCBkZWZzIGluaXRpYWxpc2F0aW9uIGZhaWxlZCEnKTtcclxuICAgICAgICB9KTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoRGlhZ3JhbSwgRXZlbnRhYmxlKTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLm5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHtcInhtbG5zOmRhbGFcIjogXCJodHRwOi8vd3d3LmRhbGEuY29tXCJ9O1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuZ2V0Um9vdFNWRyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnN2Zy5yb290O1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUudHJpZ2dlclVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudHJpZ2dlcignZGlhZ3JhbV91cGRhdGVkJywgdGhpcy5pZCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGVNZ3IuZ2V0Tm9kZXMoZmlsdGVyKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZ0LCBhcmdzKSB7XHJcbiAgICAvL3BlcmhhcHMgYWxzbyBsaXN0ZW4gdG8gZGlhZ3JhbSBpbnRlcm4gZXZlbnRzIG5vdCBvbmx5IGRvbSBldmVudHMuXHJcbiAgICB0aGlzLnN2Zy5yb290LnRyaWdnZXIoZXZ0LCBhcmdzKTtcclxuICAgIHRoaXMuZXZlbnQudHJpZ2dlcihldmVudCwgYXJncyk7XHJcbn07XHJcblxyXG4vKlxyXG4gKiBJbml0aWFsaXplcyBTdGFnZSBNb3VzZSBhbmQgS2V5IGV2ZW50cy5cclxuICovXHJcbkRpYWdyYW0ucHJvdG90eXBlLmluaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAvLyBEb3VibGUgY2xpY2tzIG9uIHRoZSBzdGFnZSBhcmVhIHdpbGwgY3JlYXRlIG5ldyBub2RlcyBvZiB0aGUgc2VsZWN0ZWRcclxuICAgIC8vIHRlbXBsYXRlIHR5cGUuIE9ubHkgaWYgd2UgZG8gbm90IGRiY2xpY2sgYW5vdGhlciBub2RlIGluIHRoaXMgY2FzZVxyXG4gICAgLy8gd2Ugc3RhcnQgYSB0cmFuc2l0aW9uIGRyYWcuXHJcbiAgICB0aGlzLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICBpZiAoY29uZmlnLmlzKCdkaWFncmFtX21vZGVfZHJhd190cmFuc2l0aW9uJykpIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhhdC5nZXRTdGFnZVBvc2l0aW9uKGV2dCk7XHJcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlRnJlZVRyYW5zaXRpb24ocG9zaXRpb24sIHBvc2l0aW9uLCB0cnVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCF0aGF0LnNlbGVjdGlvbk1nci5pc0VsZW1lbnRIb3ZlcigpICYmICFjb25maWcuaXMoJ2RpYWdyYW1fbW9kZV9tb3ZlJykpIHtcclxuICAgICAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKCdub2RlX2NyZWF0ZScsIHRoYXQudGVtcGxhdGVNZ3IuZ2V0U2VsZWN0ZWRUZW1wbGF0ZSgpLCBldnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGF0LmdldFN0YWdlUG9zaXRpb24oZXZ0KTtcclxuXHJcbiAgICAgICAgaWYgKGV2dC5jdHJsS2V5IHx8IGNvbmZpZy5pcygnZGlhZ3JhbV9tb2RlX21vdmUnKSkge1xyXG4gICAgICAgICAgICAvL01vdmUgbWFpbiBwYXJ0XHJcbiAgICAgICAgICAgIHRoYXQubWFpblBhcnQuZHJhZ2dhYmxlKHtcclxuICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdhbGwtc2Nyb2xsJyxcclxuICAgICAgICAgICAgICAgIGRyYWdNb3ZlOiBmdW5jdGlvbiAoZXZlbnQsIGR4LCBkeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZXZlbnQudHJpZ2dlcigndmlld3BvcnRfdXBkYXRlJywgdGhpcy5wb3NpdGlvbigpKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkcmFnRW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmV2ZW50LnRyaWdnZXIoJ3ZpZXdwb3J0X3VwZGF0ZWQnLCB0aGlzLnBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlc3RyaWN0aW9uWDogZnVuY3Rpb24gKGV2ZW50LCBkeCwgZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMueCgpICsgZHggPD0gMCkgPyBkeCA6IDA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVzdHJpY3Rpb25ZOiBmdW5jdGlvbiAoZXZlbnQsIGR4LCBkeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy55KCkgKyBkeSA8PSAwKSA/IGR5IDogMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXRTY2FsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhhdC5tYWluUGFydC50cmlnZ2VyKCdtb3VzZWRvd24nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbk1nci5kcmFnU2VsZWN0aW9uU3RhcnQoZXZ0LCBzdGFydFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbignbW91c2V1cCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbk1nci5kcmFnU2VsZWN0aW9uRW5kKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBldmVudC5vbihkb2N1bWVudCwgXCJkcmFnc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBpZiAoZS50YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJQT0xZTElORVwiIHx8IGUudGFyZ2V0Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdQQVRIJyB8fCBlLnRhcmdldC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQ0lSQ0xFJykge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmNyZWF0ZUZyZWVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGluaXREcmFnLCBncm91cCkge1xyXG4gICAgdmFyIHN0YXJ0S25vYiA9IG5ldyBLbm9iKHRoaXMsIHN0YXJ0LCB7cmFkaXVzOiAxMH0sIGdyb3VwKS5kcmFnZ2FibGUoKTtcclxuICAgIHZhciBlbmRLbm9iID0gbmV3IEtub2IodGhpcywgZW5kLCB7cmFkaXVzOiAxMH0sIGdyb3VwKS5kcmFnZ2FibGUoKTtcclxuICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5jcmVhdGVUcmFuc2l0aW9uKHN0YXJ0S25vYi5ub2RlLCBlbmRLbm9iLm5vZGUpO1xyXG5cclxuICAgIGlmIChncm91cCkge1xyXG4gICAgICAgIGdyb3VwLmFwcGVuZCh0cmFuc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5pdERyYWcpIHtcclxuICAgICAgICBlbmRLbm9iLmluaXREcmFnKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJhbnNpdGlvbi5vbigncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHN0YXJ0S25vYi5yZW1vdmUoKTtcclxuICAgICAgICBlbmRLbm9iLnJlbW92ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc3RhcnRLbm9iLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbi5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGVuZEtub2Iub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cmFuc2l0aW9uLnJlbW92ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGFydEtub2I6IHN0YXJ0S25vYixcclxuICAgICAgICBlbmRLbm9iOiBlbmRLbm9iLFxyXG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25cclxuICAgIH1cclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLnBhcnQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLnN2Zy5wYXJ0KGlkKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAodGhpcy5ub2RlTWdyLnNpemUoKSkgPyB0aGlzLm5vZGVNZ3IuZ2V0Qm90dG9tTm9kZSgpLmdldEJvdHRvbVkodHJ1ZSkgOiAwO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubm9kZU1nci5zaXplKCkpID8gdGhpcy5ub2RlTWdyLmdldFJpZ2h0Tm9kZSgpLmdldFJpZ2h0WCh0cnVlKSA6IDA7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5kaW1lbnNpb25zID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICBpZiAodGhpcy5ub2RlTWdyLnNpemUoKSkge1xyXG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IHRoaXMubm9kZU1nci5nZXRMZWZ0Tm9kZSgpO1xyXG4gICAgICAgIHZhciB0b3BOb2RlID0gdGhpcy5ub2RlTWdyLmdldFRvcE5vZGUoKTtcclxuICAgICAgICB2YXIgcmlnaHROb2RlID0gdGhpcy5ub2RlTWdyLmdldFJpZ2h0Tm9kZSgpO1xyXG4gICAgICAgIHZhciBib3R0b21Ob2RlID0gdGhpcy5ub2RlTWdyLmdldEJvdHRvbU5vZGUoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aDogcmlnaHROb2RlLmdldFJpZ2h0WCgpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbU5vZGUuZ2V0Qm90dG9tWSgpLFxyXG4gICAgICAgICAgICB4OiBsZWZ0Tm9kZS54KCksXHJcbiAgICAgICAgICAgIHk6IGJvdHRvbU5vZGUueSgpLFxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5pbXBvcnQgPSBmdW5jdGlvbiAoc3ZnLCBwYXJ0LCBwcmVwZW5kKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdmcuaW1wb3J0KHN2ZywgcGFydCwgcHJlcGVuZCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5wYXJ0ID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdmcucGFydChpZCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5pbml0RGVmcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdGhhdC50ZW1wbGF0ZU1nci5nZXRUZW1wbGF0ZSgnZGVmc19tYXJrZXInKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodG1wbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRtcGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXBsLmNyZWF0ZU5vZGUoe2RpYWdyYW1JZDogdGhhdC5pZH0sIHRoYXQpLmluaXQoJ3Jvb3QnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgnQ291bGQgaW5pdGlhbGl6ZSBkZWZzIHRlbXBsYXRlIHJlc3VsdCB1bmRlZmluZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5jcmVhdGVLbm9iTm9kZSA9IGZ1bmN0aW9uIChwLCBncm91cCwgY2ZnKSB7XHJcbiAgICByZXR1cm4gdGhpcy5rbm9iTWdyLmNyZWF0ZUtub2JOb2RlKHAsIGdyb3VwLCBjZmcpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuYWN0aXZhdGVLbm9iTm9kZSA9IGZ1bmN0aW9uIChzdmdOb2RlLCBjZmcpIHtcclxuICAgIHJldHVybiB0aGlzLmtub2JNZ3IuYWN0aXZhdGVLbm9iTm9kZShzdmdOb2RlLCBjZmcpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUudW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbmV3SWQgPSB0aGlzLmNoZWNrSWQoRGF0ZS5ub3coKSArICcnKTtcclxuICAgIHRoaXMudW5pcXVlSWRzLnB1c2gobmV3SWQpO1xyXG4gICAgcmV0dXJuIG5ld0lkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByZXZlbnQgZHVwbGljYXRlc1xyXG4gKi9cclxuRGlhZ3JhbS5wcm90b3R5cGUuY2hlY2tJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgcmV0dXJuICgkLmluQXJyYXkoaWQsIHRoaXMudW5pcXVlSWRzKSA+IC0xKSA/IHRoaXMuY2hlY2tJZCgndScgKyBpZCkgOiBpZDtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmlzTXVsdGlTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25NZ3IuaXNNdWx0aVNlbGVjdGlvbigpO1xyXG59O1xyXG5cclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLm5ld0RpYWdyYW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvL1RPRE86IHdlIHNob3VsZCB1bmlmeSB0aGlzIHdpdGggdGhlIGNvbnN0cnVjdG9yIHN2ZyBjcmVhdGlvbiB0ZWNobmlxdWVcclxuICAgIHRoaXMubG9hZERpYWdyYW0oJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHZlcnNpb249XCIxLjFcIiBpZD1cInN2Z1N0YWdlX3N2Z1wiIHhtbG5zOmRhbGE9XCJodHRwOi8vd3d3LmRhbGEuY29tXCIgaGVpZ2h0PVwiMTAwJVwiIHdpZHRoPVwiMTAwJVwiPjwvc3ZnPicpO1xyXG4gICAgdGhpcy5pbml0RGVmcygpO1xyXG59O1xyXG5EaWFncmFtLnByb3RvdHlwZS5sb2FkRGlhZ3JhbSA9IGZ1bmN0aW9uIChzdmdTdHJpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAvL1RPRE86IHJhdGhlciBoYW5kbGUgdGhpcyBwZXIgZXZlbnQgb3IgaW4gY29uc3RydWN0b3JcclxuICAgIHRoaXMuY2xlYXIoKTtcclxuICAgIHRoaXMuc3ZnLnNldFJvb3QoZG9tLmltcG9ydFNWRyh0aGlzLnN2Zy4kY29udGFpbmVyLCBzdmdTdHJpbmcpKTtcclxuICAgIHRoaXMuZ2V0Um9vdFNWRygpLmhlaWdodCgnMTAwJScpO1xyXG4gICAgdGhpcy5nZXRSb290U1ZHKCkud2lkdGgoJzEwMCUnKTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuYWN0aXZhdGVOb2RlcygpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoYXQuYWN0aXZhdGVUcmFuc2l0aW9ucygpO1xyXG4gICAgICAgIHRoYXQuaW5pdEV2ZW50cygpO1xyXG4gICAgICAgIGlmIChvYmplY3QuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sodGhhdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uTWdyLmNsZWFyKCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy4kY29udGFpbmVyLmVtcHR5KCk7XHJcbiAgICB0aGlzLm5vZGVNZ3IuY2xlYXIoKTtcclxuICAgIHRoaXMuc2VsZWN0aW9uTWdyLmNsZWFyKCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS50cmlnZ2VyRG9ja2luZ1Zpc2liaWxpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5rbm9iTWdyLmhpZGVEb2NraW5nKSB7XHJcbiAgICAgICAgdGhpcy5rbm9iTWdyLnNob3dLbm9icygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmtub2JNZ3IuaGlkZUtub2JzKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5hY3RpdmF0ZU5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICB0aGlzLmdldFJvb3RTVkcoKS4kKCkuZmluZCgnLmVsZW1lbnRfcm9vdCcpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHByb21pc2VzLnB1c2godGhhdC5ub2RlTWdyLmFjdGl2YXRlTm9kZSh0aGlzKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbn07XHJcblxyXG4vL1RPRE86IG1vdmUgdG8gdHJhbnNpdGlvbm1nclxyXG5EaWFncmFtLnByb3RvdHlwZS5hY3RpdmF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy50cmFuc2l0aW9uTWdyLmFjdGl2YXRlVHJhbnNpdGlvbigkKCcudHJhbnNpdGlvbicpKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmdldE5vZGVCeUlkID0gZnVuY3Rpb24gKG5vZGVJZCkge1xyXG4gICAgdmFyIHJlc3VsdCA9ICB0aGlzLm5vZGVNZ3IuZ2V0Tm9kZShub2RlSWQpO1xyXG4gICAgaWYoIXJlc3VsdCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHRoaXMua25vYk1nci5nZXRLbm9iTm9kZShub2RlSWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmdldFRyYW5zaXRpb25CeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uTWdyLmdldE5vZGUoaWQpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuem9vbUluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5zY2FsZSArPSAwLjE7XHJcbiAgICB0aGlzLnBhcnQoJ21haW4nKS5zY2FsZSh0aGlzLnNjYWxlKTtcclxuICAgIHRoaXMuZXhlYygnem9vbUluJywgW3RoaXMuc2NhbGVdKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLnpvb21PdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5zY2FsZSA+IDApIHtcclxuICAgICAgICB0aGlzLnNjYWxlIC09IDAuMTtcclxuICAgICAgICB0aGlzLnBhcnQoJ21haW4nKS5zY2FsZSh0aGlzLnNjYWxlKTtcclxuICAgICAgICB0aGlzLmV4ZWMoJ3pvb21PdXQnLCBbdGhpcy5zY2FsZV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGRldGVybWluZXMgdGhlIHJlbGF0aXZlIHN0YWdlIGNvb3JkaW5hdGVzIGZvciBhIGdpdmVuXHJcbiAqIHdpbmRvdyBwb3NpdGlvbiBlaXRoZXIgYnkgcHJvdmlkaW5nIHRoZSB4IGFuZCB5IHBvc2l0aW9uIG9yIGFuIGV2ZW50XHJcbiAqIG9iamVjdCB3aXRoIGdpdmVuIHBhZ2VYIGFuZCBwYWdlWSBhdHRyaWJ1dGVzIG9yIGFuIHBvaW50IHdpdGggeCx5IGF0dHJpYnV0ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dHlwZX0geCBlaXRoZXIgYW4gZXZlbnQgb2JqZWN0IHdpdGggcGFnZVgsIHBhZ2VZIG9yIGFuIHBvaW50IHdpdGggeCx5XHJcbiAqICAgICAgICAgICAgICAgICBvciBqdXN0IHRoZSBwbGFpbiB4IGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7dHlwZX0geSB0aGUgeSBjb29yZGluYXRlIGlzIGp1c3QgbWFuZGF0b3J5IGlmIHRoZSBmaXNyc3QgYXJnIGlzIHRoZSBwbGFpbiB4XHJcbiAqIEByZXR1cm5zIHtEaWFncmFtX0wxMy5EaWFncmFtLnByb3RvdHlwZS5nZXRTdGFnZVBvc2l0aW9uLkRpYWdyYW1Bbm9ueW0kMn1cclxuICovXHJcbkRpYWdyYW0ucHJvdG90eXBlLmdldFN0YWdlUG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgaWYgKG9iamVjdC5pc0RlZmluZWQoeC5wYWdlWCkpIHtcclxuICAgICAgICB5ID0geC5wYWdlWTtcclxuICAgICAgICB4ID0geC5wYWdlWDtcclxuICAgIH0gZWxzZSBpZiAob2JqZWN0LmlzRGVmaW5lZCh4LngpKSB7XHJcbiAgICAgICAgeSA9IHgueTtcclxuICAgICAgICB4ID0geC54O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdGFnZVBvc2l0aW9uID0gdGhpcy4kY29udGFpbmVyLm9mZnNldCgpO1xyXG4gICAgdmFyIHZpZXdQb2ludEFsaWdubWVudCA9IHRoaXMubWFpblBhcnQucG9zaXRpb24oKTtcclxuXHJcbiAgICAvL1RPRE86IHZpZXdib3ggYWxpZ25lbWVudCA/XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHBhcnNlSW50KCh4IC0gc3RhZ2VQb3NpdGlvbi5sZWZ0IC0gdmlld1BvaW50QWxpZ25tZW50LngpIC8gdGhpcy5zY2FsZSksXHJcbiAgICAgICAgeTogcGFyc2VJbnQoKHkgLSBzdGFnZVBvc2l0aW9uLnRvcCAtIHZpZXdQb2ludEFsaWdubWVudC55KSAvIHRoaXMuc2NhbGUpXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGdpdmVuIHBvc2l0aW9uIGlzIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiBhIGRpYWdyYW0gbm9kZS5cclxuICogVE9ETzogZWl0aGVyIHJldHVybiBhbGwgb3ZlcmxheSBub2RlcyBvciBqdXN0IHRoZSBvbmUgd2l0aCB0aGUgYmlnZ2VzdCBpbmRleC4uLlxyXG4gKiBAcGFyYW0ge3R5cGV9IHBvc2l0aW9uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuRGlhZ3JhbS5wcm90b3R5cGUuZ2V0Tm9kZUJ5UG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLm5vZGVNZ3Iubm9kZXMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vdmVybGF5cyhwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRtcGxJZCwgcG9zaXRpb24pIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdGhhdC5sb2FkVGVtcGxhdGUodG1wbElkKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhhdC5ub2RlTWdyLmNyZWF0ZU5vZGVDb21tYW5kKHRlbXBsYXRlLCBwb3NpdGlvbikpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmdldFNlbGVjdGVkVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICh0bXBsLCBwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTWdyLnNlbGVjdGVkVHJhbnNpdGlvbjtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmxvYWRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0bXBsKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHRoYXQudGVtcGxhdGVNZ3IuZ2V0VGVtcGxhdGUodG1wbClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5zY3JlZW5TaG90ID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgd2l0aGFkZGl0aW9ucykge1xyXG4gICAgdmFyIHN0cmluZ1ZhbCA9ICh3aXRoYWRkaXRpb25zKSA/IHRoaXMuYXNTdHJpbmcoKSA6IHRoaXMuYXNQbGFpblN0cmluZygpO1xyXG4gICAgZmlsZU1hbmFnZXIubWFrZVNjcmVlblNob3QoY29udGFpbmVyLCBzdHJpbmdWYWwsIHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5nZXRTZWxlY3RlZE5vZGVzID0gZnVuY3Rpb24gKHRtcGwsIHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25NZ3IuZ2V0U2VsZWN0ZWROb2RlcygpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuY3JlYXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChub2RlMSwgbm9kZTIpIHtcclxuICAgIHJldHVybiBub2RlMS5hZGRpdGlvbnMudHJhbnNpdGlvbi5zdGFydE5ld1RyYW5zaXRpb24obm9kZTIpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25NZ3IuZ2V0VHJhbnNpdGlvbihpZCk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5hc1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnN2Zy5hc1N0cmluZygpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuYXNQbGFpblN0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciAkZGlhZ3JhbVhtbCA9IHRoaXMuY2xvbmUoKTtcclxuICAgICRkaWFncmFtWG1sLmZpbmQoJy5rbm9iJykucmVtb3ZlKCk7XHJcbiAgICAvL1RPRE86IERpYWdyYW0gZGltZW5zaW9uIHNldHRpbmdzXHJcbiAgICAkZGlhZ3JhbVhtbC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodCgpICsgMTApO1xyXG4gICAgJGRpYWdyYW1YbWwuYXR0cignd2lkdGgnLCB0aGlzLndpZHRoKCkgKyAxMCk7XHJcbiAgICAkZGlhZ3JhbVhtbC5maW5kKCcub3JpZW50YXRpb25Lbm9iJykuaGlkZSgpO1xyXG4gICAgJGRpYWdyYW1YbWwuZmluZCgnIycgKyB0aGlzLm1haW5QYXJ0LmF0dHIoJ2lkJykpLmF0dHIoJ3RyYW5zZm9ybScsICcnKTtcclxuICAgIHJldHVybiB1dGlsLnhtbC5zZXJpYWxpemVUb1N0cmluZygkZGlhZ3JhbVhtbFswXSk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnN2Zy5jbG9uZSgpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUudW5kb0NvbW1hbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmNvbW1hbmRNZ3IudW5kbygpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUucmVkb0NvbW1hbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmNvbW1hbmRNZ3IucmVkbygpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUucmVnaXN0ZXJDb21tYW5kID0gZnVuY3Rpb24gKGNtZElkLCBjbWQpIHtcclxuICAgIHRoaXMuY29tbWFuZE1nci5yZWdpc3RlcihjbWRJZCwgY21kKTtcclxufTtcclxuXHJcbkRpYWdyYW0ucHJvdG90eXBlLmV4ZWN1dGVDb21tYW5kID0gZnVuY3Rpb24gKGNtZElkLCBkb0FyZ3MsIHVuZG9BcmdzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWdyLmV4ZWMoY21kSWQsIGRvQXJncywgdW5kb0FyZ3MpO1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUuYWRkQ29tbWFuZCA9IGZ1bmN0aW9uIChjbWRJZCwgZG9BcmdzLCB1bmRvQXJncykge1xyXG4gICAgdGhpcy5jb21tYW5kTWdyLmFkZChjbWRJZCwgZG9BcmdzLCB1bmRvQXJncyk7XHJcbn07XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJzxociAvPic7XHJcbiAgICByZXN1bHQgKz0gJ0RpYWdyYW06ICcrdGhpcy5pZCsnPGJyIC8+JztcclxuICAgIHJlc3VsdCArPSB0aGlzLm5vZGVNZ3IuZHVtcCgpO1xyXG4gICAgcmVzdWx0ICs9IHRoaXMudHJhbnNpdGlvbk1nci5kdW1wKCkrJzxiciAvPic7XHJcbiAgICByZXN1bHQgKz0gJzxociAvPic7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuRGlhZ3JhbS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIHJlc3VsdFsndHJhbnNpdGlvbk1hbmFnZXInXSA9IHRoaXMudHJhbnNpdGlvbk1nci52YWxpZGF0ZSgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlhZ3JhbTtcclxuXHJcbiIsInZhciBEaWFncmFtID0gcmVxdWlyZSgnLi9kaWFncmFtJyk7XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxudmFyIGNsaWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvY2xpZW50Jyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcblxyXG52YXIgdXNlck1hbmFnZXIgPSByZXF1aXJlKCcuLi91c2VyL3VzZXJNYW5hZ2VyJyk7XHJcbnZhciBmaWxlTWFuYWdlciA9IHJlcXVpcmUoJy4uL2NvcmUvZmlsZU1hbmFnZXInKTtcclxuXHJcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb3JlL2NvbmZpZycpO1xyXG5cclxudmFyIGRpYWdyYW1zID0ge307XHJcbnZhciBhY3RpdmVEaWFncmFtSWQ7XHJcblxyXG4vL1RPRE86IGxvYWQgZnJvbSByZW1vdGUvbG9jYWwgc3RvcmFnZVxyXG5cclxuY29uZmlnLnNldFZhbCgndHJhbnNpdGlvbl9zZXR0aW5ncycsIHtcclxuICAgIHR5cGU6ICdzdHJhaWdodCcsXHJcbiAgICBzdHJva2U6ICcjNDc0NzQ3JyxcclxuICAgICdzdHJva2Utd2lkdGgnOiAnMScsXHJcbiAgICAnbWFya2VyLXN0YXJ0JzogJ25vbmUnLFxyXG4gICAgJ21hcmtlci1lbmQnIDogJ3RyaWFuZ2xlZmlsbCcsXHJcbiAgICAnc3Ryb2tlLWRhc2hhcnJheScgOiAnbm9uZSdcclxufSk7XHJcblxyXG5jb25maWcuc2V0VmFsKCdub2RlX3NldHRpbmdzJywge1xyXG4gICAgc3Ryb2tlOiAnIzQ3NDc0NycsXHJcbiAgICAnc3Ryb2tlLXdpZHRoJzogJzEnLFxyXG4gICAgJ3N0cm9rZS1kYXNoYXJyYXknIDogJ25vbmUnLFxyXG4gICAgZmlsbDogJyNmMmYyZjInXHJcbn0pO1xyXG5cclxudmFyIGluaXRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZXZlbnQubGlzdGVuKCdkaWFncmFtX2Rvd25sb2FkX2FzJywgZG93bmxvYWREaWFncmFtQXNMaXN0ZW5lcik7XHJcblxyXG4gICAgZXZlbnQubGlzdGVuKCdkaWFncmFtX25ldycsIG5ld0RpYWdyYW1MaXN0ZW5lcik7XHJcbiAgICBldmVudC5saXN0ZW4oJ3RhYl9hY3RpdmF0ZWQnLCBhY3RpdmVUYWJMaXN0ZW5lcik7XHJcbiAgICBldmVudC5saXN0ZW4oJ2tleV9zYXZlX3ByZXNzJywgc2F2ZURpYWdyYW0pO1xyXG4gICAgZXZlbnQubGlzdGVuKCdrZXlfcGFzdGVfcHJlc3MnLCBwYXN0ZURpYWdyYW1EYXRhTGlzdGVuZXIpO1xyXG4gICAgZXZlbnQubGlzdGVuKCdrZXlfY29weV9wcmVzcycsIGNvcHlEaWFncmFtRGF0YUxpc3RlbmVyKVxyXG5cclxuICAgIGV2ZW50Lmxpc3Rlbigndmlld196b29tSW4nLCB6b29tSW4pO1xyXG4gICAgZXZlbnQubGlzdGVuKCd2aWV3X3pvb21PdXQnLCB6b29tT3V0KTtcclxuICAgIGV2ZW50Lmxpc3Rlbigndmlld190b2dnbGVfbW9kZV9tb3ZlJywgdG9nZ2xlTW9kZU1vdmUpO1xyXG4gICAgZXZlbnQubGlzdGVuKCd2aWV3X3RvZ2dsZV9zZXR0aW5nX2FsaWduJywgdG9nZ2xlU2V0dGluZ0FsaWduKTtcclxuXHJcbiAgICBldmVudC5saXN0ZW4oJ2tleV9yZWRvX3ByZXNzJywgcmVkb0NvbW1hbmQpO1xyXG4gICAgZXZlbnQubGlzdGVuKCdrZXlfdW5kb19wcmVzcycsIHVuZG9Db21tYW5kKTtcclxufTtcclxuXHJcbnZhciBkb3dubG9hZERpYWdyYW1Bc0xpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB2YXIgZGlhZ3JhbSA9IGdldEFjdGl2ZURpYWdyYW0oKTtcclxuICAgIHZhciBjb250ZW50ID0gZGlhZ3JhbS5hc1BsYWluU3RyaW5nKCk7XHJcbiAgICB2YXIgZmlsZU5hbWUgPSBldnQuZGF0YS5maWxlTmFtZSB8fCBkaWFncmFtLnRpdGxlO1xyXG4gICAgdmFyIG1pbWUgPSBldnQuZGF0YS5taW1lIHx8ICdpbWFnZS9zdmcreG1sJztcclxuICAgIGZpbGVNYW5hZ2VyLmRvd25sb2FkQXMoY29udGVudCwgZmlsZU5hbWUsIGRpYWdyYW0ud2lkdGgoKSwgZGlhZ3JhbS5oZWlnaHQoKSwgbWltZSk7XHJcbn07XHJcblxyXG52YXIgdG9nZ2xlTW9kZU1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciAgdmFsID0gY29uZmlnLmlzKCdkaWFncmFtX21vZGVfbW92ZScsIGZhbHNlKTtcclxuICAgIGNvbmZpZy5zZXRWYWwoJ2RpYWdyYW1fbW9kZV9tb3ZlJywgIXZhbCk7XHJcbiAgICBjb25maWcuc2V0VmFsKCdldmVudHNfcmVzdHJpY3RlZCcsICF2YWwpO1xyXG59O1xyXG5cclxudmFyIHRvZ2dsZVNldHRpbmdBbGlnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyICB2YWwgPSBjb25maWcuaXMoJ2RyYWdBbGlnbicsIHRydWUpO1xyXG4gICAgY29uZmlnLnNldFZhbCgnZHJhZ0FsaWduJywgIXZhbCk7XHJcbn07XHJcblxyXG52YXIgdW5kb0NvbW1hbmQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGdldEFjdGl2ZURpYWdyYW0oKS51bmRvQ29tbWFuZCgpO1xyXG59O1xyXG5cclxudmFyIHJlZG9Db21tYW5kID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBnZXRBY3RpdmVEaWFncmFtKCkucmVkb0NvbW1hbmQoKTtcclxufTtcclxuXHJcbnZhciBjb3B5RGlhZ3JhbURhdGFMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdmFyIGFjdGl2ZURpYWdyYW0gPSBnZXRBY3RpdmVEaWFncmFtKCk7XHJcbiAgICBpZihhY3RpdmVEaWFncmFtKSB7XHJcbiAgICAgICAgYWN0aXZlRGlhZ3JhbS50cmlnZ2VyKCdjb3B5JyxbZXZ0Lm1vdXNlXSk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxudmFyIHBhc3RlRGlhZ3JhbURhdGFMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdmFyIGFjdGl2ZURpYWdyYW0gPSBnZXRBY3RpdmVEaWFncmFtKCk7XHJcbiAgICBpZihhY3RpdmVEaWFncmFtKSB7XHJcbiAgICAgICAgYWN0aXZlRGlhZ3JhbS50cmlnZ2VyKCdwYXN0ZScsW2V2dC5tb3VzZV0pO1xyXG4gICAgfTtcclxufTtcclxuXHJcbnZhciBzYXZlRGlhZ3JhbSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdmFyIGFjdGl2ZURpYWdyYW0gPSBnZXRBY3RpdmVEaWFncmFtKCk7XHJcbiAgICBpZihhY3RpdmVEaWFncmFtICYmIHVzZXJNYW5hZ2VyLmlzTG9nZ2VkSW4oKSl7XHJcbiAgICAgICAgLy9UT0RPOiBSZW1vdmUgRG9ja2luZ3MuLi4uLlxyXG4gICAgICAgIC8vVE9ETzogY2hlY2sgaWYgbG9nZ2VkSW4sIGlmIG5vdCBsb2dpbiBmaXJzdCBkaWFsb2cuLi4gb3Igc2F2ZSB2aWEgYnJvd3NlciBjYWNoZSA/XHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIFwiZGlhZ3JhbVwiIDogYWN0aXZlRGlhZ3JhbS5hc1N0cmluZygpLFxyXG4gICAgICAgICAgICBcImRpYWdyYW1JZFwiIDogYWN0aXZlRGlhZ3JhbS5pZCxcclxuICAgICAgICAgICAgXCJwcm9qZWN0SWRcIiA6IGFjdGl2ZURpYWdyYW0ucHJvamVjdElkLFxyXG4gICAgICAgICAgICBcInRpdGxlXCIgOiBhY3RpdmVEaWFncmFtLnRpdGxlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjbGllbnQucG9zdCgnL3Byb2plY3Qvc2F2ZURpYWdyYW0nLCBkYXRhLCB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbihyZXNwb25zZSkge30sXHJcbiAgICAgICAgICAgIGVycm9yIDogZnVuY3Rpb24oc3RhdHVzLCBlcnJvciwgZXJyb3Jjb2RlKSB7fSxcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlIDoge1xyXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiAnQ291bGQgbm90IHNhdmUgZGlhZ3JhbSwgcGxlYXNlIHRyeSBhZ2FpbiBsYXRlciBvciBiYWNrdXAgdmlhIGRvd25sb2FkIScsXHJcbiAgICAgICAgICAgICAgICAnNDAxJzogICdDb3VsZCBub3Qgc2F2ZSBkaWFncmFtLiBQbGVhc2UgbG9naW4gb3IgY3JlYXRlIGFuIGFjY291bnQgZmlyc3QhJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdWNjZXNzTWVzc2FnZSA6ICdEaWFncmFtIHdhcyBzYXZlZCAhJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbnZhciBjcmVhdGVEaWFncmFtSWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAodXNlck1hbmFnZXIuaXNMb2dnZWRJbigpKSA/IERhdGUubm93KCkgKyAnXycgK3VzZXJNYW5hZ2VyLmdldFVzZXJJZCgpIDogRGF0ZS5ub3coKSsnJztcclxufTtcclxuXHJcbnZhciBuZXdEaWFncmFtTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHZhciBkaWFncmFtSWQgPSBldnQuZGF0YS5kaWFncmFtSWQ7XHJcbiAgICB2YXIgc3RhZ2VJZCA9IGV2dC5kYXRhLnN0YWdlSWQ7XHJcbiAgICB2YXIgcHJvamVjdElkID0gZXZ0LmRhdGEucHJvamVjdElkO1xyXG4gICAgdmFyIHRpdGxlID0gZXZ0LmRhdGEudGl0bGU7XHJcbiAgICBldnQuZGF0YS5kaWFncmFtSWQgPSBkaWFncmFtSWQ7XHJcbiAgICB2YXIgZGlhZ3JhbSA9IHJlZ2lzdGVyKG5ldyBEaWFncmFtKHtpZDpkaWFncmFtSWQsIGNvbnRhaW5lcjonIycrc3RhZ2VJZCwgcHJvamVjdElkOiBwcm9qZWN0SWQsIHRpdGxlOiB0aXRsZX0pKTtcclxuICAgIGV2ZW50LnRyaWdnZXIoJ2RpYWdyYW1faW5pdGlhbGl6ZWQnLCBldnQuZGF0YSk7XHJcbiAgICByZXR1cm4gZGlhZ3JhbTtcclxufTtcclxuXHJcbnZhciByZWdpc3RlciA9IGZ1bmN0aW9uKGRpYWdyYW0sIGFjdGl2YXRlKSB7XHJcbiAgICBkaWFncmFtc1tkaWFncmFtLmlkXSA9IGRpYWdyYW07XHJcbiAgICBkaWFncmFtc1tkaWFncmFtLmlkXS5vbignYWN0aXZhdGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBhY3RpdmVEaWFncmFtSWQgPSBkaWFncmFtLmlkO1xyXG4gICAgfSk7XHJcbiAgICBpZihhY3RpdmF0ZSkge1xyXG4gICAgICAgIGRpYWdyYW0udHJpZ2dlcignYWN0aXZhdGUnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkaWFncmFtO1xyXG59O1xyXG5cclxudmFyIGFjdGl2ZVRhYkxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBhY3RpdmVEaWFncmFtSWQgPSBldnQuZGF0YTtcclxufTtcclxuXHJcbnZhciB6b29tSW4gPSBmdW5jdGlvbigpIHtcclxuICAgIGdldEFjdGl2ZURpYWdyYW0oKS56b29tSW4oKTtcclxuICAgIGV2ZW50LnRyaWdnZXIoJ3ZpZXdfem9vbWVkSW4nKTtcclxufTtcclxuXHJcbnZhciB6b29tT3V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBnZXRBY3RpdmVEaWFncmFtKCkuem9vbU91dCgpO1xyXG4gICAgZXZlbnQudHJpZ2dlcigndmlld196b29tZWRPdXQnKTtcclxufTtcclxuXHJcbnZhciBnZXRBY3RpdmVEaWFncmFtID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gZGlhZ3JhbXNbYWN0aXZlRGlhZ3JhbUlkXTtcclxufVxyXG5cclxuaW5pdExpc3RlbmVyKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdldEFjdGl2ZURpYWdyYW06IGdldEFjdGl2ZURpYWdyYW0sXHJcbiAgICBjcmVhdGVEaWFncmFtSWQgOiBjcmVhdGVEaWFncmFtSWQsXHJcbiAgICByZWdpc3RlciA6IHJlZ2lzdGVyXHJcbn07IiwiLyoqXHJcbiAqIFRoaXMgdXRpbGl0eSBtb2R1bGUgcHJvdmllcyBidWlsZC1pbiBkb2NraW5nIHRlY2huaXF1ZXMgZm9yIHRyYW5zaXRpb25zIGFuZCBvdGhlclxyXG4gKiBkb2NrYWJsZSBlbGVtZW50cy4gVGhlIGRvY2tpbmcgdHlwZSBjYW4gYmUgY29uZmlndXJlZCB3aXRoaW4gdGhlIHRlbXBsYXRlXHJcbiAqIHdpdGggdGhlIGNvbmZpZyBrZXkgXCJkb2NraW5nVHlwZVwiLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKiAgPGNvbmZpZz5cclxuICogICAgICB7XHJcbiAqICAgICAgICAgIFwibm9kZUlEXCIgOiBcImVlcl9lbnRpdHlEZWZhdWx0XCIsXHJcbiAqICAgICAgICAgIFwiZG9ja2luZ1wiIDoge3R5cGU6ICdSRUNUJywgb3JpZW50YXRpb246J2NlbnRlcicsIC4uLn1cclxuICogICAgICAgICAgLi4uXHJcbiAqICAgICAgfVxyXG4gKiA8L2NvbmZpZz5cclxuICovXHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcbnZhciBtYXRoID0gdXRpbC5tYXRoO1xyXG5cclxudmFyIGNoZWNrT3JpZW50YXRpb25Cb3VuZGFyeSA9IGZ1bmN0aW9uKG5vZGUsIHApIHtcclxuICAgIHZhciBkb2NraW5nVHlwZSA9IChub2RlLmNvbmZpZy5kb2NraW5nICYmIG5vZGUuY29uZmlnLmRvY2tpbmcudHlwZSkgPyBub2RlLmNvbmZpZy5kb2NraW5nLnR5cGUgOiAnUkVDVCc7XHJcbiAgICBzd2l0Y2goZG9ja2luZ1R5cGUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgIGNhc2UgJ0NFTlRFUic6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjYXNlICdDSVJDTEUnOlxyXG4gICAgICAgICAgICByZXR1cm4gQ0lSQ0xFX0JPVU5EQVJZLmNhbGwobm9kZSwgcCk7XHJcbiAgICAgICAgY2FzZSAnRUxMSVBTRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBFTExJUFNFX0JPVU5EQVJZLmNhbGwobm9kZSwgcCk7XHJcbiAgICAgICAgY2FzZSAnU1FVQVJFJzpcclxuICAgICAgICBjYXNlICdSRUNUJzpcclxuICAgICAgICAgICAgcmV0dXJuIFJFQ1RfQk9VTkRBUlkuY2FsbChub2RlLCBwKTtcclxuICAgIH07XHJcbn07XHJcblxyXG52YXIgY2FsY3VsYXRlRG9ja2luZ1Bvc2l0aW9uID0gZnVuY3Rpb24obm9kZSwgb3JpZW50YXRpb25PdXQsIG9yaWVudGF0aW9uSW4pIHtcclxuICAgIHZhciBkb2NraW5nVHlwZSA9IChub2RlLmNvbmZpZy5kb2NraW5nICYmIG5vZGUuY29uZmlnLmRvY2tpbmcudHlwZSkgPyBub2RlLmNvbmZpZy5kb2NraW5nLnR5cGUgOiAnUkVDVCc7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgc3dpdGNoKGRvY2tpbmdUeXBlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlICdTSU1QTEUnOlxyXG4gICAgICAgICAgICByZXN1bHQgPSBTSU1QTEUuY2FsbChub2RlLCBvcmllbnRhdGlvbk91dCwgb3JpZW50YXRpb25Jbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0NFTlRFUic6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IENFTlRFUi5jYWxsKG5vZGUsIG9yaWVudGF0aW9uT3V0LCBvcmllbnRhdGlvbkluKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnQ0lSQ0xFJzpcclxuICAgICAgICAgICAgcmVzdWx0ID0gQ0lSQ0xFLmNhbGwobm9kZSwgb3JpZW50YXRpb25PdXQsIG9yaWVudGF0aW9uSW4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdFTExJUFNFJzpcclxuICAgICAgICAgICAgcmVzdWx0ID0gRUxMSVBTRS5jYWxsKG5vZGUsIG9yaWVudGF0aW9uT3V0LCBvcmllbnRhdGlvbkluKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnU1FVQVJFJzpcclxuICAgICAgICBjYXNlICdSRUNUJzpcclxuICAgICAgICAgICAgcmVzdWx0ID0gUkVDVC5jYWxsKG5vZGUsb3JpZW50YXRpb25PdXQsIG9yaWVudGF0aW9uSW4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdGUkVFJzpcclxuICAgICAgICAgICAgcmVzdWx0ID0gRlJFRS5jYWxsKG5vZGUsb3JpZW50YXRpb25PdXQsIG9yaWVudGF0aW9uSW4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXN1bHQgPSBDRU5URVIuY2FsbChub2RlLCBvcmllbnRhdGlvbk91dCwgb3JpZW50YXRpb25Jbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHJvdGF0aW9uID0gbm9kZS5yb290LnJvdGF0ZSgpO1xyXG4gICAgaWYocm90YXRpb24pIHtcclxuICAgICAgICByZXN1bHQgPSBtYXRoLnJvdGF0ZShyZXN1bHQsIG5vZGUucG9zaXRpb24oKSwgcm90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgRlJFRSA9IGZ1bmN0aW9uKHBvc2l0aW9uICwgb3JpZW50YXRpb25Jbikge1xyXG4gICAgcmV0dXJuIG9yaWVudGF0aW9uSW47XHJcbn07XHJcblxyXG52YXIgRUxMSVBTRSA9IGZ1bmN0aW9uKHBvc2l0aW9uICwgb3JpZW50YXRpb25Jbikge1xyXG4gICAgdmFyIHJ4ID0gdGhpcy53aWR0aCgpIC8gMjtcclxuICAgIHZhciByeSA9IHRoaXMuaGVpZ2h0KCkgLyAyO1xyXG4gICAgdmFyIGVsbGlwc2UgPSBuZXcgbWF0aC5FbGxpcHNlKHRoaXMuZ2V0Q2VudGVyKCksIHJ4LCByeSk7XHJcbiAgICB2YXIgcmVzdWx0ID0gZWxsaXBzZS5jYWxjTGluZUludGVyY2VwdChwb3NpdGlvbiwgb3JpZW50YXRpb25Jbik7XHJcbiAgICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPiAwKT9yZXN1bHRbMF06b3JpZW50YXRpb25JbjtcclxuXHJcbn07XHJcblxyXG52YXIgRUxMSVBTRV9CT1VOREFSWSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICB2YXIgcnggPSB0aGlzLndpZHRoKCkgLyAyO1xyXG4gICAgdmFyIHJ5ID0gdGhpcy5oZWlnaHQoKSAvIDI7XHJcbiAgICByZXR1cm4gbmV3IG1hdGguRWxsaXBzZSh0aGlzLmdldENlbnRlcigpLCByeCwgcnkpLm92ZXJsYXlzKHBvc2l0aW9uKTtcclxufTtcclxuXHJcbnZhciBDSVJDTEUgPSBmdW5jdGlvbihwb3NpdGlvbiwgb3JpZW50YXRpb25Jbikge1xyXG4gICAgLy9Ob3RlIHRoZSBzdHJva2UgaXMgbm90IGluY2x1ZGVkIGluIHNvbWUgYnJvd3NlcnMuLi5cclxuICAgIHZhciByYWRpdXMgPSB0aGlzLndpZHRoKCkgLyAyO1xyXG4gICAgdmFyIGNpcmNsZSA9IG5ldyBtYXRoLkNpcmNsZSh0aGlzLmdldENlbnRlcigpLCByYWRpdXMpO1xyXG4gICAgdmFyIHJlc3VsdCA9IGNpcmNsZS5jYWxjTGluZUludGVyY2VwdChwb3NpdGlvbiwgb3JpZW50YXRpb25Jbik7XHJcblxyXG4gICAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID4gMCk/cmVzdWx0WzBdOm9yaWVudGF0aW9uSW47XHJcbn07XHJcblxyXG52YXIgQ0lSQ0xFX0JPVU5EQVJZID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgdmFyIHJhZGl1cyA9IHRoaXMud2lkdGgoKSAvIDI7XHJcbiAgICByZXR1cm4gbmV3IG1hdGguQ2lyY2xlKHRoaXMuZ2V0Q2VudGVyKCksIHJhZGl1cykub3ZlcmxheXMocG9zaXRpb24pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgdGVjaG5pcXVlIHVzZXMgdGhlIGNlbnRlciBvZiB0aGUgbm9kZSBhcyBvcmllbnRhdGlvbiBwb2ludCBhbmRcclxuICogcmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBub2RlIGJvdW5kYXJ5IGFuZCB0aGUgbGluZSBmcm9tIHRoZSBvdXRlclxyXG4gKiBvcmllbnRhdGlvbiBwb2ludCB0byB0aGUgY2VudGVyIG9mIHRoZSBub2RlIGFzIHJlc3VsdC5cclxuICpcclxuICogX19fX19fX19fX1xyXG4gKiB8ICAgICAgICB8XHJcbiAqIHwgICAgICAgIHxcclxuICogfCAgICB4ICAgfDwtLS0tLS0tLS0tLS0tLS0teFxyXG4gKiB8ICAgICAgICB8XHJcbiAqIHwgICAgICAgIHxcclxuICogLS0tLS0tLS0tLVxyXG4gKlxyXG4gKiBAcGFyYW0ge3R5cGV9IHBvc2l0aW9uIHRoZSBvdXRlciBvcmllbnRhdGlvbiBwb2ludFxyXG4gKiBAcmV0dXJucyB7RG9ja2luZ1R5cGVfTDIwQGNhbGw7Z2V0Q2VudGVyfVxyXG4gKi9cclxudmFyIFJFQ1QgPSBmdW5jdGlvbihwb3NpdGlvbiwgb3JpZW50YXRpb24pIHtcclxuICAgIGlmKHRoaXMub3ZlcmxheXMocG9zaXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0cmFuc2l0aW9uID0gbmV3IG1hdGguTGluZShwb3NpdGlvbiwgb3JpZW50YXRpb24pO1xyXG5cclxuICAgIGlmKHRoaXMuaXNSaWdodE9mKHBvc2l0aW9uKSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2l0aW9uLmNhbGNGWCh0aGlzLngoKSk7XHJcbiAgICAgICAgaWYodGhpcy5vdmVybGF5cyhyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuaXNMZWZ0T2YocG9zaXRpb24pKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zaXRpb24uY2FsY0ZYKHRoaXMuZ2V0UmlnaHRYKCkpO1xyXG4gICAgICAgIGlmKHRoaXMub3ZlcmxheXMocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLmlzT3Zlcihwb3NpdGlvbikpIHtcclxuICAgICAgICB2YXIgYm90dG9tWSA9IHRoaXMuZ2V0Qm90dG9tWSgpO1xyXG5cclxuICAgICAgICBpZih0cmFuc2l0aW9uLmlzVmVydGljYWwoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge3g6IG9yaWVudGF0aW9uLngsIHk6IGJvdHRvbVl9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYob3JpZW50YXRpb24ueCA9PT0gcG9zaXRpb24ueCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge3g6b3JpZW50YXRpb24ueCwgeTpib3R0b21ZfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvdHRvbUxpbmUgPSBuZXcgbWF0aC5MaW5lKHt4OjEseTpib3R0b21ZfSwge3g6Mix5OmJvdHRvbVl9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNpdGlvbi5jYWxjTGluZUludGVyY2VwdChib3R0b21MaW5lKTtcclxuICAgICAgICAvL1dlIGV4cGxpY2l0bHkgc2V0IHRoaXMgYmVjYXVzZSBvZiBwb3NzaWJsZSBjYWxjdWxhdGlvbiBkZXZpYXRpb25zXHJcbiAgICAgICAgcmVzdWx0LnkgPSBib3R0b21ZO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmKHRyYW5zaXRpb24uaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt4Om9yaWVudGF0aW9uLngsIHk6IHRoaXMueSgpfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG9yaWVudGF0aW9uLnggPT09IHBvc2l0aW9uLngpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt4Om9yaWVudGF0aW9uLngsIHk6dGhpcy55KCl9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdG9wTGluZSA9IG5ldyBtYXRoLkxpbmUoe3g6MSx5OnRoaXMueSgpfSwge3g6Mix5OnRoaXMueSgpfSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zaXRpb24uY2FsY0xpbmVJbnRlcmNlcHQodG9wTGluZSk7XHJcbiAgICAgICAgLy9XZSBleHBsaWNpdGx5IHNldCB0aGlzIGJlY2F1c2Ugb2YgcG9zc2libGUgY2FsY3VsYXRpb24gZGV2aWF0aW9uc1xyXG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy55KCk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgUkVDVF9CT1VOREFSWSA9IGZ1bmN0aW9uKHApIHtcclxuICAgIHJldHVybiB0aGlzLm92ZXJsXHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyB0ZWNobmlxdWUganVzdCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIG5vZGUgYXMgcmVzdWx0LlxyXG4gKiBOb3RlIHRoYXQgbGluZSB3aWxsIHN0YXJ0IG9yIGVuZCB3aXRoaW4gdGhlIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dHlwZX0gcG9zaXRpb25cclxuICogQHJldHVybnMge0RvY2tpbmdUeXBlX0wyMC5DRU5URVJAY2FsbDtnZXRDZW50ZXJ9XHJcbiAqL1xyXG52YXIgQ0VOVEVSID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLmdldENlbnRlcigpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgdGVjaG5pcXVlIHByb3ZpZGVzIDQgZGlmZmVyZW50IGRvY2tpbmcgcG9pbnRzICh0b3AvcmlnaHQvYm90dG9tL2xlZnQpXHJcbiAqIGFuZCByZXR1cm5zIHRoZSBtb3N0IHN1aXRhYmxlIGRvY2tpbmcgcG9pbnQgZm9yIHRoZSBnaXZlbiBvdXRlciBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHt0eXBlfSBwb3NpdGlvblxyXG4gKi9cclxudmFyIFNJTVBMRSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBvcmllbnRhdGlvbkluKSB7XHJcbiAgICAvL1RoZSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIG5vZGVcclxuICAgIGlmKHRoaXMub3ZlcmxheXMocG9zaXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uSW47XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5pc0xlZnRPZihwb3NpdGlvbikpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLmdldFJpZ2h0WCgpLFxyXG4gICAgICAgICAgICB5OiBvcmllbnRhdGlvbkluLnlcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNSaWdodE9mKHBvc2l0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucm9vdC54KCksXHJcbiAgICAgICAgICAgIHk6IG9yaWVudGF0aW9uSW4ueVxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYodGhpcy5pc092ZXIocG9zaXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogb3JpZW50YXRpb25Jbi54LFxyXG4gICAgICAgICAgICB5OiB0aGlzLmdldEJvdHRvbVkoKVxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYodGhpcy5pc1VuZGVyKHBvc2l0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IG9yaWVudGF0aW9uSW4ueCxcclxuICAgICAgICAgICAgeTogdGhpcy5yb290LnkoKVxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vVGhlIHBvc2l0aW9uIGlzIG5vdCBvdXRzaWRlIG9mIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBDRU5URVIgOiBDRU5URVIgLFxyXG4gICAgU0lNUExFIDogU0lNUExFICxcclxuICAgIERFRkFVTFQgOiBDRU5URVIsXHJcbiAgICBjYWxjdWxhdGVEb2NraW5nUG9zaXRpb24gOiBjYWxjdWxhdGVEb2NraW5nUG9zaXRpb24sXHJcbiAgICBjaGVja09yaWVudGF0aW9uQm91bmRhcnkgOiBjaGVja09yaWVudGF0aW9uQm91bmRhcnlcclxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29yZS9jb25maWcnKTtcclxuXHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIERFRl9UT0xFUkFOQ0UgPSAxMDtcclxuXHJcbnZhciBBbGlnbm1lbnQgPSBmdW5jdGlvbih0b2xlcmFuY2UsIGRpbWVuc2lvbikge1xyXG4gICAgdGhpcy5kaW1lbnNpb24gPSBkaW1lbnNpb247XHJcbiAgICB0aGlzLnRvbGVyYW5jZSA9IHRvbGVyYW5jZTtcclxuICAgIHRoaXMuYWN0dWFsRCA9IDA7XHJcbn07XHJcblxyXG5BbGlnbm1lbnQucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oc291cmNlLCBzb3VyY2VJbmRleEFycix0YXJnZXQsIGQpIHtcclxuICAgIGlmKHRoaXMuY2hlY2tSYW5nZShzb3VyY2UsIHRhcmdldCwgZCkpIHtcclxuICAgICAgICAvLyBXZSBrZWVwIHRoZSBzb3VyY2UgcG9zaXRpb24gZm9yIHRoZSByZWFsaWdubWVudFxyXG4gICAgICAgIGlmKCF0aGlzLndhc0FsaWduZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlSW5kZXggPSBzb3VyY2VJbmRleEFycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGQgYmV0d2VlbiB0YXJnZXQgYW5kIHNvdXJjZSBiZWZvcmUgZHJhZ1xyXG4gICAgICAgIHRoaXMuZCA9ICh0YXJnZXRbdGhpcy5kaW1lbnNpb25dIC0gKHNvdXJjZVt0aGlzLmRpbWVuc2lvbl0pKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBhY3R1YWwgZHJhZyB3aGlsZSBiZWVpbmcgYWxpZ25lZCBmb3IgdGhlIHJlYWxpZ25cclxuICAgICAgICB0aGlzLmFjdHVhbEQgKz0gZDtcclxuICAgIH1cclxufTtcclxuXHJcbkFsaWdubWVudC5wcm90b3R5cGUuY2hlY2tSYW5nZSA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0LCBkKSB7XHJcbiAgICAvL0NoZWNrIGlmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gc291cmNlIChhZnRlciBkcmFnKSBhbmQgdGFyZ2V0IGlzIHdpdGhpbiB0aGUgdG9sZXJhbmVcclxuICAgIHJldHVybiB1dGlsLm1hdGguY2hlY2tSYW5nZURpZmYodGFyZ2V0W3RoaXMuZGltZW5zaW9uXSwgKHNvdXJjZVt0aGlzLmRpbWVuc2lvbl0gKyB0aGlzLmFjdHVhbEQgKyBkKSwgdGhpcy50b2xlcmFuY2UpO1xyXG59O1xyXG5cclxuQWxpZ25tZW50LnByb3RvdHlwZS5yZWFsaWduID0gZnVuY3Rpb24oYWxpZ25Db25maWcsIGQpIHtcclxuICAgIC8vIFdlIGp1c3QgaGF2ZSB0byBjYWxjdWxhdGUgdGhlIHJlYWxpZ25tZW50IGlmIGFuIGFsaWdubWVudCB3YXMgc2V0XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgaWYodGhpcy53YXNBbGlnbmVkKSB7XHJcbiAgICAgICAgLy9Ob3cgd2UgcmV0cmlldmUgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGFsaWduZWQgc291cmNlIGJ5IG91ciBzb3VyY2VJbmRleFxyXG4gICAgICAgIHZhciBjdXJyZW50U291cmNlUG9zaXRpb24gPSBhbGlnbkNvbmZpZ1t0aGlzLnNvdXJjZUluZGV4WzBdXS5zb3VyY2VbdGhpcy5zb3VyY2VJbmRleFsxXV07XHJcbiAgICAgICAgcmVzdWx0ID0gKHRoaXMuc291cmNlW3RoaXMuZGltZW5zaW9uXSArIHRoaXMuYWN0dWFsRCArIGQpIC0gY3VycmVudFNvdXJjZVBvc2l0aW9uW3RoaXMuZGltZW5zaW9uXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gZDtcclxuXHJcbiAgICB9XHJcbiAgICB0aGlzLmFjdHVhbEQgPSAwO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbkFsaWdubWVudC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihpbml0aWFsaXplKSB7XHJcbiAgICBpZighaW5pdGlhbGl6ZSkge1xyXG4gICAgICAgIHRoaXMud2FzQWxpZ25lZCA9IHRoaXMuaXNBbGlnbmVkKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMud2FzQWxpZ25lZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZSB0aGlzLnRhcmdldDtcclxuICAgIGRlbGV0ZSB0aGlzLmQ7XHJcbn07XHJcblxyXG5BbGlnbm1lbnQucHJvdG90eXBlLmlzQWxpZ25lZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG9iamVjdC5pc0RlZmluZWQodGhpcy50YXJnZXQpO1xyXG59O1xyXG5cclxudmFyIERyYWdBbGlnbm1lbnQgPSBmdW5jdGlvbihkaWFncmFtLCBnZXRDb25maWcsIHRvbGVyYW5jZSkge1xyXG4gICAgdGhpcy5kaWFncmFtID0gZGlhZ3JhbTtcclxuICAgIHRoaXMudG9sZXJhbmNlID0gdG9sZXJhbmNlIHx8IERFRl9UT0xFUkFOQ0U7XHJcbiAgICB0aGlzLmdldENvbmZpZyA9IGdldENvbmZpZztcclxuICAgIHRoaXMuYWxpZ25YID0gbmV3IEFsaWdubWVudCh0aGlzLnRvbGVyYW5jZSwgJ3gnKTtcclxuICAgIHRoaXMuYWxpZ25ZID0gbmV3IEFsaWdubWVudCh0aGlzLnRvbGVyYW5jZSwgJ3knKTtcclxuICAgIHRoaXMuYWN0dWFsRHJhZyA9IHt4OjAsIHk6MH07XHJcbn07XHJcblxyXG5EcmFnQWxpZ25tZW50LnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGlmKGNvbmZpZy5pcygnZHJhZ0FsaWduJywgdHJ1ZSkgJiYgIXRoaXMuZGlhZ3JhbS5pc011bHRpU2VsZWN0aW9uKCkpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHRoZSBhbGlnbm1lbnRzIHRvIG5vdGlmeSBhIG5ldyBzZWFyY2ggbG9vcFxyXG4gICAgICAgIHRoaXMuYWxpZ25YLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5hbGlnblkucmVzZXQoKTtcclxuXHJcbiAgICAgICAgdmFyIGFsaWdubWVudENvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKGR4LCBkeSk7XHJcbiAgICAgICAgb2JqZWN0LmVhY2goYWxpZ25tZW50Q29uZmlnLCBmdW5jdGlvbihjb25maWdJbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZUFyciA9IHZhbHVlLnNvdXJjZTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldEFyciA9IHZhbHVlLnRhcmdldDtcclxuICAgICAgICAgICAgb2JqZWN0LmVhY2goc291cmNlQXJyLCBmdW5jdGlvbihzb3VyY2VJbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuY2hlY2tBbGlnbm1lbnQodmFsdWUsIHRhcmdldEFyciwgW2NvbmZpZ0luZGV4LCBzb3VyY2VJbmRleF0sIGR4LCBkeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGhhdC5hbGlnblguaXNBbGlnbmVkKCkgJiYgdGhhdC5hbGlnblkuaXNBbGlnbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vRXNjYXBlIHRoZSBlYWNoIGxvb3Agc2luY2Ugd2UgZm91bmQgYm90aCBhbGluZ21lbnRzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgZHggOiAodGhpcy5hbGlnblguaXNBbGlnbmVkKCkpID8gdGhpcy5hbGlnblguZCA6IHRoaXMuYWxpZ25YLnJlYWxpZ24oYWxpZ25tZW50Q29uZmlnLCBkeCksXHJcbiAgICAgICAgICAgIGR5IDogKHRoaXMuYWxpZ25ZLmlzQWxpZ25lZCgpKSA/IHRoaXMuYWxpZ25ZLmQgOiB0aGlzLmFsaWduWS5yZWFsaWduKGFsaWdubWVudENvbmZpZywgZHkpXHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hbGlnblgucmVzZXQodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5hbGlnblkucmVzZXQodHJ1ZSk7XHJcbiAgICAgICAgcmVzdWx0ID0ge2R4IDogZHgsIGR5IDogZHl9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5EcmFnQWxpZ25tZW50LnByb3RvdHlwZS5jaGVja0FsaWdubWVudCA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0cywgc291cmNlSW5kZXhBcnIsIGR4LCBkeSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgb2JqZWN0LmVhY2godGFyZ2V0cywgZnVuY3Rpb24oaW5kZXgsIHRhcmdldCkge1xyXG4gICAgICAgIGlmKCF0aGF0LmFsaWduWC5pc0FsaWduZWQoKSkge1xyXG4gICAgICAgICAgICB0aGF0LmFsaWduWC5jaGVjayhzb3VyY2Usc291cmNlSW5kZXhBcnIsIHRhcmdldCwgZHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIXRoYXQuYWxpZ25ZLmlzQWxpZ25lZCgpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYWxpZ25ZLmNoZWNrKHNvdXJjZSxzb3VyY2VJbmRleEFyciwgdGFyZ2V0LCBkeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGF0LmFsaWduWC5pc0FsaWduZWQoKSAmJiB0aGF0LmFsaWduWS5pc0FsaWduZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vRXNjYXBlIHRoZSBlYWNoIGxvb3Agc2luY2Ugd2UgZm91bmQgYm90aCBhbGluZ21lbnRzXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbkRyYWdBbGlnbm1lbnQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmFsaWduWC5yZXNldCh0cnVlKTtcclxuICAgIHRoaXMuYWxpZ25ZLnJlc2V0KHRydWUpO1xyXG59O1xyXG5cclxuRHJhZ0FsaWdubWVudC5wcm90b3R5cGUuaXNBbGlnbmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hbGlnblguaXNBbGlnbmVkIHx8IHRoaXMuYWxpZ25ZLmlzQWxpZ25lZCgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEcmFnQWxpZ25tZW50O1xyXG5cclxuIiwicmVxdWlyZSgnLi4vc3ZnL2RyYWdnYWJsZScpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgRHJhZ0FsaWdubWVudCA9IHJlcXVpcmUoJy4vZHJhZ0FsaWdubWVudCcpO1xyXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xyXG5cclxudmFyIGRvbSA9IHV0aWwuZG9tO1xyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcblxyXG52YXIgbGFzdERyYWc7XHJcblxyXG52YXIgRHJhZ0NvbnRleHQgPSBmdW5jdGlvbihub2RlLCBjZmcpIHtcclxuICAgIHRoaXMuY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIHRoaXMuZHhTdW0gPSAwO1xyXG4gICAgdGhpcy5keVN1bSA9IDA7XHJcbn07XHJcblxyXG5EcmFnQ29udGV4dC5wcm90b3R5cGUuZHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB0aGlzLmR4U3VtID0gMDtcclxuICAgIHRoaXMuZHlTdW0gPSAwO1xyXG4gICAgdGhpcy5mcm9tID0gdGhpcy5ub2RlLnBvc2l0aW9uKCk7XHJcbiAgICBkZWxldGUgdGhpcy50bztcclxuICAgIGlmKHRoaXMuY2ZnLmRyYWdTdGFydCkge1xyXG4gICAgICAgIHRoaXMuY2ZnLmRyYWdTdGFydChldnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRHJhZ0NvbnRleHQucHJvdG90eXBlLndhc01vdmVkID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5keFN1bSAhPT0gMCB8fCB0aGlzLmR5U3VtICE9PSAwO1xyXG59O1xyXG5cclxuRHJhZ0NvbnRleHQucHJvdG90eXBlLmRyYWdNb3ZlID0gZnVuY3Rpb24oZXZ0LCBkeCwgZHkpIHtcclxuICAgIHRoaXMuZHhTdW0gKz0gZHg7XHJcbiAgICB0aGlzLmR5U3VtICs9IGR5O1xyXG4gICAgaWYodGhpcy5jZmcuZHJhZ01vdmUpIHtcclxuICAgICAgICB0aGlzLmNmZy5kcmFnTW92ZShldnQsIGR4LGR5KTtcclxuICAgIH1cclxufTtcclxuXHJcbkRyYWdDb250ZXh0LnByb3RvdHlwZS5kcmFnRW5kID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBpZih0aGlzLmR4U3VtICE9IDAgfHwgdGhpcy5keVN1bSAhPSAwKSB7XHJcbiAgICAgICAgdGhpcy50byA9IHRoaXMubm9kZS5wb3NpdGlvbigpO1xyXG4gICAgICAgIGlmICh0aGlzLmNmZy5kcmFnRW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2ZnLmRyYWdFbmQoZXZ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5EcmFnQ29udGV4dC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZHhTdW0gOiB0aGlzLmR4U3VtLFxyXG4gICAgICAgIGR5U3VtIDogdGhpcy5keVN1bSxcclxuICAgICAgICBmcm9tIDogdGhpcy5mcm9tLFxyXG4gICAgICAgIHRvIDogdGhpcy50b1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZHJhZ2dhYmxlID0gZnVuY3Rpb24oY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGlzLmRyYWdDb250ZXh0ID0gbmV3IERyYWdDb250ZXh0KHRoaXMsIGNmZyk7XHJcblxyXG4gICAgdmFyIGRyYWdDb25maWcgPSB7XHJcbiAgICAgICAgY3Vyc29yOiAnYWxsLXNjcm9sbCcsXHJcbiAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgdGhhdC5kcmFnQ29udGV4dC5kcmFnU3RhcnQoZXZ0KTtcclxuICAgICAgICAgICAgbGFzdERyYWcgPSB0aGF0LmRyYWdDb250ZXh0O1xyXG4gICAgICAgICAgICB0aGF0LmV4ZWMoJ2RyYWdTdGFydCcsIFtldnRdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdNb3ZlIDogZnVuY3Rpb24oZXZ0LCBkeCAsIGR5KSB7XHJcbiAgICAgICAgICAgIHRoYXQuZHJhZ0NvbnRleHQuZHJhZ01vdmUoZXZ0LCBkeCwgZHkpO1xyXG4gICAgICAgICAgICAvL3RoYXQuZXhlYygnZHJhZ01vdmUnLCBbZHgsZHksIGV2dF0pO1xyXG4gICAgICAgICAgICAvL1dlIHNraXAgdGhlIHRoZSBkb21FdmVudCBkcmFnTW92ZSBoZXJlIGNhdXNlIG9mIHBlcmZvcm1hbmNlLi4uXHJcbiAgICAgICAgICAgIHRoYXQuZXhlYygnZHJhZ01vdmUnLCBbZHgsZHksIGV2dF0sIHRydWUpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdFbmQgOiBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgaWYodGhhdC5kcmFnQ29udGV4dC53YXNNb3ZlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmRyYWdDb250ZXh0LmRyYWdFbmQoZXZ0KTtcclxuICAgICAgICAgICAgICAgIHRoYXQuZXhlYygnZHJhZ0VuZCcsIFtldnRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2NhbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5kaWFncmFtLnNjYWxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzdHJpY3Rpb25YIDogY2ZnLnJlc3RyaWN0aW9uWCxcclxuICAgICAgICByZXN0cmljdGlvblkgOiBjZmcucmVzdHJpY3Rpb25ZLFxyXG4gICAgICAgIGN1cnNvciA6IGNmZy5jdXJzb3JcclxuICAgIH07XHJcblxyXG4gICAgaWYoIWNmZy5wcmV2ZW50QWxpZ25tZW50KSB7XHJcbiAgICAgICAgdmFyIGRyYWdBbGlnbm1lbnQ7XHJcbiAgICAgICAgaWYoY2ZnLmRyYWdBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgZHJhZ0FsaWdubWVudCA9IChjZmcuZHJhZ0FsaWdubWVudCBpbnN0YW5jZW9mIERyYWdBbGlnbm1lbnQpXHJcbiAgICAgICAgICAgICAgICA/IGNmZy5kcmFnQWxpZ25tZW50IDogbmV3IERyYWdBbGlnbm1lbnQodGhpcy5kaWFncmFtLCBjZmcuZHJhZ0FsaWdubWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZHJhZ0FsaWdubWVudCA9IG5ldyBEcmFnQWxpZ25tZW50KHRoYXQuZGlhZ3JhbSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGlnbm1lbnRzID0gdGhhdC5nZXRUcmFuc2l0aW9uQWxpZ25tZW50VGFyZ2V0cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudHMucHVzaCh7c291cmNlOlt0aGF0LmdldENlbnRlcigpXSwgdGFyZ2V0OnRoYXQuZ2V0Tm9kZUFsaWdubWVudFRhcmdldHMoKX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGlnbm1lbnRzO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRyYWdDb25maWcuZHJhZ0FsaWdubWVudCA9IGRyYWdBbGlnbm1lbnQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHRoaXMucm9vdC5kcmFnZ2FibGUoZHJhZ0NvbmZpZywgdGhpcy5nZXREcmFnRWxlbWVudCgpKTtcclxuXHJcbiAgICAvL1NpbXVsYXRlcyBhbiBkcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICB0aGlzLmluaXREcmFnID0gdGhpcy5yb290LmluaXREcmFnO1xyXG5cclxuICAgIC8vRm9yIG1hbnVhbCBkcmFnZ2luZyBhIHN2ZyBlbGVtZW50IHRoZSB0cmlnZ2VyRXZlbnQgaXMgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50IHdhcyB0cmlnZ2VyZWQgbWFudWFsbHlcclxuICAgIHRoaXMudHJpZ2dlckRyYWcgPSB0aGlzLnJvb3QudHJpZ2dlckRyYWc7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uQWxpZ25tZW50VGFyZ2V0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkaXRpb25zLnRyYW5zaXRpb24uZ2V0VHJhbnNpdGlvbkFsaWdubWVudFRhcmdldHMoKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmdldE5vZGVBbGlnbm1lbnRUYXJnZXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgb2JqZWN0LmVhY2godGhpcy5kaWFncmFtLmdldE5vZGVzKCksIGZ1bmN0aW9uKGtleSwgbm9kZSkge1xyXG4gICAgICAgIGlmKG5vZGUuaWQgIT09IHRoYXQuaWQgJiYgIW5vZGUua25vYiAmJiAhbm9kZS5wcmV2QWxpZ24pIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5nZXRDZW50ZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmdldERyYWdFbGVtZW50ID0gZnVuY3Rpb24oKSB7IFxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Um9vdFNWRygpLmluc3RhbmNlKCk7XHJcbiAgICAvL3JldHVybiBkb20uZmluZEluY2x1ZGVTZWxmKHRoaXMuZ2V0Um9vdFNWRygpLmluc3RhbmNlKCksICdbY2xhc3N+PScrdGhpcy5nZXROb2RlU2VsZWN0b3IoJ2RyYWdSb3V0ZV8nKSsnXScpO1xyXG5cclxuICAgIC8vVE9ETzogd2UgaGF2ZSB0byB1c2UgdGhlIFtjbGFzc349YmxhXSBzZWxlY3RvciBzaW5jZSBpZSwgZWRnZSAod2hvIGVsc2UpIHRocm93aW5nIGVycm9ycyBmb3IgLmNsYXNzIHNlbGVjdG9ycyBpbiBqcXVlcnlcclxuICAgIC8vdGhpcyBtYXkgY2hhbmdlIGluIGZvbGxvd2luZyBqcWVyeSB2ZXJzaW9ucy5cclxuICAgIC8vcmV0dXJuIGRvbS5maW5kSW5jbHVkZVNlbGYodGhpcy5nZXRSb290U1ZHKCkuaW5zdGFuY2UoKSwgJ1tjbGFzc349Jyt0aGlzLmdldE5vZGVTZWxlY3RvcignZHJhZ1JvdXRlXycpKyddJyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdldExhc3REcmFnIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhc3REcmFnO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgQWJzdHJhY3RFZGl0QWRkaXRpb24gPSByZXF1aXJlKCcuL2Fic3RyYWN0RWRpdEFkZGl0aW9uJyk7XHJcblxyXG52YXIgZWRpdEZ1bmN0aW9ucyA9IHtcclxuICAgIHN0cm9rZSA6ICdzdHJva2UnLFxyXG4gICAgJ3N0cm9rZS13aWR0aCcgOiAnc3Ryb2tlV2lkdGgnLFxyXG4gICAgJ3N0cm9rZS1kYXNoJyA6ICdzdHJva2VEYXNoYXJyYXknLFxyXG4gICAgZmlsbCA6ICdmaWxsJyxcclxuICAgIGNvbG9yIDogJ2ZpbGwnLFxyXG4gICAgdGV4dCA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzLm5vZGUuZ2V0Tm9kZVNlbGVjdG9yKGVkaXRJdGVtLmJpbmQpKS50ZXh0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgJCh0aGlzLm5vZGUuZ2V0Tm9kZVNlbGVjdG9yKGVkaXRJdGVtLmJpbmQpKS50ZXh0KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGV4dGFyZWEgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dEFyZWFDb250ZW50KHRoaXMubm9kZS5nZXROb2RlU2VsZWN0b3IoZWRpdEl0ZW0uYmluZCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciAkZWRpdFNWR05vZGUgPSAkKHRoaXMubm9kZS5nZXROb2RlU2VsZWN0b3IoZWRpdEl0ZW0uYmluZCkpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFRleHRBcmVhQ29udGVudCgkZWRpdFNWR05vZGUsdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAndGV4dC1zaXplJyA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldElubmVyU1ZHKGVkaXRJdGVtLmJpbmQpLmZvbnRTaXplKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmdldElubmVyU1ZHKGVkaXRJdGVtLmJpbmQpLmZvbnRTaXplKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgRWRpdE5vZGVBZGRpdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIEFic3RyYWN0RWRpdEFkZGl0aW9uLmNhbGwodGhpcywgbm9kZSwgZWRpdEZ1bmN0aW9ucywgbm9kZS5jb25maWcuZWRpdCk7XHJcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhFZGl0Tm9kZUFkZGl0aW9uLCBBYnN0cmFjdEVkaXRBZGRpdGlvbik7XHJcblxyXG5FZGl0Tm9kZUFkZGl0aW9uLnByb3RvdHlwZS5vblNldFZhbHVlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLm5vZGUuZXZlbnQudHJpZ2dlcignbm9kZV9lZGl0JywgdGhpcy5ub2RlKTtcclxufTtcclxuXHJcbkVkaXROb2RlQWRkaXRpb24ucmVxdWlyZUNvbmZpZyA9IHRydWU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVkaXROb2RlQWRkaXRpb247IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIEFic3RyYWN0RWRpdEFkZGl0aW9uID0gcmVxdWlyZSgnLi9hYnN0cmFjdEVkaXRBZGRpdGlvbicpO1xyXG5cclxudmFyIEVkaXRUcmFuc2l0aW9uQWRkaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICBBYnN0cmFjdEVkaXRBZGRpdGlvbi5jYWxsKHRoaXMsIHRyYW5zaXRpb24sIGVkaXRGdW5jdGlvbnMsIGNvbmZpZyk7XHJcbiAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhFZGl0VHJhbnNpdGlvbkFkZGl0aW9uLCBBYnN0cmFjdEVkaXRBZGRpdGlvbiApO1xyXG5cclxudmFyIGVkaXRGdW5jdGlvbnMgPSB7XHJcbiAgICBzdHJva2UgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5zdHJva2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGJpbmRpbmcsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbi5zdHJva2UodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAnc3Ryb2tlLXdpZHRoJyA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLnN0cm9rZVdpZHRoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihiaW5kaW5nLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24uc3Ryb2tlV2lkdGgodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAnc3Ryb2tlLWRhc2gnIDoge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKGVkaXRJdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24ubGluZS5zdHJva2VEYXNoYXJyYXkoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGVkaXRJdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24ubGluZS5zdHJva2VEYXNoYXJyYXkodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0ZXh0IDoge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKGVkaXRJdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMudHJhbnNpdGlvbi5nZXRUcmFuc2l0aW9uU2VsZWN0b3IoZWRpdEl0ZW0uYmluZCkpLnRleHQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGVkaXRJdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAkKHRoaXMudHJhbnNpdGlvbi5nZXRUcmFuc2l0aW9uU2VsZWN0b3IoZWRpdEl0ZW0uYmluZCkpLnRleHQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0ZXh0YXJlYSA6IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbihlZGl0SXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0QXJlYUNvbnRlbnQodGhpcy50cmFuc2l0aW9uLmdldFRyYW5zaXRpb25TZWxlY3RvcihlZGl0SXRlbS5iaW5kKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyICRlZGl0U1ZHTm9kZSA9ICQodGhpcy50cmFuc2l0aW9uLmdldFRyYW5zaXRpb25TZWxlY3RvcihlZGl0SXRlbS5iaW5kKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VGV4dEFyZWFDb250ZW50KCRlZGl0U1ZHTm9kZSx2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgICd0ZXh0LXNpemUnIDoge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKGVkaXRJdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy50cmFuc2l0aW9uLmdldElubmVyU1ZHKGVkaXRJdGVtLmJpbmQpLnN0eWxlKCdmb250LXNpemUnKTtcclxuICAgICAgICAgICAgaWYoZGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb24uc3Vic3RyaW5nKDAsIGRlZmluaXRpb24ubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGVkaXRJdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24uZ2V0SW5uZXJTVkcoZWRpdEl0ZW0uYmluZCkuc3R5bGUoJ2ZvbnQtc2l6ZScsIHZhbHVlKydweCcpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAndHlwZScgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi50eXBlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uLnR5cGUodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24uZ3JvdXAuZGFsYSgndHJhbnNpdGlvblR5cGUnLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgICdzdGFydE1hcmtlcicgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5zdGFydE1hcmtlclZhbHVlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbihlZGl0SXRlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAnJztcclxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uLnN0YXJ0TWFya2VyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgJ2VuZE1hcmtlcicgOiB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5lbmRNYXJrZXJWYWx1ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24oZWRpdEl0ZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgJyc7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbi5lbmRNYXJrZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBjb25maWcgPSB7XHJcbiAgICAndGV4dDAnIDoge3R5cGUgOiAndGV4dCcsIGJpbmQgOiAndGV4dDAnLCB0cmlnZ2VyIDogJ3RleHQwJ30sXHJcbiAgICAndGV4dDEnIDoge3R5cGUgOiAndGV4dCcsIGJpbmQgOiAndGV4dDEnLCB0cmlnZ2VyIDogJ3RleHQxJ30sXHJcbiAgICAndGV4dDInIDoge3R5cGUgOiAndGV4dCcsIGJpbmQgOiAndGV4dDInLCB0cmlnZ2VyIDogJ3RleHQyJ30sXHJcbiAgICAndGV4dDMnIDoge3R5cGUgOiAndGV4dCcsIGJpbmQgOiAndGV4dDMnLCB0cmlnZ2VyIDogJ3RleHQzJ30sXHJcbiAgICAndGV4dDQnIDoge3R5cGUgOiAndGV4dCcsIGJpbmQgOiAndGV4dDQnLCB0cmlnZ2VyIDogJ3RleHQ0J30sXHJcbiAgICAndGV4dDUnIDoge3R5cGUgOiAndGV4dCcsIGJpbmQgOiAndGV4dDUnLCB0cmlnZ2VyIDogJ3RleHQ1J30sXHJcbiAgICAndHlwZScgIDoge3R5cGUgOiAndHlwZScsIGJpbmQgOiAnbGluZSd9LFxyXG4gICAgJ3N0cm9rZScgOiB7IHR5cGUgOiAnc3Ryb2tlJywgYmluZCA6ICdsaW5lJ30sXHJcbiAgICAnc3Ryb2tlLWRhc2gnIDogeyB0eXBlIDogJ3N0cm9rZS1kYXNoJywgYmluZCA6ICdsaW5lJ30sXHJcbiAgICAnc3RhcnRNYXJrZXInIDogeyB0eXBlIDogJ3N0YXJ0TWFya2VyJywgYmluZCA6ICdsaW5lJ30sXHJcbiAgICAnZW5kTWFya2VyJyA6IHsgdHlwZSA6ICdlbmRNYXJrZXInLCBiaW5kIDogJ2xpbmUnfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFZGl0VHJhbnNpdGlvbkFkZGl0aW9uOyIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgU1ZHU2hhcGUgPSByZXF1aXJlKCcuLi9zdmcvc3ZnU2hhcGUnKTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLmhvdmVyYWJsZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcclxuICAgIGlmKG9iamVjdC5pc0Jvb2xlYW4oaGFuZGxlcikpIHtcclxuICAgICAgICB0aGlzLmhvdmVyRmxhZyA9IGhhbmRsZXI7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlciB8fCB7fTtcclxuICAgICAgICB0aGlzLmhvdmVyRmxhZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlciA9IGhhbmRsZXIgfHwge307XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGV2dCkge1xyXG5cclxuICAgICAgICBpZih0aGF0LmhvdmVyRmxhZykge1xyXG4gICAgICAgICAgICB0aGF0LmhvdmVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBldmVudC50cmlnZ2VyKCdlbGVtZW50X2hvdmVySW4nLCB0aGF0KTtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZXIuaW4pIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuaW4uYXBwbHkodGhhdCwgW2V2dF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKGV2dCkge1xyXG5cclxuICAgICAgICBpZihldnQub3JpZ2luYWxFdmVudCAmJiBldnQub3JpZ2luYWxFdmVudC5idXR0b25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ZXN0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xyXG5cclxuICAgICAgICBpZih0aGF0LmhvdmVyRmxhZykge1xyXG4gICAgICAgICAgICB0aGF0LmhvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcignZWxlbWVudF9ob3Zlck91dCcsIHRoYXQpO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlci5vdXQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIub3V0LmFwcGx5KHRoYXQsIFtldnRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59OyIsInJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcclxucmVxdWlyZSgnLi9ub2RlJyk7XHJcblxyXG5yZXF1aXJlKCcuL3RlbXBsYXRlTWFuYWdlcicpLnJlZ2lzdGVyVGVtcGxhdGUoJ2ltYWdlJywge1xyXG4gICAgc3ZnIDonPGcgaWQ9XCJ7bm9kZV9pZH1cIiBjbGFzcz1cIntjc3NDbGFzc31cIj48aW1hZ2UgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwie3dpZHRofVwiIGhlaWdodD1cIntoZWlnaHR9XCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeGxpbms6aHJlZj1cIntkYXRhfVwiPjwvaW1hZ2U+PC9nPicsXHJcbiAgICBkYXRhOiBcImRhdGE6aW1hZ2UvanBnO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSUFBQUFDQUNBWUFBQUREUG1ITEFBQVdiMGxFUVZSNFh1MWRXMnhreVZuKy9qcm45TVYydTkyK2pqMmVkZWE2TTBsMmRvSE5DZ2lDaUlDQ2dIQjc0NTBueENZaEQ3endoc1JqRW1rSjRvSEg4RUFRYkZBa0VDRktGbkxQYkRZN3M1UGRKTE16T3p2aisvM1d0cnY3OUttZjJxSkwxZmJwY1h2YXgzM09lazdKbitxMFc3SmEvcjcvVW4vOVZZMTBwRWlSSXNXVENqcnh2NWNPUHUwQ0lJMTJBa2hGd0VrVUJFVkF2bWpBMFdnbGdwUjRxUkRvV1FOOEdnUkFDczZmL3RVWGg5eE1iblJyZFNGYjNTMTdNdkFGczZRbmxuRkRMUkVjeCtPbDZUdnJyNy95bFRVQUZZV3FncThRSkVVRUxqb2ZRb0dlL2ZVLytMTjhZZURUTERsZ1ppSmlFb1FuZGtpMklpQWlzYm0rOG5xdEhuenV6VzkvOVQ2QURZV3lRaTBwSXFEaldMOUM5bS8vL2Q3ZjlBK05memJqTUR5SElBZ2doU2ZaQTBnRlB3QnFBY09Yd01MME85OTcrWE12dm5UMzlmLzVLWUJsaFMyRnFoSEIrOWtEZUg2dDZqR0FwMGNFbmhzWGtKd0dma0hBelhtSlcvTU15WXloaWZPLytrZWYrYno3YjU5NzhZdjMzL2p1YlFCSWlnaGNIRzg0UVZBWGtvR01BL1JsMEJCQUtvQ01vMW5GUUpaUXJqRkd6ajM5d3A5ODlxVlB2Zno1VC8yZEVzRWJTUkdCZTl6bEgwc1dETUFpSGR4QXdNQndEMkd5bi9EVEZZblJwNjQrcjBUd1lwSkVJSEM4UVF5R0pqNWxQcndhWVAyRE0zMkVxOE1DR1llaFJmQ1hMNzE0L3ZwSHJ3TVlVK2hYeU1hMWhIYWpVTHZSTFRNcklDVy94ZXN6dlFSQTRHZnZlWUtwL3hmQnkxK0kzeE9JS0pUT1VFaVpEOUhPWVJGWVR6QVZtU2VJWHdBcCthM3JBWUZrTlNkYkJDS3FlSmRxNEFEWWdJRUVld0kzcXNvWHQ4NEIwaHlBRkJLY0U0Z29oQzViNWdCcEJzQWhOU1RQRTdoUitIK1dESUJTRDlCc0ZBelVKU0JoUmpTZUlJRkpZSm9JSHI0NmdobUo5QVFpaWh4QUFtQVEwbUZCRkdJck1oRWtTd0JRZUtRSFNEMEFFU1ZhQkc1MElTQmRCUmd3UWpVQWk0VGxCRzVVKzk5OElsYkVvZWVUQkJHRm5qdUZJd0JCQUpCc0VialJoSURvUFlDVTBzS1FmNUlpYUJBdWlDQ0VNRGhXSFlDTWNFR0pGWUViV2JZTEJrQ1JrVit2Vk9EdjdhRldxNkZlcnhzUm5CZ00rZVI1OFBKNVpMTlpaREtaemtYQXpicEtyaWR3SXlsNGFCVkU1L1o5UmJnM080dis1V1ZJSWJvV0FvU1VtSFljTEF3T1luaG9TSlB2ZVY0SDRTQkVmTmRFRUY4U0dBMzUydnA5M3djcDYzZHFOVGlPZzY0TktiR3hzb0tINVRJeW5vZGNMZ2ZIY2JRUWlLZ0REeENQQ0xvc2dDaHpBT3NCaE85clFpQkVkM2FhaURScm01dWJXRkFDR0JzZFJhbFUwcUhnY1QwUTc5c0VvQ2dDbzI0cUlRajgxSWpBZGhiZEFzQU5WRTFsdnJ0SllFUTVBRE1iTHdBT0FpMEFoUzYyODBwVWxPZlpBYlFYMHArRFdZT0lPckJkUWwweTl1cGtOWXpPK3ljS0dlQ3BJdUh1R21QNDNOUFAvK0ZuWHZxTGw3L3c2WmNlM3Y1T0FLRGU4QUIrVndYQWtodkVSYmdNYXdoQmt4OEVYYTNleUNCQTNSQjByQ1VoNldsNml6Ry9IZXlybkZicmpJcENwdzIwdFRwcmhyMlJLeC81aFUvKytTZVZBT1lBcmR0S1F3aWt3RjFyQ1pNUjVnQjZ0aFlKRUhXNWZNY2hDKzNFQTJRY1JpRkxvWS9QalVZUlZ4eEZBSzFwOURKUUlnSnEya0VHUXdCR0d1Y05Oa3dZNkY0SXNEa0FFRkVPQU9aWUJRQ2k1cEQwMkRsQXdNQzFZZUJpaVIvSktUTWRPU2srT0J3Q3ZqZEQrUDRzRVBqVmZLTk1uRy93U2QxS0FpM1k3SDlUVkpXL0pBamdtQjRBeURySE5TNEdjOWdMQ0dIK05vRmw0QURJTnJnVVhSZUFiQUFjRlZIeEN5Q3F3U2YwY2ZiYkNRc0FCaFJEUTRpR25sSUJSQXNpYWgxNndvZHdLTlp6QVRLcXl3YUl6RU5zQW1EbWxrUjBlYlROTzlqcU5TRk5vWHhLY2dDVGRMWEpBV0tIdGcrT1ZRQTJVMVZnUkxjSzBJaEpBQWE4SHlHQnhpa0lzaFZZeU9RMGhEQndDanlBRWJTVUVrRVFRTzlFU2huYTRpTUExTmdqTU9pV01OZ1lYdXdoSVBvVHdmRUw0RDNTZlIvVnZUMlV5enZReFJZYmN3R1dFQUE4WW5pdUE4ZHg0Ym91SEFXemNhUmd4SEJpZVlBRUpVUUEzTUFwRVFCbGNxajJEMk91YndJYllnaTFJSTg2T1dBU1lBREVBVnhaUjE3V2tLM1UwQnZzb2toMTlIa0NQYmtzTXRtYzdpTm8ya1hVaUh4d3dub0N3YWRBQUZKaThMbGZ3OUNWajJCUEVWa1YxSEoxVTFQWVZaQ1NRVUVkVG0wWGZaVU5ESlkzTWVKc290amJnNTdlWHIyVDZIbWVFVUtrcXdCUU1nUmdSWURUSVFBdjM0Tk1UeDdpa0UxVlE2VkRCSFk5Qkc0UjYva2kxdndxWnNvckdGbGJ4TVRXRmtyOS9lZ3JGTFFRWE5lTnpCdXdBcXo3VDBnT3dCUkY0U04yQVRBekFpTm9Qdm9WVzVyWFRCWjdwYk40MER1RTVmVVpuRjFZd01UT0RrcURnK2p0N1ExNWcrTjRBZ1lweEo0RFdDVXlUbXdWMEwzcUhFdEkwODdkNFU0ZEFUcVBLSTlleEozTklqWlc3dUlEZTdNWUhSbEJvYjlmZXdQSGNkcUpvTjBtbEYwRnhPMEJtak5ranE0T0VKc0F0QWVJSU1rU0lNamlDT1l5ZWV6Ty9nU1ZtVmxNakFjWUdCZ0lpYUR6YmZoRWVBQ042TThCeENnQXlkRmR3Q2p5ZlZpYmZCYTFCemRSbjU0QlM2bERRbnNSdE4rQ0ppUW9CNGlhSW9wTEFKSWhBU0JLRWVUeTJIcnFXZHk5OXlwb2RsYm5BUU9sa2hGQlI1dEJqaUJrWE1EelJHQnVIalVPK1hRVWdtTDJBTVRSTHRVcDE0TU5KWUo3ZDc0RGIzNWVGNDVNUXFqbXh6WTZWd0JabDlSTXg2b011RWp1aUcwVklDUDNabzI1TUlDVmlRL2ozUWMza012YmdsRW55ME5TME55ekZBMGVuVmdhUW5DYVNzR3l5UU9jUU5HT1dXSGtIT2FYSDZKL2JoNjl2WDNtOUpFV1FtZmVoY2tRZjZweUFNU2NBeERqUkFZNURpcm5Qb2laTjJaUVdsNDZUbjBnL21XZ1ZjRHA4d0Rnazl2S284SVExb3FUbUYrY1JtbHdDRDA5UGRvREtIU3dDNXVFVW5DMGNjQmFmUkIwZXRDdU02OGhBN0NVa0YyNFRibzJmZ21MTis5Z2ZHME54V0xSaElMSHVsQkNjaUlhUXFJbG40amdDQUYyWGV5cDJROENCQXI4V0lReUtOc0RKOS83ZUx6SUFCVTNlNUlld0xMWFA0S05YQW1ycXlzWUhSdlRvZUJnWFlDWjI3U01KOGdEY0RUa2E3aENZTzNpUmR3RzhIQjZHbXZLU21xKzMxNEUybjFMK0g0QThhR1BvZWVaano3VzBUSlNxSGhaUUo3d3RmY0VVTVpEcFRpTzFjWGJLSmZMdWtLb3ZNRFI5d0k0S2YwQTBYZkM2cVNvcDFSQzZmeDVCSVVDaXVVeS9DTUlnSm0xdDlqMkEweGYrREFxK1Q1elJncjBPREc2STdPaUkvOXZxSkc4QmFWeGJENTREZVh0YlhNVzBZU0JJK3dGR01OTGtBZGdSSE5HMEhFY25SaU5Db0grUXNHMFpSMHBEUGkxS21aMkFzejFEOEhuWmpMNGhFWE5od3FEVy9UMG9YOFE1VHByRDFDdFZyVjRRNGxnMHZzQmVKOGtJL1VDV2dqNWZONXNFQjNwWnBGYXRZcDVMMEJkdUhhWE10YkJJZGFrRVlIam9lTG1zYnV6bzI5Q01TSW5vZzZTN2pnOWdOVjFWQUl3TUJaeEpBRm9vY2dBTlNFUVlIOGRuV0tsUC95S1FaRENoWFN6cUZRcUpnU0VRdHFqWHJPMXVhU3NBamp1Vzd1MEJZRUJId0tCRGZ3dHBVbGRJTHpkN3lVSk1EbmErbHVzZE5xS1FTYXBEc0FjUlE0UVJTK0JCRXVDZEZwWDg0eU9PR0loOEdIbjl4N2hBMWdoa0JJQjI2V3VRZnVsSUVXU0JJcElaUjhMK1dFcklRNVFsNHg2YUgvMGFBZnFHSFM4TmNBKzhpMWs4MFhTSUZUckVrRzFBcEFsKzMzWEVNSUdDVGxNQ1lVYzE3VVk2aEp3U0FHQUlLdDJhcG1qay9uQk1LMWdtd3VvSUFzQ0gxSm9aR3VOTnRTMEpwL3RMSTBJNm5Wa0tqdHdlc0pWd1BhRm9PVHNCU1JxRUFrVXlFY0dFbFZOdXIyNG1jeXpwYzJLZ0ZnL1hYVGV3ZTlsdm9ZZitDL2dSdjJYUUljMC96RzNkTy9XMGtQRWsrM29KUUIrRmM3dUpqSm5KaDY3Ull5Um9LNWd5Y25KQVlnSXZTVFJGK3loN21RaGlDSFFMQVQ3REpBUkJoaUU4ODY3K09Qc2YySk1MRURnQnU3TEMxamp3WllCZ1EreGNpSjdBd2pCL2s1d1F4d05FZkw2TWpKQkZkbGN6dHhIZU9RbEx5RlJkUUFqNi9oRGdIQUVlbDNDMEY0WjY1bUJmY21mYUlRQ01yTWxIMVBPTkQ2cExIL01XUVVqaTNGM0JTL0ltL2ltLzdGUVR2QW9OODlrTEgwL3lIaUFBeUxneGZ2SUM2Q25SMjhKUDVZWFlIQ3k2Z0JzdEo2QUVKRHpQSXlXdDNHZjZ5QnlJY2dLd0NGRFBrTkFQK0NjbU1YdlovOGI0MklaUUVhQklNRDR4Y3liZUlldjRHRXdDYkdQZEd2YThzRGV2Q1J1aUlBUk5EeU1UUkNhQkZHcmd1YmVSbjl2RC9yNmRHUEkwVnZGRlpCRUR4RDNNUDExWGlhRENWcERuNytEM1Z3UmdqVHhXdTNtV1pBbVI1RytoTi9OdnFMbVZRQTVCVEtSR3YxVXdTOW5ibUs5TmdhZlBlTjNtK0s0amNYUzdHQ0ROTW1CSlY1UHNPRkJRNjdNSXJzNmpZRkxVM29uc04xMk1ETW44MndnR09CRTVBQVdqdXVpbEJFWTMxdkN1N2wrT0VSd0c2c0JQV3NTb0MzK0U1bFhjTlpaQnBBMWFhSmxqaGlYYVJyMzVYMzhMTGdDYXBhNkpkKzRmZ1FORngrWUdIMUFLTUlrYnBKUi85bVBNT3d3QmdlSHpGYXdJYm85K1VuMEFQWkYvRjdBZFYzMDV2UDR3UFlhRnF0bEJEMEZRejVjb1FXQUViR0czODU4VzVHL3RKLzhBeGJva1ZTaDRDMHMxYzVpaDN1dEFJekxwLzN4UGJDOGE4RkoyTGdQQlJKQWZYRVd6cjNYTURvK2pLRWgzUkZremc2R2lPK0kvUGliUXVNUEF6a2xnRE81TFl4dlBjUmM3aG9jUjVqNGoxR3hqdC9LZkF2bm5BV0FNcmFua3FobGZuM0dXY2VIM0x1NFdiOE9OZ0dDVE55M0RmbkJBZUlsQThJbWdocGNEMUQ5OFNzWUpSOW54aWQwSDBBdWx6dk0vU2ROQU1tSHVlYTlXQ2pnUW5rSjI5dUxxSlhHTmIvRFloTy9xU3ovS1djZUlFL0JnVmtjV3V1blVOSDFtdmNPNXZnY1Z1UWdDUHV0bjRER2dWSkx1RGhZYzJEOUdwVzd0NUM1K3lPY3ZYQU9ZMk5qNk8vdk4wMmg2SFRFdnhtVW1CekF3bmlCc1VJUEpsZnY0RUcyRjBNRjRPT1ovOFVIbkJsTFBoUklOSW5BQnZobUhSUm9UM21CdC9GRC8zbjRjTUFIa2p4cVJxdDFvZ0NxaTNPb2ZlY3JtQ3IyWW5MeUhJYUhoNDMxdDQvMXlROEJESEN5dklES3JQV0ozSW5OTGNpRkgrSlhCc3E0NE13ZUlGOEJ3b2pBZWdCQ2lNVXBaeFl6Y2hJUDVWa2pkRXYrZ1hKSU0wQkFiV3NENVZmK0JjUCtGczVmZlFZVEV4UGEranYrVmhMU09QWVFPS1hESm9RZUJvc09QajcrYzF6Mkh1eS9WSk9FSlI4YTFpT1FuczN2TkRMazQ1cDdCM2xVTEFtaEhWSDdyRUZBcmJ5RnpXOThHZjJMZDNIeDBpVk1UVTNwNUMrZnozZCtTdGg2M2xRQWorNFBsT0Q2RnFZRzcySnl1QUlTelVTM0lKL3M2K2E4UUFNYUdCWExPTzg4QUN6SmtBYlFzTThFVk5aWHNQNWZYMExmdzl1NGZPa2lMbDY4cUdPL0t2NGNLZllUMGVQZTBwNEtRRXFKZWoxQXJiS0tRZTgxbFBJcmhsaERxSFg1R3BiazFqQVRRU0RBRlVkVjhHaFRrMndRY0JQMGE4YjIvVHRZKytvL29yandjMXk5ZkFsWHJselJydCtjQXdpVGUzUVJNQnVrQW1oSmZuVnZEUVAwS2dheTh5QUtXYjRodlEzNXNMUE5kbENrRFNXQ253TXM5NUV1RmVvS2xmSTJsci8vTld4OTlSOHdWbDNEQjY5ZHc5TlhyMkp5Y3JMVkJSRWRpMEFpOVFDdHlhK3NvMGczTUpDYkJaSFRITnN0K1JxaUpla1cxSHE1QTRtTDRwN2VOUXhnTEI3WVU4U3YvZVJWTFB6cjM0TnUvQWN1ajVady9mcDFYRzJRWHlxVmROWnZ5ZSs4VjVMdFI0cGZBSlNNbU4rdy9BMFU4VU9Vc2c5QkpwblRPQkRuNmZEaWp3VzN6THp5dElObnhDM3d6aW8yNW1Zdzk0TnZZUHFmWDBMbDYvK0VzMXpHc3grNmh1dlBQbWZjZmh2TDd3U1VqS1pRb3JnVllMOXByRnJaUkQ5dUtQSWZnTWdGb0VDT0JZdzNFR0dyUC9xdXZ4RUJ6b21IOEw3N0E5ejgrbDJNRkF1WUdCM0d4TlVyR0R0ekJpTWpJOXJpVmJJWDlUVnhWb3lVcEVvZ3hXdjV0YjB0RlBnOTh1K0Q5cEZ1WWEwL1JINzczYTdtR1ZMREZUNCs4UXh3OXcwUGhkSVpaZTJYdGJVUERnNDJFeCtWMVlldmlCR0FLeElnQUlJQ3grajJLMXZvNDFjeG1MMEhJUnlBWEFzYkFsb2tnZWpJL1lPbEVRTXVUQlh3Tzc4eGdkdnY5dW5MbjFSMVR4ZDRGUGxSWEJYYldqZ0VlQUxJWjRDTUUzY0lzQTh4a2IrTlh2a2UrVzlEQ0dGSXR6TmM0d0ZDMW44MDh2blJ6eXhCQkx6d1RCNkxHelZVOWlybWZKOUJaT2Npd3UreHRuNGg0azRDQ2FBWXllOEpYc05ROWc2RUlBQ0h1ZjNXc2QrQ1c0UDFmT2o3QXdXQjV5NVhzYm14aE0zTnJlWmpYaWVsL3VSY0VFR3h1ZjF5Zy95M29MbUhkdmxXQkJhUElMNGRPV0dpdysvQnpManlGSEIvYmhtTGk0c3FCQlRhZFBoRWtua241MlFRYVhTVC9CMWs2ei9HVU81Tk9BSk5ibCswemZZdGFYYXlDUXcxdmRmSzJtV0lmRE5sczFCZVlCZmZ2RG1MbGRWU2M1Tkg1Q0tnSkowT3BxN1c5alg1eUNuTEg4N2UwdVFEM2dIQ3cvWDcxa2RZRGpidFVaaGNTM3p6OHE5MWdzakE1Q2d3TmJLQ3VZVjVGRzBpR01FM29DZjhkREJSZHpaMktwVmRaT28zRmZrMzRRb0c0QjRnVzRSOVV0aUtReXVBa0l4RFhrQWFFZGhuUGlBb2hzNURybCtzWXU3R0hKYVc5QTNoMmd0MEdBb09PU3JPVmdTeEM0RE1mTktXdjRlTS96cEdNeitDSzRKR3ZDY0xPa0FxTTBEY05NdjkvcE5EWmQ5RGxuNHk1QW5za25DLzFvYUt3TFduMW5CN2VzNjBlNWtid0NMKzBnaUdSQktTUUFNK09jdXZWaXB3YTdjd21uMVZGMSswYnBsYUd5N3RyOXBaTVlnR2FTMVBCN1kvOXNFdFBJRjl6d0xBdGFrYTNsMll3OExpRUFxRnZoTkpDSmtwSVdjRHJWRkZUNzZVcUZiMzRQcUsvTXozNFlvYWdIQTh0U1JMQUVLVEJDSnIvU0RyK2pYc0ZIN0JvVUFiQ2dNYzZObUM5MmttbndPZXZiQ0JiNzAxZzlYVmttbjhpRFFoWkNSb0dVaWtFREg1VW1yTGgxTzdqVkh2dS9CRVpiOWVpUjhkNDBrL1doR0VXcjNvYUtiREJ3WEF0ditYZzNCSWdBazN3TlNaT3M3T3pXTmhZZGdzQ3p0TkNKUDloUkhXcGloYThxdFZ1SXI4RWZmYjhNUnV3L0s1cGJ1M0ZxOUF6ZkdmTkVIVzZzbncxTDRLU0llSndKS3Y1cGFyQk5jbFBIZXBqSys5Tm9QbDVVRzlMQXhkQ1hzc0VDVGlGMEI0di9yWWUvcXM3d1IwYW04cDhyK0ZqQ2dEY01La294MzUxdVZiNGgvRFZmRkJrY0dRM0RvVWNMaHdORktTdURLeGhMZVhGMUFxRGVoUUVFVnRnTUw1YXZ3Q0lJb3E2ZlBoS2ZJSG5XOGk0MnpiVm0zcll1MU1obVJwUG9COTMrNzFkNTZvRUt5TkVWdVNTVnY5L3JuWkhwbE50TUdIeis5aVlYTWU2K3RuZEN1WXFRMGNheVNxRUVSUmtHK3RIL1ZWWklQYjJLdExsQU5QTHdFbEIyQ0dYZXRUWUFzK09OaldiYXhMSTRLMWFyZzR4SHl3UUdSRGdwbFpTdmcrZzBFWUxaYXhYTnRGcmVhSHJvSkx5QmRIeGcvelQ2MXpIMmIzUG9xRitYbk16ODloYlcwVk96czcram9WNWxZRkVFTkNpT09UdlFhS0VhNG93dEV3MWkrRWk3eUsvY1BEb3pnemtZTVFoSmhHOGdWZzRxSndzdkN5ZytnckVrYTRCejJGY2RSOHZidDJpT3JqdnhDU1FDSGRPY0xSMlg5Zm9RK0RKYjBjakg2REtCR3JnRWdQY2pqbzdlM1I4OEJBc2MwMXNja0dFWmx6aWxvSXBrUG9kSGtBSWcyS1NBQ21ZT0o1WGpURXh3OWo5V1krcFI2QUNJaFFCTXlzNTlNMGlFNXpEc0R2eDM5V09rU2Nld0VwNHE4RGlHaTZrMUwrNDdtRy9JaytHWlR5eituWndDY2J6RSswQUZMeVpSS09oeE5wcEtQTDRHUjVnQmhFa0NJbUQ1QWlyUU9raUI4c2JVTktRbllER1VUZE9DV2NEaUlBUVJXb1ZVQkJqUUJRWEFKZzgxQ3BFOVlyZ0dUcVNwMkFuOWc2QkVNUVVLbjVvQ0FBY2NBQU9BNEJNQlNJaEJRQ2VIWE93ZTBsRWFKRXRGa2xFQTU3UDN6ZXcvUmQxaVVnT2NxL245d2lHTzk3WU1nZ3dOWk9CdG1zaEhDOU9vQ2F1YXE0Mng1QXlxQytIVlQzTnJjQ0g1dFNPbUJKSmlMQWRNYTBJVURQaHhGRUZNcCtBOGxxanZUdkoxOEFzQUx3YTFWSUp1SWcyQUN3cFZBMUl1aVdBQ1FVYm56cHI3L3NlTmxibGEzVnlicS9OOFJCMEFPd0U2a1ZVZGdrK09UK2Z2TEJUTXdNQ0hlM3VyMDJEV0JKWVZ2QlY1RGRFckNqa0ZFb0tBd3BEQ3YwSzJUVDFVVlhRQTJyMzFCWVVWaFYyRExob0ZzZXdGY29ONTdMRFVFNFhia3lJQjFrN3FWVTJGUFk3YTRIc0NwMExDQzZTbndxQUZZSURvQzduY09RUnBlamFZcldOMXAwTDRsTld3TVk3OStSSWtXS0ZDblM4WDhOU040WS9KV09GZ0FBQUFCSlJVNUVya0pnZ2c9PVwiLFxyXG4gICAgd2lkdGg6JzEyOCcsXHJcbiAgICBoZWlnaHQ6JzEyOCdcclxufSk7IiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcblxyXG52YXIgS25vYk1hbmFnZXIgPSBmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICB0aGlzLmtub2JzID0gW107XHJcbiAgICB0aGlzLmhpZGVEb2NraW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSBkaWFncmFtO1xyXG4gICAgdGhpcy50ZW1wbGF0ZU1nciA9IGRpYWdyYW0udGVtcGxhdGVNZ3I7XHJcbiAgICBkaWFncmFtLmV2ZW50Lmxpc3Rlbigna25vYl9hZGRlZCcsIHRoaXMuYWRkS25vYkxpc3RlbmVyLCB0aGlzKTtcclxuICAgIGRpYWdyYW0uZXZlbnQubGlzdGVuKCdrbm9iX2RlbGV0ZScsIHRoaXMuZGVsZXRlS25vYkxpc3RlbmVyLCB0aGlzKTtcclxufTtcclxuXHJcbktub2JNYW5hZ2VyLnByb3RvdHlwZS5nZXRLbm9iTm9kZSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgJC5lYWNoKHRoaXMua25vYnMsIGZ1bmN0aW9uKGksIGtub2IpIHtcclxuICAgICAgICBpZihrbm9iLm5vZGUuaWQgPT0gaWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ga25vYi5ub2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vTGVhdmUgbG9vcFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbktub2JNYW5hZ2VyLnByb3RvdHlwZS5hZGRLbm9iTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmKGV2dC5kYXRhKSB7XHJcbiAgICAgICAgdGhpcy5rbm9icy5wdXNoKGV2dC5kYXRhKTtcclxuICAgIH1cclxufTtcclxuXHJcbktub2JNYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZUtub2JOb2RlID0gZnVuY3Rpb24oc3ZnTm9kZSwgY2ZnKSB7XHJcbiAgICB2YXIgdG1wbElkID0gc3ZnTm9kZS5kYWxhKCd0bXBsJyk7XHJcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZU1nci5nZXRUZW1wbGF0ZVN5bmModG1wbElkKS5jcmVhdGVOb2RlKGNmZywgdGhpcy5kaWFncmFtKS5hY3RpdmF0ZShzdmdOb2RlLmF0dHIoJ2lkJykpO1xyXG59O1xyXG5cclxuS25vYk1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUtub2JOb2RlID0gZnVuY3Rpb24ocCwgZ3JvdXAsIGNmZykge1xyXG4gICAgdmFyIGtub2JJZCA9IHRoaXMuZGlhZ3JhbS51bmlxdWVJZCgpO1xyXG4gICAgdmFyIGNvbmZpZyA9IG9iamVjdC5leHRlbmQoe25vZGVfaWQ6J2RvY2tpbmdfJytrbm9iSWQsIHg6IHAueCwgeTogcC55LCB0eXBlOidjaXJjbGUnfSwgY2ZnKTtcclxuICAgIHZhciB0bXBsX2lkID0gJ2tub2JfJytjb25maWcudHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdmFyIG5vZGUgPSB0aGlzLnRlbXBsYXRlTWdyLmdldFRlbXBsYXRlU3luYyh0bXBsX2lkKS5jcmVhdGVOb2RlKGNvbmZpZywgdGhpcy5kaWFncmFtKS5pbml0KCk7XHJcbiAgICBpZihncm91cCkge1xyXG4gICAgICAgIHRoaXMuZGlhZ3JhbS5zdmcuYWRkVG9Hcm91cChncm91cCwgbm9kZS5yb290KTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuS25vYk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUtub2JMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChldnQuZGF0YSkpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmtub2JzLmluZGV4T2YoZXZ0LmRhdGEpO1xyXG4gICAgICAgIGlmKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5rbm9icy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldnQuZGF0YS5yZW1vdmUoKTtcclxuICAgIH1cclxufTtcclxuXHJcbktub2JNYW5hZ2VyLnByb3RvdHlwZS5oaWRlS25vYnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaGlkZURvY2tpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5leGVjdXRlT25BbGxLbm9icyhmdW5jdGlvbihrbm9iKSB7XHJcbiAgICAgICAga25vYi5oaWRlKCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbktub2JNYW5hZ2VyLnByb3RvdHlwZS5zaG93S25vYnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaGlkZURvY2tpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuZXhlY3V0ZU9uQWxsS25vYnMoZnVuY3Rpb24oa25vYikge1xyXG4gICAgICAgIGtub2Iuc2hvdygpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Lbm9iTWFuYWdlci5wcm90b3R5cGUuZXhlY3V0ZU9uQWxsS25vYnMgPSBmdW5jdGlvbihmdW5jKSB7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLmtub2JzLCBmdW5jdGlvbihpbmRleCwga25vYikge1xyXG4gICAgICAgIGZ1bmMoa25vYik7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS25vYk1hbmFnZXI7XHJcbiIsInJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcclxucmVxdWlyZSgnLi9ub2RlJyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG5cclxudmFyIHRlbXBsYXRlTWdyID0gcmVxdWlyZSgnLi90ZW1wbGF0ZU1hbmFnZXInKTtcclxuXHJcbnZhciBkZWZhdWx0Q29uZmlnID0ge1xyXG4gICAgZG9ja2luZ1R5cGU6IFwiQ0VOVEVSXCIsXHJcbiAgICBmaWxsOiBcInNpbHZlclwiLFxyXG4gICAgJ2ZpbGwtYWN0aXZlJzogJ2dyZWVuJyxcclxuICAgICdmaWxsLW9wYWNpdHknOiAnMC41JyxcclxuICAgIHJhZGl1czogNSxcclxuICAgIHN0cm9rZTogJyM3QzdDN0MnLFxyXG4gICAgJ3N0cm9rZS13aWR0aCc6ICcxJyxcclxuICAgICdjc3NDbGFzcyc6ICdrbm9iJyxcclxuICAgIHByZXZlbnRTZWxlY3Rpb246IHRydWVcclxufTtcclxuXHJcbnZhciBjaXJjbGVDb25maWcgPSBvYmplY3QuZXh0ZW5kKHt9LCBkZWZhdWx0Q29uZmlnLFxyXG4gICAge1xyXG4gICAgICAgIHN2ZyA6JzxjaXJjbGUgY3g9XCIwXCIgY3k9XCIwXCIgcj1cIntyYWRpdXN9XCIgaWQ9XCJ7bm9kZV9pZH1cIiBjbGFzcz1cIntjc3NDbGFzc31cIiBzdHlsZT1cInN0cm9rZS13aWR0aDp7c3Ryb2tlLXdpZHRofTtzdHJva2U6e3N0cm9rZX07ZmlsbDp7ZmlsbH07ZmlsbC1vcGFjaXR5OntmaWxsLW9wYWNpdHl9O1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7eH0ge3l9KVwiPjwvY2lyY2xlPidcclxuICAgIH0pO1xyXG5cclxudGVtcGxhdGVNZ3IucmVnaXN0ZXJUZW1wbGF0ZSgna25vYl9jaXJjbGUnLCBjaXJjbGVDb25maWcpO1xyXG5cclxudmFyIHJlY3RDb25maWcgPSBvYmplY3QuZXh0ZW5kKHt9LCBkZWZhdWx0Q29uZmlnLFxyXG4gICAge1xyXG4gICAgICAgIHN2ZyA6JzxyZWN0IHg9XCIwXCIgeT1cIjBcIiBpZD1cIntub2RlX2lkfVwiIGhlaWdodD1cIntzaXplfVwiIHdpZHRoPVwie3NpemV9XCIgY2xhc3M9XCJ7Y3NzQ2xhc3N9XCIgc3R5bGU9XCJzdHJva2Utd2lkdGg6e3N0cm9rZS13aWR0aH07c3Ryb2tlOntzdHJva2V9O2ZpbGw6e2ZpbGx9O2ZpbGwtb3BhY2l0eTp7ZmlsbC1vcGFjaXR5fTtcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoe3h9IHt5fSlcIj48L3JlY3Q+J1xyXG4gICAgfSk7XHJcblxyXG50ZW1wbGF0ZU1nci5yZWdpc3RlclRlbXBsYXRlKCdrbm9iX3JlY3QnLCByZWN0Q29uZmlnKTsiLCIvKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBub2RlcyBvZiBhIGRpYWdyYW0uIEV2ZXJ5IG5vdGUgaGFzIGEgdW5pcXVlIElEIGFuZFxyXG4gKiBhIHRlbXBsYXRlIGRlZmluaW5nIHRoZSB0eXBlIG9mIHRoZSBub2RlLlxyXG4gKi9cclxudmFyIEV2ZW50YWJsZSA9IHJlcXVpcmUoJy4vLi4vZG9tL2V2ZW50YWJsZU5vZGUnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIGRvY2tpbmdUeXBlID0gcmVxdWlyZSgnLi9kb2NraW5nJyk7XHJcbnZhciBTVkcgPSByZXF1aXJlKCcuLi9zdmcvc3ZnJyk7XHJcbnZhciBub2RlQWRkaXRpb25zID0gcmVxdWlyZSgnLi9ub2RlQWRkaXRpb25zJyk7XHJcblxyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxuXHJcbnZhciBST09UX0NMQVNTID0gJ2VsZW1lbnRfcm9vdCc7XHJcblxyXG4vKipcclxuICogVGhlIGNvbnN0cnVjdG9yIGRvZXMgbm90IHJlbmRlciBhIG5vZGUgdG8gdGhlIHN0YWdlLiBUbyByZW5kZXIgYSBub2RlXHJcbiAqIHRoZSBpbml0IG1ldGhvZCBoYXMgdG8gYmUgY2FsbGVkLlxyXG4gKi9cclxudmFyIE5vZGUgPSBmdW5jdGlvbih0bXBsLCBjb25maWcsIGRpYWdyYW0pIHtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgdGhpcy5kYXRhID0ge307XHJcbiAgICB0aGlzLmRpYWdyYW0gPSBkaWFncmFtO1xyXG4gICAgdGhpcy5pc05vZGUgPSB0cnVlO1xyXG4gICAgdGhpcy5ldmVudCA9IGRpYWdyYW0uZXZlbnQ7XHJcbiAgICB0aGlzLmlkID0gY29uZmlnLm5vZGVfaWQ7XHJcbiAgICB0aGlzLnRlbXBsYXRlID0gdG1wbDtcclxuICAgIHRoaXMuc2VsZWN0YWJsZSA9IG9iamVjdC5pc0RlZmluZWQodGhpcy5jb25maWcuc2VsZWN0YWJsZSkgPyB0aGlzLmNvbmZpZy5zZWxlY3RhYmxlIDogdHJ1ZTtcclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKE5vZGUsIEV2ZW50YWJsZSk7XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgbm9kZSB0byB0aGUgc3RhZ2UgYW5kIGluaXRpYWxpemVzIGFsbCBldmVudCBoYW5kbGVyc1xyXG4gKiBXaXRoIHRoZSBwYXJ0IGFyZ3VtZW50IHdlIGNhbiBpbXBvcnQgdGhlIG5vZGUgdG8gYW5vdGhlciBzdmcgcGFydCB0aGFuIHRoZSBkZWZhdWx0IHdoaWNoIGlzIHRoZSBtYWluIHN0YWdlLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGV4YW1wbGUgZm9yIHRoZSBkZWZzICh3aGljaCBpcyB0ZWNobmljYWxseSBub3QgYSByZWFsIG5vZGUpXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtOb2RlX0w3Lk5vZGUucHJvdG90eXBlfVxyXG4gKi9cclxuTm9kZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHBhcnQsIHByZXBlbmQpIHtcclxuICAgIC8vQUREIEVsZW1lbnQgdG8gc3RhZ2VcclxuICAgIHRoaXMuX3NldFJvb3QodGhpcy5kaWFncmFtLmltcG9ydCh0aGlzLnRlbXBsYXRlLmdldFNWR1N0cmluZyh0aGlzLmNvbmZpZyksIHBhcnQsIHByZXBlbmQpKTtcclxuICAgIHRoaXMuYWN0aXZhdGUoKTtcclxuICAgIHRoaXMuZXhlYygnaW5pdCcpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRDb3JuZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgeCA9IHRoaXMueCgpO1xyXG4gICAgdmFyIHkgPSB0aGlzLnkoKTtcclxuICAgIHZhciBib3R0b215ID0gdGhpcy5nZXRCb3R0b21ZKCk7XHJcbiAgICB2YXIgcmlnaHR4ID0gdGhpcy5nZXRSaWdodFgoKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAge3g6eCx5Onl9LFxyXG4gICAgICAgIHt4OnJpZ2h0eCwgeTp5fSxcclxuICAgICAgICB7eDpyaWdodHgsIHk6Ym90dG9teX0sXHJcbiAgICAgICAge3g6eCx5OmJvdHRvbXl9XHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFjdGl2YXRlcyB0aGUgdGhlIG5vZGUgYW5kIGhhbmRsZXIgZnVuY3Rpb25zIGJ5IG1lYW5zIG9mIHRoZSBnaXZlbiBjb25maWdcclxuICpcclxuICogQHJldHVybnMgaXRzZWxmXHJcbiAqL1xyXG5Ob2RlLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKG5vZGVJRCkge1xyXG5cclxuICAgIHZhciBjc3NDbGFzcyA9IHRoaXMuY29uZmlnWydjc3NDbGFzcyddIHx8IFJPT1RfQ0xBU1M7XHJcbiAgICBpZihub2RlSUQpIHtcclxuICAgICAgICB0aGlzLmlkID0gdGhpcy5jb25maWcubm9kZV9pZCA9IG5vZGVJRDtcclxuICAgIH1cclxuXHJcbiAgICBpZighdGhpcy5yb290KSB7XHJcbiAgICAgICAgLy9BY3RpdmF0aW9uXHJcbiAgICAgICAgdGhpcy5fc2V0Um9vdCh0aGlzLmRpYWdyYW0uc3ZnLmdldCh0aGlzLmlkKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbm9kZUFkZGl0aW9ucy5pbml0KHRoaXMpO1xyXG5cclxuICAgIGlmKHRoaXMucm9vdCAmJiB0aGlzLmlkKSB7XHJcbiAgICAgICAgdGhpcy5pbml0RXZlbnRGdW5jdGlvbnModGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMucm9vdC5kYWxhKCd0bXBsJyAsIHRoaXMudGVtcGxhdGUuaWQpO1xyXG4gICAgICAgIC8vV2Ugc2V0IHRoZSBkYWxhIG5hbWVzcGFjZSBiZWNhdXNlIGluIGNhc2UgdGhlIG5vZGVzIGFyZSBpbXBvcnRlZC9leHBvcnRlZC9wYXJzZWQuLi5cclxuICAgICAgICB0aGlzLnJvb3QuYXR0cignaWQnLCB0aGlzLmlkKTtcclxuICAgICAgICB0aGlzLnJvb3QuYXR0cih0aGlzLmRpYWdyYW0ubnMoKSk7XHJcbiAgICAgICAgdGhpcy5yb290LmF0dHIoJ2NsYXNzJywgY3NzQ2xhc3MpO1xyXG4gICAgICAgIGlmKHRoaXMuY29uZmlnLnggJiYgdGhpcy5jb25maWcueSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVUbyh0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKG5vZGVJRCkge1xyXG4gICAgICAgIHRoaXMuZXhlYygnYWN0aXZhdGUnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuX3NldFJvb3QgPSBmdW5jdGlvbihyb290KSB7XHJcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmV2ZW50QmFzZSA9IHJvb3Q7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5pbml0RXZlbnRGdW5jdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICBpZih0aGlzLnJvb3QuaG92ZXJhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5yb290LmhvdmVyYWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlYnVnZ2VyO1xyXG5cclxuICAgIHRoaXMub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHRoYXQuZXhlYygnZGJsY2xpY2snLCBbZXZ0XSwgdHJ1ZSk7XHJcbiAgICB9KS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgaWYoIWV2dC5jdHJsS2V5ICYmIHRoYXQuaXNWaXNpYmxlKCkpIHtcclxuXHJcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgdGhhdC5leGVjKCdtb3VzZWRvd24nLCBbZXZ0XSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmKCF0aGF0LnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QuaXNWaXNpYmxlKCk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJvb3QuaGlkZSgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKG9wYWNpdHkpIHtcclxuICAgIHRoaXMucm9vdC5zaG93KG9wYWNpdHkpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLiQoKS5pbmRleCgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZmlyc3RDaGlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5maXJzdENoaWxkKCk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS4kID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290LiQoKTtcclxufVxyXG5cclxuTm9kZS5wcm90b3R5cGUubW92ZVVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZWN0b3IgPSAnLicrUk9PVF9DTEFTUztcclxuICAgIHRoaXMucm9vdC5tb3ZlVXAoc2VsZWN0b3IpO1xyXG4gICAgdGhpcy5leGVjKCdtb3ZlVXAnKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZWN0b3IgPSAnLicrUk9PVF9DTEFTUztcclxuICAgIHRoaXMucm9vdC5tb3ZlRG93bihzZWxlY3Rvcik7XHJcbiAgICB0aGlzLmV4ZWMoJ21vdmVEb3duJyk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vTm90ZToganF1ZXJ5IHRyaWdnZXJzIGEgcmVtb3ZlIGRvbSBldmVudCBpdHNlbGYuLi5cclxuICAgIHRoaXMuZXhlYygncmVtb3ZlJywgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgIHRoaXMucm9vdC5yZW1vdmUoKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3Qucm90YXRlKGEpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgdGhpcy5yb290Lm1vdmUoZHgsIGR5KTtcclxuICAgIHRoaXMuZXhlYygnbW92ZScsIFtkeCxkeV0pO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdGhpcy5yb290Lm1vdmVUbyh4LCB5KTtcclxuICAgIHRoaXMuZXhlYygnbW92ZVRvJywgW3gseV0pO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IHRoaXMueCgpLFxyXG4gICAgICAgIHkgOiB0aGlzLnkoKVxyXG4gICAgfTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmdldElubmVyU1ZHID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICByZXR1cm4gJC5zdmcodGhpcy5nZXROb2RlU2VsZWN0b3IocHJlZml4KSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS51cGRhdGVBZGRpdGlvbnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICB0aGlzLmV4ZWMoJ3VwZGF0ZScpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuYWRkT3V0Z29pbmdUcmFuc2l0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmFkZGl0aW9ucy50cmFuc2l0aW9uLmFkZE91dGdvaW5nVHJhbnNpdGlvbih2YWx1ZSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5yZW1vdmVPdXRnb2luZ1RyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB0aGlzLmFkZGl0aW9ucy50cmFuc2l0aW9uLnJlbW92ZU91dGdvaW5nVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmFkZEluY29taW5nVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIHRoaXMuYWRkaXRpb25zLnRyYW5zaXRpb24uYWRkSW5jb21pbmdUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUucmVtb3ZlSW5jb21pbmdUcmFuc2l0aW9uID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgdGhpcy5hZGRpdGlvbnMudHJhbnNpdGlvbi5yZW1vdmVJbmNvbWluZ1RyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRSb290U1ZHID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290O1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuaW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQodGhpcy5yb290KSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuaW5zdGFuY2UoKTtcclxuICAgIH1cclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnNlbGVjdG9yID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICBpZihvYmplY3QuaXNBcnJheShwcmVmaXgpKSB7XHJcbiAgICAgICAgdmFyIHN0cmluZ1NlbGVjdG9yID0gW107XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG9iamVjdC5lYWNoKHByZWZpeCwgZnVuY3Rpb24oaW5kZXgsIHZhbCkge1xyXG4gICAgICAgICAgICBzdHJpbmdTZWxlY3Rvci5wdXNoKHRoYXQuc2VsZWN0b3IodmFsKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ1NlbGVjdG9yLmpvaW4oJywgJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE5vZGVTZWxlY3RvcihwcmVmaXgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZ2V0Tm9kZVNlbGVjdG9yID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcblxyXG4gICAgaWYoIXByZWZpeCB8fCBwcmVmaXgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcjJyt0aGlzLmlkO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZighdXRpbC5zdHJpbmcuc3RhcnRzV2l0aChwcmVmaXgsICcjJykgJiYgIXV0aWwuc3RyaW5nLnN0YXJ0c1dpdGgocHJlZml4LCAnLicpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gJyMnK3ByZWZpeDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcHJlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1dGlsLnN0cmluZy5lbmRzV2l0aChwcmVmaXgsICdfJylcclxuICAgICAgICA/IHJlc3VsdCArIHRoaXMuaWRcclxuICAgICAgICA6IHJlc3VsdCArICdfJyArIHRoaXMuaWQ7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRSb290Tm9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5nZXRSb290Tm9kZSgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZXhlY3V0ZVRlbXBsYXRlSG9vayA9IGZ1bmN0aW9uKGhvb2ssIGFyZ3MpIHtcclxuICAgIGlmKHRoaXMudGVtcGxhdGUuY29uZmlnICYmIHRoaXMudGVtcGxhdGUuY29uZmlnLm9uKSB7XHJcbiAgICAgICAgdmFyIGhvb2sgPSB0aGlzLnRlbXBsYXRlLmNvbmZpZy5vbltob29rXTtcclxuICAgICAgICBpZihob29rKSB7XHJcbiAgICAgICAgICAgIGhvb2suYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2hpZnRlZCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICBjb25zb2xlLmxvZygnc2VsZWN0Jyk7XHJcbiAgICB0aGlzLmV4ZWMoJ3NlbGVjdCcsIFtzaGlmdGVkXSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5leGVjKCdkZXNlbGVjdCcpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZXh0cmFjdE5vZGVJZCA9IGZ1bmN0aW9uKHJhd0lkKSB7XHJcbiAgICB2YXIgc3BsaXR0ZWQgPSByYXdJZC5zcGxpdCgnXycpO1xyXG4gICAgcmV0dXJuIHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKHdpdGhTdHJva2UpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QueCh3aXRoU3Ryb2tlKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnkgPSBmdW5jdGlvbih3aXRoU3Ryb2tlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290Lnkod2l0aFN0cm9rZSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QuaGVpZ2h0KCk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC53aWR0aCgpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHRYID0gZnVuY3Rpb24od2l0aFN0cm9rZSkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5nZXRSaWdodFgod2l0aFN0cm9rZSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5nZXRCb3R0b21ZID0gZnVuY3Rpb24od2l0aFN0cm9rZSkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5nZXRCb3R0b21ZKHdpdGhTdHJva2UpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuaXNMZWZ0T2YgPSBmdW5jdGlvbihtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gbW91c2VQb3NpdGlvbi54ID4gKHRoaXMuZ2V0UmlnaHRYKCkpO1xyXG59O1xyXG5cclxuTm9kZS5wcm90b3R5cGUuaXNSaWdodE9mID0gZnVuY3Rpb24obW91c2VQb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIG1vdXNlUG9zaXRpb24ueCA8ICh0aGlzLngoKSk7XHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZS5pc092ZXIgPSBmdW5jdGlvbihtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gbW91c2VQb3NpdGlvbi55ID4gKHRoaXMuZ2V0Qm90dG9tWSgpKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLm92ZXJsYXlzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yb290Lm92ZXJsYXlzLmFwcGx5KHRoaXMucm9vdCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmlzVW5kZXIgPSBmdW5jdGlvbihtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gbW91c2VQb3NpdGlvbi55IDwgKHRoaXMuZ2V0Qm90dG9tWSgpKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5nZXRDZW50ZXIoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHRoZSBsb2NhdGlvbiBvZiBhIGdpdmVuIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBub2RlIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlXHJcbiAqIEBwYXJhbSBwb3NpdGlvblxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbk5vZGUucHJvdG90eXBlLmdldFJlbGF0aXZlTG9jYXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5nZXRSZWxhdGl2ZUxvY2F0aW9uKHBvc2l0aW9uKTtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSAnPGI+Tm9kZTwvYj4gLSA8Yj4nK3RoaXMuaWQrJzwvYj48YnIgLz4nO1xyXG4gICAgcmVzdWx0ICs9ICdUZW1wbGF0ZTogJyt0aGlzLnRlbXBsYXRlLmlkKyc8YnIgLz4nO1xyXG4gICAgJC5lYWNoKHRoaXMuYWRkaXRpb25zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYodmFsdWUuZHVtcCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWUuZHVtcCgpKyc8YnIgLz4nO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbk5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QudG9TdHJpbmcoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZTsiLCJ2YXIgYWRkaXRpb25zID0gcmVxdWlyZSgnLi9hZGRpdGlvbnMnKTtcclxuXHJcbi8vSW5pdCBkZWZhdWx0IGFkZGl0aW9uc1xyXG5hZGRpdGlvbnMucmVnaXN0ZXJOb2RlQWRkaXRpb24oJ3Jlc2l6ZScsIHJlcXVpcmUoJy4vcmVzaXplQWRkaXRpb24nKSk7XHJcbmFkZGl0aW9ucy5yZWdpc3Rlck5vZGVBZGRpdGlvbignZWRpdCcsIHJlcXVpcmUoJy4vZWRpdE5vZGVBZGRpdGlvbicpKTtcclxuYWRkaXRpb25zLnJlZ2lzdGVyTm9kZUFkZGl0aW9uKCd0cmFuc2l0aW9uJywgcmVxdWlyZSgnLi90cmFuc2l0aW9uQWRkaXRpb24nKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGluaXQgOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgYWRkaXRpb25zLmluaXROb2RlQWRkaXRpb24oJ3RyYW5zaXRpb24nLCBub2RlKTtcclxuICAgICAgICBhZGRpdGlvbnMuaW5pdE5vZGVBZGRpdGlvbignZWRpdCcsIG5vZGUpO1xyXG4gICAgICAgIGFkZGl0aW9ucy5pbml0Tm9kZUFkZGl0aW9uKCdyZXNpemUnLCBub2RlKTtcclxuICAgIH1cclxufSIsInJlcXVpcmUoJy4vZHJhZ2dhYmxlJyk7XHJcbnJlcXVpcmUoJy4vaG92ZXJhYmxlJyk7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XHJcbnZhciBBYnN0cmFjdE1hbmFnZXIgPSByZXF1aXJlKCcuL2Fic3RyYWN0TWFuYWdlcicpO1xyXG5cclxudmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vY29yZS9jYWNoZScpO1xyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvcmUvY29uZmlnJyk7XHJcblxyXG52YXIgRVZUX0NSRUFURSA9ICdub2RlX2NyZWF0ZSc7XHJcbi8vVE9ETzogaW1wbGVtZW50IGxpa2UgY29weSBwYXN0ZSBieSBkaWFncmFtIGV2ZW50XHJcbnZhciBFVlRfREVMRVRFID0gJ25vZGVfZGVsZXRlJztcclxuXHJcbnZhciBFVlRfUkVTSVpFRCA9ICdub2RlX3Jlc2l6ZWQnO1xyXG52YXIgRVZUX0FEREVEID0gJ25vZGVfYWRkZWQnO1xyXG52YXIgRVZUX1NFTEVDVEVEID0gJ25vZGVfc2VsZWN0ZWQnO1xyXG52YXIgRVZUX0RFU0VMRUNURUQgPSAnbm9kZV9kZXNlbGVjdGVkJztcclxudmFyIEVWVF9SRU1PVkVEID0gJ25vZGVfcmVtb3ZlZCc7XHJcblxyXG52YXIgQ01EX0FERCA9ICdub2RlX2FkZCc7XHJcbnZhciBDTURfREVMRVRFID0gJ25vZGVfZGVsZXRlJztcclxudmFyIENNRF9DT1BZID0gJ25vZGVfY29weSc7XHJcbnZhciBDTURfRFJPUCA9ICdub2RlX2Ryb3AnO1xyXG52YXIgQ01EX1JFU0laRSA9ICdub2RlX3Jlc2l6ZSc7XHJcbnZhciBDTURfRURJVCA9ICdub2RlX2VkaXQnO1xyXG5cclxudmFyIE5vZGVNYW5hZ2VyID0gZnVuY3Rpb24oZGlhZ3JhbSkge1xyXG4gICAgLy8gQ29udGFpbnMgYWxsIG5vZGVzIGFkZGVkIHRvIHRoZSBkaWFncmFtXHJcbiAgICBBYnN0cmFjdE1hbmFnZXIuY2FsbCh0aGlzLCBkaWFncmFtKTtcclxuICAgIHRoaXMubm9kZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLnNlbGVjdGlvbk1nciA9IGRpYWdyYW0uc2VsZWN0aW9uTWdyO1xyXG4gICAgdGhpcy50ZW1wbGF0ZU1nciA9IGRpYWdyYW0udGVtcGxhdGVNZ3I7XHJcblxyXG4gICAgdGhpcy5saXN0ZW4oRVZUX0NSRUFURSwgdGhpcy5jcmVhdGVOb2RlTGlzdGVuZXIpO1xyXG4gICAgdGhpcy5saXN0ZW4oRVZUX0RFTEVURSwgdGhpcy5kZWxldGVOb2RlTGlzdGVuZXIpO1xyXG4gICAgdGhpcy5saXN0ZW4oRVZUX1JFU0laRUQsIHRoaXMucmVzaXplTm9kZUxpc3RlbmVyKTtcclxuXHJcbiAgICB0aGlzLmNvbW1hbmQoQ01EX0FERCwgdGhpcy5jcmVhdGVOb2RlLCB0aGlzLmRlbGV0ZU5vZGUpO1xyXG4gICAgdGhpcy5jb21tYW5kKENNRF9ERUxFVEUsIHRoaXMuZGVsZXRlTm9kZSwgdGhpcy5pbXBvcnROb2RlKTtcclxuICAgIHRoaXMuY29tbWFuZChDTURfQ09QWSwgdGhpcy5pbXBvcnROb2RlLCB0aGlzLmRlbGV0ZU5vZGUpO1xyXG4gICAgdGhpcy5jb21tYW5kKENNRF9EUk9QLCB0aGlzLm1vdmVOb2RlLCB0aGlzLm1vdmVOb2RlKTtcclxuICAgIHRoaXMuY29tbWFuZChDTURfUkVTSVpFLCB0aGlzLnJlc2l6ZU5vZGUsIHRoaXMucmVzaXplTm9kZSk7XHJcbiAgICB0aGlzLmNvbW1hbmQoQ01EX0VESVQsIHRoaXMuZWRpdE5vZGUsIHRoaXMudW5kb0VkaXQpO1xyXG5cclxuICAgIHRoaXMuaW5pdENvcHlQYXN0ZUhhbmRsZXIoKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoTm9kZU1hbmFnZXIsIEFic3RyYWN0TWFuYWdlcik7XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuaW5pdENvcHlQYXN0ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmRpYWdyYW0ub24oJ2NvcHknLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgY29weU5vZGVzID0ge307XHJcbiAgICAgICAgdmFyIGNvcHlUcmFuc2l0aW9ucyA9IHt9O1xyXG4gICAgICAgIHZhciBub2RlQ291bnQgPSAwO1xyXG5cclxuICAgICAgICBpZighdGhhdC5zZWxlY3Rpb25NZ3Iuc2VsZWN0ZWROb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhhdC5sYXN0Q29weSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICQuZWFjaCh0aGF0LnNlbGVjdGlvbk1nci5zZWxlY3RlZE5vZGVzLCBmdW5jdGlvbihpbmRleCwgbm9kZSkge1xyXG4gICAgICAgICAgICBpZighbm9kZS5rbm9iKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlQ291bnQrKztcclxuICAgICAgICAgICAgICAgIGNvcHlOb2Rlc1tub2RlLmlkXSA9ICB7c3ZnIDogbm9kZS50b1N0cmluZygpLCBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbigpfTtcclxuICAgICAgICAgICAgICAgICQuZWFjaChub2RlLmFkZGl0aW9ucy50cmFuc2l0aW9uLm91dGdvaW5nVHJhbnNpdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHJhbnNpdGlvbi5nZXRFbmROb2RlKCkuc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29weVRyYW5zaXRpb25zW3RyYW5zaXRpb24uaWRdID17c3ZnIDogdHJhbnNpdGlvbi50b1N0cmluZygpLCBzdGFydDogdHJhbnNpdGlvbi5nZXRTdGFydE5vZGUoKS5pZCwgZW5kOiB0cmFuc2l0aW9uLmdldEVuZE5vZGUoKS5pZH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgJC5lYWNoKG5vZGUuYWRkaXRpb25zLnRyYW5zaXRpb24uaW5jb21pbmdUcmFuc2l0aW9ucywgZnVuY3Rpb24oaW5kZXgsIHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZighY29weVRyYW5zaXRpb25zW3RyYW5zaXRpb24uaWRdICYmIHRyYW5zaXRpb24uZ2V0U3RhcnROb2RlKCkuc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29weVRyYW5zaXRpb25zW3RyYW5zaXRpb24uaWRdID0ge3N2ZyA6IHRyYW5zaXRpb24udG9TdHJpbmcoKSwgc3RhcnQ6IHRyYW5zaXRpb24uZ2V0U3RhcnROb2RlKCkuaWQsIGVuZDogdHJhbnNpdGlvbi5nZXRFbmROb2RlKCkuaWR9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIHZhciB0b3BOb2RlID0gdGhhdC5nZXRUb3BOb2RlKHRoYXQuc2VsZWN0aW9uTWdyLnNlbGVjdGVkTm9kZXMpO1xyXG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IHRoYXQuZ2V0TGVmdE5vZGUodGhhdC5zZWxlY3Rpb25NZ3Iuc2VsZWN0ZWROb2Rlcyk7XHJcblxyXG4gICAgICAgIHRoYXQubGFzdENvcHkgPSB7XHJcbiAgICAgICAgICAgIHggOiBsZWZ0Tm9kZS54KCksXHJcbiAgICAgICAgICAgIHk6IHRvcE5vZGUueSgpLFxyXG4gICAgICAgICAgICBub2RlcyA6IGNvcHlOb2RlcyxcclxuICAgICAgICAgICAgY291bnQgOiBub2RlQ291bnQsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25zIDogY29weVRyYW5zaXRpb25zXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZGlhZ3JhbS5vbigncGFzdGUnLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZighdGhhdC5sYXN0Q29weSB8fCAhdGhhdC5sYXN0Q29weS5jb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbW91c2UgPSB0aGF0LmRpYWdyYW0uZ2V0U3RhZ2VQb3NpdGlvbihldmVudC5tb3VzZSgpKTtcclxuICAgICAgICB2YXIgZCA9IHt4Oihtb3VzZS54IC0gdGhhdC5sYXN0Q29weS54KSwgeToobW91c2UueSAtIHRoYXQubGFzdENvcHkueSl9O1xyXG5cclxuICAgICAgICB0aGF0LmltcG9ydENvcHlOb2RlcygpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHZhciBpZHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHN2Z1N0cmluZ3MgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG5vZGVJZE1hcHBpbmcgPSB7fTtcclxuICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uTWdyLmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICAkLmVhY2gocmVzdWx0LCBmdW5jdGlvbihpbmRleCwgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2VsZWN0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZUlkTWFwcGluZ1tub2RlLmNvbmZpZy5vbGRJZF0gPSBub2RlLmNvbmZpZy5uZXdJZDtcclxuICAgICAgICAgICAgICAgIGlkcy5wdXNoKG5vZGUuaWQpO1xyXG4gICAgICAgICAgICAgICAgc3ZnU3RyaW5ncy5wdXNoKG5vZGUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhhdC5pbXBvcnRDb3B5VHJhbnNpdGlvbnMobm9kZUlkTWFwcGluZykudGhlbihmdW5jdGlvbih0cmFuc2l0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgLy90aGF0LmFkZENtZCgnY21kX2dyb3VwJywgW1tDTURfQ09QWSwgW3N2Z1N0cmluZ3NdLCBbaWRzXV0sIFtdXSlcclxuICAgICAgICAgICAgICAgICQuZWFjaChub2RlcywgZnVuY3Rpb24oaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnRyaWdnZXJEcmFnKGQueCwgZC55KTtcclxuICAgICAgICAgICAgICAgICAgICAvL1dlIGhhdmUgdG8gZGVzZWxlY3QgYmVjYXVzZSBpdHMgYWxyZWFkeSBzZWxlY3RlZCBhZnRlciBjcmVhdGlvbiBhbmQgd2Ugc2hpZnQgc2VsZWN0IGl0XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgbXVsdGlwbGUgbm9kZSBjb3BpZXMuIElmIG5vdCBkZXNlbGVjdGVkIHRoaXMgd291bGQgZGVzZWxlY3QgdGhlIG5vZGUgaW4gc2VsZWN0aW9ubWdyXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kZXNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2VsZWN0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAkLmVhY2godHJhbnNpdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5tb3ZlSW5uZXJLbm9icyhkKTtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnNlbGVjdElubmVyS25vYnMoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoYXQuYWRkQ21kKENNRF9DT1BZLCBbc3ZnU3RyaW5nc10sIFtpZHNdKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge30pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG9iamVjdC5zaXplKHRoaXMubm9kZXMpO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmdldFRvcE5vZGUgPSBmdW5jdGlvbihub2Rlcykge1xyXG4gICAgcmV0dXJuIHRoaXMuc29ydGVkKG5vZGVzLCBmdW5jdGlvbihhLGIpIHtcclxuICAgICAgICByZXR1cm4gKGEueSgpID4gYi55KCkpID8gMSA6IC0xO1xyXG4gICAgfSlbMF07XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuZ2V0TGVmdE5vZGUgPSBmdW5jdGlvbihub2Rlcykge1xyXG4gICAgcmV0dXJuIHRoaXMuc29ydGVkKG5vZGVzLCBmdW5jdGlvbihhLGIpIHtcclxuICAgICAgICByZXR1cm4gKGEueCgpID4gYi54KCkpID8gMSA6IC0xO1xyXG4gICAgfSlbMF07XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuZ2V0Qm90dG9tTm9kZSA9IGZ1bmN0aW9uKG5vZGVzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zb3J0ZWQobm9kZXMsIGZ1bmN0aW9uKGEsYikge1xyXG4gICAgICAgIHJldHVybiAoYS5nZXRCb3R0b21ZKCkgPCBiLmdldEJvdHRvbVkoKSkgPyAxIDogLTE7XHJcbiAgICB9KVswXTtcclxufTtcclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRSaWdodE5vZGUgPSBmdW5jdGlvbihub2Rlcykge1xyXG4gICAgcmV0dXJuIHRoaXMuc29ydGVkKG5vZGVzLCBmdW5jdGlvbihhLGIpIHtcclxuICAgICAgICByZXR1cm4gKGEuZ2V0UmlnaHRYKCkgPCBiLmdldFJpZ2h0WCgpKSA/IDEgOiAtMTtcclxuICAgIH0pWzBdO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLnNvcnRlZCA9IGZ1bmN0aW9uKG5vZGVzLCBjb21wYXJlKSB7XHJcbiAgICBpZihvYmplY3QuaXNGdW5jdGlvbihub2RlcykpIHtcclxuICAgICAgICBjb21wYXJlID0gbm9kZXM7XHJcbiAgICAgICAgbm9kZXMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBub2RlcyA9IHRoaXMuZ2V0Tm9kZXNBc0FycmF5KG5vZGVzKTtcclxuICAgIHJldHVybiBub2Rlcy5zb3J0KGNvbXBhcmUpO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmdldE5vZGVzQXNBcnJheSA9IGZ1bmN0aW9uKG5vZGVzKSB7XHJcbiAgICBub2RlcyA9IG5vZGVzIHx8IHRoaXMubm9kZXM7XHJcbiAgICBpZighb2JqZWN0LmlzQXJyYXkobm9kZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuICQubWFwKG5vZGVzLCBmdW5jdGlvbih2YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuaW1wb3J0Q29weU5vZGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICQuZWFjaCh0aGF0Lmxhc3RDb3B5Lm5vZGVzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGF0LmltcG9ydE5vZGUodmFsdWUuc3ZnLCB7XHJcbiAgICAgICAgICAgIG9sZElkIDoga2V5LFxyXG4gICAgICAgICAgICB4IDogdmFsdWUucG9zaXRpb24ueCxcclxuICAgICAgICAgICAgeSA6IHZhbHVlLnBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgIG5ld0lkIDogdGhhdC5kaWFncmFtLnVuaXF1ZUlkKClcclxuICAgICAgICB9KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuaW1wb3J0Q29weVRyYW5zaXRpb25zID0gZnVuY3Rpb24obm9kZUlkTWFwcGluZykge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAkLmVhY2godGhhdC5sYXN0Q29weS50cmFuc2l0aW9ucywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgc3ZnID0gdmFsdWUuc3ZnO1xyXG4gICAgICAgICAgICBzdmcgPSBzdmcucmVwbGFjZShuZXcgUmVnRXhwKHZhbHVlLnN0YXJ0LCAnZycpLCBub2RlSWRNYXBwaW5nW3ZhbHVlLnN0YXJ0XSk7XHJcbiAgICAgICAgICAgIHN2ZyA9IHN2Zy5yZXBsYWNlKG5ldyBSZWdFeHAodmFsdWUuZW5kLCAnZycpLCBub2RlSWRNYXBwaW5nW3ZhbHVlLmVuZF0pO1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoYXQuZGlhZ3JhbS50cmFuc2l0aW9uTWdyLmltcG9ydFRyYW5zaXRpb24oc3ZnLCB7b2xkSWQ6a2V5LCBuZXdJZDp0aGF0LmRpYWdyYW0udW5pcXVlSWQoKX0pO1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0cmFuc2l0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVOb2RlTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHN0YWdlUG9zaXRpb24gPSB0aGlzLmRpYWdyYW0uZ2V0U3RhZ2VQb3NpdGlvbihldnQpO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlTm9kZUNvbW1hbmQoZXZ0LmRhdGEsIHN0YWdlUG9zaXRpb24pO1xyXG4gICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgZXZlbnQudHJpZ2dlcignZXJyb3InLCAnRXJyb3Igb2NjdXJlZCB3aGlsZSBjcmVhdGluZyBub2RlICEnKTtcclxuICAgIH1cclxufTtcclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVOb2RlQ29tbWFuZCA9IGZ1bmN0aW9uKHRtcGwsIGNmZykge1xyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgY2ZnID0gJC5leHRlbmQoe30sIGNmZywgY29uZmlnLnZhbCgnbm9kZV9zZXR0aW5ncycsIHt9KSk7XHJcblxyXG4gICAgaWYoIXRtcGwpIHtcclxuICAgICAgICBldmVudC50cmlnZ2VyKCd3YXJuJywgJ0NvdWxkIG5vdCBjcmVhdGUgTm9kZTogTm8gdGVtcGxhdGUgc2VsZWN0ZWQhJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNmZy5ub2RlX2lkID0gdGhpcy5kaWFncmFtLnVuaXF1ZUlkKCk7XHJcbiAgICBjZmcuZGlhZ3JhbUlkID0gdGhpcy5kaWFncmFtLmlkO1xyXG4gICAgcmV0dXJuIHRoaXMuZXhlYyhDTURfQURELCBbdG1wbCwgY2ZnXSwgW2NmZy5ub2RlX2lkXSk7XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uKHRtcGwsIGNmZykge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdmFyIG5vZGUgPSB0bXBsLmNyZWF0ZU5vZGUoY2ZnLCB0aGlzLmRpYWdyYW0pLmluaXQoKTtcclxuICAgIGlmKCFjZmcucHJldmVudERyYWcpIHtcclxuICAgICAgICBub2RlLmRyYWdnYWJsZSgpO1xyXG4gICAgICAgIG5vZGUub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgY29uc29sZS5sb2coJ3llZXNzc3NzcycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGUub24oJ3NlbGVjdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LmV2ZW50LnRyaWdnZXIoRVZUX1NFTEVDVEVELCBub2RlKTtcclxuICAgICAgICB9KS5vbignZGVzZWxlY3QnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKEVWVF9ERVNFTEVDVEVELCBub2RlKTtcclxuICAgICAgICB9KS5vbigncmVtb3ZlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZXZlbnQudHJpZ2dlcihFVlRfUkVNT1ZFRCwgbm9kZSk7XHJcbiAgICAgICAgfSkub24oJ2VkaXQnLCBmdW5jdGlvbihldnQsIGtleSwgdmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYWRkQ21kKENNRF9FRElULCBbbm9kZS5pZCwga2V5LCB2YWx1ZV0sIFtub2RlLmlkLCBrZXksIG9sZFZhbHVlXSk7XHJcbiAgICAgICAgfSkub24oJ2RyYWdFbmQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoYXQuc2VsZWN0aW9uTWdyLmdldFNlbGVjdGVkTm9kZXMoKTtcclxuICAgICAgICAgICAgLy9XZSBqdXN0IGFkZCB0aGUgY29tbWFuZCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGV4ZWN1dGUgdGhlIGRyYWcgdHdpY2VcclxuXHJcbiAgICAgICAgICAgIC8vRm9yIEFQSSBjYWxscyB3aGVyZSB0aGUgbm9kZSBpcyBub3QgbmVjZXNzYXJpbHkgc2VsZWN0ZWRcclxuICAgICAgICAgICAgaWYoJChzZWxlY3Rpb24pLmZpbHRlcihmdW5jdGlvbihpKSB7IHJldHVybiB0aGlzLmlkID09PSBub2RlLmlkO30pLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgdGhhdC5hZGRDbWQoQ01EX0RST1AsXHJcbiAgICAgICAgICAgICAgICBbc2VsZWN0aW9uLCBub2RlLmRyYWdDb250ZXh0LmR4U3VtLCBub2RlLmRyYWdDb250ZXh0LmR5U3VtXSxcclxuICAgICAgICAgICAgICAgIFtzZWxlY3Rpb24sICgtMSAqIG5vZGUuZHJhZ0NvbnRleHQuZHhTdW0pLCAoLTEgKiBub2RlLmRyYWdDb250ZXh0LmR5U3VtKV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hZGROb2RlKG5vZGUpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHRoaXMubm9kZXNbbm9kZS5pZF0gPSBub2RlO1xyXG4gICAgdGhpcy5ldmVudC50cmlnZ2VyKEVWVF9BRERFRCwgbm9kZSk7XHJcbn07XHJcblxyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGNmZykge1xyXG4gICAgdmFyIGRvbU5vZGU7XHJcbiAgICBpZihub2RlLlNWR0VsZW1lbnQpIHtcclxuICAgICAgICBkb21Ob2RlID0gbm9kZS5pbnN0YW5jZSgpO1xyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgIGRvbU5vZGUgPSB0aGlzLmRpYWdyYW0uc3ZnLmdldChub2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9tTm9kZSA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBkb20uZ2V0QXR0cmlidXRlcyhkb21Ob2RlKTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB0aGF0LnRlbXBsYXRlTWdyLmdldFRlbXBsYXRlKGF0dHJpYnV0ZXNbJ2RhbGE6dG1wbCddKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodG1wbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGF0LmFjdGl2YXRlKGF0dHJpYnV0ZXNbJ2lkJ10sIHRtcGwsIGNmZykpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihub2RlSWQsIHRtcGwsIGNmZykge1xyXG4gICAgLy9DcmVhdGUgTm9kZSBpbnN0YW5jZSBhbmQgc2V0IG5vZGVJZFxyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgdmFyIG5vZGUgPSB0bXBsLmNyZWF0ZU5vZGUoY2ZnLCB0aGlzLmRpYWdyYW0pXHJcbiAgICAgICAgLmFjdGl2YXRlKG5vZGVJZClcclxuICAgICAgICAuZHJhZ2dhYmxlKCk7XHJcblxyXG4gICAgdGhpcy5hZGROb2RlKG5vZGUpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlTm9kZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5nZXROb2RlKGV2dC5kYXRhKTtcclxuICAgICAgICBpZihub2RlLmtub2IpIHtcclxuICAgICAgICAgICAgLy9DTUQgaXMgaGFuZGxlZCBieSB0cmFuc2l0aW9uTWdyXHJcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlYyhDTURfREVMRVRFLCBbbm9kZS5pZF0sIFtub2RlLnRvU3RyaW5nKCldKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICBldmVudC50cmlnZ2VyKCdlcnJvcicsICdDb3VsZCBub3QgZGVsZXRlIG5vZGUoJytub2RlLmlkKycpJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihub2Rlcykge1xyXG4gICAgJC5lYWNoKHRoaXMubm9kZXMsIGZ1bmN0aW9uKGlkLCBub2RlKSB7XHJcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICBpZihvYmplY3QuaXNBcnJheShub2RlKSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAkLmVhY2gobm9kZSwgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZGVsZXRlTm9kZSh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZGUgPSB0aGlzLmdldE5vZGUobm9kZSk7XHJcbiAgICBpZihub2RlKSB7XHJcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tub2RlLmlkXTtcclxuICAgICAgICBjYWNoZS5jbGVhckJ5U3VmZml4KG5vZGUuaWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2RlbGV0ZSBub2RlIHdhcyBjYWxsZWQgZm9yIHVua25vd24gbm9kZScpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmltcG9ydE5vZGUgPSBmdW5jdGlvbihub2RlU3RyLCBjZmcpIHtcclxuICAgIGlmKG9iamVjdC5pc0FycmF5KG5vZGVTdHIpKSB7XHJcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICQuZWFjaChub2RlU3RyLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGF0LmltcG9ydE5vZGUodmFsdWUsIGNmZykpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5vZGVzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuXHJcbiAgICAvL0lmIHNldCB3ZSByZXBsYWNlIHRoZSBvbGQgbm9kZSBpZCB3aXRoIGEgbmV3IG9uZSBlLmcuIHdoZW4gd2UgY29weSBhIG5vZGVcclxuICAgIGlmKGNmZy5uZXdJZCAmJiBjZmcub2xkSWQpIHtcclxuICAgICAgICBub2RlU3RyID0gbm9kZVN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoY2ZnLm9sZElkLCAnZycpLCBjZmcubmV3SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vSW5zZXJ0IHRvIGRvbSBhbmQgYWN0aXZhdGUgdGhlIG5ldyBub2RlXHJcbiAgICB2YXIgdGFyZ2V0SW5zdGFuY2UgPSB0aGlzLmRpYWdyYW0uaW1wb3J0KG5vZGVTdHIpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVOb2RlKHRhcmdldEluc3RhbmNlLCBjZmcpO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmdldE5vZGVBc1N0cmluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIG5vZGUgPSB0aGlzLmdldE5vZGUobm9kZSk7XHJcbiAgICByZXR1cm4gbm9kZS50b1N0cmluZygpO1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLm1vdmVOb2RlID0gZnVuY3Rpb24obm9kZSwgZHhTdW0sIGR5U3VtKSB7XHJcbiAgICBpZihvYmplY3QuaXNBcnJheShub2RlKSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAkLmVhY2gobm9kZSwgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoYXQubW92ZU5vZGUodmFsdWUsIGR4U3VtLCBkeVN1bSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGUgPSB0aGlzLmdldE5vZGUobm9kZSk7XHJcbiAgICAgICAgaWYobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnRyaWdnZXJEcmFnKGR4U3VtLCBkeVN1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IGxpc3RlbiB0aHJvdWdoIG5vZGUgZXZlbnQgIVxyXG4gKiBAcGFyYW0gZXZ0XHJcbiAqL1xyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUucmVzaXplTm9kZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBub2RlID0gZXZ0LmRhdGE7XHJcbiAgICAgICAgaWYobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzaXplSW5zdGFuY2UgPSBub2RlLmFkZGl0aW9ucy5yZXNpemUuZ2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ21kKENNRF9SRVNJWkUsXHJcbiAgICAgICAgICAgICAgICBbbm9kZS5pZCwgcmVzaXplSW5zdGFuY2UuZHgsIHJlc2l6ZUluc3RhbmNlLmR5LCByZXNpemVJbnN0YW5jZS5rbm9iXSxcclxuICAgICAgICAgICAgICAgIFtub2RlLmlkLCAoLTEqcmVzaXplSW5zdGFuY2UuZHgpLCAoLTEqcmVzaXplSW5zdGFuY2UuZHkpLCByZXNpemVJbnN0YW5jZS5rbm9iXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLnJlc2l6ZU5vZGUgPSBmdW5jdGlvbihub2RlLCBkeCwgZHksIGtub2IpIHtcclxuICAgIG5vZGUgPSB0aGlzLmdldE5vZGUobm9kZSk7XHJcbiAgICBpZihub2RlKSB7XHJcbiAgICAgICAgbm9kZS5hZGRpdGlvbnMucmVzaXplLmdldCgpLnJlc2l6ZShkeCxkeSxrbm9iKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdyZXNpemVOb2RlIHdhcyBmb3IgdW5rbm93biBub2RlIDonK25vZGUudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICBpZihvYmplY3QuaXNTdHJpbmcoaWQpICYmICFpc05hTihpZCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1twYXJzZUludChpZCldO1xyXG4gICAgfSBlbHNlIGlmKCFpc05hTihpZCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1tpZF07XHJcbiAgICB9IGVsc2UgaWYoaWQgaW5zdGFuY2VvZiBOb2RlKSB7XHJcbiAgICAgICAgLy9XZSBhc3N1bWUgYSBub2RlIGluc3RhbmNlXHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2dldE5vZGUgY2FsbCB3aXRoIG5vIHJlc3VsdCBmb3IgOicraWQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24oZmlsdGVyKSB7XHJcbiAgICBpZighZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b0FycmF5KHRoaXMubm9kZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgb2JqZWN0LmVhY2godGhpcy5ub2RlcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZihmaWx0ZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaFt2YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLmVkaXROb2RlID0gZnVuY3Rpb24obm9kZSwgZWRpdEtleSwgbmV3VmFsdWUpIHtcclxuICAgIG5vZGUgPSB0aGlzLmdldE5vZGUobm9kZSk7XHJcbiAgICBub2RlLmFkZGl0aW9ucy5lZGl0LnNldFZhbHVlKGVkaXRLZXksIG5ld1ZhbHVlKTtcclxufTtcclxuXHJcbk5vZGVNYW5hZ2VyLnByb3RvdHlwZS51bmRvRWRpdCA9IGZ1bmN0aW9uKG5vZGUsIGVkaXRLZXksIG5ld1ZhbHVlKSB7XHJcbiAgICBub2RlID0gdGhpcy5nZXROb2RlKG5vZGUpO1xyXG4gICAgbm9kZS5hZGRpdGlvbnMuZWRpdC5zZXRWYWx1ZShlZGl0S2V5LCBuZXdWYWx1ZSk7XHJcbn07XHJcblxyXG5Ob2RlTWFuYWdlci5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9ICc8Yj5Ob2RlbWFuYWdlcjwvYj4gLSAnK3RoaXMuc2l6ZSgpKycgTm9kZXM8YnIgLz48YnIgLz4nO1xyXG4gICAgJC5lYWNoKHRoaXMubm9kZXMsIGZ1bmN0aW9uKGluZGV4LCBub2RlKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IG5vZGUuZHVtcCgpKyc8YnIgLz4nO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuTm9kZU1hbmFnZXIucHJvdG90eXBlLnZhbGlkYXRlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIGlmKCFub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFsnRXJyb3I6IFVuZGVmaW5lZCBOb2RlISddO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmKCFub2RlLmlkKSB7XHJcbiAgICAgICAgcmVzdWx0WydOb2RlSWQnXSA9ICdFcnJvcjogTm9kZSBoYXMgbm8gSWQhJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYoIXRoaXMuZ2V0Tm9kZShub2RlLmlkKSkge1xyXG4gICAgICAgICAgICByZXN1bHRbJ05vZGVJZCddID0gJ0Vycm9yOiBOb2RlICcrbm9kZS5pZCsnIG5vdCByZWdpc3RlcmVkISc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCF0aGlzLmRpYWdyYW0uc3ZnLmdldCgnIycrbm9kZS5pZCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFsnTm9kZUlkJ10gPSAnRXJyb3I6IE5vZGUnK25vZGUuaWQrJyBub3QgcGFydCBvZiBTVkchJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlTWFuYWdlcjsiLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29yZS9jb25maWcnKTtcclxudmFyIEN1cnZlUGF0aE1hbmFnZXIgPSByZXF1aXJlKCcuL2N1cnZlZFBhdGhNYW5hZ2VyJyk7XHJcbnZhciBTdHJhaWdodFBhdGhNYW5hZ2VyID0gcmVxdWlyZSgnLi9zdHJhaWdodFBhdGhNYW5hZ2VyJyk7XHJcbnZhciBSb3VuZFBhdGhNYW5hZ2VyID0gcmVxdWlyZSgnLi9yb3VuZFBhdGhNYW5hZ2VyJyk7XHJcbnZhciBwYXRoTWFuYWdlciA9IHt9O1xyXG5cclxudmFyIHJlZ2lzdGVyID0gICBmdW5jdGlvbihjb25zdHJ1Y3Rvcikge1xyXG4gICAgcGF0aE1hbmFnZXJbY29uc3RydWN0b3IudHlwZV0gPSBjb25zdHJ1Y3RvcjtcclxufTtcclxuXHJcbnJlZ2lzdGVyKEN1cnZlUGF0aE1hbmFnZXIpO1xyXG5yZWdpc3RlcihTdHJhaWdodFBhdGhNYW5hZ2VyKTtcclxucmVnaXN0ZXIoUm91bmRQYXRoTWFuYWdlcik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICB7XHJcbiAgICByZWdpc3RlciA6IHJlZ2lzdGVyLFxyXG4gICAgZ2V0IDogZnVuY3Rpb24odHJhbnNpdGlvbiwgaWQpIHtcclxuICAgICAgICBpZCA9IGlkIHx8IGNvbmZpZy52YWwoJ3RyYW5zaXRpb25fdHlwZScsIFN0cmFpZ2h0UGF0aE1hbmFnZXIudHlwZSk7XHJcbiAgICAgICAgaWYocGF0aE1hbmFnZXJbaWRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcGF0aE1hbmFnZXJbaWRdKHRyYW5zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcbnZhciBDb21tYW5kID0gcmVxdWlyZSgnLi4vY29yZS9jb21tYW5kJyk7XHJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi9zdmcvdHJhbnNmb3JtJyk7XHJcbnZhciBTVkcgPSByZXF1aXJlKCcuLi9zdmcvc3ZnJyk7XHJcbnZhciBEcmFnQ29uZmlnID0gcmVxdWlyZSgnLi4vc3ZnL2RyYWdDb25maWcnKTtcclxudmFyIEtub2IgPSByZXF1aXJlKCcuL2tub2InKTtcclxuXHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIGRvbSA9IHV0aWwuZG9tO1xyXG5cclxuLy8gVXNlZCB0byBpZGVudGlmeSB0aGUgZGlmZmVyZW50IGtub2JzIGZyb20gbm9ydGggd2VzdCBjbG9ja3dpc2VcclxudmFyIEtOT0JfTlcgPSAwO1xyXG52YXIgS05PQl9OID0gMTtcclxudmFyIEtOT0JfTkUgPSAyO1xyXG52YXIgS05PQl9FID0gMztcclxudmFyIEtOT0JfU0UgPSA0O1xyXG52YXIgS05PQl9TID0gNTtcclxudmFyIEtOT0JfU1cgPSA2O1xyXG52YXIgS05PQl9XID0gNztcclxuXHJcblxyXG4vLyBzcGVjaWZpZXMgdGhlIHNwYWNlIGJldHdlZW4gbm9kZSBhbmQgcmVzaXplIGtub2JcclxudmFyIERJRiA9IDM7XHJcblxyXG4vLyBzcGVjaWZpZXMgdGhlIHNpemUgb2YgYSBrbm9iXHJcbnZhciBTSVpFID0gNTtcclxuXHJcbi8vIHVzZWQgZm9yIGNhbGN1bGF0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUga25vYnNcclxudmFyIERJRl9SRUwgPSBESUYgKyBTSVpFO1xyXG5cclxudmFyIFJlc2l6ZSA9IGZ1bmN0aW9uKG5vZGUsIGRpYWdyYW0pIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IGRpYWdyYW07XHJcbiAgICB0aGlzLmV2ZW50ID0gZGlhZ3JhbS5ldmVudDtcclxuICAgIHRoaXMua25vYnMgPSBbXTtcclxuICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMubm9kZS50ZW1wbGF0ZS5jb25maWcucmVzaXplO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhlIGtub2JzIGFyb3VuZCB0aGUgbm9kZS5cclxuICovXHJcblJlc2l6ZS5wcm90b3R5cGUuYWN0aXZhdGVLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuY2FsY3VsYXRlS25vYlBvc2l0aW9uKCk7XHJcblxyXG5cclxuICAgIGlmKCEkKCcjcmVzaXplX2dyb3VwXycrdGhpcy5ub2RlLmlkKS5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmdyb3VwID0gdGhpcy5kaWFncmFtLnN2Zy5nKHtpZDogJ3Jlc2l6ZV9ncm91cF8nICsgdGhpcy5ub2RlLmlkfSkudHJhbnNsYXRlKHRoaXMubm9kZS5wb3NpdGlvbigpKS5yb3RhdGUodGhpcy5ub2RlLnJvdGF0ZSgpKTtcclxuXHJcbiAgICAgICAgLy9Jbml0aWFsaXplIHRoZSBkaWZmZXJlbnQga25vYnMgd2l0aCBkaWZmZXJlbnQgZHJhZyByZXN0cmljaXRvbnNcclxuICAgICAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9OVywgcG9zaXRpb25zW0tOT0JfTlddLCBuZXcgRHJhZ0NvbmZpZygpKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9OLCBwb3NpdGlvbnNbS05PQl9OXSwgbmV3IERyYWdDb25maWcoKS55T25seSgpKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9ORSwgcG9zaXRpb25zW0tOT0JfTkVdLCBuZXcgRHJhZ0NvbmZpZygpKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9FLCBwb3NpdGlvbnNbS05PQl9FXSwgbmV3IERyYWdDb25maWcoKS54T25seSgpKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9TRSwgcG9zaXRpb25zW0tOT0JfU0VdLCBuZXcgRHJhZ0NvbmZpZygpKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9TLCBwb3NpdGlvbnNbS05PQl9TXSwgbmV3IERyYWdDb25maWcoKS55T25seSgpKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9TVywgcG9zaXRpb25zW0tOT0JfU1ddLCBuZXcgRHJhZ0NvbmZpZygpKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUtub2IoS05PQl9XLCBwb3NpdGlvbnNbS05PQl9XXSwgbmV3IERyYWdDb25maWcoKS54T25seSgpKTtcclxuXHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVuZGVycyBhIGtub2IgdG8gdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBjb25maWd1cmVzIHRoZSBkcmFnIGFuZCBob3ZlclxyXG4gKiBsb2dpYy4gVGhlIHRvdGFsIGRyYWcgYW1vdW50IG9mIG9uZSBkcmFnIGlzIGNhbiBiZSBhY2Vzc2VkIHRocm91Z2hcclxuICogdGhpcy5keCBhbmQgdGhpcy5keS5cclxuICovXHJcblJlc2l6ZS5wcm90b3R5cGUuY3JlYXRlS25vYiA9IGZ1bmN0aW9uKGtub2IsIHAsIGRyYWdDZmcpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIC8vIEluaXRpYWxpemUgZHJhZ2xvZ2ljXHJcbiAgICB2YXIgZHJhZ0hvb2sgPSBkcmFnQ2ZnXHJcbiAgICAgICAgLmRyYWdTdGFydChmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgdGhhdC5keCA9IDA7XHJcbiAgICAgICAgICAgIHRoYXQuZHkgPSAwO1xyXG4gICAgICAgICAgICB0aGF0LmRyYWdLbm9iID0ga25vYjtcclxuICAgICAgICAgICAgdGhhdC5rbm9ic1trbm9iXS5maWxsKCdncmVlbicpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmRyYWdNb3ZlKGZ1bmN0aW9uKGV2dCwgZHgsIGR5KSB7XHJcbiAgICAgICAgICAgIC8vV2Uga2VlcCB0cmFjayBvZiB0aGUgdG90YWwgZHJhZyBtb3ZlbWVudFxyXG4gICAgICAgICAgICBkeCA9IG9iamVjdC5pc09uZU9mKGtub2IsIEtOT0JfTlcsIEtOT0JfVywgS05PQl9TVykgPyAtMSAqIGR4IDogZHg7XHJcbiAgICAgICAgICAgIGR5ID0gb2JqZWN0LmlzT25lT2Yoa25vYiwgS05PQl9OVywgS05PQl9OLCBLTk9CX05FKSA/IC0xICogZHkgOiBkeTtcclxuXHJcbiAgICAgICAgICAgIHRoYXQuZHggKz0gZHg7XHJcbiAgICAgICAgICAgIHRoYXQuZHkgKz0gZHk7XHJcblxyXG4gICAgICAgICAgICB0aGF0LnJlc2l6ZShkeCxkeSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZHJhZ0VuZChmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKCdub2RlX3Jlc2l6ZWQnLCB0aGF0Lm5vZGUpO1xyXG4gICAgICAgICAgICB0aGF0Lmtub2JzW2tub2JdLmZpbGwoJ2JsYWNrJyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZ2V0U2NhbGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmRpYWdyYW0uc2NhbGU7XHJcbiAgICAgICAgfSkuZ2V0KCk7XHJcblxyXG4gICAgZHJhZ0hvb2sucHJldmVudEFsaWdubWVudCA9IHRydWU7XHJcblxyXG4gICAgLy8gUmVuZGVyIHRoZSBrbm9iIG9uIHN0YWdlXHJcbiAgICB0aGlzLmtub2JzW2tub2JdID0gbmV3IEtub2IodGhpcy5kaWFncmFtLCBwLCB7dHlwZToncmVjdCcsIGZpbGw6J2JsYWNrJywgJ2ZpbGwtYWN0aXZlJzonYmxhY2snLCBzdHJva2U6J25vbmUnLCBzZWxlY3RhYmxlOmZhbHNlLCAnc3Ryb2tlLXdpZHRoJzowLCBzaXplOlNJWkUsICdmaWxsLW9wYWNpdHknOjF9LCB0aGlzLmdyb3VwKVxyXG4gICAgICAgIC5kcmFnZ2FibGUoZHJhZ0hvb2spLmhvdmVyYWJsZSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgYWxsIHN2ZyBlbGVtZW50cyBwYXJ0aWNpcGF0aW5nIGluIHRoZSByZXNpemUgcHJvY2Vzcywgd2hpY2hcclxuICogYXJlIGNvbmZpZ3VyZWQgaW4gdGhlIHJlc2l6ZSBjb25maWcgYmluZCBhdHRyaWJ1dGVcclxuICovXHJcblJlc2l6ZS5wcm90b3R5cGUuZ2V0UmVzaXplRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIG9iamVjdC5lYWNoKHRoaXMuY29uZmlnLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpZih2YWx1ZS5iaW5kID09PSAncm9vdCcpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHRoYXQubm9kZS5yb290O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzdmdTZWxlY3RvciA9IHRoYXQubm9kZS5nZXROb2RlU2VsZWN0b3IodmFsdWUuYmluZCk7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSAkLnFDYWNoZSgpLnN2ZyhzdmdTZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIHJlc2l6ZSBsb2dpY1xyXG4gKi9cclxuUmVzaXplLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVzaXplKDAsMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzaXplcyB0aGUgbm9kZSBieSBhcHBseWluZyB0aGUgY29uZmlndXJlZCByZXNpemUgbG9naWMgdG8gdGhlIGlubmVyXHJcbiAqIHN2ZyBlbGVtZW50cyBvZiB0aGUgbm9kZXMuIFRoZSBkeCBhbmQgZHkgdmFsdWVzIHNwZWNpZmllIHRoZSByZXNpemVcclxuICogYW1vdW50IG9mIHRoZSB4LSBhbmQgeS1heGlzLiBBZnRlciB0aGUgYWN0dWFsIHJlc2l6ZSBwcm9jZXNzIHRoZSBrbm9ic1xyXG4gKiBhcmUgYWxpZ25lZCB0byB0aGUgbmV3IG5vZGUgZGltZW5zaW9uLlxyXG4gKi9cclxuUmVzaXplLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgIHRoaXMudXBkYXRlTm9kZXMoZHgsZHkpO1xyXG4gICAgdGhpcy51cGRhdGVLbm9icyh0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlnbnMgYSBzaW5nbGUga25vYiB0byB0aGVcclxuICogQHBhcmFtIHt0eXBlfSByZXNpemVLbm9iXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5SZXNpemUucHJvdG90eXBlLnVwZGF0ZUtub2JzID0gZnVuY3Rpb24ocmVzaXplS25vYikge1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZCh0aGlzLmdyb3VwKSkge1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQocmVzaXplS25vYikgJiYgcmVzaXplS25vYikge1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5jYWxjdWxhdGVLbm9iUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5rbm9ic1tLTk9CX05XXS5tb3ZlVG8ocG9zaXRpb25zW0tOT0JfTlddKTtcclxuICAgICAgICAgICAgdGhpcy5rbm9ic1tLTk9CX05dLm1vdmVUbyhwb3NpdGlvbnNbS05PQl9OXSk7XHJcbiAgICAgICAgICAgIHRoaXMua25vYnNbS05PQl9ORV0ubW92ZVRvKHBvc2l0aW9uc1tLTk9CX05FXSk7XHJcbiAgICAgICAgICAgIHRoaXMua25vYnNbS05PQl9FXS5tb3ZlVG8ocG9zaXRpb25zW0tOT0JfRV0pO1xyXG4gICAgICAgICAgICB0aGlzLmtub2JzW0tOT0JfU0VdLm1vdmVUbyhwb3NpdGlvbnNbS05PQl9TRV0pO1xyXG4gICAgICAgICAgICB0aGlzLmtub2JzW0tOT0JfU10ubW92ZVRvKHBvc2l0aW9uc1tLTk9CX1NdKTtcclxuICAgICAgICAgICAgdGhpcy5rbm9ic1tLTk9CX1NXXS5tb3ZlVG8ocG9zaXRpb25zW0tOT0JfU1ddKTtcclxuICAgICAgICAgICAgdGhpcy5rbm9ic1tLTk9CX1ddLm1vdmVUbyhwb3NpdGlvbnNbS05PQl9XXSk7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5leGVjKCdyZXNpemUnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL0lmIHRoZSBmbGFnIGlzIG5vdCBzZXQgd2UganVzdCBkbyBhbiB1cGRhdGUgcHJvYmFibHkgZnJvbSBzaW1wbGUgbm9kZSBkcmFnL2Ryb3BcclxuICAgICAgICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGUodGhpcy5ub2RlLnBvc2l0aW9uKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblJlc2l6ZS5wcm90b3R5cGUuY2FsY3VsYXRlS25vYlBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2l6ZURpZnN1bSA9IChTSVpFICsgRElGKVxyXG4gICAgdmFyIGxlZnQgPSAtMSAqIHNpemVEaWZzdW07XHJcbiAgICB2YXIgdG9wID0gbGVmdDtcclxuICAgIHZhciByaWdodCA9IHRoaXMubm9kZS53aWR0aCgpICsgRElGO1xyXG4gICAgdmFyIGNlbnRlclggPSByaWdodCAvIDIgLSAoc2l6ZURpZnN1bSAvIDIpO1xyXG4gICAgdmFyIGJvdHRvbSA9IHRoaXMubm9kZS5oZWlnaHQoKSArIERJRjtcclxuICAgIHZhciBjZW50ZXJZID0gYm90dG9tIC8gMiAtIChzaXplRGlmc3VtIC8gMik7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgcmVzdWx0W0tOT0JfTlddID0ge3g6bGVmdCwgeTp0b3B9O1xyXG4gICAgcmVzdWx0W0tOT0JfTl0gPSB7eDpjZW50ZXJYLCB5OnRvcH07XHJcbiAgICByZXN1bHRbS05PQl9ORV0gPSB7eDpyaWdodCwgeTp0b3B9O1xyXG4gICAgcmVzdWx0W0tOT0JfRV0gPSB7eDpyaWdodCwgeTpjZW50ZXJZfTtcclxuICAgIHJlc3VsdFtLTk9CX1NFXSA9IHt4OnJpZ2h0LCB5OmJvdHRvbX07XHJcbiAgICByZXN1bHRbS05PQl9TXSA9IHt4OmNlbnRlclgsIHk6Ym90dG9tfTtcclxuICAgIHJlc3VsdFtLTk9CX1NXXSA9IHt4OmxlZnQsIHk6Ym90dG9tfTtcclxuICAgIHJlc3VsdFtLTk9CX1ddID0ge3g6bGVmdCwgeTpjZW50ZXJZfTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG59O1xyXG5cclxuUmVzaXplLnByb3RvdHlwZS5yZW1vdmVLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZCh0aGlzLmdyb3VwKSkge1xyXG4gICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlKCk7XHJcbiAgICB9IGVsc2UgaWYoJCgnI3Jlc2l6ZV9ncm91cF8nK3RoaXMubm9kZS5pZCkubGVuZ3RoKSB7XHJcbiAgICAgICAgJCgnI3Jlc2l6ZV9ncm91cF8nK3RoaXMubm9kZS5pZCkucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgdGhpcy5ncm91cDtcclxufTtcclxuXHJcblJlc2l6ZS5wcm90b3R5cGUudXBkYXRlTm9kZXMgPSBmdW5jdGlvbihkeCxkeSkge1xyXG5cclxuICAgIGlmKCFvYmplY3QuaXNEZWZpbmVkKHRoaXMucmVzaXplRWxlbWVudHMpKSB7XHJcbiAgICAgICAgdGhpcy5yZXNpemVFbGVtZW50cyA9IHRoaXMuZ2V0UmVzaXplRWxlbWVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLnJlc2l6ZUVsZW1lbnRzLCBmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xyXG4gICAgICAgIHRoYXQudXBkYXRlTm9kZShpbmRleCxlbGVtZW50LGR4LGR5KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmKCFvYmplY3QuaXNEZWZpbmVkKGR4KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWxpZ25YID0gb2JqZWN0LmlzT25lT2YodGhpcy5kcmFnS25vYiwgS05PQl9OVywgS05PQl9XLCBLTk9CX1NXKSA/IGR4ICogLTEgOiAwO1xyXG4gICAgdmFyIGFsaWduWSA9IG9iamVjdC5pc09uZU9mKHRoaXMuZHJhZ0tub2IsIEtOT0JfTlcsIEtOT0JfTiwgS05PQl9ORSkgPyBkeSAqIC0xIDogMDtcclxuICAgIHRoaXMubm9kZS5yb290Lm1vdmUoYWxpZ25YLCBhbGlnblkpO1xyXG5cclxuICAgIC8vRm9yIEFQSSBjYWxscyB0aGUgZ3JvdXAgd2FzIG5vdCByZW5kZXJlZCBpZiB0aGUgbm9kZSBpcyBub3Qgc2VsZWN0ZWRcclxuICAgIGlmKHRoaXMuZ3JvdXApIHtcclxuICAgICAgICB0aGlzLmdyb3VwLm1vdmUoYWxpZ25YLCBhbGlnblkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUmVzaXplLnByb3RvdHlwZS51cGRhdGVOb2RlID0gZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQsIGR4LCBkeSkge1xyXG4gICAgZHggPSAoIW9iamVjdC5pc0RlZmluZWQoZHgpKT8gMCA6IGR4O1xyXG4gICAgZHkgPSAoIW9iamVjdC5pc0RlZmluZWQoZHkpKT8gMCA6IGR5O1xyXG5cclxuICAgIHZhciBlbGVtZW50Q29uZmlnID0gdGhpcy5jb25maWdbaW5kZXhdO1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChlbGVtZW50Q29uZmlnLnZhbHVlKSkge1xyXG4gICAgICAgIC8vVE9ETzogY2xlYW5lciBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgIC8vU2NhbGUgd2l0aCBldmVuIGFsaWdubWVudCAoZGVmYXVsdCBmb3IgdHlwZSBzY2FsZSlcclxuICAgICAgICBpZihlbGVtZW50Q29uZmlnLnZhbHVlWzBdLnR5cGUgPT09ICdzY2FsZScgJiYgZWxlbWVudENvbmZpZy5ldmVuKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdXRpbC5tYXRoLm1pbk1heChkeCxkeSkubWF4O1xyXG4gICAgICAgICAgICB0aGlzLnNldFJlc2l6ZShlbGVtZW50LCBlbGVtZW50Q29uZmlnLCBlbGVtZW50Q29uZmlnLnZhbHVlWzBdLCBkLCAnd2lkdGgnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZihlbGVtZW50Q29uZmlnLnZhbHVlWzBdLnR5cGUgIT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVzaXplKGVsZW1lbnQsIGVsZW1lbnRDb25maWcsIGVsZW1lbnRDb25maWcudmFsdWVbMF0sIGR4LCAnd2lkdGgnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1dlIGp1c3Qgc2V0IG9uZSBkaW1lbnNpb24gZm9yIGEgY2lyY2xlXHJcbiAgICAgICAgICAgIGlmKGVsZW1lbnRDb25maWcudmFsdWVbMF0udHlwZSAhPT0gJ2NpcmNsZScgfHwgdGhpcy5kcmFnS25vYiA9PT0gS05PQl9TIHx8IHRoaXMuZHJhZ0tub2IgPT09IEtOT0JfTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXNpemUoZWxlbWVudCxlbGVtZW50Q29uZmlnLCBlbGVtZW50Q29uZmlnLnZhbHVlWzFdLCBkeSwgJ2hlaWdodCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoZWxlbWVudENvbmZpZy5taW4pKSB7XHJcbiAgICAgICAgdGhpcy5hbGlnblZhbHVlTGltaXQoZWxlbWVudCwgZWxlbWVudENvbmZpZy5taW5bMF0sICd3aWR0aCcsICdtaW4nKTtcclxuICAgICAgICB0aGlzLmFsaWduVmFsdWVMaW1pdChlbGVtZW50LCBlbGVtZW50Q29uZmlnLm1pblsxXSwgJ2hlaWdodCcsICdtaW4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGVsZW1lbnRDb25maWcubWF4KSkge1xyXG4gICAgICAgIHRoaXMuYWxpZ25WYWx1ZUxpbWl0KGVsZW1lbnQsIGVsZW1lbnRDb25maWcubWF4WzBdLCAnd2lkdGgnLCAnbWF4Jyk7XHJcbiAgICAgICAgdGhpcy5hbGlnblZhbHVlTGltaXQoZWxlbWVudCwgZWxlbWVudENvbmZpZy5tYXhbMV0sICdoZWlnaHQnLCAnbWF4Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChlbGVtZW50Q29uZmlnLnBvc2l0aW9uKSkge1xyXG4gICAgICAgIHRoaXMuYWxpZ25Qb3NpdGlvbihlbGVtZW50LCBlbGVtZW50Q29uZmlnKTtcclxuICAgIH1cclxufTtcclxuXHJcblJlc2l6ZS5wcm90b3R5cGUuc2V0UmVzaXplID0gZnVuY3Rpb24oc3ZnRWxlbWVudCwgZWxlbWVudENvbmZpZywgc2V0dGluZywgZCwgZGltZW5zaW9uKSB7XHJcbiAgICBzd2l0Y2goc2V0dGluZy50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnc3RhdGljJzpcclxuICAgICAgICBjYXNlICdub25lJzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxyXG4gICAgICAgICAgICB2YXIgbmV3WSA9IHBhcnNlSW50KHN2Z0VsZW1lbnQuYXR0cigneTInKSkgKyBkO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LmF0dHIoJ3kyJywgbmV3WSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3BhcmVudCc6XHJcbiAgICAgICAgICAgIC8vV2UgY291bGQgY2hlY2sgdGhlIHJlc2l6ZSBzZXR0aW5ncyBvZiB0aGUgcGFyZW50IGlmIHRoaXMgaXMgc3RhdGljXHJcbiAgICAgICAgICAgIC8vd2UgZG8gbm90IGhhdmUgdG8gY2hhbmdlIGFueXRoaW5nIHdoZW4gcmVzaXppbmcuXHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnRbZGltZW5zaW9uXSgxKTtcclxuXHJcbiAgICAgICAgICAgIC8vR2V0IHRoZSBkaW1lbnNpb24gZnJvbSBwYXJlbnQgbm9kZVxyXG4gICAgICAgICAgICB2YXIgcGFyZW50VmFsID0gc3ZnRWxlbWVudC4kKCkucGFyZW50KCkuZ2V0KDApLmdldEJCb3goKVtkaW1lbnNpb25dO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50W2RpbWVuc2lvbl0ocGFyZW50VmFsICsgc2V0dGluZy52YWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3NjYWxlJzpcclxuICAgICAgICAgICAgaWYoZWxlbWVudENvbmZpZy5ldmVuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBzdmdFbGVtZW50LnNjYWxlKClbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBkIC8gc3ZnRWxlbWVudC5nZXRCQm94KCkud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzdmdFbGVtZW50LnNjYWxlKHNjYWxlICsgcmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgJC5lYWNoKHN2Z0VsZW1lbnQuZmluZCgnLmFsaWduU2NhbGUnKSwgZnVuY3Rpb24oaW5kZXgsIHN2Z1RvQWxpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdmdUb0FsaWduLnNjYWxlKDEgLyBzdmdFbGVtZW50LnNjYWxlKClbMF0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAkLmVhY2goc3ZnRWxlbWVudC5maW5kKCcuYWxpZ25TY2FsZVN0cm9rZScpLCBmdW5jdGlvbihpbmRleCwgc3ZnVG9BbGlnbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gc3ZnVG9BbGlnbi5zdHJva2VXaWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gY3VycmVudCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Z1RvQWxpZ24uc3Ryb2tlV2lkdGgoaW5pdCAvIHN2Z0VsZW1lbnQuc2NhbGUoKVswXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlT2xkICA9IHN2Z0VsZW1lbnQuc2NhbGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZUluZGV4ID0gKGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcpID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVOZXcgPSBzY2FsZU9sZC5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgLy9BZGQgdGhlIHJhdGlvIGZyb20gb3JpZ2luYWwgc2l6ZSAod2l0aG91dCBzY2FsZSlcclxuICAgICAgICAgICAgICAgIHNjYWxlTmV3W3NjYWxlSW5kZXhdICs9IChkIC8gc3ZnRWxlbWVudC5nZXRCQm94KClbZGltZW5zaW9uXSk7XHJcbiAgICAgICAgICAgICAgICBzdmdFbGVtZW50LnNjYWxlKHNjYWxlTmV3WzBdLCBzY2FsZU5ld1sxXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVE9ETzogc2VhcmNoIGZvciBpbm5lciBlbGVtZW50cyB3aXRoIGNsYXNzIC5hbGlnblNjYWxpbmcgYW5kIGFsaW5nIGUuZy4gc3Ryb2tlLXdpZHRoLCBmb250LXNpemUuLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWwgPSBzdmdFbGVtZW50W2RpbWVuc2lvbl0oZmFsc2UpO1xyXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAoY3VycmVudFZhbCArIGQpO1xyXG4gICAgICAgICAgICBpZihuZXdWYWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnRbZGltZW5zaW9uXSgoY3VycmVudFZhbCArIGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufTtcclxuXHJcblJlc2l6ZS5wcm90b3R5cGUuYWxpZ25WYWx1ZUxpbWl0ID0gZnVuY3Rpb24oc3ZnRWxlbWVudCwgc2V0dGluZywgZGltZW5zaW9uLCB0eXBlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBzZXR0aW5nLnR5cGU7XHJcbiAgICB2YXIgbGltaXQ7XHJcblxyXG4gICAgaWYodmFsdWUgPT09ICdwYXJlbnQnKSB7XHJcbiAgICAgICAgbGltaXQgPSBzdmdFbGVtZW50LiQoKS5wYXJlbnQoKVswXS5nZXRCQm94KClbZGltZW5zaW9uXTtcclxuICAgIH0gZWxzZSBpZighaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgbGltaXQgPSBwYXJzZUludCh2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYodXRpbC5zdHJpbmcuc3RhcnRzV2l0aCh2YWx1ZSwgJyMnKSkge1xyXG4gICAgICAgIGxpbWl0ID0gJC5xQ2FjaGUodGhpcy5ub2RlLmdldE5vZGVTZWxlY3Rvcih2YWx1ZSkpWzBdLmdldEJCb3goKVtkaW1lbnNpb25dO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChzZXR0aW5nLnZhbHVlKSkge1xyXG4gICAgICAgIGxpbWl0ICs9IHNldHRpbmcudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGN1cnJlbnRWYWwgPSBzdmdFbGVtZW50W2RpbWVuc2lvbl0oZmFsc2UpXHJcbiAgICBpZigodHlwZSA9PT0gJ21pbicgJiYgY3VycmVudFZhbCA8IGxpbWl0KSB8fCAodHlwZSA9PT0gJ21heCcgJiYgY3VycmVudFZhbCA+IGxpbWl0KSkge1xyXG4gICAgICAgIHN2Z0VsZW1lbnRbZGltZW5zaW9uXShsaW1pdCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5SZXNpemUucHJvdG90eXBlLmFsaWduUG9zaXRpb24gPSBmdW5jdGlvbihzdmdFbGVtZW50LCBlbGVtZW50Q29uZmlnKSB7XHJcbiAgICAvL3ZhciBzZXR0aW5nID0gZWxlbWVudENvbmZpZy5cclxuICAgIC8vVE9ETzogc2V0IGFsaWduRWxlbWVudCBpZCBpbiBjb25maWcgIVxyXG4gICAgdmFyIHggPSB0aGlzLmdldEFsaWduZWRQb3NpdGlvbihzdmdFbGVtZW50LGVsZW1lbnRDb25maWcucG9zaXRpb25bMF0sIGVsZW1lbnRDb25maWcuYWxpZ250bywgJ3dpZHRoJyAsICd4Jyk7XHJcbiAgICB2YXIgeSA9IHRoaXMuZ2V0QWxpZ25lZFBvc2l0aW9uKHN2Z0VsZW1lbnQsZWxlbWVudENvbmZpZy5wb3NpdGlvblsxXSwgZWxlbWVudENvbmZpZy5hbGlnbnRvLCAnaGVpZ2h0JywgJ3knKTtcclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHgpKSB7XHJcbiAgICAgICAgc3ZnRWxlbWVudC5tb3ZlWCh4KTtcclxuICAgIH1cclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHkpKSB7XHJcbiAgICAgICAgc3ZnRWxlbWVudC5tb3ZlWSh5KTtcclxuICAgIH1cclxufTtcclxuXHJcblJlc2l6ZS5wcm90b3R5cGUuZ2V0QWxpZ25lZFBvc2l0aW9uID0gZnVuY3Rpb24oc3ZnRWxlbWVudCwgc2V0dGluZ3MsIGFsaWdudG8sIGRpbWVuc2lvbiwgZGltZW5zaW9uQ29vcmQpIHtcclxuICAgIHN3aXRjaChzZXR0aW5ncy50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnbm9uZSc6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgIHZhciBhbGlnblNWRyA9IHRoaXMuZ2V0QWxpZ25FbGVtZW50KGFsaWdudG8sIHN2Z0VsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKGFsaWduU1ZHKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFsaWduVmFsID0gYWxpZ25TVkcuZ2V0Q2VudGVyKClbZGltZW5zaW9uQ29vcmRdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsaWduVmFsIC0gKHN2Z0VsZW1lbnRbZGltZW5zaW9uXSgpIC8gMikgLSBzZXR0aW5ncy52YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncmVsYXRpdmUnOlxyXG4gICAgICAgICAgICB2YXIgJHByZXZOb2RlID0gc3ZnRWxlbWVudC4kKCkucHJldigpO1xyXG4gICAgICAgICAgICBpZigkcHJldk5vZGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldlNWRyA9ICQucUNhY2hlKCkuc3ZnKCRwcmV2Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbCA9IHByZXZTVkdbZGltZW5zaW9uXSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZDb29yZCA9IHByZXZTVkdbZGltZW5zaW9uQ29vcmRdKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHByZXZDb29yZCArIHByZXZWYWwpICsgc2V0dGluZ3MudmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL05vIHByZXYgc2libGluZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICB2YXIgYWxpZ25TVkcgPSB0aGlzLmdldEFsaWduRWxlbWVudChhbGlnbnRvLCBzdmdFbGVtZW50KTtcclxuICAgICAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChhbGlnblNWRykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbGlnblZhbCA9IChzZXR0aW5ncy50eXBlID09PSAncmlnaHQnKT8gYWxpZ25TVkcuZ2V0UmlnaHRYKCk6YWxpZ25TVkcuZ2V0Qm90dG9tWSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhbGlnblZhbCAtIHN2Z0VsZW1lbnRbZGltZW5zaW9uXSgpKSAtIHNldHRpbmdzLnZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn07XHJcblxyXG5SZXNpemUucHJvdG90eXBlLmdldEFsaWduRWxlbWVudCA9IGZ1bmN0aW9uKGFsaWdudG8sIHN2Z0VsZW1lbnQpIHtcclxuICAgIHZhciBlbGVtZW50VG9BbGlnbjtcclxuICAgIC8vVGhlIGFsaWdudG8gc2V0dGluZyBjYW4gYmUgdGhlIHBhcmVudC0sIHJvb3QtIG9yIGFuIGV4cGxpY2l0IGVsZW1lbnQgZGVmYXVsdCBpcyB0aGUgcHJldmlvdXMgc2libGluZyBlbGVtZW50XHJcbiAgICBpZighYWxpZ250byB8fCBhbGlnbnRvID09PSAncHJldicpIHtcclxuICAgICAgICBlbGVtZW50VG9BbGlnbiA9ICQucUNhY2hlKCkuc3ZnKHN2Z0VsZW1lbnQuJCgpLnByZXYoKSk7XHJcbiAgICB9ZWxzZSBpZihhbGlnbnRvID09PSAncGFyZW50Jykge1xyXG4gICAgICAgIGVsZW1lbnRUb0FsaWduID0gJC5xQ2FjaGUoKS5zdmcoc3ZnRWxlbWVudC4kKCkucGFyZW50KCkpOztcclxuICAgIH0gZWxzZSBpZihhbGlnbnRvID09PSAncm9vdCcpIHtcclxuICAgICAgICBlbGVtZW50VG9BbGlnbiA9IHRoaXMubm9kZS5yb290O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtZW50VG9BbGlnbiA9ICQucUNhY2hlKCkuc3ZnKHRoaXMubm9kZS5nZXROb2RlU2VsZWN0b3IoYWxpZ250bykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCFlbGVtZW50VG9BbGlnbikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGRldGVybWluZSBhbGlnbnRvIGVsZW1lbnQgXCInK2FsaWdudG8rJ1wiIGZvciBub2RlICcrdGhpcy5ub2RlLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudFRvQWxpZ247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2l6ZTtcclxuIiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBSZXNpemUgPSByZXF1aXJlKCcuL3Jlc2l6ZScpO1xyXG5cclxudmFyIFJlc2l6ZUFkZGl0aW9uID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIHRoaXMucmVzaXplID0gbmV3IFJlc2l6ZSh0aGlzLm5vZGUsIHRoaXMubm9kZS5kaWFncmFtKTtcclxufTtcclxuXHJcblJlc2l6ZUFkZGl0aW9uLnByb3RvdHlwZS5yZXNpemVOb2RlID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICAvL1RoaXMgaXMgdGhlIGFwaSB3YXkgdG8gcmVzaXplIGEgbm9kZSB3ZSBpbWl0YXRlIHRoZSBkcmFnZXZlbnQuXHJcbiAgICB0aGlzLnJlc2l6ZS51cGRhdGVOb2RlcyhkeCxkeSk7XHJcbiAgICB0aGlzLnJlc2l6ZS5kcmFnS25vYiA9IDQ7IC8vV2Ugc2V0IHRoZSBLTk9CX1NFIGtub2IgYXMgZHJhZ0tub2IgZm9yIHRoZSByZWRvIGNvbW1hbmRcclxuICAgIHRoaXMucmVzaXplLmR4ID0gZHg7XHJcbiAgICB0aGlzLnJlc2l6ZS5keSA9IGR5O1xyXG4gICAgdGhpcy5ub2RlLmV2ZW50LnRyaWdnZXIoJ25vZGVfcmVzaXplZCcsIHRoaXMubm9kZSk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlc2l6ZS5hY3RpdmF0ZUtub2JzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVzaXplLnJlbW92ZUtub2JzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRlc2VsZWN0KCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuZHJhZ01vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVzaXplLnVwZGF0ZUtub2JzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuZWRpdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZXNpemUudXBkYXRlKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvL1RPRE86IFRocm91Z2ggRVZFTlRTICFcclxuICAgIHRoaXMucmVzaXplLnVwZGF0ZUtub2JzKCk7XHJcbn07XHJcblxyXG5SZXNpemVBZGRpdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZXNpemUudXBkYXRlTm9kZXMoKTtcclxufTtcclxuXHJcblJlc2l6ZUFkZGl0aW9uLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZXNpemUudXBkYXRlTm9kZXMoKTtcclxufTtcclxuXHJcblJlc2l6ZUFkZGl0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJlc2l6ZTtcclxufTtcclxuXHJcblJlc2l6ZUFkZGl0aW9uLnJlcXVpcmVDb25maWcgPSB0cnVlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXNpemVBZGRpdGlvbjsiLCJ2YXIgU3RyYWlnaHRQYXRoTWFuYWdlciA9IHJlcXVpcmUoJy4vc3RyYWlnaHRQYXRoTWFuYWdlcicpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG5cclxudmFyIFJvdW5kUGF0aE1hbmFnZXIgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICBTdHJhaWdodFBhdGhNYW5hZ2VyLmNhbGwodGhpcywgdHJhbnNpdGlvbik7XHJcbiAgICB0aGlzLnR5cGUgPSBSb3VuZFBhdGhNYW5hZ2VyLnR5cGU7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKFJvdW5kUGF0aE1hbmFnZXIsIFN0cmFpZ2h0UGF0aE1hbmFnZXIpO1xyXG5cclxuUm91bmRQYXRoTWFuYWdlci50eXBlID0gJ3JvdW5kJztcclxuXHJcblJvdW5kUGF0aE1hbmFnZXIucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xyXG4gICAgdGhpcy5pbml0KHBvc2l0aW9uc1swXSk7XHJcbiAgICB0aGlzLmNyZWF0ZShwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtMV0pO1xyXG5cclxuICAgIGZvcih2YXIgaSAgPSAxOyBpIDwgcG9zaXRpb25zLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIHRoaXMuYWRkKGksIHBvc2l0aW9uc1tpXSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Sb3VuZFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpbmRleCwgcG9zaXRpb24pIHtcclxuICAgIHZhciBjb3JuZXJzID0gdGhpcy5wYXRoLnZhbHVlc0J5VHlwZSgnUScpO1xyXG4gICAgaWYodGhpcy5wYXRoLmxlbmd0aCgpID09IDEpIHsgLy8gSW5pdGlhbCBBZGRcclxuICAgICAgICB0aGlzLnBhdGguaW5zZXJ0TGluZShpbmRleCwgcG9zaXRpb24pO1xyXG4gICAgfSBlbHNlIGlmKGluZGV4IC0gMSA8PSBjb3JuZXJzLmxlbmd0aCkgeyAvL0FkZCBpbm5zZXIgS25vYlxyXG4gICAgICAgIC8vR2V0IHRoZSBlbmRJbmRleC9wb3NpdGlvbiBvZiB0aGUgbGluZSBiZWZvcmUgdGhlIG5ldyBjb3JuZXJcclxuICAgICAgICB2YXIgcHJldkVuZEluZGV4ID0gKGluZGV4ID09IDEpID8gMSA6IGNvcm5lcnNbaW5kZXggLSAyXS5pbmRleCArIDE7XHJcbiAgICAgICAgdGhpcy5wYXRoLmluc2VydFFCZXppZXIocHJldkVuZEluZGV4ICsgMSxwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5wYXRoLmluc2VydExpbmUocHJldkVuZEluZGV4ICsgMiwgdGhpcy5wYXRoLnZhbHVlKHByZXZFbmRJbmRleCkudG8oKSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQYXJ0KGluZGV4KTtcclxuICAgIH0gZWxzZSB7IC8vIEFwcGVuZCBrbm9iXHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucGF0aC5lbmQoKTtcclxuICAgICAgICB0aGlzLnBhdGgucUJlemllcihwb3NpdGlvbiwgdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLnBhdGgubGluZShlbmQpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ29ybmVyKGluZGV4KTtcclxuICAgIH1cclxufTtcclxuXHJcblJvdW5kUGF0aE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVBhcnQgPSBmdW5jdGlvbihpbmRleCwgcG9zaXRpb24sIHByZXZVcGRhdGVOZWlnaGJvcnMpIHtcclxuICAgIHZhciBjb3JuZXJzID0gdGhpcy5wYXRoLnZhbHVlc0J5VHlwZSgnUScpO1xyXG4gICAgaWYoaW5kZXggPT0gMCkgeyAvLyBGaXJzdCBLbm9iXHJcbiAgICAgICAgdGhpcy5wYXRoLnN0YXJ0KHBvc2l0aW9uKTtcclxuICAgICAgICBpZihjb3JuZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXJ0KDEsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmKGluZGV4ID4gY29ybmVycy5sZW5ndGgpIHsgLy8gTGFzdCBLbm9iXHJcblxyXG4gICAgICAgIHRoaXMucGF0aC5lbmQocG9zaXRpb24pO1xyXG4gICAgICAgIGlmKGNvcm5lcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhcnQoY29ybmVycy5sZW5ndGgsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHsgLy8gSW5uZXIgS25vYnNcclxuICAgICAgICB0aGlzLnVwZGF0ZUNvcm5lcihpbmRleCwgcG9zaXRpb24sIHByZXZVcGRhdGVOZWlnaGJvcnMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUm91bmRQYXRoTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQ29ybmVyID0gZnVuY3Rpb24oaW5kZXgsIHBvc2l0aW9uLCBwcmV2VXBkYXRlTmVpZ2hib3JzKSB7XHJcbiAgICB2YXIgY29ybmVycyA9IHRoaXMucGF0aC52YWx1ZXNCeVR5cGUoJ1EnKTtcclxuICAgIHZhciBjb3JuZXJJbmRleCA9IGluZGV4IC0gMTtcclxuICAgIHRoaXMudXBkYXRlQ29ybmVyU3RhcnQoY29ybmVySW5kZXgsIGNvcm5lcnMsIHBvc2l0aW9uKTtcclxuICAgIHRoaXMudXBkYXRlQ29ybmVyRW5kKGNvcm5lckluZGV4LCBjb3JuZXJzLCBwb3NpdGlvbik7XHJcblxyXG4gICAgaWYoIXByZXZVcGRhdGVOZWlnaGJvcnMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBhcnQoaW5kZXggKyAxLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUGFydChpbmRleCAtIDEsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Sb3VuZFBhdGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVDb3JuZXJTdGFydCA9IGZ1bmN0aW9uKGNvcm5lckluZGV4LCBjb3JuZXJzLCBwb3NpdGlvbikge1xyXG4gICAgdmFyIHVwZGF0ZUNvcm5lciA9IGNvcm5lcnNbY29ybmVySW5kZXhdO1xyXG5cclxuICAgIGlmKCF1cGRhdGVDb3JuZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCB1cGRhdGVDb3JuZXIudmFsdWUuY29udHJvbCgpO1xyXG4gICAgdmFyIHN0YXJ0T3JpZW50YXRpb24gPSAoY29ybmVySW5kZXggPiAwKSA/IGNvcm5lcnNbY29ybmVySW5kZXggLSAxXS52YWx1ZS50bygpIDogdGhpcy5wYXRoLnN0YXJ0KCk7XHJcbiAgICB2YXIgY3VydmVTdGFydCA9IHV0aWwubWF0aC5MaW5lLm1vdmVBbG9uZyhzdGFydE9yaWVudGF0aW9uLCBwb3NpdGlvbiwgLTIwKTtcclxuICAgIHRoaXMucGF0aC5zZXRUbyh1cGRhdGVDb3JuZXIuaW5kZXggLSAxLCBjdXJ2ZVN0YXJ0KTtcclxufTtcclxuXHJcblJvdW5kUGF0aE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUNvcm5lckVuZCA9IGZ1bmN0aW9uKGNvcm5lckluZGV4LCBjb3JuZXJzLCBwb3NpdGlvbikge1xyXG4gICAgdmFyIHVwZGF0ZUNvcm5lciA9IGNvcm5lcnNbY29ybmVySW5kZXhdO1xyXG5cclxuICAgIGlmKCF1cGRhdGVDb3JuZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCB1cGRhdGVDb3JuZXIudmFsdWUuY29udHJvbCgpO1xyXG4gICAgdmFyIGVuZE9yaWVudGF0aW9uID0gKGNvcm5lckluZGV4ID09IGNvcm5lcnMubGVuZ3RoIC0gMSkgPyB0aGlzLnBhdGguZW5kKCkgOiBjb3JuZXJzW2Nvcm5lckluZGV4ICsgMV0udmFsdWUudG8oKTtcclxuICAgIHZhciBjdXJ2ZUVuZCA9IHV0aWwubWF0aC5MaW5lLm1vdmVBbG9uZyhwb3NpdGlvbiwgZW5kT3JpZW50YXRpb24sIDIwKTtcclxuICAgIHVwZGF0ZUNvcm5lci52YWx1ZS5jb250cm9sKHBvc2l0aW9uKS50byhjdXJ2ZUVuZCk7XHJcbn07XHJcblxyXG5Sb3VuZFBhdGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRJbmRleEZvclBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIC8vVGhlIHJvdW5kIHBhdGggaXMgZGl2aWRlZCBsaWtlIHRoZSB0aGlzOiBNIEwgLSBRIEwgLSBRIEwgLSBRIEwgd2hlcmUgdGhlIGZpcnN0IE0gTCBjYW4gYmUgc2VlbiBhcyBpbmRleCAxLi4uXHJcbiAgICB2YXIgcGF0aEluZGV4ID0gdGhpcy5wYXRoLmdldFBhdGhJbmRleEZvclBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgIHZhciBldmVuUGF0aEluZGV4ID0gKHBhdGhJbmRleCAlIDIgPT0gMCkgPyBwYXRoSW5kZXggOiBwYXRoSW5kZXggLSAxO1xyXG4gICAgcmV0dXJuIChldmVuUGF0aEluZGV4IC8gMikgKyAxO1xyXG59O1xyXG5cclxuUm91bmRQYXRoTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlUGF0aFBhcnQgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgaWYodGhpcy5wYXRoICYmIGluZGV4ID4gMCkge1xyXG4gICAgICAgIHZhciBjb3JuZXIgPSB0aGlzLnBhdGgudmFsdWVzQnlUeXBlKCdRJylbaW5kZXggLSAxXTtcclxuICAgICAgICBpZihjb3JuZXIpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnZlRW5kID0gdGhpcy5wYXRoLnZhbHVlKGNvcm5lci5pbmRleCArIDEpLnRvKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aC52YWx1ZShjb3JuZXIuaW5kZXggLSAxKS50byhjdXJ2ZUVuZCk7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aC5yZW1vdmVQYXRoKGNvcm5lci5pbmRleCArIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnBhdGgucmVtb3ZlUGF0aChjb3JuZXIuaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblJvdW5kUGF0aE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkgey8qKiBub3RoaW5nICoqL307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kUGF0aE1hbmFnZXI7XHJcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxudmFyIFBhdGhEYXRhID0gcmVxdWlyZSgnLi4vc3ZnL1BhdGhEYXRhJyk7XHJcblxyXG52YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxuXHJcbnZhciBTZWxlY3Rpb25NYW5hZ2VyID0gZnVuY3Rpb24gKGRpYWdyYW0pIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IGRpYWdyYW07XHJcbiAgICB0aGlzLmV2ZW50ID0gZGlhZ3JhbS5ldmVudDtcclxuICAgIHRoaXMuc2VsZWN0ZWROb2RlcyA9IFtdO1xyXG4gICAgdGhpcy5zZWxlY3RlZFRyYW5zaXRpb247XHJcbiAgICB0aGlzLmhvdmVyRWxlbWVudDtcclxuXHJcbiAgICBldmVudC5saXN0ZW4oJ2tleV91cF9wcmVzcycsIHRoaXMudXBMaXN0ZW5lciwgdGhpcyk7XHJcbiAgICBldmVudC5saXN0ZW4oJ25vZGVfbW92ZXVwJywgdGhpcy5tb3ZlVXBMaXN0ZW5lciwgdGhpcyk7XHJcbiAgICBldmVudC5saXN0ZW4oJ25vZGVfbW92ZWRvd24nLCB0aGlzLm1vdmVEb3duTGlzdGVuZXIsIHRoaXMpO1xyXG4gICAgZXZlbnQubGlzdGVuKCdrZXlfZG93bl9wcmVzcycsIHRoaXMuZG93bkxpc3RlbmVyLCB0aGlzKTtcclxuICAgIGV2ZW50Lmxpc3Rlbigna2V5X2RlbF9wcmVzcycsIHRoaXMuZGVsZXRlTGlzdGVuZXIsIHRoaXMpO1xyXG4gICAgZXZlbnQubGlzdGVuKCd0YWJfYWN0aXZhdGVkJywgdGhpcy5jbGVhciwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5ldmVudC5saXN0ZW4oJ3RyYW5zaXRpb25fYWRkZWQnLCB0aGlzLnRyYW5zaXRpb25BZGRlZExpc3RlbmVyLCB0aGlzKTtcclxuICAgIHRoaXMuZXZlbnQubGlzdGVuKCdub2RlX2FkZGVkJywgdGhpcy5ub2RlQWRkZWRMaXN0ZW5lciwgdGhpcyk7XHJcbiAgICB0aGlzLmV2ZW50Lmxpc3Rlbigna25vYl9hZGRlZCcsIHRoaXMua25vYkFkZGVkTGlzdGVuZXIsIHRoaXMpO1xyXG5cclxuICAgIC8vVGhlc2UgYXJlIGN1cnJlbnRseSBnbG9iYWwgZXZlbnRzIG5vdCBkaWFncmFtIGNvbnRleHQgZXZlbnRzXHJcbiAgICBldmVudC5saXN0ZW4oJ2VsZW1lbnRfaG92ZXJJbicsIHRoaXMuaG92ZXJJbkVsZW1lbnRMaXN0ZW5lciwgdGhpcyk7XHJcbiAgICBldmVudC5saXN0ZW4oJ2VsZW1lbnRfaG92ZXJPdXQnLCB0aGlzLmhvdmVyT3V0RWxlbWVudExpc3RlbmVyLCB0aGlzKTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZE5vZGVzLnNsaWNlKCk7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTZWxlY3RlZE5vZGVJZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAkLmVhY2godGhpcy5zZWxlY3RlZE5vZGVzLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUuaWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUua25vYkFkZGVkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICB2YXIga25vYiA9IGV2dC5kYXRhO1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5hZGROb2RlRXZlbnRzKGtub2Iubm9kZSk7XHJcbiAgICBpZiAoa25vYi5ub2RlLnNlbGVjdGFibGUpIHtcclxuICAgICAgICBrbm9iLm5vZGUub24oJ3NlbGVjdCcsIGZ1bmN0aW9uIChzZWxlY3RFdnQsIHNoaWZ0ZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoYXQuZHJhZ1NlbGVjdGlvbiB8fCBldnQuc2hpZnRLZXkgfHwgc2hpZnRlZCAmJiAoa25vYi50cmFuc2l0aW9uICYmIGtub2IudHJhbnNpdGlvbi5zZWxlY3RlZCkpIHtcclxuICAgICAgICAgICAgICAgIGtub2IudHJhbnNpdGlvbi5kZXNlbGVjdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtub2IudHJhbnNpdGlvbiAmJiAha25vYi50cmFuc2l0aW9uLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBrbm9iLnRyYW5zaXRpb24uc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm5vZGVBZGRlZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgdGhpcy5hZGROb2RlRXZlbnRzKGV2dC5kYXRhKTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZE5vZGVFdmVudHMgPSBmdW5jdGlvbiAobm9kZSwgc2hpZnRlZCkge1xyXG4gICAgaWYgKG5vZGUuc2VsZWN0YWJsZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBub2RlLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoZXZ0LCBzaGlmdGVkKSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2V0Tm9kZVNlbGVjdGlvbihub2RlLCBzaGlmdGVkKTtcclxuICAgICAgICB9KS5vbignZGVzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoYXQucmVtb3ZlU2VsZWN0ZWROb2RlKG5vZGUpO1xyXG4gICAgICAgIH0pLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoYXQucmVtb3ZlU2VsZWN0ZWROb2RlKG5vZGUpO1xyXG4gICAgICAgIH0pLnNlbGVjdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS50cmFuc2l0aW9uQWRkZWRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHZhciB0cmFuc2l0aW9uID0gZXZ0LmRhdGE7XHJcbiAgICB0cmFuc2l0aW9uLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoZXZ0LCBzaGlmdGVkKSB7XHJcbiAgICAgICAgdGhhdC5zZXRUcmFuc2l0aW9uU2VsZWN0aW9uKHRyYW5zaXRpb24pO1xyXG4gICAgfSkub24oJ2Rlc2VsZWN0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoYXQucmVtb3ZlU2VsZWN0ZWRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG4gICAgfSkub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGF0LnJlbW92ZVNlbGVjdGVkVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcclxuICAgIH0pLnNlbGVjdChldnQuc2hpZnRLZXkpO1xyXG59O1xyXG5cclxuLy9UT0RPOiBDT01NQU5EUyArIE1vdmUgdG8gTm9kZU1hbmFnZXIhXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm1vdmVVcExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0ZWROb2Rlcy5zbGljZSgwKTtcclxuICAgIHNlbGVjdGlvbi5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIChhLmluZGV4KCkgPCBiLmluZGV4KCkpID8gMSA6IC0xO1xyXG4gICAgfSk7XHJcblxyXG4gICAgb2JqZWN0LmVhY2goc2VsZWN0aW9uLCBmdW5jdGlvbiAoaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICBpZiAob2JqZWN0LmlzRGVmaW5lZChub2RlKSkge1xyXG4gICAgICAgICAgICBub2RlLm1vdmVVcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBMaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIGlmIChldnQuY3RybEtleSkge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMubW92ZVVwTGlzdGVuZXIoKTtcclxuICAgIH1cclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRvd25MaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIGlmIChldnQuY3RybEtleSkge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMubW92ZURvd25MaXN0ZW5lcigpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubW92ZURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGVkTm9kZXMuc2xpY2UoMCk7XHJcbiAgICBzZWxlY3Rpb24uc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiAoYS5pbmRleCgpIDwgYi5pbmRleCgpKSA/IC0xIDogMTtcclxuICAgIH0pO1xyXG5cclxuICAgIG9iamVjdC5lYWNoKHNlbGVjdGlvbiwgZnVuY3Rpb24gKGluZGV4LCBub2RlKSB7XHJcbiAgICAgICAgaWYgKG9iamVjdC5pc0RlZmluZWQobm9kZSkpIHtcclxuICAgICAgICAgICAgbm9kZS5tb3ZlRG93bigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaG92ZXJJbkVsZW1lbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIHRoaXMuaG92ZXJFbGVtZW50ID0gZXZ0LmRhdGE7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ob3Zlck91dEVsZW1lbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIGRlYnVnZ2VyO1xyXG4gICAgZGVsZXRlIHRoaXMuaG92ZXJFbGVtZW50O1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlZFRyYW5zaXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIGlmIChvYmplY3QuaXNEZWZpbmVkKGV2dC5kYXRhKSkge1xyXG4gICAgICAgIGlmIChldnQuZGF0YSA9PT0gdGhpcy5zZWxlY3RlZFRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZWROb2RlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBpZiAob2JqZWN0LmlzRGVmaW5lZChldnQuZGF0YSkpIHtcclxuICAgICAgICAvL1JlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICBvYmplY3QucmVtb3ZlRnJvbUFycmF5KHRoaXMuc2VsZWN0ZWROb2RlcywgZXZ0LmRhdGEpO1xyXG5cclxuICAgICAgICAvL0NoZWNrIGlmIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBob3ZlckVsZW1lbnQgdG9vXHJcbiAgICAgICAgaWYgKGV2dC5kYXRhLnJvb3QgPT09IHRoaXMuaG92ZXJFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaG92ZXJPdXRFbGVtZW50TGlzdGVuZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIC8vUmVtb3ZlIHNlbGVjdGVkIHRyYW5zaXRpb25cclxuICAgIGlmIChvYmplY3QuaXNEZWZpbmVkKHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uKSAmJiAhdGhpcy5zZWxlY3RlZFRyYW5zaXRpb24uZ2V0U2VsZWN0ZWRLbm9icygpLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnQudHJpZ2dlcigndHJhbnNpdGlvbl9kZWxldGUnLCB0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgO1xyXG5cclxuICAgIHRoaXMuZGVsZXRlU2VsZWN0aW9uTm9kZXMoKTtcclxuICAgIHRoaXMuY2xlYXIoKTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGlvbk5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyckNsb25lID0gdGhpcy5zZWxlY3RlZE5vZGVzLnNsaWNlKDApO1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgb2JqZWN0LmVhY2goYXJyQ2xvbmUsIGZ1bmN0aW9uIChpbmRleCwgbm9kZSkge1xyXG4gICAgICAgIGlmIChvYmplY3QuaXNEZWZpbmVkKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZXZlbnQudHJpZ2dlcignbm9kZV9kZWxldGUnLCBub2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL0lmIHRoZXJlIGlzIGEgdW5kZWZpbmVkIHZhbHVlIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGVzLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnRyYW5zaXRpb25DcmVhdGVkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICB0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbiA9IGV2dC5kYXRhO1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaXNFbGVtZW50SG92ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gb2JqZWN0LmlzRGVmaW5lZCh0aGlzLmhvdmVyRWxlbWVudCk7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRUcmFuc2l0aW9uU2VsZWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcclxuICAgIC8vV2UgZG8gbm90IGNhbGwgdGhpcy5jbGVhciBiZWNhdXNlIHdlIHdvdWxkIGhpZGUgdGhlIGVkaXQgZmllbGRzIHRyb3VnaCB0aGUgdHJpZ2dlcmVkIGV2ZW50XHJcbiAgICB0aGlzLmNsZWFyTm9kZXMoZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gIXRyYW5zaXRpb24ub3duc0tub2JOb2RlKG5vZGUpXHJcbiAgICB9KTtcclxuICAgIGlmICh0cmFuc2l0aW9uICE9PSB0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbikge1xyXG4gICAgICAgIHRoaXMuY2xlYXJUcmFuc2l0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0Tm9kZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWxlY3RlZE5vZGUsIHNoaWZ0ZWQpIHtcclxuICAgIC8vc29tZSB0ZW1wbGF0ZXMgb3Igbm9kZXMgYXJlIHNob3VsZCBub3QgYWZmZWN0IHRoZSBzZWxlY3Rpb24gKGUuZy4gcmVzaXplIGtub2JzKVxyXG4gICAgaWYgKCFzZWxlY3RlZE5vZGUuc2VsZWN0YWJsZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIDtcclxuXHJcbiAgICBpZiAoIXRoaXMuY29udGFpbnNOb2RlKHNlbGVjdGVkTm9kZSkpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8vQ2xlYXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlmIG5vdCBzaGlmdGVkIG9yIGRyYWdTZWxlY3Rpb25cclxuICAgICAgICBpZiAoIXNoaWZ0ZWQgJiYgIXRoaXMuZHJhZ1NlbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyTm9kZXMoZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZE5vZGUuaWQgIT09IG5vZGUuaWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkVGVtcGxhdGUgPSBzZWxlY3RlZE5vZGUudGVtcGxhdGU7XHJcbiAgICAgICAgdGhpcy5hZGRTZWxlY3RlZE5vZGUoc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICB0aGlzLmNsZWFyVHJhbnNpdGlvbihzZWxlY3RlZE5vZGUsIG9iamVjdC5pc0RlZmluZWQodGhpcy5kcmFnU2VsZWN0aW9uKSk7XHJcblxyXG4gICAgICAgIC8vVHJpZ2dlciBkcmFnIGZvciBhbGwgc2VsZWN0ZWQgbm9kZXMgaWYgb25lIHNlbGVjdGlvbiBpcyBkcmFnZ2VkXHJcbiAgICAgICAgLy9XZSB1c2UgYWRkaXRvbiBzdHlsZSBpbnN0ZWFkIG9mIG9uIGV2ZW50IGZvciBhIHBlcmZvcm1hbmNlIGdhaW4gKG9uLmRyYWdNb3ZlIGlzIGRlYWN0aXZhdGVkIHNlZSBkcmFnZ2FibGUuanMpXHJcbiAgICAgICAgLy9XZSBkb24ndCBoYXZlIHRvIHJlbW92ZSB0aGlzIGFkZGl0aW9uIGFmdGVyIHJlc2VsZWN0IGJlY2F1c2Ugb25seSBzZWxlY3RlZCBub2RlcyBjYW4gYmUgZHJhZ2dlZCBhbnl3YXlzLlxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAoIXNlbGVjdGVkTm9kZS5hZGRpdGlvbnNbJ211bHRpU2VsZWN0aW9uRHJhZyddKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZS5hZGRpdGlvbnNbJ211bHRpU2VsZWN0aW9uRHJhZyddID0ge1xyXG4gICAgICAgICAgICAgICAgZHJhZ01vdmU6IGZ1bmN0aW9uIChkeCwgZHksIGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZ0LnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWFjaCh0aGF0LnNlbGVjdGVkTm9kZXMsIGZ1bmN0aW9uIChpbmRleCwgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5pZCAhPT0gbm9kZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHJpZ2dlckRyYWcoZHgsIGR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzaGlmdGVkICYmICF0aGlzLmRyYWdTZWxlY3Rpb24pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGVkTm9kZShzZWxlY3RlZE5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZHJhZ1NlbGVjdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGV2dCwgc3RhcnRQb3NpdGlvbikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgLy8gSU5JVCBkcmFnIHNlbGVjdGlvblxyXG4gICAgaWYgKCF0aGlzLmlzRWxlbWVudEhvdmVyKCkpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5kaWFncmFtLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFnZVBvc2l0aW9uID0gdGhhdC5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICAgICAgaWYgKCF0aGF0LmRyYWdTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdGlvbiA9IHRoYXQuZGlhZ3JhbS5zdmcucGF0aCh7c3R5bGU6ICdzdHJva2U6Z3JheTtzdHJva2Utd2lkdGg6MXB4O3N0cm9rZS1kYXNoYXJyYXk6NSw1O2ZpbGw6bm9uZTsnfSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmRyYWdTZWxlY3Rpb24uZCgpLnN0YXJ0KHN0YXJ0UG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmxpbmUoc3RhcnRQb3NpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAubGluZShzdGFnZVBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5saW5lKHN0YWdlUG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL01vdmUgc2VsZWN0aW9uIGF3YXkgZnJvbSBtb3VzZSBwb2ludGVyXHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ25lZE1vdXNlWCA9IHN0YWdlUG9zaXRpb24ueCAtIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ25lZE1vdXNlWSA9IHN0YWdlUG9zaXRpb24ueSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9VcGRhdGUgcGF0aGRhdGFcclxuICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdGlvbi5kKCkuY2xlYXIoKS5zdGFydChzdGFydFBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5saW5lKHt4OiBzdGFydFBvc2l0aW9uLngsIHk6IGFsaWduZWRNb3VzZVl9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5saW5lKHt4OiBhbGlnbmVkTW91c2VYLCB5OiBhbGlnbmVkTW91c2VZfSlcclxuICAgICAgICAgICAgICAgICAgICAubGluZSh7eDogYWxpZ25lZE1vdXNlWCwgeTogc3RhcnRQb3NpdGlvbi55fSlcclxuICAgICAgICAgICAgICAgICAgICAuY29tcGxldGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGZvciBob3ZlcmVkIGVsZW1lbnRzIHRvIHNlbGVjdFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0LmVhY2godGhhdC5kaWFncmFtLm5vZGVNZ3Iubm9kZXMsIGZ1bmN0aW9uIChpZCwgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdChub2RlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG9iamVjdC5lYWNoKHRoYXQuZGlhZ3JhbS5rbm9iTWdyLmtub2JzLCBmdW5jdGlvbiAoaWQsIGtub2IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmRyYWdTZWxlY3Qoa25vYi5ub2RlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RyaWdnZXIgYXR0cmlidXRlIHVwZGF0ZVxyXG4gICAgICAgICAgICB0aGF0LmRyYWdTZWxlY3Rpb24udXBkYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kcmFnU2VsZWN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIGlmICghbm9kZS5zZWxlY3RhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZHJhZ1NlbGVjdGlvbi5vdmVybGF5cyhub2RlLmdldENlbnRlcigpKSkge1xyXG4gICAgICAgIGlmICghbm9kZS5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICBub2RlLnNlbGVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobm9kZS5zZWxlY3RlZCkge1xyXG4gICAgICAgIG5vZGUuZGVzZWxlY3QoKTtcclxuICAgIH1cclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRyYWdTZWxlY3Rpb25FbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmRpYWdyYW0ub2ZmKCdtb3VzZW1vdmUnKTtcclxuICAgIGlmICh0aGlzLmRyYWdTZWxlY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb24ucmVtb3ZlKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZHJhZ1NlbGVjdGlvbjtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBqdXN0IGFkZHMgbmV3IG5vZGVzIHRvIHRoZSBzZWxlY3Rpb24gaWYgaXQgaGF2ZSBub3QgYmVlblxyXG4gKiBhZGRlZCB5ZXQgd2l0aG91dCBhbnkgYWRkaXRpb25hbCByZXN0cmljdGlvbnMuXHJcbiAqXHJcbiAqIEFsbCBzZWxlY3RlZCB0cmFuc2l0aW9ucyBhcmUgZGVzZWxlY3RlZCBzaW5jZSB0aGUgbWl4ZWQgc2VsZWN0aW9uXHJcbiAqIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dHlwZX0gc2VsZWN0ZWROb2RlXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRTZWxlY3RlZE5vZGUgPSBmdW5jdGlvbiAoc2VsZWN0ZWROb2RlKSB7XHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXMucHVzaChzZWxlY3RlZE5vZGUpO1xyXG59O1xyXG5cclxuU2VsZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlU2VsZWN0ZWRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcclxuICAgIGlmICh0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbiA9PT0gdHJhbnNpdGlvbikge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbjtcclxuICAgIH1cclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVNlbGVjdGVkTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlbGVjdGVkTm9kZXMuaW5kZXhPZihub2RlKTtcclxuICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb250YWluc05vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWROb2Rlcy5pbmRleE9mKG5vZGUpID4gLTE7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY2xlYXJOb2RlcygpO1xyXG4gICAgdGhpcy5jbGVhclRyYW5zaXRpb24oKTtcclxuICAgIHRoaXMuZXZlbnQudHJpZ2dlcignc2VsZWN0aW9uX2NsZWFyJyk7XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhck5vZGVzID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgZmlsdGVyID0gZmlsdGVyIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgIC8vV2UgY2xvbmUgdGhlIGFycmF5IHNpbmNlIHRoZSBvcmlnaW5hbCBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQgd2hpbGUgZGVzZWxlY3Rpb24uXHJcbiAgICB2YXIgc2VsZWN0ZWROb2Rlc0FyciA9IG9iamVjdC5jbG9uZUFycmF5KHRoaXMuc2VsZWN0ZWROb2Rlcyk7XHJcbiAgICBvYmplY3QuZWFjaChzZWxlY3RlZE5vZGVzQXJyLCBmdW5jdGlvbiAoaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZS5zZWxlY3RhYmxlICYmIGZpbHRlcihub2RlKSkge1xyXG4gICAgICAgICAgICBub2RlLmRlc2VsZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNlbGVjdGVkTm9kZXMgPSBbXTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBmb3JjZSkge1xyXG4gICAgaWYgKCF0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChmb3JjZSB8fCAhbm9kZSB8fCAhbm9kZS5rbm9iIHx8ICF0aGlzLnNlbGVjdGVkVHJhbnNpdGlvbk93bnNLbm9iTm9kZShub2RlKSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uLmRlc2VsZWN0KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZWxlY3RlZFRyYW5zaXRpb25Pd25zS25vYk5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uICYmIHRoaXMuc2VsZWN0ZWRUcmFuc2l0aW9uLm93bnNLbm9iTm9kZShub2RlKTtcclxufTtcclxuXHJcblNlbGVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmlzTXVsdGlTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgY291bnQgKz0gdGhpcy5zZWxlY3RlZE5vZGVzLmxlbmd0aDtcclxuICAgIHJldHVybiBjb3VudCA+IDE7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGlvbk1hbmFnZXI7XHJcbiIsIi8qKlxyXG4gKiBTaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgcGF0aCBtYW5hZ2VyXHJcbiAqIEB0eXBlIHtQYXRoRGF0YXxleHBvcnRzfG1vZHVsZS5leHBvcnRzfVxyXG4gKi9cclxudmFyIEFic3RyYWN0UGF0aE1hbmFnZXIgPSByZXF1aXJlKCcuL2Fic3RyYWN0UGF0aE1hbmFnZXInKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxuXHJcbnZhciBMaW5lUGF0aE1hbmFnZXIgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICBBYnN0cmFjdFBhdGhNYW5hZ2VyLmNhbGwodGhpcywgdHJhbnNpdGlvbik7XHJcbiAgICB0aGlzLnR5cGUgPSBMaW5lUGF0aE1hbmFnZXIudHlwZTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoTGluZVBhdGhNYW5hZ2VyLCBBYnN0cmFjdFBhdGhNYW5hZ2VyKTtcclxuXHJcbkxpbmVQYXRoTWFuYWdlci50eXBlID0gJ3N0cmFpZ2h0JztcclxuXHJcbkxpbmVQYXRoTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHRoaXMucGF0aC5saW5lKHBvc2l0aW9uKTtcclxufTtcclxuXHJcbkxpbmVQYXRoTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaW5kZXgsIHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLnBhdGguaW5zZXJ0TGluZShpbmRleCwgcG9zaXRpb24pO1xyXG59O1xyXG5cclxuTGluZVBhdGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihwb3NpdGlvbikgey8qIE5vdGhpbmcgdG8gZG8gaGVyZSAqL307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVQYXRoTWFuYWdlcjtcclxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIHhtbCA9IHJlcXVpcmUoJy4uL3V0aWwveG1sJyk7XHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XHJcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb3JlL2NvbmZpZycpO1xyXG5cclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcblxyXG52YXIgVGVtcGxhdGUgPSBmdW5jdGlvbihpZCwgY2ZnKSB7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNmZyB8fCB7fTtcclxuICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAvL1RlbXBsYXRlcyBjYW4gZGVmaW5lIHRoZSBzdmdTdHJpbmcgd2l0aGluIHRoZSBjb25maWcsIHNvIHRoZSBzdmcgZG9lc24ndCBoYXZlIHRvIGJlIGxvYWRlZCBpbiBhZGRpdGlvblxyXG4gICAgaWYodGhpcy5jb25maWcuc3ZnKSB7XHJcbiAgICAgICAgdGhpcy5pbml0KHRoaXMuY29uZmlnLnN2Zyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBpbXBsZW1lbnQgYSBtb3JlIGdlbmVyaWMgd2F5Li4uXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHRoaXMuY29uZmlnLnJlc2l6ZSkpIHtcclxuICAgICAgICB0aGlzLmluaXRSZXNpemVDb25maWcoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRlbXBsYXRlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24odG1wbFN0cikge1xyXG4gICAgdGhpcy5zdmcgPSB0bXBsU3RyO1xyXG59O1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlLmlzSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAhIXRoaXMuc3ZnO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVzaXplIGFkZGl0aW9uIGFsbG93cyB0byBjb25maWd1cmUgYSByZXNpemUgYmVoYXZpb3VyIGZvciBzdmcgZWxlbWVudHNcclxuICogYnkgbWVhbnMgb2YgZGVmaW5pbmcgdGhlIGxvZ2ljIGZvciBjaGFuZ2VzIG9mIHggKHdpZHRoKSBhbmQgeSAoaGVpZ2h0KVxyXG4gKiBpbiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqIGUuZy46XHJcbiAqXHJcbiAqIHBhcmVudCg1KSBkZWZhdWx0XHJcbiAqXHJcbiAqIHdoZXJlIHRoZSB4IHZhbHVlIGlzXHJcbiAqIEBwYXJhbSB7dHlwZX0gcmVzaXplQ29uZmlnXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5UZW1wbGF0ZS5wcm90b3R5cGUuaW5pdFJlc2l6ZUNvbmZpZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5jb25maWcucmVzaXplLCBmdW5jdGlvbihpbmRleCwgcmVzaXplSXRlbSkge1xyXG4gICAgICAgIC8vIEhlcmUgd2UganVzdCBwYXJzZSB0aGUgcmF3IHN0cmluZyB0byBhbiBhcnJheSBvZiBmZWF0dXJlIHNldHRpbmdzXHJcbiAgICAgICAgdGhhdC5zZXR1cFNldHRpbmdzKGluZGV4LCByZXNpemVJdGVtLCAndmFsdWUnKTtcclxuICAgICAgICB0aGF0LnNldHVwU2V0dGluZ3MoaW5kZXgsIHJlc2l6ZUl0ZW0sICdwb3NpdGlvbicpO1xyXG4gICAgICAgIHRoYXQuc2V0dXBTZXR0aW5ncyhpbmRleCwgcmVzaXplSXRlbSwgJ21heCcpO1xyXG4gICAgICAgIHRoYXQuc2V0dXBTZXR0aW5ncyhpbmRleCwgcmVzaXplSXRlbSwgJ21pbicpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UZW1wbGF0ZS5wcm90b3R5cGUuc2V0dXBTZXR0aW5ncyA9IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBzZXR0aW5nKSB7XHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKGl0ZW1bc2V0dGluZ10pKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHV0aWwuYXBwLnBhcnNlRmVhdHVyZVN0cmluZ3MoaXRlbVtzZXR0aW5nXSwgMCk7XHJcblxyXG4gICAgICAgIC8vSWYgdGhlciBpcyBqdXN0IG9uZSB2YWx1ZSBnaXZlbiB3ZSB1c2UgaXQgZm9yIGJvdGggeCBhbmQgeVxyXG4gICAgICAgIGlmKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgdmFsdWVzWzFdID0gdmFsdWVzWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcucmVzaXplW2luZGV4XVtzZXR0aW5nXSA9IHZhbHVlcztcclxuICAgIH1cclxufTtcclxuXHJcblRlbXBsYXRlLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24oY29uZmlnLCBkaWFncmFtKSB7XHJcbiAgICB2YXIgcmVzdWx0Q29uZmlnID0gdGhpcy5nZXRDb25maWcoY29uZmlnKTtcclxuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCByZXN1bHRDb25maWcsIGRpYWdyYW0pO1xyXG59O1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlLmdldFNWR1N0cmluZyA9IGZ1bmN0aW9uKGNmZykge1xyXG4gICAgcmV0dXJuIGNvbmZpZy5yZXBsYWNlQ29uZmlnVmFsdWVzKHRoaXMuc3ZnLCBjZmcpO1xyXG59O1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKGNmZykge1xyXG4gICAgcmV0dXJuIG9iamVjdC5leHRlbmQoe30sIHRoaXMuY29uZmlnLCBjZmcpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZW1wbGF0ZTsiLCJ2YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcbnZhciBjbGllbnQgPSByZXF1aXJlKCcuLi9jb3JlL2NsaWVudCcpO1xyXG5cclxudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xyXG5cclxudmFyIFBBVEhfUEFORUxTID0gJy90ZW1wbGF0ZS9wYW5lbCc7XHJcbnZhciBQQVRIX1RFTVBMQVRFUyA9ICcvdGVtcGxhdGVzJztcclxuXHJcbnZhciBFVkVOVF9QQU5FTF9MT0FERUQgPSAndGVtcGxhdGVfcGFuZWxfbG9hZGVkJztcclxuXHJcbnZhciBwYW5lbHMgPSB7fTtcclxudmFyIHRlbXBsYXRlcyA9IHt9O1xyXG52YXIgc2VsZWN0ZWRUZW1wbGF0ZTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBsaXN0ZW5lcnMgYW5kIGxvYWRzIHRoZSBpbml0aWFsIHRlbXBsYXRlIHBhbmVscyBzZXQgaW4gZGFsYV9lbnYuaW5pdGlhbF90ZW1wbGF0ZXMgYXJyYXkuXHJcbiAqL1xyXG52YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZXZlbnQubGlzdGVuKCdub2RlX3NlbGVjdGVkJywgbm9kZVNlbGVjdGlvbkxpc3RlbmVyKTtcclxuICAgIGV2ZW50Lmxpc3RlbigndGVtcGxhdGVfc2VsZWN0JywgdGVtcGxhdGVTZWxlY3RMaXN0ZW5lcik7XHJcblxyXG4gICAgaWYoZGFsYV9lbnYuaW5pdGlhbF90ZW1wbGF0ZXMgJiYgZGFsYV9lbnYuaW5pdGlhbF90ZW1wbGF0ZXMucGFuZWxzKSB7XHJcbiAgICAgICAgJC5lYWNoKGRhbGFfZW52LmluaXRpYWxfdGVtcGxhdGVzLnBhbmVscywgZnVuY3Rpb24oaW5kZXgsIHBhbmVsSWQpIHtcclxuICAgICAgICAgICAgX2xvYWRQYW5lbChwYW5lbElkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBub2RlU2VsZWN0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIF9zZXRTZWxlY3RlZFRlbXBsYXRlKGV2dC5kYXRhLnRlbXBsYXRlKTtcclxufTtcclxuXHJcbnZhciB0ZW1wbGF0ZVNlbGVjdExpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICBpZihldnQuZGF0YSkge1xyXG4gICAgICAgIF9zZXRTZWxlY3RlZFRlbXBsYXRlKGV2dC5kYXRhKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBfc2V0U2VsZWN0ZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uKHRtcGxJZCkge1xyXG4gICAgaWYoIW9iamVjdC5pc0RlZmluZWQodG1wbElkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluc3RhbmNlO1xyXG5cclxuICAgIGlmKCFvYmplY3QuaXNTdHJpbmcodG1wbElkKSkge1xyXG4gICAgICAgIGlmKCF0bXBsSWQuY29uZmlnLnByZXZlbnRTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRUZW1wbGF0ZSA9IHRtcGxJZDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdldFRlbXBsYXRlKHRtcGxJZClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb25maWcucHJldmVudFNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsdCBub3QgZGV0ZXJtaW5lIHRlbXBsYXRlOiAnK3RtcGxJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciB3aGlsZSBkZXRlcm1pbmluZyB0ZW1wbGF0ZTogJyt0bXBsSWQrJyAtICcrZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHRlbXBsYXRlaW5zdGFuY2UsIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgaWYgbm90IGxvYWRlZCB5ZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB0bXBsSWRcclxuICogQHBhcmFtIHRtcGxSb290RWxcclxuICogQHJldHVybnMge2JsdWViaXJkfGV4cG9ydHN8bW9kdWxlLmV4cG9ydHN9XHJcbiAqL1xyXG52YXIgZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbih0bXBsSWQpIHtcclxuICAgIHZhciBwYW5lbElkID0gdG1wbElkLnN1YnN0cmluZygwLCB0bXBsSWQuaW5kZXhPZignXycpKTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBpZih0ZW1wbGF0ZXNbdG1wbElkXSkgeyAvL1RlbXBsYXRlIGlzIGxvYWRlZFxyXG4gICAgICAgICAgICB2YXIgdG1wbCA9IHRlbXBsYXRlc1t0bXBsSWRdO1xyXG4gICAgICAgICAgICBpZighdG1wbC5pc0luaXRpYWxpemVkKCkpIHsgLy9UZW1wbGF0ZSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0IHNvIGxvYWQgc3ZnXHJcbiAgICAgICAgICAgICAgICBfbG9hZFJlbW90ZVRlbXBsYXRlU1ZHKHRtcGxJZCwgcGFuZWxJZCkuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0bXBsKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRlbXBsYXRlc1t0bXBsSWRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7IC8vVGVtcGxhdGUgbm90IGxvYWRlZCB5ZXRcclxuICAgICAgICAgICAgaWYocGFuZWxJZCkgeyAvL0xvYWQgYW5kIGluaXRpYWxpemUgdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgIC8vVE9ETzogaGVyZSB3ZSBoYXZlIHRvIGNvbnNpZGVyIG90aGVyIGxvYWRpbmcgbWVjaGFuaXNtIGFzIGRvbSBsb2FkaW5nIC8gYnJvd3NlciBjYWNoZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgX2xvYWRSZW1vdGVUZW1wbGF0ZShwYW5lbElkLCB0bXBsSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odG1wbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRtcGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoX2NyZWF0ZVRlbXBsYXRlKHRtcGxJZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBzaW1wbHkgcmV0dXJucyBhIHRlbXBsYXRlIGlmIGl0cyBhbHJlYWR5IGxvYWRlZC4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZW1wbGF0ZXMgd2hpY2ggYXJlIHJlZ2lzdGVyZWRcclxuICogb24gc3RhcnR1cCBhbmQgYWxyZWFkeSBsb2FkZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB0bXBsSWRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG52YXIgZ2V0VGVtcGxhdGVTeW5jID0gZnVuY3Rpb24odG1wbElkKSB7XHJcbiAgICByZXR1cm4gdGVtcGxhdGVzW3RtcGxJZF07XHJcbn07XHJcblxyXG4vKipcclxuICogTG9hZHMgYSBwYW5lbCBkZWZpbml0aW9uIGZyb20gdGhlIHNlcnZlci4gV2hlbiBsb2FkZWQgdGhlIHBhbmVsIHdpbGwgcmVnaXN0ZXIgaXRzZWxmIHRvIHRoZSB0ZW1wbGF0ZU1hbmFnZXIuXHJcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZS5cclxuICpcclxuICogQHBhcmFtIHBhbmVsSWRcclxuICogQHJldHVybnMge2JsdWViaXJkfGV4cG9ydHN8bW9kdWxlLmV4cG9ydHN9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG52YXIgX2xvYWRQYW5lbCA9IGZ1bmN0aW9uKHBhbmVsSWQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBjbGllbnQuZ2V0U2NyaXB0KFBBVEhfVEVNUExBVEVTKycvJytwYW5lbElkKycvJytwYW5lbElkKycuanMnLCB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgOiB7XHJcbiAgICAgICAgICAgICAgICA0MDQ6ICdDb3VsZCBub3QgbG9hZCBwYW5lbCAnK3BhbmVsSWQrJyBmaWxlIHdhcyBub3QgZm91bmQgb24gdGhlIHNlcnZlciAhJyxcclxuICAgICAgICAgICAgICAgICdkZWZhdWx0JzogJ0NvdWxkIG5vdCBsb2FkIHBhbmVsICcrcGFuZWxJZCsnIHNvbWV0aGluZyB3ZW50IHdyb25nICEnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWRzIGEgcmVtb3RlIHRhbXBsYXRlIGZyb20gdGhlIHNlcnZlci4gV2hlbiBsb2FkZWQgdGhlIHRlbXBsYXRlIHdpbGwgcmVnaXN0ZXIgaXRzZWxmIHRvIHRoZSB0ZW1wbGF0ZU1hbmFnZXJcclxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZSB3aXRob3V0IHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHBhbmVsSWRcclxuICogQHBhcmFtIHRtcGxJZFxyXG4gKiBAcmV0dXJucyB7Ymx1ZWJpcmR8ZXhwb3J0c3xtb2R1bGUuZXhwb3J0c31cclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBfbG9hZFJlbW90ZVRlbXBsYXRlID0gZnVuY3Rpb24ocGFuZWxJZCwgdG1wbElkKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGNsaWVudC5nZXRTY3JpcHQoUEFUSF9URU1QTEFURVMrJy8nK3BhbmVsSWQrJy8nK3RtcGxJZCsnLmpzJywge1xyXG4gICAgICAgICAgICBzdWNjZXNzIDogZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vTm93IHRoYXQgd2UgaGF2ZSBsb2FkZWQgYW5kIGluaXRpYWxpemVkIHRoZSB0ZW1wbGF0ZSBzY3JpcHQgd2UgY2FuIGdldCB0aGUgdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgIGdldFRlbXBsYXRlKHRtcGxJZCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3JNc2cpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvck1zZyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA6IHtcclxuICAgICAgICAgICAgICAgIDQwNDogJ0NvdWxkIG5vdCBsb2FkIHRlbXBsYXRlIFwiJyt0bXBsSWQrJ1wiIGZpbGUgd2FzIG5vdCBmb3VuZCBvbiB0aGUgc2VydmVyICEnLFxyXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiAnQ291bGQgbm90IGxvYWQgdGVtcGxhdGUgXCInK3RtcGxJZCsnXCIgc29tZXRoaW5nIHdlbnQgd3JvbmcgISdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGEgdGVtcGxhdGUgYnkgY3JlYXRpbmcgYSBuZXcgVGVtcGxhdGUgaW5zdGFuY2Ugb3V0IG9mIHRoZSBnaXZlbiBhcmd1bWVudHMuXHJcbiAqIEBwYXJhbSB0ZW1wbGF0ZUlkXHJcbiAqIEBwYXJhbSBwYW5lbElkXHJcbiAqIEBwYXJhbSBjb25maWdcclxuICovXHJcbnZhciByZWdpc3RlclRlbXBsYXRlID0gZnVuY3Rpb24odGVtcGxhdGVJZCwgY29uZmlnKSB7XHJcbiAgICBfYWRkVGVtcGxhdGUobmV3IFRlbXBsYXRlKHRlbXBsYXRlSWQsIGNvbmZpZykpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWRzIHRoZSB0ZW1wbGF0ZSBzdmcgYXMgeG1sIGRvY3VtZW50IGZvciB0aGUgZ2l2ZW4gdG1wbElkLlxyXG4gKiBAcGFyYW0gdG1wbElkXHJcbiAqIEBwYXJhbSBwYW5lbElkXHJcbiAqIEByZXR1cm5zIHtibHVlYmlyZHxleHBvcnRzfG1vZHVsZS5leHBvcnRzfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIF9sb2FkUmVtb3RlVGVtcGxhdGVTVkcgPSBmdW5jdGlvbih0bXBsSWQsIHBhbmVsSWQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBjbGllbnQudGV4dCgnL3RlbXBsYXRlcy8nK3BhbmVsSWQrJy8nK3RtcGxJZCsnLnRtcGwnLCB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgX2luaXRUZW1wbGF0ZSh0bXBsSWQsIHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgOiAge1xyXG4gICAgICAgICAgICAgICAgNDA0OiAnQ291bGQgbm90IGxvYWQgdGVtcGxhdGUgXCInK3RtcGxJZCsnXCIgZmlsZSB3YXMgbm90IGZvdW5kIG9uIHRoZSBzZXJ2ZXIgIScsXHJcbiAgICAgICAgICAgICAgICAnZGVmYXVsdCc6ICdDb3VsZCBub3QgbG9hZCB0ZW1wbGF0ZSBcIicrdG1wbElkKydcIiBzb21ldGhpbmcgd2VudCB3cm9uZyAhJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbn07XHJcblxyXG52YXIgX2luaXRUZW1wbGF0ZSA9IGZ1bmN0aW9uKHRtcGxJZCwgdG1wbFN0cikge1xyXG4gICAgdGVtcGxhdGVzW3RtcGxJZF0uaW5pdCh0bXBsU3RyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBuZXcgcGFuZWwuXHJcbiAqIEBwYXJhbSBjZmdcclxuICovXHJcbnZhciByZWdpc3RlclBhbmVsID0gZnVuY3Rpb24oY2ZnKSB7XHJcbiAgaWYoY2ZnLmlkKSB7XHJcbiAgICAgIHBhbmVsc1tjZmcuaWRdID0gY2ZnO1xyXG4gICAgICBldmVudC50cmlnZ2VyKEVWRU5UX1BBTkVMX0xPQURFRCwgY2ZnKTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgX2NyZWF0ZVRlbXBsYXRlID0gZnVuY3Rpb24odG1wbElkLCB0bXBsUm9vdEVsKSB7XHJcbiAgICByZXR1cm4gX2FkZFRlbXBsYXRlKG5ldyBUZW1wbGF0ZSh0bXBsSWQsIHRydWUsIHRtcGxSb290RWwpKTtcclxufTtcclxuXHJcbnZhciBfYWRkVGVtcGxhdGUgPSBmdW5jdGlvbih0bXBsKSB7XHJcbiAgICB0ZW1wbGF0ZXNbdG1wbC5pZF0gPSB0bXBsO1xyXG4gICAgcmV0dXJuIHRtcGw7XHJcbn07XHJcblxyXG52YXIgZ2V0U2VsZWN0ZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHNlbGVjdGVkVGVtcGxhdGU7XHJcbn07XHJcblxyXG52YXIgZ2V0UGFuZWwgPSBmdW5jdGlvbihwYW5lbElkKSB7XHJcbiAgICByZXR1cm4gcGFuZWxzW3BhbmVsSWRdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICByZWdpc3RlclBhbmVsIDogcmVnaXN0ZXJQYW5lbCxcclxuICAgIHJlZ2lzdGVyVGVtcGxhdGUgOiByZWdpc3RlclRlbXBsYXRlLFxyXG4gICAgZ2V0UGFuZWw6IGdldFBhbmVsLFxyXG4gICAgZ2V0VGVtcGxhdGU6IGdldFRlbXBsYXRlLFxyXG4gICAgZ2V0VGVtcGxhdGVTeW5jIDogZ2V0VGVtcGxhdGVTeW5jLFxyXG4gICAgZ2V0U2VsZWN0ZWRUZW1wbGF0ZTogZ2V0U2VsZWN0ZWRUZW1wbGF0ZSxcclxuICAgIGluaXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpbml0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvcmUvY29uZmlnJyk7XHJcblxyXG52YXIgRXZlbnRhYmxlID0gcmVxdWlyZSgnLi8uLi9kb20vZXZlbnRhYmxlTm9kZScpO1xyXG5cclxudmFyIFRyYW5zaXRpb25Lbm9iTWFuYWdlciA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbktub2JNYW5hZ2VyJyk7XHJcbnZhciBUcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIgPSByZXF1aXJlKCcuL3RyYW5zaXRpb25Eb2NraW5nTWFuYWdlcicpO1xyXG52YXIgdHJhbnNpdGlvbkFkZGl0aW9ucyA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbkFkZGl0aW9ucycpO1xyXG5cclxudmFyIHBhdGhNYW5hZ2VyRmFjdG9yeSA9IHJlcXVpcmUoJy4vcGF0aE1hbmFnZXJGYWN0b3J5Jyk7XHJcblxyXG52YXIgQ09MT1JfQUNUSVZFID0gXCJibHVlXCI7XHJcbnZhciBDT0xPUl9JTkFDVElWRSA9IFwiYmxhY2tcIjtcclxudmFyIERFRkFVTFRfRU5ETUFSS0VSID0gJ3RyaWFuZ2xlZmlsbCc7XHJcbnZhciBTVFlMRV9BUkVBID0gXCJzdHJva2U6Z3JleTtzdHJva2Utb3BhY2l0eTowLjA7c3Ryb2tlLXdpZHRoOjExO2ZpbGw6bm9uZTtcIjtcclxuXHJcbnZhciBERUZBVUxUX1dJRFRIID0gJzEnO1xyXG5cclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcblxyXG52YXIgVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0UG9zaXRpb24sIGNmZykge1xyXG4gICAgdGhpcy5jZmcgPSBjZmcgfHwge307XHJcbiAgICBpZihub2RlLmlzTm9kZSkge1xyXG4gICAgICAgIHRoaXMuZGlhZ3JhbSA9IG5vZGUuZGlhZ3JhbTtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gdGhpcy5kaWFncmFtLmV2ZW50O1xyXG4gICAgICAgIHRoaXMuc3ZnID0gdGhpcy5kaWFncmFtLnN2ZztcclxuICAgICAgICB0aGlzLmluaXQobm9kZSwgc3RhcnRQb3NpdGlvbik7XHJcbiAgICB9IGVsc2UgeyAvL25vZGUgPSBkaWFncmFtLCBzdGFydFBvc2l0aW9uID0gZG9tR3JvdXAgb2YgdHJhbnNpdGlvblxyXG4gICAgICAgIHRoaXMuZGlhZ3JhbSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHRoaXMuZGlhZ3JhbS5ldmVudDtcclxuICAgICAgICB0aGlzLnN2ZyA9IHRoaXMuZGlhZ3JhbS5zdmc7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZShzdGFydFBvc2l0aW9uKTtcclxuICAgIH1cclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoVHJhbnNpdGlvbiwgRXZlbnRhYmxlKTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnBhdGhNYW5hZ2VyLnBhdGg7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKHZhbHVlICYmIHZhbHVlICE9PSB0aGlzLnBhdGhNYW5hZ2VyLnR5cGUpIHtcclxuICAgICAgICB2YXIgbmV3UGF0aE1hbmFnZXIgPSBwYXRoTWFuYWdlckZhY3RvcnkuZ2V0KHRoaXMsIHZhbHVlKTtcclxuICAgICAgICBpZihuZXdQYXRoTWFuYWdlcikge1xyXG4gICAgICAgICAgICBuZXdQYXRoTWFuYWdlci5yZXBsYWNlKHRoaXMucGF0aE1hbmFnZXIsIHRoaXMua25vYk1hbmFnZXIuZ2V0S25vYlBvc2l0aW9ucygpKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGhNYW5hZ2VyLnR5cGU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGRvbUdyb3VwKSB7XHJcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmdyb3VwID0gJC5zdmcoZG9tR3JvdXApO1xyXG4gICAgdGhpcy5pZCA9IHRoaXMuZ3JvdXAuYXR0cignaWQnKTtcclxuXHJcbiAgICB0cmFuc2l0aW9uQWRkaXRpb25zLmluaXQodGhpcyk7XHJcblxyXG4gICAgLy9HZXQgbGluZSBhbmQgbGluZWFyZWEgZnJvbSBkb21cclxuICAgIHRoaXMuZ2V0TGluZSgpO1xyXG4gICAgdGhpcy5jb2xvckluYWN0aXZlID0gdGhpcy5saW5lLnN0cm9rZSgpO1xyXG5cclxuICAgIHRoaXMuZ2V0TGluZUFyZWEoKTtcclxuICAgIHRoaXMubGluZUFyZWEuZCh0aGlzLmxpbmUuZCgpKTtcclxuXHJcbiAgICAvL0luaXQgTWFuYWdlclxyXG4gICAgdGhpcy5kb2NraW5nTWFuYWdlciA9IG5ldyBUcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIodGhpcykuYWN0aXZhdGUoKTtcclxuICAgIHRoaXMucGF0aE1hbmFnZXIgPSBwYXRoTWFuYWdlckZhY3RvcnkuZ2V0KHRoaXMsIHRoaXMuZ3JvdXAuZGFsYSgndHJhbnNpdGlvblR5cGUnKSkuYWN0aXZhdGUoKTtcclxuICAgIHRoaXMua25vYk1hbmFnZXIgPSBuZXcgVHJhbnNpdGlvbktub2JNYW5hZ2VyKHRoaXMpLmFjdGl2YXRlKCk7XHJcbiAgICB0aGlzLmluaXRFdmVudHMoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAuY2hpbGRyZW4oc2VsZWN0b3IpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRQYXRoKCkuZ2V0RGlzdGFuY2UoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmZpcnN0Q2hpbGQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAuZmlyc3RDaGlsZChzZWxlY3Rvcik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRMaW5lID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZighdGhpcy5saW5lICYmIHRoaXMuZ3JvdXApIHtcclxuICAgICAgICB0aGlzLl9zZXRMaW5lKHRoaXMuZ2V0SW5uZXJTVkcoJ2xpbmUnKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5saW5lO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0TGluZUFyZWEgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKCF0aGlzLmxpbmVBcmVhICYmIHRoaXMuZ3JvdXApIHtcclxuICAgICAgICAgdGhpcy5fc2V0TGluZUFyZWEodGhpcy5nZXRJbm5lclNWRygnbGluZUFyZWEnKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5saW5lQXJlYTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLl9zZXRMaW5lQXJlYSA9IGZ1bmN0aW9uKHN2Z0xpbmVBcmVhKSB7XHJcbiAgICB0aGlzLmxpbmVBcmVhID0gdGhpcy5ldmVudEJhc2UgPSBzdmdMaW5lQXJlYTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLl9zZXRMaW5lID0gZnVuY3Rpb24oc3ZnTGluZSkge1xyXG4gICAgdGhpcy5saW5lID0gc3ZnTGluZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhIG5ldyB0cmFuc2l0aW9uIGJ5IGNyZWF0aW5nIHRoZSBzdmcgbm9kZXMgYW5kIHN0YXJ0ZG9ja2luZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3R5cGV9IG1vdXNlXHJcbiAqL1xyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obm9kZSwgbW91c2UpIHtcclxuICAgIHRoaXMuaWQgPSB0aGlzLmRpYWdyYW0udW5pcXVlSWQoKTtcclxuICAgIC8vSW5pdGlhbGl6ZXMgdGhlIHRyYW5zaXRpb24gZ3JvdXAgY29udGFpbmVyXHJcbiAgICB0aGlzLmluaXRTVkdHcm91cCgpO1xyXG5cclxuICAgIHRyYW5zaXRpb25BZGRpdGlvbnMuaW5pdCh0aGlzKTtcclxuXHJcbiAgICAvL0luaXRpYWxpemUgdGhlIHRyYW5zaXRpb24gZG9ja2luZyBtZWNoYW5pc20gKHN0YXJ0L2VuZCkgZG9ja2luZyB0byBub2Rlcy5cclxuICAgIHRoaXMuZG9ja2luZ01hbmFnZXIgPSBuZXcgVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyKHRoaXMsIG5vZGUsIG1vdXNlKTtcclxuICAgIC8vSW5pdGlhbGl6ZSB0aGUgcGF0aCBjcmVhdG9yIHdoaWNoIGNyZWF0ZXMgdGhlIHBhdGggd2l0aCB0aGUgaGVscCBvZiB0aGUga25vYnMgYW5kIGEgZ2l2ZW4gdHJhbnNpdGlvbnR5cGUuXHJcbiAgICB0aGlzLnBhdGhNYW5hZ2VyID0gcGF0aE1hbmFnZXJGYWN0b3J5LmdldCh0aGlzLCB0aGlzLmNmZ1sndHlwZSddKTtcclxuICAgIHRoaXMuZ3JvdXAuZGFsYSgndHJhbnNpdGlvblR5cGUnLCB0aGlzLnBhdGhNYW5hZ2VyLnR5cGUpO1xyXG5cclxuICAgIC8vSW5pdGlhbGl6ZSB0aGUgdHJhbnNpdGlvbiBrbm9iIG1lY2hhbmlzbSBmb3IgKHN0YXJ0L2VuZCkgYW5kIGlubmVyIGtub2JzIGZvciBtYW5pcHVsYXRpbmcgdHJhbnNpdGlvbnNcclxuICAgIHRoaXMua25vYk1hbmFnZXIgPSBuZXcgVHJhbnNpdGlvbktub2JNYW5hZ2VyKHRoaXMpO1xyXG5cclxuICAgIC8vQ2FsY3VsYXRlIHN0YXJ0IHBvc2l0aW9uIGZvciBvdXRlciBvcmllbnRhdGlvbiAobW91c2UgcG9zaXRpb24pXHJcbiAgICB2YXIgc3RhcnREb2NraW5nUG9zaXRpb24gPSB0aGlzLmRvY2tpbmdNYW5hZ2VyLmNhbGN1bGF0ZVN0YXJ0KG1vdXNlKTtcclxuXHJcbiAgICAvL0luaXQga25vYiBmb3Igc3RhcnRQb3NpdGlvblxyXG4gICAgdGhpcy5leGVjKCdzZXRTdGFydE5vZGUnLCBbbm9kZV0pO1xyXG5cclxuICAgIC8vQ3JlYXRlIFNWRyBFbGVtZW50cyBpbiBkb20gYW5kIHRyYW5zaXRpb24gZXZlbnRzXHJcbiAgICB0aGlzLmluaXRUcmFuc2l0aW9uU1ZHKCk7XHJcbiAgICB0aGlzLmluaXRFdmVudHMoKTtcclxuICAgIHRoaXMudXBkYXRlKG1vdXNlKTtcclxuICAgIHRoaXMuZ3JvdXAucG9pbnRlckV2ZW50cygnbm9uZScpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuaW5pdFNWR0dyb3VwID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmdyb3VwID0gdGhpcy5zdmcuZyh7XCJjbGFzc1wiOid0cmFuc2l0aW9uJywgJ3htbG5zOmRhbGEnOlwiaHR0cDovL3d3dy5kYWxhLmNvbVwiLCBpZCA6IHRoaXMuaWR9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmdldFN0YXJ0QWxpZ25tZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge3NvdXJjZTpbdGhpcy5kb2NraW5nTWFuYWdlci5zdGFydERvY2tpbmcucG9zaXRpb24oKV19O1xyXG4gICAgaWYoIXRoaXMua25vYk1hbmFnZXIuaGFzSW5uZXJLbm9icygpKSB7XHJcbiAgICAgICAgcmVzdWx0LnRhcmdldCA9IFt0aGlzLmRvY2tpbmdNYW5hZ2VyLmVuZERvY2tpbmcucG9zaXRpb24oKV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBbdGhpcy5rbm9iTWFuYWdlci5nZXRLbm9iKDEpLnBvc2l0aW9uKCldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmdldEVuZEFsaWdubWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHtzb3VyY2U6W3RoaXMuZG9ja2luZ01hbmFnZXIuZW5kRG9ja2luZy5wb3NpdGlvbigpXX07XHJcbiAgICBpZighdGhpcy5rbm9iTWFuYWdlci5oYXNJbm5lcktub2JzKCkpIHtcclxuICAgICAgICByZXN1bHQudGFyZ2V0ID0gW3RoaXMuZG9ja2luZ01hbmFnZXIuc3RhcnREb2NraW5nLnBvc2l0aW9uKCldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQudGFyZ2V0ID0gW3RoaXMua25vYk1hbmFnZXIuZ2V0S25vYigtMikucG9zaXRpb24oKV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0U3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2NraW5nTWFuYWdlci5zdGFydE5vZGU7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRFbmROb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kb2NraW5nTWFuYWdlci5lbmROb2RlO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmtub2JNYW5hZ2VyLnN0YXJ0KCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmtub2JNYW5hZ2VyLmVuZCgpO1xyXG59O1xyXG5cclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmdldFN0YXJ0TG9jYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmRvY2tpbmdNYW5hZ2VyLnN0YXJ0Tm9kZS5nZXRSZWxhdGl2ZUxvY2F0aW9uKHRoaXMuc3RhcnQoKSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRFbmRMb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9ja2luZ01hbmFnZXIuZW5kTm9kZS5nZXRSZWxhdGl2ZUxvY2F0aW9uKHRoaXMuZW5kKCkpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZHJhZ1N0YXJ0T3JpZW50YXRpb24gPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgIHRoaXMuZG9ja2luZ01hbmFnZXIuZHJhZ1N0YXJ0T3JpZW50YXRpb24oZHgsIGR5KTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmRyYWdFbmRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgdGhpcy5kb2NraW5nTWFuYWdlci5kcmFnRW5kT3JpZW50YXRpb24oZHgsIGR5KTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmdldElubmVyU1ZHID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICByZXR1cm4gJC5zdmcodGhpcy5nZXRUcmFuc2l0aW9uU2VsZWN0b3IocHJlZml4KSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5pbml0VHJhbnNpdGlvblNWRyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGhNYW5hZ2VyLnBhdGg7XHJcblxyXG4gICAgLy9Ob3RlIHdlIHNoYXJlIHRoZSBwYXRoIGJldHdlZW4gbGluZSBhbmQgbGluZUFyZWEgYW4gdXBkYXRlXHJcbiAgICB0aGlzLl9zZXRMaW5lKHRoaXMuc3ZnLnBhdGgoe1xyXG4gICAgICAgIGQgOiBwYXRoLFxyXG4gICAgICAgIGlkIDogJ2xpbmVfJyt0aGlzLmlkLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIHRoaXMuX3NldExpbmVBcmVhKHRoaXMuc3ZnLnBhdGgoe1xyXG4gICAgICAgIGQgOiBwYXRoLFxyXG4gICAgICAgIGlkOiAnbGluZUFyZWFfJyt0aGlzLmlkLFxyXG4gICAgICAgIHN0eWxlICA6IFNUWUxFX0FSRUFcclxuICAgIH0pKTtcclxuXHJcbiAgICB0aGlzLl9zZXRJbml0U3R5bGUoKTtcclxuICAgIHRoaXMuZ3JvdXAucHJlcGVuZCh0aGlzLmxpbmVBcmVhLCB0aGlzLmxpbmUpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuX3NldEluaXRTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy9UT0RPOiBzZXQgYWN0aXZlIGNvbG9yIGZyb20gZ2xvYmFsIHNldHRpbmdzXHJcbiAgICB0aGlzLmNvbG9ySW5hY3RpdmUgPSB0aGlzLmNmZ1snc3Ryb2tlJ10gfHwgQ09MT1JfSU5BQ1RJVkU7XHJcbiAgICB0aGlzLmNvbG9yQWN0aXZlID0gQ09MT1JfQUNUSVZFO1xyXG5cclxuICAgIHRoaXMubGluZS5maWxsKCdub25lJyk7XHJcbiAgICB0aGlzLmFjdGl2ZVN0eWxlKCk7XHJcbiAgICB0aGlzLnN0cm9rZVdpZHRoKHRoaXMuY2ZnWydzdHJva2Utd2lkdGgnXSB8fCBERUZBVUxUX1dJRFRIKTtcclxuICAgIHRoaXMubGluZS5zdHJva2VEYXNoYXJyYXkodGhpcy5jZmdbJ3N0cm9rZS1kYXNoYXJyYXknXSk7XHJcbiAgICB0aGlzLnN0YXJ0TWFya2VyKHRoaXMuY2ZnWydtYXJrZXItc3RhcnQnXSk7XHJcbiAgICB0aGlzLmVuZE1hcmtlcih0aGlzLmNmZ1snbWFya2VyLWVuZCddIHx8IERFRkFVTFRfRU5ETUFSS0VSKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnN0cm9rZVdpZHRoID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHRoaXMubGluZS5zdHJva2VXaWR0aCh2YWx1ZSk7XHJcbiAgICBpZih2YWx1ZSA+IDExKSB7XHJcbiAgICAgICAgdGhpcy5saW5lQXJlYS5zdHJva2VXaWR0aCh2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubGluZUFyZWEuc3Ryb2tlV2lkdGgoMTEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuaW5pdEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5saW5lQXJlYS5ob3ZlcmFibGUoe1xyXG4gICAgICAgIGluOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5ob3ZlcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5ob3Zlck91dCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZihldnQuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3RJbm5lcktub2JzKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9KS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICB2YXIgZHJhZ0luaXRpYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhhdC5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICB2YXIgcGF0aFBhcnRJbmRleCA9IHRoYXQucGF0aE1hbmFnZXIuZ2V0SW5kZXhGb3JQb3NpdGlvbihzdGFydFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgaWYoZXZ0LnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBrbm9ic0J5SW5kZXggPSB0aGF0Lmtub2JNYW5hZ2VyLmdldEtub2JzQnlJbmRleChwYXRoUGFydEluZGV4KTtcclxuICAgICAgICAgICAgaWYocGF0aFBhcnRJbmRleCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAga25vYnNCeUluZGV4WzFdLnNlbGVjdCh0cnVlKS5pbml0RHJhZygpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5kb2NraW5nTWFuYWdlci5zdGFydERvY2tpbmcua25vYi5pbml0RHJhZygpO1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBpbXBsZW1lbnQgc2FtZSBiZWhhdmlvdXIgZm9yIGxhc3QgaW5kZXggKyBjaGVjayBkbyAvIHVuZG9cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGtub2JzQnlJbmRleFswXS5zZWxlY3QodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBrbm9ic0J5SW5kZXhbMV0uc2VsZWN0KHRydWUpLmluaXREcmFnKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIXRoYXQuc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoYXQuZnJlZXplZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIGlmIChwYXRoUGFydEluZGV4KSB7XHJcbiAgICAgICAgICAgIGV2ZW50Lm9uY2UoZG9jdW1lbnQsIFwibW91c2V1cFwiLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuZGlhZ3JhbS5vZmYoJ21vdXNlbW92ZScpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhhdC5kaWFncmFtLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW92ZVBvc2l0aW9uID0gdGhhdC5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vV2UganVzdCBzdGFydCB0aGUgZHJhZyBldmVudCBpbiBjYXNlIHdlIG1vdmUgbW9yZSB0aGFudCA1cHggYXdheVxyXG4gICAgICAgICAgICAgICAgaWYoIWRyYWdJbml0aWF0ZWQgJiYgdXRpbC5hcHAuaXNNaW5EaXN0KHN0YXJ0UG9zaXRpb24sIG1vdmVQb3NpdGlvbiwgNSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga25vYiA9IHRoYXQua25vYk1hbmFnZXIuYWRkS25vYihzdGFydFBvc2l0aW9uLCBwYXRoUGFydEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBrbm9iLmluaXREcmFnKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0luaXRpYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhhdC5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZ0KTtcclxuICAgICAgICB2YXIgcG9pbnRPbkxpbmUgPSB0aGF0LnBhdGhNYW5hZ2VyLmdldE5lYXJlc3RQb2ludChzdGFydFBvc2l0aW9uKTtcclxuICAgICAgICB2YXIga25vYkluZGV4ID0gdGhhdC5wYXRoTWFuYWdlci5nZXRJbmRleEZvclBvc2l0aW9uKHN0YXJ0UG9zaXRpb24pO1xyXG4gICAgICAgIHRoYXQuYWRkS25vYihwb2ludE9uTGluZSwga25vYkluZGV4KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmZyZWV6ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5kb2NraW5nTWFuYWdlci5mcmVlemUoKTtcclxuICAgIHRoaXMua25vYk1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUudW5mcmVlemUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZnJlZXplZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5kb2NraW5nTWFuYWdlci51bmZyZWV6ZSgpO1xyXG4gICAgdGhpcy5rbm9iTWFuYWdlci51bmZyZWV6ZSgpO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmFkZEtub2IgPSBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcclxuICAgIGlmKCF0aGlzLmlzSW5pdFN0YXRlKCkpIHtcclxuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDE7XHJcbiAgICAgICAgdmFyIGtub2IgPSB0aGlzLmtub2JNYW5hZ2VyLmFkZEtub2IocG9zaXRpb24sIGluZGV4KTtcclxuICAgICAgICB0aGlzLmV4ZWMoJ2tub2JfYWRkJywgW2luZGV4LCBwb3NpdGlvbl0pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGtub2I7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5vd25zS25vYk5vZGUgPSBmdW5jdGlvbihrbm9iTm9kZSkge1xyXG4gICAgcmV0dXJuIHRoaXMua25vYk1hbmFnZXIub3duc0tub2JOb2RlKGtub2JOb2RlKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG1vdXNlKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUVuZChtb3VzZSk7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXJ0KG1vdXNlKTtcclxuICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICB0aGlzLmV4ZWMoJ3VwZGF0ZScsW10sIHRydWUpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmxpbmUgJiYgdGhpcy5saW5lQXJlYSkge1xyXG4gICAgICAgIHRoaXMubGluZS51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLmxpbmVBcmVhLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMua25vYk1hbmFnZXIuZ2V0U2VsZWN0ZWRLbm9icygpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUudXBkYXRlU3RhcnQgPSBmdW5jdGlvbihtb3VzZSkge1xyXG4gICAgdmFyIG91dGVyT3JpZW50YXRpb24gPSBtb3VzZSB8fCB0aGlzLmtub2JNYW5hZ2VyLmdldFBvc2l0aW9uKDEpO1xyXG4gICAgdGhpcy5rbm9iTWFuYWdlci51cGRhdGVTdGFydEtub2IodGhpcy5kb2NraW5nTWFuYWdlci5jYWxjdWxhdGVTdGFydChvdXRlck9yaWVudGF0aW9uKSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS51cGRhdGVFbmQgPSBmdW5jdGlvbihtb3VzZSkge1xyXG4gICAgaWYodGhpcy5pc0luaXRTdGF0ZSgpKSB7XHJcbiAgICAgICAgbW91c2UgPSB0aGlzLmFsaWduRW5kUG9zaXRpb25Gb3JNb3VzZShtb3VzZSk7XHJcbiAgICAgICAgdGhpcy5wYXRoTWFuYWdlci5kcmFnTGluZShtb3VzZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBvdXRlck9yaWVudGF0aW9uID0gdGhpcy5rbm9iTWFuYWdlci5nZXRQb3NpdGlvbigtMik7XHJcbiAgICAgICAgdGhpcy5rbm9iTWFuYWdlci51cGRhdGVFbmRLbm9iKHRoaXMuZG9ja2luZ01hbmFnZXIuY2FsY3VsYXRlRW5kKG91dGVyT3JpZW50YXRpb24pKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmlzSW5pdFN0YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZG9ja2luZ01hbmFnZXIuZW5kTm9kZTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmFsaWduRW5kUG9zaXRpb25Gb3JNb3VzZSA9IGZ1bmN0aW9uKG1vdXNlKSB7XHJcbiAgICAvL1RoaXMgcHJldmVudHMgdGhlIGxpbmUgcmVuZGVyaW5nIHRvIG92ZXJsYXAgdGhlIGV4YWN0IG1vdXNlIHBvc2l0aW9uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHggOiAodGhpcy5rbm9iTWFuYWdlci5zdGFydEtub2IueCgpIDwgbW91c2UueCkgPyBtb3VzZS54IC0gMSA6IG1vdXNlLnggKyAxLFxyXG4gICAgICAgIHkgOiAodGhpcy5rbm9iTWFuYWdlci5zdGFydEtub2IueSgpIDwgbW91c2UueSkgPyBtb3VzZS55IC0gMSA6IG1vdXNlLnkgKyAxXHJcbiAgICB9O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuc2V0U3RhcnROb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdGhpcy5leGVjKCdzZXRTdGFydE5vZGUnLCBbbm9kZV0pO1xyXG4gICAgaWYoIXRoaXMuaXNJbml0U3RhdGUoKSkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEb21Qb3NpdGlvbigpO1xyXG4gICAgfVxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnNldEVuZE5vZGUgPSBmdW5jdGlvbihub2RlLCBtb3VzZVBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLmV4ZWMoJ3NldEVuZE5vZGUnLCBbbm9kZSwgbW91c2VQb3NpdGlvbl0pO1xyXG4gICAgdGhpcy5jaGVja0RvbVBvc2l0aW9uKCk7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgdGhpcy5ncm91cC5wb2ludGVyRXZlbnRzKCdhbGwnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmNoZWNrRG9tUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBtYXhOb2RlSW5kZXggPSBNYXRoLm1heCh0aGlzLmRvY2tpbmdNYW5hZ2VyLnN0YXJ0Tm9kZS5pbmRleCgpLCB0aGlzLmRvY2tpbmdNYW5hZ2VyLmVuZE5vZGUuaW5kZXgoKSk7XHJcbiAgICB2YXIgdHJhbnNpdGlvbkluZGV4ID0gdGhpcy5pbmRleCgpO1xyXG5cclxuICAgIGlmKHRyYW5zaXRpb25JbmRleCA8IG1heE5vZGVJbmRleCkge1xyXG4gICAgICAgIGRvbS5pbnNlcnRBZnRlckluZGV4KHRoaXMuZ3JvdXAuaW5zdGFuY2UoKSwgbWF4Tm9kZUluZGV4KTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLm1vdmVJbm5lcktub2JzID0gZnVuY3Rpb24oZGlzdGFuY2UpIHtcclxuICAgIHRoaXMua25vYk1hbmFnZXIubW92ZUlubmVyS25vYnMoZGlzdGFuY2UpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuc2VsZWN0SW5uZXJLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5rbm9iTWFuYWdlci5zZWxlY3RJbm5lcktub2JzKCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVtb3ZlZCA9IHRydWU7XHJcbiAgICB0aGlzLmdyb3VwLnJlbW92ZSgpO1xyXG4gICAgdGhpcy5kb2NraW5nTWFuYWdlci5yZW1vdmUoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ncm91cC4kKCkuaW5kZXgoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmluc3RhbmNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAuaW5zdGFuY2UoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmVuZE1hcmtlciA9IGZ1bmN0aW9uKG1hcmtlcikge1xyXG4gICAgcmV0dXJuIHRoaXMubWFya2VyKCdlbmQnLCBtYXJrZXIpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuZW5kTWFya2VyVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1hcmtlclZhbHVlKCdlbmQnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnN0YXJ0TWFya2VyID0gZnVuY3Rpb24obWFya2VyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIoJ3N0YXJ0JywgbWFya2VyKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnN0YXJ0TWFya2VyVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1hcmtlclZhbHVlKCdzdGFydCcpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUubWFya2VyID0gZnVuY3Rpb24odHlwZSwgbWFya2VyKSB7XHJcbiAgICB2YXIga2V5ID0gJ21hcmtlci0nK3R5cGU7XHJcbiAgICBpZih1dGlsLm9iamVjdC5pc0RlZmluZWQobWFya2VyKSkge1xyXG4gICAgICAgIHRoaXMubGluZS5hdHRyKGtleSwgdGhpcy5nZXRNYXJrZXJWYWx1ZVN0cmluZyhtYXJrZXIpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIG1hcmtlclN0ciA9IHRoaXMubGluZS5hdHRyKGtleSk7XHJcbiAgICAgICAgaWYobWFya2VyU3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJTdHIuc3Vic3RyaW5nKDUsIG1hcmtlclN0ci5sZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5zZWxlY3RvciA9IGZ1bmN0aW9uKHByZWZpeCkge1xyXG4gICAgdmFyIHN0cmluZ1NlbGVjdG9yO1xyXG4gICAgaWYob2JqZWN0LmlzQXJyYXkocHJlZml4KSkge1xyXG4gICAgICAgIHN0cmluZ1NlbGVjdG9yID0gW107XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG9iamVjdC5lYWNoKHByZWZpeCwgZnVuY3Rpb24oaW5kZXgsIHZhbCkge1xyXG4gICAgICAgICAgICBzdHJpbmdTZWxlY3Rvci5wdXNoKHRoYXQuc2VsZWN0b3IodmFsKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RyaW5nU2VsZWN0b3IgPSBzdHJpbmdTZWxlY3Rvci5qb2luKCcsICcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzdHJpbmdTZWxlY3RvciA9IHByZWZpeDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldFRyYW5zaXRpb25TZWxlY3RvcihzdHJpbmdTZWxlY3Rvcik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uU2VsZWN0b3IgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuXHJcbiAgICBpZighdXRpbC5zdHJpbmcuc3RhcnRzV2l0aChwcmVmaXgsICcjJykgJiYgIXV0aWwuc3RyaW5nLnN0YXJ0c1dpdGgocHJlZml4LCAnLicpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gJyMnK3ByZWZpeDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcHJlZml4O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1dGlsLnN0cmluZy5lbmRzV2l0aChwcmVmaXgsICdfJylcclxuICAgICAgICA/IHJlc3VsdCArIHRoaXMuaWRcclxuICAgICAgICA6IHJlc3VsdCArICdfJyArIHRoaXMuaWQ7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5tYXJrZXJWYWx1ZSA9IGZ1bmN0aW9uKHR5cGUsIG1hcmtlcikge1xyXG4gICAgdmFyIG1hcmtlclN0cmluZyA9IHRoaXMubWFya2VyKHR5cGUsIG1hcmtlcik7XHJcbiAgICBpZihtYXJrZXJTdHJpbmcpIHsgLy8gdHJpYW5nbGVfc18xMjMxMjQyMyAtLT4gdHJpYW5nbGVfc1xyXG4gICAgICAgIHJldHVybiBtYXJrZXJTdHJpbmcuc3Vic3RyaW5nKDAsIG1hcmtlclN0cmluZy5sZW5ndGggLSB0aGlzLmRpYWdyYW0uaWQubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRNYXJrZXJWYWx1ZVN0cmluZyA9IGZ1bmN0aW9uKG1hcmtlcklkKSB7XHJcbiAgICBtYXJrZXJJZCA9ICh1dGlsLnN0cmluZy5lbmRzV2l0aChtYXJrZXJJZCwgdGhpcy5kaWFncmFtLmlkKSkgPyBtYXJrZXJJZCA6IG1hcmtlcklkICsgJ18nICsgdGhpcy5kaWFncmFtLmlkO1xyXG4gICAgcmV0dXJuICd1cmwoIycgKyBtYXJrZXJJZCArICcpJztcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICB0aGlzLmFjdGl2ZVN0eWxlKCk7XHJcbiAgICB0aGlzLmV4ZWMoJ3NlbGVjdCcpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuaG92ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZXhlYygnaG92ZXInKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmhvdmVyT3V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmV4ZWMoJ2hvdmVyT3V0Jyk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5zdHJva2UgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmNvbG9ySW5hY3RpdmUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmxpbmUuc3Ryb2tlKHZhbHVlKTtcclxufVxyXG5cclxuVHJhbnNpdGlvbi5wcm90b3R5cGUuYWN0aXZlU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vdGhpcy5saW5lLnN0cm9rZSh0aGlzLmNvbG9yQWN0aXZlKTtcclxuICAgIC8vYWN0aXZlIHN0eWxlIHdhcyByZW1vdmVkXHJcbiAgICB0aGlzLmluYWN0aXZlU3R5bGUoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmluYWN0aXZlU3R5bGUoKTtcclxuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuZXhlYygnZGVzZWxlY3QnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmluYWN0aXZlU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubGluZS5zdHJva2UodGhpcy5jb2xvckluYWN0aXZlKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSAnPGI+VHJhbnNpdGlvbjwvYj4gLSA8Yj4nK3RoaXMuaWQrJzwvYj48YnIgLz5cXG4nO1xyXG4gICAgcmVzdWx0ICs9IHRoaXMua25vYk1hbmFnZXIuZHVtcCgpO1xyXG4gICAgcmVzdWx0ICs9IHRoaXMuZG9ja2luZ01hbmFnZXIuZHVtcCgpO1xyXG4gICAgcmVzdWx0ICs9IHRoaXMucGF0aE1hbmFnZXIuZHVtcCgpO1xyXG4gICAgJC5lYWNoKHRoaXMuYWRkaXRpb25zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYodmFsdWUuZHVtcCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWUuZHVtcCgpKyc8YnIgLz5cXG4nO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICByZXN1bHRbJ2tub2JNYW5hZ2VyJ10gPSB0aGlzLmtub2JNYW5hZ2VyLnZhbGlkYXRlKCk7XHJcbiAgICByZXN1bHRbJ2RvY2tpbmdNYW5hZ2VyJ10gPSB0aGlzLmRvY2tpbmdNYW5hZ2VyLnZhbGlkYXRlKCk7XHJcbiAgICAvL3Jlc3VsdFsncGF0aE1hbmFnZXInXSA9IHRoaXMucGF0aE1hbmFnZXIudmFsaWRhdGUoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ncm91cC50b1N0cmluZygpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uO1xyXG4iLCJ2YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG52YXIgVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0cmFuc2l0aW9uYWRkaXRpb24gZm9yIG5vZGVzIGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgdXBkYXRpbmcvcmVuZGVyaW5nIHRoZSBpbmNvbWluZyBhbmQgb3V0Z29pbmdcclxuICogdHJhbnNpdGlvbnMgb2YgYSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBUcmFuc2l0aW9uQWRkaXRpb24gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgdGhpcy5ldmVudCA9IG5vZGUuZXZlbnQ7XHJcbiAgICB0aGlzLmRpYWdyYW0gPSB0aGlzLm5vZGUuZGlhZ3JhbTtcclxuICAgIHRoaXMudHJhbnNpdGlvbk1nciA9IHRoaXMuZGlhZ3JhbS50cmFuc2l0aW9uTWdyO1xyXG4gICAgdGhpcy5vdXRnb2luZ1RyYW5zaXRpb25zID0gW107XHJcbiAgICB0aGlzLmluY29taW5nVHJhbnNpdGlvbnMgPSBbXTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuZHJhZ01vdmUgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgIHRoaXMudXBkYXRlT3JpZW50YXRpb25zKGR4ICxkeSk7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS51cGRhdGVPcmllbnRhdGlvbnMgPSBmdW5jdGlvbihkeCAsZHkpIHtcclxuICAgIHRoaXMuZXhlY3V0ZU9uT3V0Z29pbmdUcmFuc2l0aW9ucyhmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbi5kcmFnU3RhcnRPcmllbnRhdGlvbihkeCxkeSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmV4ZWN1dGVPbkluY29taW5nVHJhbnNpdGlvbnMoZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgICAgIHRyYW5zaXRpb24uZHJhZ0VuZE9yaWVudGF0aW9uKGR4LGR5KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5leGVjdXRlT25BbGxUcmFuc2l0aW9ucyhmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbi51cGRhdGUoKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZXhlY3V0ZU9uQWxsVHJhbnNpdGlvbnMoZnVuY3Rpb24oIHRyYW5zaXRpb24pIHtcclxuICAgICAgICB0cmFuc2l0aW9uLnJlbW92ZSgpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLm1vdmVVcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5leGVjdXRlT25BbGxUcmFuc2l0aW9ucyhmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbi5jaGVja0RvbVBvc2l0aW9uKCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb2RlIGRiY2xpY2sgdHJpZ2dlcnMgdGhlIGNyZWF0aW9uIG9mIGEgdHJhbnNpdGlvbi5cclxuICovXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuZGJsY2xpY2sgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIHRoaXMuc3RhcnROZXdUcmFuc2l0aW9uKHVuZGVmaW5lZCwgdGhpcy5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24oZXZ0KSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBzdGFydHMgYSBuZXcgdHJhbnNpdGlvbiBlaXRoZXIgYnkgcHJvdmlkaW5nIGEgZW5kTm9kZSBvciBieSB1c2luZyB0aGUgdHJhbnNpdGlvbmRyYWdcclxuICogQHBhcmFtIGVuZE5vZGVcclxuICovXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuc3RhcnROZXdUcmFuc2l0aW9uID0gZnVuY3Rpb24oZW5kTm9kZSwgbW91c2UpIHtcclxuICAgIGlmKHRoaXMudHJhbnNpdGlvbk1nci5pc0RyYWdUcmFuc2l0aW9uKCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaWFncmFtLnRyYW5zaXRpb25NZ3IuZ2V0RHJhZ1RyYW5zaXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbk1nci5zdGFydERyYWdUcmFuc2l0aW9uKHRoaXMubm9kZSwgbW91c2UpO1xyXG5cclxuICAgIGlmKCFlbmROb2RlKSB7XHJcbiAgICAgICAgLy9JZiBubyBlbmROb2RlIHdhcyBwcm92aWRlZCB3ZSBzdGFydCB0aGUgbW91c2UgbGlzdGVuZXIgZm9yIHRoZSB0cmFuc2l0aW9uZHJhZ1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBldmVudC5vbih0aGlzLmRpYWdyYW0uc3ZnLmdldFJvb3ROb2RlKCksIFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbkRyYWcoZXZlbnQsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL0lmIGFuIGVuZE5vZGUgd2FzIHByb3ZpZGVkIHdlIGltaXRhdGUgdGhlIHRyYW5zaXRpb25kcmFnIGFuZCBzZXQgdGhlIGVuZE5vZGVcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb25EcmFnKGVuZE5vZGUuZ2V0Q2VudGVyKCkpO1xyXG4gICAgICAgIGVuZE5vZGUuYWRkaXRpb25zLnRyYW5zaXRpb24uZW5kVHJhbnNpdGlvbkRyYWcoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhbnNpdGlvbjtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbkRyYWcgPSBmdW5jdGlvbihtb3VzZSwgaXNFdnQpIHtcclxuICAgIG1vdXNlID0gKGlzRXZ0KT8gdGhpcy5kaWFncmFtLmdldFN0YWdlUG9zaXRpb24obW91c2UpIDogbW91c2U7XHJcbiAgICAvL1VwZGF0ZSB0aGUgY3VycmVudCBkcmFnVHJhbnNpdGlvblxyXG4gICAgdGhpcy50cmFuc2l0aW9uTWdyLmdldERyYWdUcmFuc2l0aW9uKCkudXBkYXRlKG1vdXNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb2RlIG1vdXNlZG93biBlbmRzIGEgdHJhbnNpdGlvbkRyYWcgZXZlbiAoaWYgdGhlcmUgaXMgb25lKSBhbmQgc2V0cyB0aGlzIG5vZGUgYXMgZW5kbm9kZVxyXG4gKi9cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbihldnQpIHtcclxuICAgIC8vIFN0b3AgdHJhbnNpdGlvbiBkcmFnIGV2ZW50IGFuZCBzZXQgZW5kIG5vZGVcclxuICAgIGlmKHRoaXMudHJhbnNpdGlvbk1nci5pc0RyYWdUcmFuc2l0aW9uKCkpIHtcclxuICAgICAgICB0aGlzLmVuZFRyYW5zaXRpb25EcmFnKGV2dCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLmVuZFRyYW5zaXRpb25EcmFnID0gZnVuY3Rpb24obW91c2VFdnQpIHtcclxuICAgIG1vdXNlRXZ0ID0gbW91c2VFdnQgfHwgdGhpcy5ub2RlLmdldENlbnRlcigpO1xyXG4gICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25NZ3IuZ2V0RHJhZ1RyYW5zaXRpb24oKTtcclxuICAgIHRyYW5zaXRpb24uc2V0RW5kTm9kZSh0aGlzLm5vZGUsIHRoaXMuZGlhZ3JhbS5nZXRTdGFnZVBvc2l0aW9uKG1vdXNlRXZ0KSk7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25NZ3IuZW5kRHJhZ1RyYW5zaXRpb24oKTtcclxuICAgIGV2ZW50Lm9mZih0aGlzLmRpYWdyYW0uc3ZnLmdldFJvb3ROb2RlKCksICdtb3VzZW1vdmUnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUub3duc1RyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAkLmVhY2godGhpcy5vdXRnb2luZ1RyYW5zaXRpb25zLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNTdHJpbmcodHJhbnNpdGlvbikgJiYgdmFsdWUuaWQgPT09IHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL2V4aXQgZWFjaCBsb29wXHJcbiAgICAgICAgfSBlbHNlIGlmKHZhbHVlLmlkID09PSB0cmFuc2l0aW9uLmlkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9leGl0IGVhY2ggbG9vcFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmKCFyZXN1bHQpIHtcclxuICAgICAgICAkLmVhY2godGhpcy5pbmNvbWluZ1RyYW5zaXRpb25zLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYob2JqZWN0LmlzU3RyaW5nKHRyYW5zaXRpb24pICYmIHZhbHVlLmlkID09PSB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL2V4aXQgZWFjaCBsb29wXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZih2YWx1ZS5pZCA9PT0gdHJhbnNpdGlvbi5pZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9leGl0IGVhY2ggbG9vcFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuYWRkT3V0Z29pbmdUcmFuc2l0aW9uID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgdGhpcy5vdXRnb2luZ1RyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvbjtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuZXhlY3V0ZU9uQWxsVHJhbnNpdGlvbnMgPSBmdW5jdGlvbihoYW5kbGVyKSB7XHJcbiAgICB0aGlzLmV4ZWN1dGVPbk91dGdvaW5nVHJhbnNpdGlvbnMoaGFuZGxlcik7XHJcbiAgICB0aGlzLmV4ZWN1dGVPbkluY29taW5nVHJhbnNpdGlvbnMoaGFuZGxlcik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLmV4ZWN1dGVPbk91dGdvaW5nVHJhbnNpdGlvbnMgPSBmdW5jdGlvbihoYW5kbGVyKSB7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLm91dGdvaW5nVHJhbnNpdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgaWYodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBoYW5kbGVyKHRyYW5zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5leGVjdXRlT25JbmNvbWluZ1RyYW5zaXRpb25zID0gZnVuY3Rpb24oaGFuZGxlcikge1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5pbmNvbWluZ1RyYW5zaXRpb25zLCBmdW5jdGlvbihpbmRleCwgdHJhbnNpdGlvbikge1xyXG4gICAgICAgIGlmKHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaGFuZGxlcih0cmFuc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkFsaWdubWVudFRhcmdldHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMub3V0Z29pbmdUcmFuc2l0aW9ucywgZnVuY3Rpb24oaW5kZXgsIHRyYW5zaXRpb24pIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKHRyYW5zaXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRyYW5zaXRpb24uZ2V0U3RhcnRBbGlnbm1lbnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgb2JqZWN0LmVhY2godGhpcy5pbmNvbWluZ1RyYW5zaXRpb25zLCBmdW5jdGlvbihpbmRleCwgdHJhbnNpdGlvbikge1xyXG4gICAgICAgIGlmIChvYmplY3QuaXNEZWZpbmVkKHRyYW5zaXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRyYW5zaXRpb24uZ2V0RW5kQWxpZ25tZW50KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUucmVtb3ZlT3V0Z29pbmdUcmFuc2l0aW9uID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5vdXRnb2luZ1RyYW5zaXRpb25zLmluZGV4T2YodHJhbnNpdGlvbik7XHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgdGhpcy5vdXRnb2luZ1RyYW5zaXRpb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucHJvdG90eXBlLmFkZEluY29taW5nVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIHRoaXMuaW5jb21pbmdUcmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkFkZGl0aW9uLnByb3RvdHlwZS5yZW1vdmVJbmNvbWluZ1RyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluY29taW5nVHJhbnNpdGlvbnMuaW5kZXhPZih0cmFuc2l0aW9uKTtcclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICB0aGlzLmluY29taW5nVHJhbnNpdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25BZGRpdGlvbi5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9ICc8Yj5UcmFuc2l0aW9uQWRkaXRpb248L2I+PGJyIC8+JztcclxuICAgIHJlc3VsdCArPSB0aGlzLm91dGdvaW5nVHJhbnNpdGlvbnMubGVuZ3RoKycgT3V0Z29pbmcgVHJhbnNpdGlvbnM6PGJyIC8+JztcclxuICAgIHRoaXMuZXhlY3V0ZU9uT3V0Z29pbmdUcmFuc2l0aW9ucyhmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9ICdUcmFuc2l0aW9uIC0gJyt0cmFuc2l0aW9uLmlkKyc8YnIgLz4nO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmVzdWx0ICs9IHRoaXMuaW5jb21pbmdUcmFuc2l0aW9ucy5sZW5ndGgrJyBJbmNvbWluZyBUcmFuc2l0aW9uczo8YnIgLz4nO1xyXG4gICAgdGhpcy5leGVjdXRlT25JbmNvbWluZ1RyYW5zaXRpb25zKGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgICAgICByZXN1bHQgKz0gJ1RyYW5zaXRpb24gLSAnK3RyYW5zaXRpb24uaWQrJzxiciAvPic7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uQWRkaXRpb24ucmVxdWlyZUNvbmZpZyA9IGZhbHNlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uQWRkaXRpb247XHJcblxyXG4iLCJ2YXIgYWRkaXRpb25zID0gcmVxdWlyZSgnLi9hZGRpdGlvbnMnKTtcclxuXHJcbi8vSW5pdCBkZWZhdWx0IGFkZGl0aW9uc1xyXG5hZGRpdGlvbnMucmVnaXN0ZXJUcmFuc2l0aW9uQWRkaXRpb24oJ3RleHQnLCByZXF1aXJlKCcuL3RyYW5zaXRpb25UZXh0QWRkaXRpb24nKSk7XHJcbmFkZGl0aW9ucy5yZWdpc3RlclRyYW5zaXRpb25BZGRpdGlvbignZWRpdCcsIHJlcXVpcmUoJy4vZWRpdFRyYW5zaXRpb25BZGRpdGlvbicpKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgaW5pdCA6IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgICAgICBhZGRpdGlvbnMuaW5pdFRyYW5zaXRpb25BZGRpdGlvbnModHJhbnNpdGlvbik7XHJcbiAgICB9XHJcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIEtub2IgPSByZXF1aXJlKCcuL0tub2InKTtcclxudmFyIGRvY2tpbmdUeXBlID0gcmVxdWlyZSgnLi9kb2NraW5nJyk7XHJcblxyXG52YXIgVHJhbnNpdGlvbkRvY2tpbmcgPSBmdW5jdGlvbihkb2NraW5nTWFuYWdlciwgbm9kZSwgbW91c2UsIHR5cGUpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gZG9ja2luZ01hbmFnZXIudHJhbnNpdGlvbjtcclxuICAgICAgICB0aGlzLmRvY2tpbmdNYW5hZ2VyID0gZG9ja2luZ01hbmFnZXI7XHJcbiAgICAgICAgaWYoIW5vZGUua25vYikge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRPcmllbnRhdGlvbihtb3VzZSwgdHlwZSk7XHJcbiAgICAgICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmcucHJvdG90eXBlLmZyZWV6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5rbm9iKSB7XHJcbiAgICAgICAgdGhpcy5rbm9iLmZyZWV6ZSgpO1xyXG4gICAgICAgIHRoaXMua25vYi5jb25maWdbJ2ZpbGwtb3BhY2l0eSddID0gMDtcclxuICAgICAgICB0aGlzLmtub2Iuc2hvdygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmcucHJvdG90eXBlLnVuZnJlZXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmtub2IpIHtcclxuICAgICAgICB0aGlzLmtub2IudW5mcmVlemUoKTtcclxuICAgICAgICB0aGlzLmtub2IuY29uZmlnWydmaWxsLW9wYWNpdHknXSA9IDAuNTtcclxuICAgICAgICB0aGlzLmtub2Iuc2hvdygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmcucHJvdG90eXBlLmluaXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHN0YXJ0UG9zaXRpb24sIHR5cGUpIHtcclxuICAgIHZhciBvcmllbnRhdGlvblBvc2l0aW9uID0gX2dldFN0YXJ0T3JpZW50YXRpb25Qb3NpdGlvbih0aGlzLm5vZGUsIHN0YXJ0UG9zaXRpb24pO1xyXG4gICAgdGhpcy5rbm9iID0gbmV3IEtub2IodGhpcy50cmFuc2l0aW9uLmRpYWdyYW0sIG9yaWVudGF0aW9uUG9zaXRpb24sIHsnY3NzQ2xhc3MnOidvcmllbnRhdGlvbktub2IgJyt0eXBlLCAnZmlsbC1hY3RpdmUnOidvcmFuZ2UnLCBmaWxsOidvcmFuZ2UnLCBzZWxlY3RhYmxlOmZhbHNlfSwgdGhpcy50cmFuc2l0aW9uLmdyb3VwKTtcclxuICAgIHRoaXMuaW5pdEtub2JFdmVudHMoKTtcclxufTtcclxuXHJcbnZhciBfZ2V0U3RhcnRPcmllbnRhdGlvblBvc2l0aW9uID0gZnVuY3Rpb24obm9kZSwgbW91c2UpIHtcclxuICAgIHZhciBvcmllbnRhdGlvblR5cGUgPSAobm9kZS5jb25maWcuZG9ja2luZyAmJiBub2RlLmNvbmZpZy5kb2NraW5nLm9yaWVudGF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gbm9kZS5jb25maWcuZG9ja2luZy5vcmllbnRhdGlvbiA6ICdjZW50ZXInO1xyXG4gICAgc3dpdGNoKG9yaWVudGF0aW9uVHlwZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgY2FzZSAnRlJFRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBtb3VzZTtcclxuICAgICAgICBjYXNlICAnQ0VOVEVSJzpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRDZW50ZXIoKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZy5wcm90b3R5cGUuaW5pdEtub2JFdmVudHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMua25vYi5kcmFnZ2FibGUoe1xyXG4gICAgICAgIHJlc3RyaWN0aW9uWCA6IGZ1bmN0aW9uKGV2dCwgZHgsIGR5KSB7XHJcbiAgICAgICAgICAgIHZhciBkcmFnQ2VudGVyID0gdGhhdC5rbm9iLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIGRyYWdDZW50ZXIueCArPSBkeDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoYXQubm9kZS5vdmVybGF5cyhkcmFnQ2VudGVyKSA/IGR4IDogMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc3RyaWN0aW9uWSA6IGZ1bmN0aW9uKGV2dCwgZHgsIGR5KSB7XHJcbiAgICAgICAgICAgIHZhciBkcmFnQ2VudGVyID0gdGhhdC5rbm9iLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIGRyYWdDZW50ZXIueSArPSBkeTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoYXQubm9kZS5vdmVybGF5cyhkcmFnQ2VudGVyKSA/IGR5IDogMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdBbGlnbm1lbnQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy9XZSBhbGlnbiBvdXIga25vYiBjZW50ZXIgdG8gdGhlIG5vZGUgY2VudGVyIGFuZCBhbHNvIHRvIG91ciB0cmFuc2l0aW9uIGFsaWdubWVudCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgYWxpZ25tZW50ID0gKHRoYXQudHlwZSA9PT0gJ3N0YXJ0JylcclxuICAgICAgICAgICAgICAgID8gdGhhdC50cmFuc2l0aW9uLmdldFN0YXJ0QWxpZ25tZW50KCkgOiB0aGF0LnRyYW5zaXRpb24uZ2V0RW5kQWxpZ25tZW50KCk7XHJcbiAgICAgICAgICAgIGFsaWdubWVudC50YXJnZXQucHVzaCh0aGF0Lm5vZGUuZ2V0Q2VudGVyKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2FsaWdubWVudF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmFnTW92ZSA6IGZ1bmN0aW9uKGV2dCwgZHggLGR5KSB7XHJcbiAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKHdpdGhTdHJva2UpIHtcclxuICAgIGlmKHRoaXMua25vYikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtub2IucG9zaXRpb24oKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDZW50ZXIoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbihwKSB7XHJcbiAgICBpZih0aGlzLmtub2IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rbm9iLm1vdmVUbyhwKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nLnByb3RvdHlwZS50cmlnZ2VyRHJhZyA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgaWYodGhpcy5rbm9iKSB7XHJcbiAgICAgICAgdGhpcy5rbm9iLnRyaWdnZXJEcmFnKGR4LCBkeSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZy5wcm90b3R5cGUuY2FsY3VsYXRlRG9ja2luZ1Bvc2l0aW9uID0gZnVuY3Rpb24ob3V0ZXJPcmllbnRhdGlvbikge1xyXG4gICAgaWYodGhpcy5ub2RlLmtub2IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldENlbnRlcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvY2tpbmdUeXBlLmNhbGN1bGF0ZURvY2tpbmdQb3NpdGlvbih0aGlzLm5vZGUsIG91dGVyT3JpZW50YXRpb24sIHRoaXMucG9zaXRpb24oKSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZy5wcm90b3R5cGUuaW5hY3RpdmVTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5rbm9iKSB7XHJcbiAgICAgICAgdGhpcy5rbm9iLmluYWN0aXZlU3R5bGUoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmtub2IpIHtcclxuICAgICAgICB0aGlzLmtub2IuaGlkZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5rbm9iKSB7XHJcbiAgICAgICAgdGhpcy5rbm9iLnJlbW92ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIFRyYW5zaXRpb25Eb2NraW5nTWFuYWdlciA9IGZ1bmN0aW9uKHRyYW5zaXRpb24sIHN0YXJ0Tm9kZSwgbW91c2UpIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IHRyYW5zaXRpb24uZGlhZ3JhbTtcclxuICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcblxyXG4gICAgaWYoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGFydE5vZGUoc3RhcnROb2RlLCBtb3VzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy50cmFuc2l0aW9uLmFkZGl0aW9uc1snZG9ja2luZ01hbmFnZXInXSA9IHtcclxuICAgICAgICBzZXRFbmROb2RlIDogZnVuY3Rpb24obm9kZSwgbW91c2VQb3NpdGlvbikge1xyXG4gICAgICAgICAgICB0aGF0LnNldEVuZE5vZGUobm9kZSwgbW91c2VQb3NpdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTdGFydE5vZGUgOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2V0U3RhcnROb2RlKG5vZGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VsZWN0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuaW5hY3RpdmVTdHlsZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzZWxlY3QgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5oaWRlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBob3ZlciA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LmluYWN0aXZlU3R5bGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhvdmVyT3V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGF0LnRyYW5zaXRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNldFN0YXJ0Tm9kZSh0aGlzLmRpYWdyYW0uZ2V0Tm9kZUJ5SWQodGhpcy5nZXRTdGFydE5vZGVGZWF0dXJlKCkpKTtcclxuICAgIHRoaXMuc2V0RW5kTm9kZSh0aGlzLmRpYWdyYW0uZ2V0Tm9kZUJ5SWQodGhpcy5nZXRFbmROb2RlRmVhdHVyZSgpKSk7XHJcblxyXG4gICAgLy9UT0RPIGFjdGl2YXRlIGtub2JzIGluc3RlYWQgb2YgcmVwbGFjZSAhXHJcbiAgICB2YXIgc3RhcnRPcmllbnRhdGlvblN2ZyA9IHRoaXMudHJhbnNpdGlvbi5ncm91cC4kKCkuY2hpbGRyZW4oJy5vcmllbnRhdGlvbktub2Iuc3RhcnQnKS5zdmcoKVswXTtcclxuICAgIGlmKHN0YXJ0T3JpZW50YXRpb25TdmcpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0RG9ja2luZy5tb3ZlVG8oc3RhcnRPcmllbnRhdGlvblN2Zy5wb3NpdGlvbigpKTtcclxuICAgICAgICBzdGFydE9yaWVudGF0aW9uU3ZnLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbmRPcmllbnRhdGlvblN2ZyA9IHRoaXMudHJhbnNpdGlvbi5ncm91cC4kKCkuY2hpbGRyZW4oJy5vcmllbnRhdGlvbktub2IuZW5kJykuc3ZnKClbMF07XHJcbiAgICBpZihlbmRPcmllbnRhdGlvblN2Zykge1xyXG4gICAgICAgIHRoaXMuZW5kRG9ja2luZy5tb3ZlVG8oZW5kT3JpZW50YXRpb25TdmcucG9zaXRpb24oKSk7XHJcbiAgICAgICAgc3RhcnRPcmllbnRhdGlvblN2Zy5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE86IGFkZCBlcnJvciBoYW5kbGVyIHdoYXQgdG9kbyBpZiB3ZSBjYW5ub3QgYWN0aXZhdGUgdGhlIHRyYW5zaXRpb24gPyByZW1vdmUgP1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmZyZWV6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5zdGFydERvY2tpbmcpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0RG9ja2luZy5mcmVlemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLmVuZERvY2tpbmcpIHtcclxuICAgICAgICB0aGlzLmVuZERvY2tpbmcuZnJlZXplKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLnVuZnJlZXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLnN0YXJ0RG9ja2luZykge1xyXG4gICAgICAgIHRoaXMuc3RhcnREb2NraW5nLnVuZnJlZXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5lbmREb2NraW5nKSB7XHJcbiAgICAgICAgdGhpcy5lbmREb2NraW5nLnVuZnJlZXplKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLnNldFN0YXJ0Tm9kZSA9IGZ1bmN0aW9uKG5vZGUsIG1vdXNlUG9zaXRpb24pIHtcclxuICAgIGlmKHRoaXMuc3RhcnROb2RlICYmIHRoaXMuc3RhcnROb2RlLmlkID09PSBub2RlLmlkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vZGUucmVtb3ZlT3V0Z29pbmdUcmFuc2l0aW9uKHRoaXMudHJhbnNpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5zdGFydERvY2tpbmcpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0RG9ja2luZy5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXJ0Tm9kZSA9IG5vZGU7XHJcbiAgICB0aGlzLnN0YXJ0Tm9kZS5hZGRPdXRnb2luZ1RyYW5zaXRpb24odGhpcy50cmFuc2l0aW9uKTtcclxuICAgIHRoaXMuc3RhcnREb2NraW5nID0gbmV3IFRyYW5zaXRpb25Eb2NraW5nKHRoaXMsIG5vZGUsIG1vdXNlUG9zaXRpb24sICdzdGFydCcpO1xyXG4gICAgdGhpcy5zZXRTdGFydE5vZGVGZWF0dXJlKCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmdldFN0YXJ0Tm9kZUZlYXR1cmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24uZ3JvdXAuZGFsYSgnc3RhcnQnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nTWFuYWdlci5wcm90b3R5cGUuc2V0U3RhcnROb2RlRmVhdHVyZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy50cmFuc2l0aW9uLmdyb3VwLmRhbGEoJ3N0YXJ0JywgdGhpcy5zdGFydE5vZGUuaWQpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5jYWxjdWxhdGVTdGFydCA9IGZ1bmN0aW9uKG91dGVyT3JpZW50YXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXJ0RG9ja2luZy5jYWxjdWxhdGVEb2NraW5nUG9zaXRpb24ob3V0ZXJPcmllbnRhdGlvbik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmRyYWdTdGFydE9yaWVudGF0aW9uID0gZnVuY3Rpb24oZHgsZHkpIHtcclxuICAgIHRoaXMuc3RhcnREb2NraW5nLnRyaWdnZXJEcmFnKGR4LGR5KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nTWFuYWdlci5wcm90b3R5cGUuc2V0RW5kTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIG1vdXNlUG9zaXRpb24pIHtcclxuICAgIGlmKHRoaXMuZW5kTm9kZSkge1xyXG4gICAgICAgIHRoaXMuZW5kTm9kZS5yZW1vdmVJbmNvbWluZ1RyYW5zaXRpb24odGhpcy50cmFuc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLmVuZERvY2tpbmcpIHtcclxuICAgICAgICB0aGlzLmVuZERvY2tpbmcucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lbmROb2RlID0gbm9kZTtcclxuICAgIHRoaXMuZW5kTm9kZS5hZGRJbmNvbWluZ1RyYW5zaXRpb24odGhpcy50cmFuc2l0aW9uKTtcclxuICAgIHRoaXMuZW5kRG9ja2luZyA9IG5ldyBUcmFuc2l0aW9uRG9ja2luZyh0aGlzLCBub2RlLCBtb3VzZVBvc2l0aW9uLCAnZW5kJyk7XHJcbiAgICB0aGlzLnNldEVuZE5vZGVGZWF0dXJlKCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmRyYWdFbmRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKGR4LGR5KSB7XHJcbiAgICB0aGlzLmVuZERvY2tpbmcudHJpZ2dlckRyYWcoZHgsZHkpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5jYWxjdWxhdGVFbmQgPSBmdW5jdGlvbihvdXRlck9yaWVudGF0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbmREb2NraW5nLmNhbGN1bGF0ZURvY2tpbmdQb3NpdGlvbihvdXRlck9yaWVudGF0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nTWFuYWdlci5wcm90b3R5cGUuZ2V0RW5kTm9kZUZlYXR1cmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24uZ3JvdXAuZGFsYSgnZW5kJyk7XHJcbn07XHJcblxyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5zZXRFbmROb2RlRmVhdHVyZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5lbmROb2RlKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uLmdyb3VwLmRhbGEoJ2VuZCcsIHRoaXMuZW5kTm9kZS5pZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmluYWN0aXZlU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuc3RhcnREb2NraW5nLmluYWN0aXZlU3R5bGUoKTtcclxuICAgIGlmKHRoaXMuZW5kRG9ja2luZykge1xyXG4gICAgICAgIHRoaXMuZW5kRG9ja2luZy5pbmFjdGl2ZVN0eWxlKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuc3RhcnREb2NraW5nLmhpZGUoKTtcclxuICAgIGlmKHRoaXMuZW5kRG9ja2luZykge1xyXG4gICAgICAgIHRoaXMuZW5kRG9ja2luZy5oaWRlKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uRG9ja2luZ01hbmFnZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5zdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0Tm9kZS5yZW1vdmVPdXRnb2luZ1RyYW5zaXRpb24odGhpcy50cmFuc2l0aW9uKTtcclxuICAgICAgICB0aGlzLnN0YXJ0RG9ja2luZy5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLmVuZE5vZGUpIHtcclxuICAgICAgICB0aGlzLmVuZE5vZGUucmVtb3ZlSW5jb21pbmdUcmFuc2l0aW9uKHRoaXMudHJhbnNpdGlvbik7XHJcbiAgICAgICAgdGhpcy5lbmREb2NraW5nLnJlbW92ZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbkRvY2tpbmdNYW5hZ2VyLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJ0RvY2tpbmdNYW5hZ2VyPGJyIC8+XFxuJztcclxuICAgIGlmKHRoaXMuc3RhcnROb2RlKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9ICdTdGFydE5vZGU6Jyt0aGlzLnN0YXJ0Tm9kZS5pZCsnPGJyIC8+XFxuJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ICs9ICdObyBTdGFydE5vZGU8YnIgLz5cXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuc3RhcnREb2NraW5nKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9ICdTdGFydERvY2tpbmc6Jyt0aGlzLnN0YXJ0RG9ja2luZy5wb3NpdGlvbigpKyc8YnIgLz5cXG4nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgKz0gJ05vIFN0YXJ0RG9ja2luZzxiciAvPlxcbic7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5lbmROb2RlKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9ICdFbmROb2RlOicrdGhpcy5lbmROb2RlLmlkKyc8YnIgLz5cXG4nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgKz0gJ05vIEVuZE5vZGU8YnIgLz5cXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuZW5kRG9ja2luZykge1xyXG4gICAgICAgIHJlc3VsdCArPSAnRW5kRG9ja2luZzonK3RoaXMuZW5kRG9ja2luZy5wb3NpdGlvbigpKyc8YnIgLz5cXG4nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgKz0gJ05vIEVuZERvY2tpbmc8YnIgLz5cXG4nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblRyYW5zaXRpb25Eb2NraW5nTWFuYWdlci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciAkdHJhbnNpdGlvbkdyb3VwID0gdGhpcy50cmFuc2l0aW9uLmdyb3VwLiQoKTtcclxuICAgIHZhciAkc3ZnUm9vdCA9IHRoaXMudHJhbnNpdGlvbi5kaWFncmFtLmdldFJvb3RTVkcoKS4kKCk7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgaWYodGhpcy5zdGFydE5vZGUpIHtcclxuICAgICAgICByZXN1bHRbJ3N0YXJ0Tm9kZSddID0gdGhpcy50cmFuc2l0aW9uLmRpYWdyYW0ubm9kZU1nci52YWxpZGF0ZU5vZGUodGhpcy5zdGFydE5vZGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZighdGhpcy5zdGFydERvY2tpbmcpIHtcclxuICAgICAgICByZXN1bHRbJ3N0YXJ0RG9ja2luZyddID0gJ0Vycm9yOiBObyBzdGFydERvY2tpbmcgc2V0ISc7XHJcbiAgICB9IGVsc2UgaWYodGhpcy5zdGFydERvY2tpbmcua25vYikge1xyXG4gICAgICAgIHZhciBzdGFydERvY2tpbmcgPSAkdHJhbnNpdGlvbkdyb3VwLmZpbmQoJyMnK3RoaXMuc3RhcnREb2NraW5nLmtub2Iubm9kZS5pZCk7XHJcbiAgICAgICAgaWYoIXN0YXJ0RG9ja2luZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0WydzdGFydERvY2tpbmcnXSA9ICdFcnJvcjogc3RhcnREb2NraW5nIG5vdCBmb3VuZCBpbiB0cmFuc2l0aW9uIGdyb3VwJztcclxuICAgICAgICB9IGVsc2UgaWYoJHRyYW5zaXRpb25Hcm91cC5jaGlsZHJlbignLm9yaWVudGF0aW9uS25vYi5zdGFydCcpLmxlbmd0aCAhPSAxKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFsnc3RhcnREb2NraW5nJ10gPSAnRXJyb3I6IGZvdW5kIGludmFsaWQgYW1vdW50IG9mIHN0YXJ0ZG9ja2luZyBub2Rlcyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuZW5kTm9kZSkge1xyXG4gICAgICAgIHJlc3VsdFsnZW5kTm9kZSddID0gdGhpcy50cmFuc2l0aW9uLmRpYWdyYW0ubm9kZU1nci52YWxpZGF0ZU5vZGUodGhpcy5lbmROb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZighdGhpcy5lbmREb2NraW5nKSB7XHJcbiAgICAgICAgcmVzdWx0WydlbmREb2NraW5nJ10gPSAnRXJyb3I6IE5vIGVuZERvY2tpbmcgc2V0ISc7XHJcbiAgICB9IGVsc2UgaWYodGhpcy5lbmREb2NraW5nLmtub2IpIHtcclxuICAgICAgICB2YXIgZW5kRG9ja2luZyA9ICR0cmFuc2l0aW9uR3JvdXAuZmluZCgnIycrdGhpcy5lbmREb2NraW5nLmtub2Iubm9kZS5pZCk7XHJcbiAgICAgICAgaWYoIWVuZERvY2tpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFsnZW5kRG9ja2luZyddID0gJ0Vycm9yOiBlbmREb2NraW5nIG5vdCBmb3VuZCBpbiB0cmFuc2l0aW9uIGdyb3VwJztcclxuICAgICAgICB9IGVsc2UgaWYoJHRyYW5zaXRpb25Hcm91cC5jaGlsZHJlbignLm9yaWVudGF0aW9uS25vYi5zdGFydCcpLmxlbmd0aCAhPSAxKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFsnZW5kRG9ja2luZyddID0gJ0Vycm9yOiBmb3VuZCBpbnZhbGlkIGFtb3VudCBvZiBlbmREb2NraW5nIG5vZGVzJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uRG9ja2luZ01hbmFnZXI7IiwiLyoqXHJcbiAqIFRoaXMgbW9kdWxlIG1hbmFnZXMgdGhlIHRyYW5zaXRpb24gZGF0YSBsaWtlIGtub2JzIGFuZCBwYXRoZGF0YS5cclxuICpcclxuICovXHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBLbm9iID0gcmVxdWlyZSgnLi9rbm9iJyk7XHJcbnZhciBEcmFnQWxpZ25tZW50ID0gcmVxdWlyZSgnLi9kcmFnQWxpZ25tZW50Jyk7XHJcbnZhciBldmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcclxuXHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG5cclxudmFyIFRyYW5zaXRpb25Lbm9iTWFuYWdlciA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcbiAgICB0aGlzLmRvY2tpbmdNYW5hZ2VyID0gdHJhbnNpdGlvbi5kb2NraW5nTWFuYWdlcjtcclxuICAgIHRoaXMuZXZlbnQgPSB0cmFuc2l0aW9uLmV2ZW50O1xyXG4gICAgdGhpcy5pbml0KCk7XHJcblxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy50cmFuc2l0aW9uLmFkZGl0aW9uc1sna25vYk1hbmFnZXInXSA9IHtcclxuICAgICAgICBzZXRFbmROb2RlIDogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICB2YXIga25vYiA9ICh0aGF0LmlzSW5pdFN0YXRlKCkpID8gdGhhdC5hZGRLbm9iKG5vZGUuZ2V0Q2VudGVyKCkpIDogdGhhdC5nZXRFbmRLbm9iKCk7XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmtub2IpIHtcclxuICAgICAgICAgICAgICAgIGtub2IuaG92ZXJhYmxlKGZhbHNlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGtub2IuaG92ZXJhYmxlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTdGFydE5vZGUgOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBrbm9iID0gKHRoYXQuaXNJbml0U3RhdGUoKSkgPyB0aGF0LmFkZEtub2Iobm9kZS5nZXRDZW50ZXIoKSwgMCkgOiB0aGF0LmdldFN0YXJ0S25vYigpO1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS5rbm9iKSB7XHJcbiAgICAgICAgICAgICAgICBrbm9iLmhvdmVyYWJsZShmYWxzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrbm9iLmhvdmVyYWJsZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VsZWN0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuaW5hY3RpdmVTdHlsZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzZWxlY3QgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhhdC5oaWRlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBob3ZlciA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LmluYWN0aXZlU3R5bGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhvdmVyT3V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGF0LnRyYW5zaXRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMua25vYnMgPSBbXTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICB2YXIgb2xkU3RhcnRLbm9iID0gdGhpcy50cmFuc2l0aW9uLmZpcnN0Q2hpbGQoJy5zdGFydEtub2InKTtcclxuICAgIHRoaXMuX2FjdGl2YXRlS25vYihvbGRTdGFydEtub2IsIDAsIHRydWUpO1xyXG5cclxuICAgIHZhciBvbGRJbm5lcktub2JzID0gdGhpcy50cmFuc2l0aW9uLmNoaWxkcmVuKCcuaW5uZXJLbm9iJyk7XHJcbiAgICAkLmVhY2gob2xkSW5uZXJLbm9icywgZnVuY3Rpb24oaSwgb2xkSW5uZXJLbm9iKSB7XHJcbiAgICAgICAgdGhhdC5fYWN0aXZhdGVLbm9iKG9sZElubmVyS25vYiwgKGkgKyAxKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgb2xkRW5kS25vYiA9IHRoaXMudHJhbnNpdGlvbi5maXJzdENoaWxkKCcuZW5kS25vYicpO1xyXG4gICAgdGhpcy5fYWN0aXZhdGVLbm9iKG9sZEVuZEtub2IsIHRoaXMua25vYnMubGVuZ3RoLCB0cnVlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuX2FjdGl2YXRlS25vYiA9IGZ1bmN0aW9uKGtub2JTdmcsIGluZGV4LCBpc0JvdW5kYXJ5S25vYikge1xyXG4gICAgdGhpcy5hZGRLbm9iKGtub2JTdmcuZ2V0Q2VudGVyKCksIGluZGV4LCB0cnVlLCBpc0JvdW5kYXJ5S25vYiwga25vYlN2Zyk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmZyZWV6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJC5lYWNoKHRoaXMua25vYnMsIGZ1bmN0aW9uKGluZGV4LCBrbm9iKSB7XHJcbiAgICAgICAga25vYi5mcmVlemUoKTtcclxuICAgICAgICBrbm9iLmNvbmZpZ1snZmlsbC1vcGFjaXR5J10gPSAwO1xyXG4gICAgICAgIGtub2Iuc2hvdygpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLnVuZnJlZXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICAkLmVhY2godGhpcy5rbm9icywgZnVuY3Rpb24oaW5kZXgsIGtub2IpIHtcclxuICAgICAgICBrbm9iLnVuZnJlZXplKCk7XHJcbiAgICAgICAgLy9UT0RPOiB3ZSBzaG91bGQgdXNlIHRoZSBvbGQgY29uZmlnIHZhbHVlIGluc3RlYWQuXHJcbiAgICAgICAga25vYi5jb25maWdbJ2ZpbGwtb3BhY2l0eSddID0gMC41O1xyXG4gICAgICAgIGtub2Iuc2hvdygpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmFkZEtub2IgPSBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgsIGFjdGl2YXRlLCBpc0JvdW5kYXJ5S25vYiwgc3ZnSW5zdGFuY2UpIHtcclxuICAgIHZhciBpbmRleCA9IGluZGV4IHx8IHRoaXMuc2l6ZSgpO1xyXG4gICAgdmFyIGlzQm91bmRhcnlLbm9iID0gKCFhY3RpdmF0ZSk/IHRoaXMuaXNJbml0U3RhdGUoKSA6IGlzQm91bmRhcnlLbm9iO1xyXG4gICAgdmFyIGtub2IgPSB0aGlzLmluaXRLbm9iKGluZGV4LCBwb3NpdGlvbiwgaXNCb3VuZGFyeUtub2IsIHN2Z0luc3RhbmNlKTtcclxuICAgIHRoaXMua25vYnMuc3BsaWNlKGluZGV4LCAwLCBrbm9iKTtcclxuXHJcbiAgICBpZihpbmRleCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnRLbm9iID0ga25vYjtcclxuICAgIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IGlzQm91bmRhcnlLbm9iKSB7XHJcbiAgICAgICAgdGhpcy5lbmRLbm9iID0ga25vYjtcclxuICAgIH1cclxuXHJcbiAgICBpZighYWN0aXZhdGUgJiYgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgIC8vV2UgZG8gbm90IG5lZWQgYXRvIGFkZCBhbiBhZGRpdGlvbmFsIHBhdGhwYXJ0IGZvciB0aGUgZW5kbm9kZTtcclxuICAgICAgICB0aGlzLmdldFBhdGhNYW5hZ2VyKCkuYWRkUGF0aFBhcnQoaW5kZXgsIHBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZighYWN0aXZhdGUpIHtcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb24ucmVkcmF3KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga25vYjtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuaW5pdEtub2IgPSBmdW5jdGlvbihrbm9iSW5kZXgsIHBvc2l0aW9uLCBpc0JvdW5kYXJ5S25vYiwgc3ZnSW5zdGFuY2UpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICB2YXIga25vYkNvbmZpZyA9IHtcclxuICAgICAgICByYWRpdXM6NSxcclxuICAgICAgICBhY3RpdmF0ZTogc3ZnSW5zdGFuY2UsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogIWlzQm91bmRhcnlLbm9iLFxyXG4gICAgICAgIGZpbGw6IGlzQm91bmRhcnlLbm9iID8gJ2dyZWVuJyA6ICdzaWx2ZXInLFxyXG4gICAgICAgIGNzc0NsYXNzOiAoa25vYkluZGV4ID09PSAwKSA/ICdzdGFydEtub2InIDogKGlzQm91bmRhcnlLbm9iKSA/ICdlbmRLbm9iJyA6ICdpbm5lcktub2InXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBrbm9iID0gbmV3IEtub2IodGhpcy50cmFuc2l0aW9uLmRpYWdyYW0sIHBvc2l0aW9uLCBrbm9iQ29uZmlnLCB0aGlzLnRyYW5zaXRpb24uZ3JvdXApO1xyXG4gICAga25vYi50cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uO1xyXG4gICAgdmFyIGluaXRpYWxEcmFnID0gdHJ1ZTtcclxuXHJcbiAgICBpZighaXNCb3VuZGFyeUtub2IpIHtcclxuICAgICAgICBrbm9iLmRyYWdnYWJsZSh7XHJcbiAgICAgICAgICAgIGRyYWdBbGlnbm1lbnQgOiBuZXcgRHJhZ0FsaWdubWVudCh0aGF0LnRyYW5zaXRpb24uZGlhZ3JhbSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gW3tzb3VyY2U6IFtrbm9iLnBvc2l0aW9uKCldLCB0YXJnZXQ6IHRoYXQuZ2V0Sm9pbmluZ09yaWVudGF0aW9uKGtub2IpfV07fSksXHJcbiAgICAgICAgICAgIGRyYWdNb3ZlIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvL1dlIGp1c3QgdXBkYXRlIGJvdW5kYXJ5IGtub2JzIGlmIHRoZXkgYXJlIG5vdCBpbiB3aXRoaW4gbXVsdGlzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmKCEodGhhdC50cmFuc2l0aW9uLmRpYWdyYW0uaXNNdWx0aVNlbGVjdGlvbigpICYmIHRoYXQuaXNCb3VuZGFyeUluZGV4KGtub2JJbmRleCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVLbm9iKHRoYXQuZ2V0SW5kZXhGb3JLbm9iKGtub2IpLCBrbm9iLnBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbi51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ0VuZCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYoaW5pdGlhbERyYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnRyYW5zaXRpb24uZXhlYygna25vYl9hZGQnLCBba25vYkluZGV4LCBrbm9iLnBvc2l0aW9uKCldKTtcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsRHJhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnRyYW5zaXRpb24uZXhlYygna25vYl9kcm9wJywgW2tub2JJbmRleCwga25vYi5wb3NpdGlvbigpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAga25vYi5kcmFnZ2FibGUoe1xyXG4gICAgICAgICAgICBwcmV2ZW50QWxpZ25tZW50IDogdHJ1ZSxcclxuICAgICAgICAgICAgZHJhZ01vdmUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vV2UganVzdCB1cGRhdGUgYm91bmRhcnkga25vYnMgaWYgdGhleSBhcmUgbm90IGluIHdpdGhpbiBtdWx0aXNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgaWYoIXRoYXQudHJhbnNpdGlvbi5kaWFncmFtLmlzTXVsdGlTZWxlY3Rpb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2V0UGF0aE1hbmFnZXIoKS51cGRhdGVQYXJ0KHRoYXQuZ2V0SW5kZXhGb3JLbm9iKGtub2IpLCBrbm9iLnBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbi5yZWRyYXcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ0VuZCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBjdXJyZW50bHkgdGhlIGdldE5vZGVCeVBvc2l0aW9uIGZ1bmN0aW9uIGRvZXMgcmV0dXJuIHRoZSBmaXJzdCBub2RlIGZvdW5kIG5vdCB0aGUgb25lIHdpdGggdGhlIGhpZ2hlc3QgaW5kZXguLi5cclxuICAgICAgICAgICAgICAgIHZhciBob3Zlck5vZGUgPSB0aGF0LnRyYW5zaXRpb24uZGlhZ3JhbS5nZXROb2RlQnlQb3NpdGlvbihrbm9iLnBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYoa25vYkluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbi5zZXRFbmROb2RlKGhvdmVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbi5zZXRTdGFydE5vZGUoaG92ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGtub2Iub24oJ2Rlc2VsZWN0JywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgaWYodGhhdC50cmFuc2l0aW9uLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIGtub2IuaW5hY3RpdmVTdHlsZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGtub2IuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGtub2Iub24oJ3JlbW92ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoYXQucmVtb3ZlS25vYihrbm9iKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vVG8gcHJldmVudCBoaWRpbmcgdGhlIGhvdmVya25vYnMgd2UgYWRvYnQgdGhlIHRyYW5zaXRpb24gaG92ZXJpbmdcclxuICAgIGtub2IuaG92ZXJhYmxlKHtcclxuICAgICAgICBpbiA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LnRyYW5zaXRpb24uaG92ZXIoKTtcclxuICAgICAgICAgICAgaWYoIWtub2IuaXNTZWxlY3RlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBrbm9iLmZpbGwoJyM5RTlFOUUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQudHJhbnNpdGlvbi5ob3Zlck91dCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBrbm9iO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFwaSBjYWxsIGZvciBtb3ZpbmcgdHJhbnNpdGlvbiBrbm9ic1xyXG4gKi9cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5tb3ZlS25vYiA9IGZ1bmN0aW9uKGtub2IsIGR4LCBkeSkge1xyXG4gICAgLy9UT0RPOiBwcmV2ZW50IHJlZHVuZGFuY3kgd2l0aCBldnQgZHJpdmVuIGFwcHJhb2NoXHJcbiAgICB2YXIga25vYiA9IChrbm9iLm5vZGUpID8ga25vYiA6IHRoaXMuZ2V0S25vYihrbm9iKTtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGb3JLbm9iKGtub2IpO1xyXG4gICAga25vYi5tb3ZlKGR4LGR5KTtcclxuICAgIC8vVE9ETzogbm90IHZlcnkgY2xlYW4uLi4gaXMgdXNlZCBmb3IgdHJhY2luZyBhcGkgbW92ZSBjYWxscy4uLiB0cmFuc2l0aW9uTWFuYWdlciBDTURfS05PQl9EUk9QIGNvbW1hbmRcclxuICAgIGtub2Iubm9kZS5yb290LmR4U3VtID0gZHg7XHJcbiAgICBrbm9iLm5vZGUucm9vdC5keVN1bSA9IGR5O1xyXG4gICAgdmFyIG5ld1Bvc3Rpb24gPSBrbm9iLnBvc2l0aW9uKCk7XHJcbiAgICB0aGlzLmdldFBhdGhNYW5hZ2VyKCkudXBkYXRlUGFydChpbmRleCwgbmV3UG9zdGlvbik7XHJcbiAgICB0aGlzLnRyYW5zaXRpb24udXBkYXRlKCk7XHJcbiAgICB0aGlzLnRyYW5zaXRpb24uZXhlYygna25vYl9kcm9wJywgW2luZGV4LCBuZXdQb3N0aW9uXSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLm1vdmVJbm5lcktub2JzID0gZnVuY3Rpb24oZGlzdGFuY2UpIHtcclxuICAgICQuZWFjaCh0aGlzLmdldElubmVyS25vYnMoKSwgZnVuY3Rpb24oaSwga25vYikge1xyXG4gICAgICAgIGtub2IudHJpZ2dlckRyYWcoZGlzdGFuY2UueCwgZGlzdGFuY2UueSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuc2VsZWN0SW5uZXJLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJC5lYWNoKHRoaXMuZ2V0SW5uZXJLbm9icygpLCBmdW5jdGlvbihpLCBrbm9iKSB7XHJcbiAgICAgICAga25vYi5zZWxlY3QodHJ1ZSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgJC5lYWNoKHRoaXMuZ2V0SW5uZXJLbm9icygpLCBmdW5jdGlvbihpbmRleCwga25vYikge1xyXG4gICAgICAgIGlmKGtub2IuaXNTZWxlY3RlZCgpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtub2IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtnZXRcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0SW5uZXJLbm9icyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yKHZhciBpID0gMTsgaSA8IHRoaXMua25vYnMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5rbm9ic1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5pc0luaXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpIDwgMjtcclxufVxyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTdGFydEtub2IgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgdGhpcy51cGRhdGVLbm9iKDAsIHBvc2l0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUudXBkYXRlRW5kS25vYiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUtub2IoLTEsIHBvc2l0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUudXBkYXRlS25vYiA9IGZ1bmN0aW9uKGtub2JJbmRleCwgcG9zaXRpb24pIHtcclxuICAgIGtub2JJbmRleCA9IG9iamVjdC5nZXRJbmRleCh0aGlzLmtub2JzLCBrbm9iSW5kZXgpO1xyXG5cclxuICAgIC8vIE5vdGUgdGhlIGZvbGxvd2luZyBpcyBvbmx5IG5lY2Nlc3NhcnkgZm9yIGJvdW5kYXJ5IGtub2JzIGJ1dCB3b24ndCBhZmZlY3Qgb3RoZXIga25vYnMgc2luY2UgdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgICAvLyBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBrbm9iIHBvc2l0aW9uIGFmdGVyIGRyYWcuXHJcbiAgICB0aGlzLmtub2JzW2tub2JJbmRleF0ubW92ZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBwYXRoXHJcbiAgICB0aGlzLmdldFBhdGhNYW5hZ2VyKCkudXBkYXRlUGFydChrbm9iSW5kZXgsIHBvc2l0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlS25vYiA9IGZ1bmN0aW9uKGtub2IpIHtcclxuICAgIGlmKCF0aGlzLnRyYW5zaXRpb24ucmVtb3ZlZCkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGb3JLbm9iKGtub2IpO1xyXG4gICAgICAgIGlmKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMua25vYnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB0aGlzLmdldFBhdGhNYW5hZ2VyKCkucmVtb3ZlUGF0aFBhcnQoaW5kZXgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbi51cGRhdGUoKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMua25vYnMubGVuZ3RoO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5sYXN0SW5kZXggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNpemUoKSAtIDE7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmhhc0lubmVyS25vYnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmtub2JzLmxlbmd0aCA+IDI7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5rbm9icywgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZURvY2tpbmdNYXJrZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudHJhbnNpdGlvbi5ncm91cC4kKCkuY2hpbGRyZW4oJy5kb2NraW5nJykucmVtb3ZlKCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmlzQm91bmRhcnlLbm9iID0gZnVuY3Rpb24oa25vYikge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNCb3VuZGFyeUluZGV4KHRoaXMuZ2V0SW5kZXhGb3JLbm9iKGtub2IpKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuaXNCb3VuZGFyeUluZGV4ID0gZnVuY3Rpb24oa25vYkluZGV4KSB7XHJcbiAgICByZXR1cm4ga25vYkluZGV4ID09PSAwIHx8IGtub2JJbmRleCA9PT0gdGhpcy5sYXN0SW5kZXgoKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0S25vYnNCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgIHJldHVybiBbdGhpcy5rbm9ic1tpbmRleCAtIDFdLCB0aGlzLmtub2JzW2luZGV4XV07XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmdldEpvaW5pbmdPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKGtub2IpIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGb3JLbm9iKGtub2IpO1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgaWYoaW5kZXggPD0gMSkgeyAvL3N0YXJ0IG9yIHNlY29uZCBkb2NraW5nXHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy50cmFuc2l0aW9uLmRvY2tpbmdNYW5hZ2VyLnN0YXJ0RG9ja2luZy5wb3NpdGlvbigpKTtcclxuICAgIH0gZWxzZSBpZihpbmRleCAhPT0gMCl7XHJcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5rbm9ic1tpbmRleCAtIDFdLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goe3ggOiBvcmllbnRhdGlvbi54LCB5IDogb3JpZW50YXRpb24ueX0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKGluZGV4ID49IHRoaXMua25vYnMubGVuZ3RoIC0yKSB7IC8vZW5kIG9yIG9uZSBiZWZvcmUgZW5kIGRvY2tpbmdcclxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnRyYW5zaXRpb24uZG9ja2luZ01hbmFnZXIuZW5kRG9ja2luZy5wb3NpdGlvbigpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5rbm9ic1tpbmRleCArIDFdLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goe3ggOiBvcmllbnRhdGlvbi54LCB5IDogb3JpZW50YXRpb24ueX0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmdldEluZGV4Rm9yS25vYiA9IGZ1bmN0aW9uKGtub2IpIHtcclxuICAgIHJldHVybiB0aGlzLmtub2JzLmluZGV4T2Yoa25vYik7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmdldEtub2JQb3NpdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMua25vYnMsIGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLnBvc2l0aW9uKCkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGFydEtub2IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldEtub2IoMCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmdldEVuZEtub2IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldEtub2IoLTEpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0S25vYigwKS5wb3NpdGlvbigpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldEtub2IoLTEpLnBvc2l0aW9uKCk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLmdldEtub2IgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgcmV0dXJuIG9iamVjdC52YWx1ZUJ5SW5kZXgodGhpcy5rbm9icywgaW5kZXgpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLmtub2JzLCBmdW5jdGlvbihpbmRleCwga25vYikge1xyXG4gICAgICAgIGlmKCFrbm9iLmlzU2VsZWN0ZWQoKSkge1xyXG4gICAgICAgICAgICBrbm9iLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuaW5hY3RpdmVTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5rbm9icywgZnVuY3Rpb24oaW5kZXgsIGtub2IpIHtcclxuICAgICAgICBpZigha25vYi5pc1NlbGVjdGVkKCkpIHtcclxuICAgICAgICAgICAga25vYi5pbmFjdGl2ZVN0eWxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLm93bnNLbm9iTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgIHJldHVybiBub2RlLnJvb3QuJCgpLnBhcmVudCgpLmF0dHIoJ2lkJykgPT09IHRoaXMudHJhbnNpdGlvbi5ncm91cC4kKCkuYXR0cignaWQnKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgaWYoaW5kZXggPCB0aGlzLnNpemUoKSkge1xyXG4gICAgICAgIHJldHVybiBvYmplY3QudmFsdWVCeUluZGV4KHRoaXMua25vYnMsIGluZGV4KS5wb3NpdGlvbigpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5nZXRQYXRoTWFuYWdlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5wYXRoTWFuYWdlcjtcclxufTtcclxuXHJcblRyYW5zaXRpb25Lbm9iTWFuYWdlci5wcm90b3R5cGUuaXNJbml0U3RhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAhdGhpcy5lbmRLbm9iO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbktub2JNYW5hZ2VyLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJ0tub2JNYW5hZ2VyIC0gJyt0aGlzLmtub2JzLmxlbmd0aCsnPGJyIC8+JztcclxuICAgIG9iamVjdC5lYWNoKHRoaXMua25vYnMsIGZ1bmN0aW9uKGluZGV4LCBrbm9iKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9ICdbJytpbmRleCsnXSgnK2tub2IucG9zaXRpb24oKS54KycvJytrbm9iLnBvc2l0aW9uKCkueSsnKTxiciAvPic7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uS25vYk1hbmFnZXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgJHRyYW5zaXRpb25Hcm91cCA9IHRoaXMudHJhbnNpdGlvbi5ncm91cC4kKCk7XHJcbiAgICB2YXIgJHN2Z1Jvb3QgPSB0aGlzLnRyYW5zaXRpb24uZGlhZ3JhbS5nZXRSb290U1ZHKCkuJCgpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIGlmKHRoaXMuaXNJbml0U3RhdGUoKSkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5rbm9icyA8IDIpIHtcclxuICAgICAgICByZXN1bHRbJ2tub2JDb3VudCddID0gJ1RvbyBsZXNzIGtub2JzIGZvdW5kISc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIXRoaXMuc3RhcnRLbm9iKSB7XHJcbiAgICAgICAgcmVzdWx0WydzdGFydEtub2InXSA9ICdObyBzdGFydEtub2IgZm91bmQhJztcclxuICAgIH0gZWxzZSBpZighJHRyYW5zaXRpb25Hcm91cC5maW5kKCcjJyt0aGlzLnN0YXJ0S25vYi5ub2RlLmlkKS5sZW5ndGgpIHtcclxuICAgICAgICByZXN1bHRbJ3N0YXJ0S25vYiddID0gJ05vIHN0YXJ0S25vYiBmb3VuZCBpbiB0cmFuc2l0aW9uIGdyb3VwISc7XHJcbiAgICB9IGVsc2UgaWYoJHRyYW5zaXRpb25Hcm91cC5maW5kKCcuc3RhcnRLbm9iJykubGVuZ3RoICE9IDEpIHtcclxuICAgICAgICByZXN1bHRbJ3N0YXJ0S25vYiddID0gJ0ludmFsaWQgc3RhcnRLbm9iIGFtb3VudCBmb3VuZCBpbiB0cmFuc2l0aW9uIGdyb3VwISc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlubmVyS25vYnMgPSB0aGlzLmdldElubmVyS25vYnMoKTtcclxuICAgIHZhciAkaW5uZXJLbm9icyA9ICR0cmFuc2l0aW9uR3JvdXAuZmluZCgnLmlubmVyS25vYicpO1xyXG4gICAgaWYoaW5uZXJLbm9icy5sZW5ndGggIT0gJGlubmVyS25vYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmVzdWx0Wydpbm5lcktub2JzJ10gPSAnSW52YWxpZCBhbW91bnQgb2YgaW5uZXJLbm9icyBmb3VuZCBpbiB0cmFuc2l0aW9uIGdyb3VwISc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoIXRoaXMuZW5kS25vYikge1xyXG4gICAgICAgIHJlc3VsdFsnZW5kS25vYiddID0gJ05vIGVuZEtub2IgZm91bmQhJztcclxuICAgIH0gZWxzZSBpZighJHRyYW5zaXRpb25Hcm91cC5maW5kKCcjJyt0aGlzLmVuZEtub2Iubm9kZS5pZCkubGVuZ3RoKSB7XHJcbiAgICAgICAgcmVzdWx0WydlbmRLbm9iJ10gPSAnTm8gc3RhcnRLbm9iIGZvdW5kIGluIHRyYW5zaXRpb24gZ3JvdXAhJztcclxuICAgIH0gZWxzZSBpZigkdHJhbnNpdGlvbkdyb3VwLmZpbmQoJy5lbmRLbm9iJykubGVuZ3RoICE9IDEpIHtcclxuICAgICAgICByZXN1bHRbJ2VuZEtub2InXSA9ICdJbnZhbGlkIGVuZEtub2IgYW1vdW50IGZvdW5kIGluIHRyYW5zaXRpb24gZ3JvdXAhJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uS25vYk1hbmFnZXI7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciB4bWwgPSByZXF1aXJlKCcuLi91dGlsL3htbCcpO1xyXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50Jyk7XHJcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb3JlL2NvbmZpZycpO1xyXG52YXIgVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbicpO1xyXG5cclxudmFyIEFic3RyYWN0TWFuYWdlciA9IHJlcXVpcmUoJy4vYWJzdHJhY3RNYW5hZ2VyJyk7XHJcblxyXG52YXIgRVZUX1RSQU5TSVRJT05fQURERUQgPSBcInRyYW5zaXRpb25fYWRkZWRcIjtcclxudmFyIEVWVF9UUkFOU0lUSU9OX1NFTEVDVEVEID0gJ3RyYW5zaXRpb25fc2VsZWN0ZWQnO1xyXG52YXIgRVZUX1RSQU5TSVRJT05fREVTRUxFQ1RFRCA9ICd0cmFuc2l0aW9uX2Rlc2VsZWN0ZWQnO1xyXG52YXIgRVZUX1RSQU5TSVRJT05fUkVNT1ZFRCA9ICd0cmFuc2l0aW9uX3JlbW92ZWQnO1xyXG5cclxudmFyIENNRF9BREQgPSBcInRyYW5zaXRpb25fYWRkXCI7XHJcbnZhciBDTURfREVMID0gXCJ0cmFuc2l0aW9uX2RlbGV0ZVwiO1xyXG52YXIgQ01EX0tOT0JfQUREID0gXCJ0cmFuc2l0aW9uX2tub2JfYWRkZWRcIjtcclxudmFyIENNRF9LTk9CX0RST1AgPSBcInRyYW5zaXRpb25fa25vYl9kcm9wcGVkXCI7XHJcbnZhciBDTURfRURJVCA9IFwidHJhbnNpdGlvbl9lZGl0XCI7XHJcblxyXG52YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICAvLyBDb250YWlucyBhbGwgbm9kZXMgYWRkZWQgdG8gdGhlIGRpYWdyYW1cclxuICAgIEFic3RyYWN0TWFuYWdlci5jYWxsKHRoaXMsIGRpYWdyYW0pO1xyXG5cclxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB7fTtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IGRpYWdyYW07XHJcbiAgICBldmVudC5saXN0ZW4oJ3RyYW5zaXRpb25fZGVsZXRlJywgdGhpcy5kZWxldGVUcmFuc2l0aW9uTGlzdGVuZXIsIHRoaXMpO1xyXG4gICAgZXZlbnQubGlzdGVuKCd0cmFuc2l0aW9uX2VkaXQnLCB0aGlzLmVkaXRUcmFuc2l0aW9uTGlzdGVuZXIsIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY29tbWFuZChDTURfQURELCB0aGlzLmltcG9ydFRyYW5zaXRpb24sIHRoaXMuZGVsZXRlVHJhbnNpdGlvbik7XHJcbiAgICB0aGlzLmNvbW1hbmQoQ01EX0RFTCwgdGhpcy5kZWxldGVUcmFuc2l0aW9uLCB0aGlzLmltcG9ydFRyYW5zaXRpb24pO1xyXG4gICAgdGhpcy5jb21tYW5kKENNRF9LTk9CX0FERCwgdGhpcy5hZGRLbm9iLCB0aGlzLmRlbGV0ZUtub2IpO1xyXG4gICAgdGhpcy5jb21tYW5kKENNRF9LTk9CX0RST1AsIHRoaXMuZHJvcERvY2tpbmcsIHRoaXMuZHJvcERvY2tpbmcpO1xyXG4gICAgdGhpcy5jb21tYW5kKENNRF9FRElULCB0aGlzLmVkaXRUcmFuc2l0aW9uLCB0aGlzLnVuZG9FZGl0KTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoVHJhbnNpdGlvbk1hbmFnZXIsIEFic3RyYWN0TWFuYWdlcik7XHJcblxyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBvYmplY3Quc2l6ZSh0aGlzLnRyYW5zaXRpb25zKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5lZGl0VHJhbnNpdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuZ2V0VHJhbnNpdGlvbihldnQuZGF0YS50cmFuc2l0aW9uKTtcclxuICAgIHZhciBrZXkgPSBldnQuZGF0YS5rZXk7XHJcbiAgICB2YXIgb2xkVmFsdWUgPSB0cmFuc2l0aW9uLmFkZGl0aW9ucy5lZGl0LmdldFZhbHVlKGtleSk7XHJcbiAgICB0aGlzLmV4ZWMoQ01EX0VESVQsIFt0cmFuc2l0aW9uLmlkLCBrZXksIGV2dC5kYXRhLnZhbHVlXSwgW3RyYW5zaXRpb24uaWQsIGtleSwgb2xkVmFsdWVdKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5lZGl0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRyYW5zaXRpb24sIGtleSwgdmFsdWUpIHtcclxuICAgIHRyYW5zaXRpb24gPSB0aGlzLmdldFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbiAgICB0cmFuc2l0aW9uLmFkZGl0aW9ucy5lZGl0LnNldFZhbHVlKGtleSwgdmFsdWUpO1xyXG4gICAgZXZlbnQudHJpZ2dlcigndHJhbnNpdGlvbl9lZGl0ZWQnLCB0cmFuc2l0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS51bmRvRWRpdCA9IGZ1bmN0aW9uKHRyYW5zaXRpb24sIGtleSwgdmFsdWUpIHtcclxuICAgIHRyYW5zaXRpb24gPSB0aGlzLmdldFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbiAgICBpZighdHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRyYW5zaXRpb24uYWRkaXRpb25zLmVkaXQuc2V0VmFsdWUoa2V5LCB2YWx1ZSk7XHJcbiAgICBldmVudC50cmlnZ2VyKCd0cmFuc2l0aW9uX2VkaXRfdW5kbycsIHRyYW5zaXRpb24pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmltcG9ydFRyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uU3RyLCBjZmcpIHtcclxuICAgIHZhciBjZmcgPSBjZmcgfHwge307XHJcblxyXG4gICAgLy9JZiBzZXQgd2UgcmVwbGFjZSB0aGUgb2xkIG5vZGUgaWQgd2l0aCBhIG5ldyBvbmUgZS5nLiB3aGVuIHdlIGNvcHkgYSBub2RlXHJcbiAgICBpZihjZmcubmV3SWQgJiYgY2ZnLm9sZElkKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvblN0ciA9IHRyYW5zaXRpb25TdHIucmVwbGFjZShuZXcgUmVnRXhwKGNmZy5vbGRJZCwgJ2cnKSwgY2ZnLm5ld0lkKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHJhbnNpdGlvbkVsZW1lbnQgPSB0aGlzLmRpYWdyYW0uaW1wb3J0KHRyYW5zaXRpb25TdHIpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVUcmFuc2l0aW9uKHRyYW5zaXRpb25FbGVtZW50KTtcclxufTtcclxuXHJcbnZhciBfc29ydEFjdGl2YXRpb25UcmFuc2l0aW9uID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgdmFyICR0QSA9ICQoYSk7XHJcbiAgICB2YXIgJHRCID0gJChiKTtcclxuXHJcbiAgICB2YXIgc3RhcnRBID0gJHRBLmF0dHIoJ2RhbGE6c3RhcnQnKTtcclxuICAgIHZhciBzdGFydEIgPSAkdEIuYXR0cignZGFsYTpzdGFydCcpO1xyXG5cclxuICAgIHZhciBlbmRBID0gJHRBLmF0dHIoJ2RhbGE6ZW5kJyk7XHJcbiAgICB2YXIgZW5kQiA9ICR0Qi5hdHRyKCdkYWxhOmVuZCcpO1xyXG5cclxuICAgIGlmKCR0QS5maW5kKCcjJytzdGFydEIpLmxlbmd0aCB8fCAkdEEuZmluZCgnIycrZW5kQikubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSBlbHNlIGlmKCR0Qi5maW5kKCcjJytzdGFydEEpLmxlbmd0aCB8fCAkdEIuZmluZCgnIycrZW5kQSkubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRvQWN0aXZhdGUpIHtcclxuICAgIGlmKG9iamVjdC5pc0FycmF5KHRvQWN0aXZhdGUpIHx8IG9iamVjdC5pc0pRdWVyeSh0b0FjdGl2YXRlKSkge1xyXG4gICAgICAgIHRvQWN0aXZhdGUuc29ydChfc29ydEFjdGl2YXRpb25UcmFuc2l0aW9uKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG9iamVjdC5lYWNoKHRvQWN0aXZhdGUsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmFjdGl2YXRlVHJhbnNpdGlvbigkKHRoaXMpLmdldCgwKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGVsc2UgIHsgLy90b0FjdGl2YXRlIGlzIGRvbUVsZW1lbnRcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRUcmFuc2l0aW9uKG5ldyBUcmFuc2l0aW9uKHRoaXMuZGlhZ3JhbSwgdG9BY3RpdmF0ZSkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmlzRHJhZ1RyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gb2JqZWN0LmlzRGVmaW5lZCh0aGlzLmRyYWdUcmFuc2l0aW9uKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydERyYWdUcmFuc2l0aW9uID0gZnVuY3Rpb24obm9kZSwgbW91c2UpIHtcclxuICAgIG1vdXNlID0gbW91c2UgfHwgbm9kZS5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICB2YXIgY2ZnID0gJC5leHRlbmQoe30sIGNvbmZpZy52YWwoJ3RyYW5zaXRpb25fc2V0dGluZ3MnLCB7fSkpO1xyXG4gICAgLy9UT0RPOiBjaGVjayBmb3Igbm9kZS90ZW1wbGF0ZSBwcmVmZXJlZC90cmFuc2l0aW9uICsgdHJhbnNpdGlvbmNvbmZpZ3VyYXRpb24gcHJlZmVyIHRlbXBsYXRlIG9yIHNldHRpbmdzXHJcbiAgICByZXR1cm4gdGhpcy5kcmFnVHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKG5vZGUsIG1vdXNlLCBjZmcpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldERyYWdUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnVHJhbnNpdGlvbjtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5lbmREcmFnVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5hZGRUcmFuc2l0aW9uKHRoaXMuZHJhZ1RyYW5zaXRpb24pO1xyXG4gICAgZGVsZXRlIHRoaXMuZHJhZ1RyYW5zaXRpb247XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuZXZlbnQudHJpZ2dlcihFVlRfVFJBTlNJVElPTl9BRERFRCwgdHJhbnNpdGlvbik7XHJcblxyXG4gICAgdHJhbnNpdGlvbi5vbignc2VsZWN0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhhdC5ldmVudC50cmlnZ2VyKEVWVF9UUkFOU0lUSU9OX1NFTEVDVEVELCB0cmFuc2l0aW9uKTtcclxuICAgIH0pLm9uKCdkZXNlbGVjdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoYXQuZXZlbnQudHJpZ2dlcihFVlRfVFJBTlNJVElPTl9ERVNFTEVDVEVELCB0cmFuc2l0aW9uKTtcclxuICAgIH0pLm9uKCdyZW1vdmUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGF0LmV2ZW50LnRyaWdnZXIoRVZUX1RSQU5TSVRJT05fUkVNT1ZFRCwgdHJhbnNpdGlvbik7XHJcbiAgICB9KS5vbigna25vYl9hZGQnLCBmdW5jdGlvbihldnQgLCBrbm9iSW5kZXgsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhhdC5hZGRDbWQoQ01EX0tOT0JfQURELCBbdHJhbnNpdGlvbi5pZCwga25vYkluZGV4LCBwb3NpdGlvbl0sIFt0cmFuc2l0aW9uLCBrbm9iSW5kZXhdKTtcclxuICAgIH0pLm9uKCdrbm9iX2Ryb3AnLCBmdW5jdGlvbihldnQgLCBrbm9iSW5kZXgpIHtcclxuICAgICAgICB2YXIga25vYiA9IHRyYW5zaXRpb24ua25vYk1hbmFnZXIuZ2V0S25vYihrbm9iSW5kZXgpO1xyXG4gICAgICAgIC8vVE9ETzogcGVyaGFwcyByYXRoZXIgdXNlIGRyYWdDb250ZXh0IG5vdGU6IGFwaSBjYWxsIGluIHRyYW5zaXRpb25rbm9ibWFuYWdlclxyXG4gICAgICAgIHRoYXQuYWRkQ21kKENNRF9LTk9CX0RST1AsXHJcbiAgICAgICAgICAgIFt0cmFuc2l0aW9uLmlkLCBrbm9iSW5kZXgsIGtub2Iubm9kZS5yb290LmR4U3VtLCBrbm9iLm5vZGUucm9vdC5keVN1bV0sXHJcbiAgICAgICAgICAgIFt0cmFuc2l0aW9uLmlkLCBrbm9iSW5kZXgsICgtMSAqIGtub2Iubm9kZS5yb290LmR4U3VtKSwgKC0xICoga25vYi5ub2RlLnJvb3QuZHlTdW0pXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmFkZENtZChDTURfQURELCBbdGhpcy5nZXRUcmFuc2l0aW9uU3RyaW5nKHRyYW5zaXRpb24pXSwgW3RyYW5zaXRpb24uaWRdKTtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zW3RyYW5zaXRpb24uaWRdID0gdHJhbnNpdGlvbjtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRLbm9iID0gZnVuY3Rpb24odHJhbnNpdGlvbiwga25vYkluZGV4LCBwb3NpdGlvbikge1xyXG4gICAgdGhpcy5nZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pLmFkZEtub2IocG9zaXRpb24sa25vYkluZGV4KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVLbm9iID0gZnVuY3Rpb24odHJhbnNpdGlvbiwgZG9ja2luZ0luZGV4KSB7XHJcbiAgICB0aGlzLmdldFRyYW5zaXRpb24odHJhbnNpdGlvbikua25vYk1hbmFnZXIuZ2V0S25vYihkb2NraW5nSW5kZXgpLnJlbW92ZSgpO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmRyb3BEb2NraW5nID0gZnVuY3Rpb24odHJhbnNpdGlvbiwgZG9ja2luZ0luZGV4LCBkeFN1bSwgZHlTdW0pIHtcclxuICAgIHRyYW5zaXRpb24gPSB0aGlzLmdldFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbiAgICBpZih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIGRvY2tpbmcgPSB0cmFuc2l0aW9uLmtub2JNYW5hZ2VyLmdldEtub2IoZG9ja2luZ0luZGV4KTtcclxuICAgICAgICBkb2NraW5nLnRyaWdnZXJEcmFnKGR4U3VtLCBkeVN1bSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUudHJhbnNpdGlvbkRvY2tpbmdDcmVhdGVkID0gZnVuY3Rpb24odHJhbnNpdGlvbiwgZG9ja2luZ0luZGV4KSB7XHJcbiAgICB2YXIgdHJhbnNpdGlvbiA9IGV2dC5kYXRhLnRyYW5zaXRpb247XHJcbiAgICB2YXIgZG9ja2luZ0luZGV4ID0gZXZ0LmRhdGEuZG9ja2luZ0luZGV4O1xyXG5cclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uU3RyaW5nID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xyXG4gICAgdHJhbnNpdGlvbiA9IHRoaXMuZ2V0VHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcclxuICAgIHJldHVybiB4bWwuc2VyaWFsaXplVG9TdHJpbmcodHJhbnNpdGlvbi5pbnN0YW5jZSgpKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVUcmFuc2l0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmKGV2dC5kYXRhKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBldnQuZGF0YTtcclxuICAgICAgICB0aGlzLmV4ZWMoQ01EX0RFTCwgW3RyYW5zaXRpb24uaWRdLCBbdGhpcy5nZXRUcmFuc2l0aW9uU3RyaW5nKHRyYW5zaXRpb24pXSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuZ2V0VHJhbnNpdGlvbihpZCk7XHJcbiAgICBpZih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMudHJhbnNpdGlvbnNbaWRdO1xyXG4gICAgICAgIHRyYW5zaXRpb24ucmVtb3ZlKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICBpZihvYmplY3QuaXNTdHJpbmcoaWQpICYmICFpc05hTihpZCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uc1twYXJzZUludChpZCldO1xyXG4gICAgfSBlbHNlIGlmKCFpc05hTihpZCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uc1tpZF07XHJcbiAgICB9IGVsc2UgaWYoaWQgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgLy9XZSBhc3N1bWUgYSBub2RlIGluc3RhbmNlXHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2dldFRyYW5zaXRpb24gY2FsbCB3aXRoIG5vIHJlc3VsdCBmb3IgOicraWQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSAnPGI+VHJhbnNpdGlvbk1hbmFnZXI8L2I+IC0gJyt0aGlzLnNpemUoKSsnIFRyYW5zaXRpb25zPGJyIC8+XFxuJztcclxuICAgICQuZWFjaCh0aGlzLnRyYW5zaXRpb25zLCBmdW5jdGlvbihpbmRleCwgdHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCArPSB0cmFuc2l0aW9uLmR1bXAoKSsnPGJyIC8+XFxuJztcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgJC5lYWNoKHRoaXMudHJhbnNpdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0Wyd0cmFuc2l0aW9uJyt0cmFuc2l0aW9uLmlkXSA9IHRyYW5zaXRpb24udmFsaWRhdGUoKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbk1hbmFnZXI7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG5cclxudmFyIE5PREVfRElTVEFOQ0UgPSAxMTtcclxudmFyIFRSQU5TSVRJT05fRElTVEFOQ0UgPSAxMDtcclxudmFyIERFRl9URVhUX0hFSUdIVCA9IDEzO1xyXG5cclxudmFyIFRyYW5zaXRpb25UZXh0QWRkaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XHJcbiAgICB0aGlzLnRleHROb2RlcyA9IFtdO1xyXG4gICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IHRoaXMudHJhbnNpdGlvbi5kaWFncmFtO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSB1cGRhdGUgYWRkaXRpb24gZnVuY3Rpb24gcmVyZW5kZXJzIGFsbCBjb250YWluaW5nIHRleHRub2RlcyBieSBtZWFuc1xyXG4gKiBvZiB0aGUgY3VycmVudCB0cmFuc2l0aW9uIHNldHRpbmdzLiBUaGlzIGZ1bmN0aW9uIGlzIGRlbGVnYXRlZCBieVxyXG4gKiB0aGUgdHJhbnNpdGlvbiBhcyBhZGRpdGlvbiBjYWxsLlxyXG4gKi9cclxuVHJhbnNpdGlvblRleHRBZGRpdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLnRleHROb2RlcywgZnVuY3Rpb24oaW5kZXgsIHRleHRTVkcpIHtcclxuICAgICAgICBpZih0ZXh0U1ZHKSB7XHJcbiAgICAgICAgICAgIHRoYXQudXBkYXRlVGV4dFBvc2l0aW9uKGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblRyYW5zaXRpb25UZXh0QWRkaXRpb24ucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIGlmKHRoaXMudGV4dE5vZGVzW3Bvc10pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0Tm9kZXNbcG9zXS4kKCkudGV4dCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIHRleHQgZm9yIGEgZ2l2ZW4gcG9zaXRpb24uIElmIHRoZSBnaXZlbiB0ZXh0IHBvc2l0aW9uIGlzIG5vdFxyXG4gKiBvY2N1cGllZCB5ZXQgd2UgY3JlYXRlIGEgbmV3IHRleHRub2RlLlxyXG4gKi9cclxuVHJhbnNpdGlvblRleHRBZGRpdGlvbi5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHBvcywgdGV4dCkge1xyXG4gICAgaWYoIXRoaXMudGV4dE5vZGVzW3Bvc10pIHtcclxuICAgICAgICB2YXIgaWQgPSAndGV4dCcrcG9zKydfJyt0aGlzLnRyYW5zaXRpb24uaWQ7XHJcbiAgICAgICAgdmFyIHRleHROb2RlID0gdGhpcy50ZXh0Tm9kZXNbcG9zXSA9IHRoaXMuZGlhZ3JhbS5zdmcudGV4dCh0ZXh0LCB7aWQgOiBpZH0pLmhhbmdpbmcoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuZGlhZ3JhbS5zdmcuYWRkVG9Hcm91cCh0aGlzLnRyYW5zaXRpb24uZ3JvdXAsIHRleHROb2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy50ZXh0Tm9kZXNbcG9zXS5jb250ZW50KHRleHQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy51cGRhdGVUZXh0UG9zaXRpb24ocG9zKTtcclxufTtcclxuXHJcblRyYW5zaXRpb25UZXh0QWRkaXRpb24ucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICQuZWFjaCh0aGlzLnRleHROb2RlcywgZnVuY3Rpb24oaW5kZXgsIHRleHQpIHtcclxuICAgICAgICBpZih0ZXh0KSB7XHJcbiAgICAgICAgICAgIHRleHQuZmlsbCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uVGV4dEFkZGl0aW9uLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICQuZWFjaCh0aGlzLnRleHROb2RlcywgZnVuY3Rpb24oaW5kZXgsIHRleHQpIHtcclxuICAgICAgICBpZih0ZXh0KSB7XHJcbiAgICAgICAgICAgIHRleHQuZm9udFNpemUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvblRleHRBZGRpdGlvbi5wcm90b3R5cGUuc2V0V2VpZ2h0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICQuZWFjaCh0aGlzLnRleHROb2RlcywgZnVuY3Rpb24oaW5kZXgsIHRleHQpIHtcclxuICAgICAgICBpZih0ZXh0KSB7XHJcbiAgICAgICAgICAgIHRleHQuZm9udFdlaWdodCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSB0ZXh0bm9kZSBwb3NpdGlvbiBhbmQgYW5jaG9yIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYnkgbWVhbnMgb2YgdGhlIGN1cnJlbnRcclxuICogdHJhbnNpdGlvbiBzZXR0aW5ncy5cclxuICovXHJcblRyYW5zaXRpb25UZXh0QWRkaXRpb24ucHJvdG90eXBlLnVwZGF0ZVRleHRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXRUZXh0UG9zaXRpb24ocG9zKTtcclxuXHJcbiAgICAvL0ZvciBzb21lIHBvaW50cyB0aGUgcG9zaXRpb24gY2Fubm90IGJlIGRldGVybWluZWQgbWFpbmx5IG9uIHRoZSBub2RlIGNvcm5lclxyXG4gICAgaWYocG9zaXRpb24pIHtcclxuICAgICAgICB0aGlzLnRleHROb2Rlc1twb3NdLm1vdmVUbyhwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5zZXRBbmNob3IocG9zKTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zaXRpb25UZXh0QWRkaXRpb24ucHJvdG90eXBlLmdldFRleHRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgdmFyIHRleHRQb3NpdGlvbjtcclxuXHJcbiAgICB2YXIgdGV4dEhlaWdodCA9IHRoaXMuZ2V0VGV4dEhlaWdodChwb3MpO1xyXG5cclxuICAgIGlmKGlzU3RhcnRQb3MocG9zKSB8fCBpc0VuZFBvcyhwb3MpKSB7XHJcbiAgICAgICAgLy9Nb3ZlIGFsb25nIHRoZSB0cmFuc2l0aW9uIGluIHRoZSByaWdodCBkaXJlY3Rpb24gdGhlIGluZGV4IC0xIHNlYXJjaGVzIHRoZSBsYXN0IHRyYW5zaXRpb25QYXJ0XHJcbiAgICAgICAgdmFyIGluZGV4ID0gaXNFbmRQb3MocG9zKSA/IC0xIDogMTtcclxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpc0VuZFBvcyhwb3MpID8gTk9ERV9ESVNUQU5DRSAqIC0xIDogTk9ERV9ESVNUQU5DRTtcclxuICAgICAgICB0ZXh0UG9zaXRpb24gPSB0aGlzLnRyYW5zaXRpb24uZ2V0UGF0aCgpLm1vdmVBbG9uZyhpbmRleCwgZGlzdGFuY2UpO1xyXG5cclxuICAgICAgICBzd2l0Y2godGhpcy5nZXRMb2NhdGlvbihwb3MpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24ueSArPSAoaXNUb3AocG9zKSkgPyAtVFJBTlNJVElPTl9ESVNUQU5DRSA6IFRSQU5TSVRJT05fRElTVEFOQ0UgKyAodGV4dEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbi54ICs9IChpc1RvcChwb3MpKSA/IFRSQU5TSVRJT05fRElTVEFOQ0UgOiAtVFJBTlNJVElPTl9ESVNUQU5DRTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9NaWQgUG9zaXRpb25cclxuICAgICAgICB0ZXh0UG9zaXRpb24gPSB0aGlzLnRyYW5zaXRpb24uZ2V0UGF0aCgpLmdldENlbnRlcigpO1xyXG4gICAgICAgIHRleHRQb3NpdGlvbi55ICs9IGlzVG9wKHBvcykgPyBUUkFOU0lUSU9OX0RJU1RBTkNFICogLTEgOiBUUkFOU0lUSU9OX0RJU1RBTkNFICsgdGV4dEhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dFBvc2l0aW9uO1xyXG59O1xyXG5cclxuVHJhbnNpdGlvblRleHRBZGRpdGlvbi5wcm90b3R5cGUuZ2V0VGV4dEhlaWdodCA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgcmV0dXJuICh0aGlzLnRleHROb2Rlc1twb3NdKSA/IHRoaXMudGV4dE5vZGVzW3Bvc10uaGVpZ2h0KCkgOiBERUZfVEVYVF9IRUlHSFQ7XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uVGV4dEFkZGl0aW9uLnByb3RvdHlwZS5nZXRBbGlnblBvc2l0aW9uID0gZnVuY3Rpb24ocG9zKSB7XHJcbiAgICBpZihpc1N0YXJ0UG9zKHBvcykpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLnN0YXJ0KCk7XHJcbiAgICB9IGVsc2UgaWYoaXNFbmRQb3MocG9zKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24uZW5kKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2l0aW9uVGV4dEFkZGl0aW9uLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgaWYoaXNTdGFydFBvcyhwb3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5nZXRTdGFydExvY2F0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYoaXNFbmRQb3MocG9zKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24uZ2V0RW5kTG9jYXRpb24oKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgdGhlIHRleHQtYW5jaG9yIGJ5IG1lYW5zIG9mIHRoZSBjdXJyZW50XHJcbiAqIG5vZGUgbG9jYXRpb24gdG8gYXNzdXJlIHRoZSB0ZXh0IGlzIG5vdCBvdmVybGFwcGluZyBvdGhlciB0ZXh0cyBvciB0aGVcclxuICogbm9kZSBpdHNlbGYuXHJcbiAqL1xyXG5UcmFuc2l0aW9uVGV4dEFkZGl0aW9uLnByb3RvdHlwZS5zZXRBbmNob3IgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIHZhciB0ZXh0U1ZHID0gdGhpcy50ZXh0Tm9kZXNbcG9zXTtcclxuICAgIGlmKCFpc01pZFBvcyhwb3MpKSB7XHJcbiAgICAgICAgc3dpdGNoKHRoaXMuZ2V0TG9jYXRpb24ocG9zKSkge1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIHRleHRTVkcuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgdGV4dFNWRy5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICBpZihpc0JvdHRvbShwb3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFNWRy5lbmQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFNWRy5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0ZXh0U1ZHLm1pZGRsZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGlzQm90dG9tID0gZnVuY3Rpb24ocG9zKSB7XHJcbiAgICByZXR1cm4gIWlzVG9wKHBvcyk7XHJcbn07XHJcblxyXG52YXIgaXNUb3AgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIHJldHVybiBwb3MgJSAyID09PSAwO1xyXG59O1xyXG5cclxudmFyIGlzU3RhcnRQb3MgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgIHJldHVybiBwb3MgPCAyO1xyXG59O1xyXG5cclxudmFyIGlzTWlkUG9zID0gZnVuY3Rpb24ocG9zKSB7XHJcbiAgICByZXR1cm4gIWlzU3RhcnRQb3MocG9zKSAmJiAhaXNFbmRQb3MocG9zKTtcclxufTtcclxuXHJcbnZhciBpc0VuZFBvcyA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgcmV0dXJuIHBvcyA+IDM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zaXRpb25UZXh0QWRkaXRpb247XHJcbiIsInZhciB4bWwgPSByZXF1aXJlKCcuLi91dGlsL3htbCcpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIHN0cmluZyA9IHJlcXVpcmUoJy4uL3V0aWwvc3RyaW5nJyk7XHJcblxyXG52YXIgZWxlbWVudENhY2hlID0ge307XHJcblxyXG52YXIgY3JlYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcywgdGV4dCkge1xyXG4gICAgdmFyICRlbGVtZW50ID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpKTtcclxuXHJcbiAgICBpZihhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgJC5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICRlbGVtZW50LmF0dHIoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGV4dCkge1xyXG4gICAgICAgICRlbGVtZW50LnRleHQodGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJGVsZW1lbnQ7XHJcbn07XHJcblxyXG52YXIgcXVlcnkgPSBmdW5jdGlvbihzZWxlY3RvciwgY2FjaGUpIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBpZihjYWNoZSkge1xyXG4gICAgICAgIHJlc3VsdCA9ICQucUNhY2hlKHNlbGVjdG9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gJChzZWxlY3Rvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIGdldEpRdWVyeU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICBpZighbm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIFRoZSBub2RlIGlzIGVpdGhlciBhIGRvbSBub2RlIG9yIGEgc2VsZWN0b3JcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhub2RlKSkge1xyXG4gICAgICAgIHJldHVybiBxdWVyeShub2RlKTtcclxuICAgIH0gZWxzZSBpZihub2RlLmdldEF0dHJpYnV0ZSl7XHJcbiAgICAgICAgdmFyIGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICAgICAgaWYoaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQucUNhY2hlKCcjJytub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSwgdHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmKG5vZGUualF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGUuZy4gZG9jdW1lbnQsIHdpbmRvdy4uLlxyXG4gICAgICAgIHJldHVybiAkKG5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIG1vdmVEb3duID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuICAgIHZhciAkbm9kZSA9IGdldEpRdWVyeU5vZGUobm9kZSk7XHJcbiAgICAkbm9kZS5iZWZvcmUoJG5vZGUubmV4dChzZWxlY3RvcikpO1xyXG59O1xyXG5cclxudmFyIG1vdmVVcCA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XHJcbiAgICB2YXIgJG5vZGUgPSBnZXRKUXVlcnlOb2RlKG5vZGUpO1xyXG4gICAgJG5vZGUuYWZ0ZXIoJG5vZGUucHJldihzZWxlY3RvcikpO1xyXG59O1xyXG5cclxudmFyIGluc2VydEFmdGVySW5kZXggPSBmdW5jdGlvbihub2RlLCBpbmRleCkge1xyXG4gICAgdmFyICRub2RlID0gZ2V0SlF1ZXJ5Tm9kZShub2RlKTtcclxuICAgICRub2RlLnBhcmVudCgpLmNoaWxkcmVuKCkuZXEoaW5kZXgpLmFmdGVyKCRub2RlKTtcclxufTtcclxuXHJcbnZhciBpbnNlcnRTVkdBZnRlciA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZWxlbWVudCwgdGV4dCwgaW5zZXJ0QWZ0ZXIpIHtcclxuICAgIHRleHQgPSB0ZXh0IHx8IGVsZW1lbnQudGV4dDtcclxuICAgIGRlbGV0ZSBlbGVtZW50LnRleHQ7XHJcbiAgICByZXR1cm4gYWRkU1ZHRWxlbWVudChjb250YWluZXIsZWxlbWVudCx0ZXh0LGluc2VydEFmdGVyKTtcclxufTtcclxuXHJcbnZhciBwcmVwZW5kU1ZHRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZWxlbWVudCwgdGV4dCkge1xyXG4gICAgdGV4dCA9IHRleHQgfHwgZWxlbWVudC50ZXh0O1xyXG4gICAgZGVsZXRlIGVsZW1lbnQudGV4dDtcclxuICAgIHJldHVybiBhZGRTVkdFbGVtZW50KGNvbnRhaW5lcixlbGVtZW50LHRydWUsdGV4dCk7XHJcbn07XHJcblxyXG52YXIgYXBwZW5kU1ZHRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZWxlbWVudCwgdGV4dCkge1xyXG4gICAgdGV4dCA9IHRleHQgfHwgZWxlbWVudC50ZXh0O1xyXG4gICAgZGVsZXRlIGVsZW1lbnQudGV4dDtcclxuICAgIHJldHVybiBhZGRTVkdFbGVtZW50KGNvbnRhaW5lcixlbGVtZW50LGZhbHNlLHRleHQpO1xyXG59O1xyXG5cclxudmFyIHByZXBlbmRUb1Jvb3QgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBpZighZWxlbWVudC5yb290Lmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICAgIGVsZW1lbnQuaW5zdGFuY2UoZWxlbWVudC5yb290LmFwcGVuZENoaWxkKGVsZW1lbnQuaW5zdGFuY2UoKSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtZW50Lmluc3RhbmNlKGVsZW1lbnQucm9vdC5pbnNlcnRCZWZvcmUoZWxlbWVudC5pbnN0YW5jZSgpLCBlbGVtZW50LnJvb3QuY2hpbGROb2Rlc1swXSkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGFkZFNWR0VsZW1lbnQgPSBmdW5jdGlvbihjb250YWluZXIsIGVsZW1lbnQsIHByZXBlbmQsIHRleHQsIGluc2VydEFmdGVyKSB7XHJcbiAgICBwcmVwZW5kID0gKG9iamVjdC5pc0RlZmluZWQocHJlcGVuZCkpPyBwcmVwZW5kIDogZmFsc2U7XHJcbiAgICAvLyBJZiBvbmx5IHRoZSBjb250YWluZXIgaXMgZ2l2ZW4gd2UgYXNzdW1lIGl0cyBhbiBTVkdFbGVtZW50IG9iamVjdCB3aXRoIGNvbnRhaW5lZCByb290IG5vZGVcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoY29udGFpbmVyKSAmJiAhb2JqZWN0LmlzRGVmaW5lZChlbGVtZW50KSkge1xyXG4gICAgICAgIGVsZW1lbnQgPSBjb250YWluZXI7XHJcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmdldFJvb3ROb2RlKCk7XHJcbiAgICB9IGVsc2UgaWYob2JqZWN0LmlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgICAgICBjb250YWluZXIgPSBxdWVyeShjb250YWluZXIpWzBdO1xyXG4gICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5pbnN0YW5jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnN0YW5jZTtcclxuXHJcbiAgICBpZighZWxlbWVudC5pbnN0YW5jZSB8fCAhb2JqZWN0LmlzRGVmaW5lZChlbGVtZW50Lmluc3RhbmNlKCkpKSB7XHJcbiAgICAgICAgaW5zdGFuY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBlbGVtZW50LnRhZ05hbWUpO1xyXG4gICAgICAgICQuZWFjaChlbGVtZW50LmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYoc3RyaW5nLnN0YXJ0c1dpdGgoa2V5LCAneGxpbms6JykpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxzdHJpbmcuY3V0cHJlZml4KGtleSwgJ3hsaW5rOicpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZSA9IGVsZW1lbnQuaW5zdGFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHRleHQpKSB7XHJcbiAgICAgICAgdmFyIHR4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcclxuICAgICAgICBpbnN0YW5jZS5hcHBlbmRDaGlsZCh0eHROb2RlKTtcclxuICAgIH1cclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoaW5zZXJ0QWZ0ZXIpKSB7XHJcbiAgICAgICAgLy9pZiB0aGUgcGFyZW50cyBsYXN0Y2hpbGQgaXMgdGhlIHRhcmdldEVsZW1lbnQuLi5cclxuICAgICAgICBpZihjb250YWluZXIubGFzdGNoaWxkID09IGluc2VydEFmdGVyKSB7XHJcbiAgICAgICAgICAgIC8vYWRkIHRoZSBuZXdFbGVtZW50IGFmdGVyIHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGluc3RhbmNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBlbHNlIHRoZSB0YXJnZXQgaGFzIHNpYmxpbmdzLCBpbnNlcnQgdGhlIG5ldyBlbGVtZW50IGJldHdlZW4gdGhlIHRhcmdldCBhbmQgaXQncyBuZXh0IHNpYmxpbmcuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoaW5zdGFuY2UsIGluc2VydEFmdGVyLm5leHRTaWJsaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYoIXByZXBlbmQgfHwgIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkgKSB7XHJcbiAgICAgICAgaW5zdGFuY2UgPSBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5zdGFuY2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZSA9IGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoaW5zdGFuY2UsY29udGFpbmVyLmNoaWxkTm9kZXNbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG9iamVjdC5pc0Z1bmN0aW9uKGVsZW1lbnQuaW5zdGFuY2UpKSB7XHJcbiAgICAgICAgZWxlbWVudC5pbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZW1lbnQuaW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbnZhciBpbXBvcnRTVkcgPSBmdW5jdGlvbihjb250YWluZXIsIHN2Z1hNTCwgcHJlcGVuZCkge1xyXG4gICAgdmFyICRzdmdYTUwsIG5hbWUsIGF0dHJpYnV0ZXM7XHJcblxyXG4gICAgaWYoc3ZnWE1MLmpxdWVyeSkge1xyXG4gICAgICAgICRzdmdYTUwgPSBzdmdYTUw7XHJcbiAgICB9IGVsc2UgaWYob2JqZWN0LmlzU3RyaW5nKHN2Z1hNTCkpIHtcclxuICAgICAgICAkc3ZnWE1MID0gJChwYXJzZVhNTChzdmdYTUwudHJpbSgpKSk7XHJcbiAgICAgICAgJHN2Z1hNTCA9ICQoJHN2Z1hNTC5nZXQoMCkuZG9jdW1lbnRFbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJHN2Z1hNTCA9ICQoc3ZnWE1MKTtcclxuICAgIH1cclxuXHJcbiAgICBpZigkc3ZnWE1MLm5vZGVOYW1lKSB7XHJcbiAgICAgICAgbmFtZSA9ICRzdmdYTUwubm9kZU5hbWU7XHJcbiAgICAgICAgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXMoJHN2Z1hNTCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5hbWUgPSAkc3ZnWE1MLmdldCgwKS50YWdOYW1lO1xyXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzKCRzdmdYTUwuZ2V0KDApKTtcclxuICAgIH1cclxuXHJcbiAgICAvL1dlIGNyZWF0ZSBhIGR1bW15IGVsZW1lbnQgb2JqZWN0XHJcbiAgICB2YXIgZWxlbWVudCA9IHtcclxuICAgICAgICB0YWdOYW1lIDogbmFtZSxcclxuICAgICAgICBhdHRyaWJ1dGVzIDogYXR0cmlidXRlcyxcclxuICAgICAgICBpbnN0YW5jZSA6IGZ1bmN0aW9uKGluc3QpIHtcclxuICAgICAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChpbnN0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZUVsZW1lbnQgPSBpbnN0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VFbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZighcHJlcGVuZCkge1xyXG4gICAgICAgIGFwcGVuZFNWR0VsZW1lbnQoY29udGFpbmVyLCBlbGVtZW50LCBfZ2V0Q2hpbGRUZXh0KCRzdmdYTUwpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJlcGVuZFNWR0VsZW1lbnQoY29udGFpbmVyLCBlbGVtZW50LCBfZ2V0Q2hpbGRUZXh0KCRzdmdYTUwpKTtcclxuICAgIH1cclxuXHJcbiAgICAkc3ZnWE1MLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihpbmRleCwgY2hpbGQpIHtcclxuICAgICAgICBpbXBvcnRTVkcoZWxlbWVudC5pbnN0YW5jZSgpLCBjaGlsZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5pbnN0YW5jZSgpO1xyXG59O1xyXG5cclxudmFyIF9nZXRDaGlsZFRleHQgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICBpZighbm9kZS5qcXVlcnkpIHtcclxuICAgICAgICBub2RlID0gJChub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2hpbGRUZXh0ID0gbm9kZS5jb250ZW50cygpLmZpbHRlcihmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlID09PSAzO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZChjaGlsZFRleHQpICYmIGNoaWxkVGV4dC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkVGV4dFswXS5ub2RlVmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICQobm9kZS5hdHRyaWJ1dGVzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJlc3VsdFt0aGlzLm5vZGVOYW1lXSA9IHRoaXMudmFsdWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgZmluZEluY2x1ZGVTZWxmID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiAkKG5vZGUpLmZpbmQoc2VsZWN0b3IpLmFuZFNlbGYoKS5maWx0ZXIoc2VsZWN0b3IpLmdldCgwKTtcclxufTtcclxuXHJcbnZhciBwYXJzZU5vZGVYTUwgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICBpZighbm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiAkLnBhcnNlWE1MKCQobm9kZSkudGV4dCgpKTtcclxufTtcclxuXHJcbnZhciBwYXJzZVhNTCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgcmV0dXJuIHhtbC5wYXJzZVhNTChzdHIpO1xyXG59O1xyXG5cclxudmFyIHBhcnNlTm9kZUpTT04gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICByZXR1cm4gJC5wYXJzZUpTT04oJChub2RlKS50ZXh0KCkpO1xyXG59O1xyXG5cclxudmFyIGdldFJhd0lkID0gZnVuY3Rpb24oaWRTZWxlY3Rvcikge1xyXG4gICAgaWYoIW9iamVjdC5pc1N0cmluZyhpZFNlbGVjdG9yKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZihpZFNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gJyMnKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkU2VsZWN0b3Iuc3Vic3RyaW5nKDEsIGlkU2VsZWN0b3IubGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGlkU2VsZWN0b3I7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgZ2V0SWRTZWxlY3RvciA9IGZ1bmN0aW9uKHJhd0lkKSB7XHJcbiAgICBpZighb2JqZWN0LmlzU3RyaW5nKHJhd0lkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmF3SWQuY2hhckF0KDApICE9PSAnIycpIHtcclxuICAgICAgICByZXR1cm4gJyMnICsgcmF3SWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByYXdJZDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgYXBwZW5kU1ZHRWxlbWVudCA6IGFwcGVuZFNWR0VsZW1lbnQsXHJcbiAgICBwcmVwZW5kU1ZHRWxlbWVudCA6IHByZXBlbmRTVkdFbGVtZW50LFxyXG4gICAgaW5zZXJ0U1ZHQWZ0ZXIgOiBpbnNlcnRTVkdBZnRlcixcclxuICAgIGluc2VydEFmdGVySW5kZXggOiBpbnNlcnRBZnRlckluZGV4LFxyXG4gICAgY3JlYXRlIDogY3JlYXRlLFxyXG4gICAgcHJlcGVuZFRvUm9vdCA6IHByZXBlbmRUb1Jvb3QsXHJcbiAgICBpbXBvcnRTVkcgOiBpbXBvcnRTVkcsXHJcbiAgICBtb3ZlRG93biA6IG1vdmVEb3duLFxyXG4gICAgbW92ZVVwIDogbW92ZVVwLFxyXG4gICAgZmluZEluY2x1ZGVTZWxmIDogZmluZEluY2x1ZGVTZWxmLFxyXG4gICAgcGFyc2VOb2RlWE1MIDogcGFyc2VOb2RlWE1MLFxyXG4gICAgcGFyc2VOb2RlSlNPTiA6IHBhcnNlTm9kZUpTT04sXHJcbiAgICBnZXRBdHRyaWJ1dGVzIDogZ2V0QXR0cmlidXRlcyxcclxuICAgIGdldFJhd0lkIDogZ2V0UmF3SWQsXHJcbiAgICBnZXRJZFNlbGVjdG9yOiBnZXRJZFNlbGVjdG9yXHJcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG52YXIgZG9tID0gdXRpbC5kb207XHJcblxyXG52YXIgRXZlbnRhYmxlID0gcmVxdWlyZSgnLi9ldmVudGFibGVOb2RlJyk7XHJcblxyXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKHRhZ05hbWUsIGNmZywgYXR0cmlidXRlU2V0dGVyKSB7XHJcbiAgICB0aGlzLmF0dHJpYnV0ZVNldHRlciA9IGF0dHJpYnV0ZVNldHRlciB8fCB7fTtcclxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuICAgIGlmKG9iamVjdC5pc09iamVjdCh0YWdOYW1lKSkge1xyXG4gICAgICAgIGNmZyA9IHRhZ05hbWU7XHJcbiAgICAgICAgdGFnTmFtZSA9IGNmZy50YWdOYW1lO1xyXG4gICAgICAgIGRlbGV0ZSBjZmcudGFnTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xyXG5cclxuICAgIGlmKG9iamVjdC5pc09iamVjdChjZmcpKSB7XHJcbiAgICAgICAgaWYoY2ZnLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjZmcuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjZmcuY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNpbmdsZSA9IGNmZy5zaW5nbGUgfHwgZmFsc2U7XHJcbiAgICAgICAgZGVsZXRlIGNmZy5zaW5nbGU7XHJcblxyXG4gICAgICAgIC8vV2UgYXNzdW1lIGFsbCByZW1haW5pbmcgY2ZnIGVudHJpZXMgYXJlIGF0dHJpYnV0ZXNcclxuICAgICAgICBmb3IodmFyIGF0dHJpYnV0ZUtleSBpbiBjZmcpIHtcclxuICAgICAgICAgICAgaWYoY2ZnLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZUtleSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZShhdHRyaWJ1dGVLZXksIGNmZ1thdHRyaWJ1dGVLZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1NlZSBldmVudGFibGVcclxuICAgIHRoaXMuZXZlbnRCYXNlID0gdGhpcztcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoRWxlbWVudCwgRXZlbnRhYmxlKTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLmluc3RhbmNlID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQoaW5zdGFuY2UpKSB7XHJcbiAgICAgICAgdGhpcy5kb21JbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIHRoaXMuJGRvbUluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhZ05hbWUgPSBpbnN0YW5jZS50YWdOYW1lO1xyXG4gICAgICAgIHRoaXMubG9hZEF0dHJpYnV0ZXMoaW5zdGFuY2UpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb21JbnN0YW5jZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBkb20gaW5zdGFuY2UgaW50byBvdXIgYXR0cmlidXRlIGFycmF5IGV4Y2VwdCBhbHJlYWR5IGV4aXN0aW5nIGF0dHJpYnV0ZXMuXHJcbiAqIEBwYXJhbSBpbnN0YW5jZVxyXG4gKi9cclxuRWxlbWVudC5wcm90b3R5cGUubG9hZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzIHx8IHt9O1xyXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBkb20uZ2V0QXR0cmlidXRlcyhpbnN0YW5jZSk7XHJcbiAgICBmb3IodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgaWYoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF0aGlzLmF0dHJpYnV0ZXNba2V5XSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkVsZW1lbnQucHJvdG90eXBlLmlkID0gZnVuY3Rpb24obmV3SWQpIHtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhuZXdJZCkpIHtcclxuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGUoJ2lkJyxuZXdJZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIGZvcihhdHRyaWJ1dGVLZXkgaW4gdGhpcy5hdHRyaWJ1dGVTZXR0ZXIpIHtcclxuICAgICAgICBpZih0aGlzLmF0dHJpYnV0ZVNldHRlci5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVLZXkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKGF0dHJpYnV0ZUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuRWxlbWVudC5wcm90b3R5cGUudXBkYXRlQXR0cmlidXRlID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGUoa2V5LCB0aGlzLmF0dHJpYnV0ZXNba2V5XSk7XHJcbn07XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS5fc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgcHJldkRvbVNldCkge1xyXG4gICAgLy8gSWYgZmlyc3QgYXJnIGlzIG9iamVjdCBoYW5kbGUgaXRzIHByb3BlcnRpZXMgYXMgYXR0cmlidXRlc1xyXG4gICAgaWYob2JqZWN0LmlzT2JqZWN0KGtleSkpIHtcclxuICAgICAgICBmb3IodmFyIGF0dHJpYnV0ZSBpbiBrZXkpIHtcclxuICAgICAgICAgICAgaWYob2JqZWN0LmlzRGVmaW5lZChhdHRyaWJ1dGUpICYmIGtleS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBrZXlbYXR0cmlidXRlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBTb21lIGVsZW1lbnR0eXBlcyBjYW4gdHJhbnNmb3JtIHNwZWNpZmljIHR5cGVzIG9mIGF0dHJpYnV0ZXMgdG8gc3BlY2lhbCBvYmplY3RzXHJcbiAgICAgICAgLy8gd2hpY2ggYXJlIGFibGUgdG8gcmVuZGVyIGFuZCBzZXQgdGhlIHZhbHVlcyBpbiBhIHNwZWNpYWwgd2F5LlxyXG4gICAgICAgIGlmKCF0aGlzLmhhc0NsYXNzKCdub1BhcnNlJykgJiYgb2JqZWN0LmlzU3RyaW5nKHZhbHVlKSAmJiBvYmplY3QuaXNEZWZpbmVkKHRoaXMuYXR0cmlidXRlU2V0dGVyW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5hdHRyaWJ1dGVTZXR0ZXJba2V5XSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEp1c3QgdHJhbnNmb3JtIHN0cmluZ2xpdHMgdmFsdWVzIHRvIGFycmF5cyBpbiBjYXNlIGl0cyBhIHN0cmluZyBsaXN0XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgLy8gRGlyZWN0bHkgc2V0IGl0IHRvIHRoZSBTVkcgaW5zdGFuY2UgaWYgYWxyZWFkeSByZW5kZXJlZFxyXG4gICAgICAgIGlmKHRoaXMuZG9tSW5zdGFuY2UgJiYgIXByZXZEb21TZXQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IEVsZW1lbnQuZ2V0QXR0cmlidXRlU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5kb21JbnN0YW5jZS5zZXRBdHRyaWJ1dGUoa2V5LHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuRWxlbWVudC5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbihzZWFyY2hDbGFzcykge1xyXG4gICAgaWYodGhpcy5kb21JbnN0YW5jZSkge1xyXG4gICAgICAgIC8vSnF1ZXJ5IGhhc2NsYXNzIGRvZXMgbm90IHdvcmsgd2l0aCBzdmcgZWxlbWVudHNcclxuICAgICAgICB2YXIgZWxlbWVudENsYXNzID0gJyAnKyB0aGlzLmF0dHIoJ2NsYXNzJykrJyAnO1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50Q2xhc3MuaW5kZXhPZignICcrc2VhcmNoQ2xhc3MrJyAnKSA+IC0xO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRWxlbWVudC5wcm90b3R5cGUuJCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICBpZighdGhpcy4kZG9tSW5zdGFuY2UgJiYgdGhpcy5kb21JbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuJGRvbUluc3RhbmNlID0gJCh0aGlzLmRvbUluc3RhbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHNlbGVjdG9yKSA/IHRoaXMuJGRvbUluc3RhbmNlLmZpbmQoc2VsZWN0b3IpIDogdGhpcy4kZG9tSW5zdGFuY2U7XHJcbn07XHJcblxyXG5FbGVtZW50LmdldEF0dHJpYnV0ZVN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcblxyXG4gICAgaWYoIW9iamVjdC5pc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG9iamVjdC5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIG9iamVjdC5lYWNoKHZhbHVlLCBmdW5jdGlvbihpbmRleCwgcGFydCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gKCsraW5kZXggPT09IHZhbHVlLmxlbmd0aCkgPyBwYXJ0IDogcGFydCsnICc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuRWxlbWVudC5nZXRBdHRyaWJ1dGVWYWx1ZUZyb21TdHJpbmdMaXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuaW5kZXhPZignICcpID4gLTEpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuc3BsaXQoL1tcXHNdKy8pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS5hdHRyTnVtYmVyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgdmFyIHZhbCA9IHV0aWwuYXBwLnBhcnNlTnVtYmVyU3RyaW5nKHRoaXMuYXR0cihrZXksIHZhbHVlKSk7XHJcbiAgICByZXR1cm4gKG9iamVjdC5pc0RlZmluZWQodmFsdWUpKSA/IHRoaXMgOiB2YWw7XHJcbn07XHJcblxyXG5FbGVtZW50LnByb3RvdHlwZS5wb2ludGVyRXZlbnRzID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgdmFsdWUpO1xyXG59O1xyXG5FbGVtZW50LnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24oYXR0cmlidXRlKSB7XHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBvYmplY3QuaXNEZWZpbmVkKGFyZ3VtZW50c1sxXSkpIHtcclxuICAgICAgICAvL1RPRE86IGltcGxlbWVudCBmb3IgbW9yIHRoYW50IDJcclxuICAgICAgICB2YXIgb2JqID0ge307XHJcbiAgICAgICAgb2JqW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cihvYmopO1xyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc1N0cmluZyhhdHRyaWJ1dGUpKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmKCFyZXN1bHQgJiYgdGhpcy5pbnN0YW5jZSgpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gIHRoaXMuJCgpLmF0dHIoYXR0cmlidXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gIEVsZW1lbnQ7XHJcbiIsInZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29yZS9jb25maWcnKTtcclxuXHJcbnZhciBFdmVudGFibGUgPSBmdW5jdGlvbihldmVudEJhc2UpIHtcclxuICAgIHRoaXMuZXZlbnRCYXNlID0gZXZlbnRCYXNlO1xyXG59O1xyXG5cclxuRXZlbnRhYmxlLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oZnVuYywgYXJncywgcHJldkRvbUV2ZW50KSB7XHJcbiAgICBhcmdzID0gYXJncyB8fCB0aGlzO1xyXG4gICAgdGhpcy5leGVjdXRlQWRkaXRpb24oZnVuYywgYXJncyk7XHJcbiAgICBpZih0aGlzLmV4ZWN1dGVUZW1wbGF0ZUhvb2spIHtcclxuICAgICAgICB0aGlzLmV4ZWN1dGVUZW1wbGF0ZUhvb2soZnVuYywgYXJncyk7XHJcbiAgICB9XHJcbiAgICBpZih0aGlzLmV2ZW50QmFzZSAmJiAhcHJldkRvbUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKGZ1bmMsIGFyZ3MpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRXZlbnRhYmxlLnByb3RvdHlwZS5leGVjdXRlQWRkaXRpb24gPSBmdW5jdGlvbihmdW5jLCBhcmdzKSB7XHJcbiAgICBpZighdGhpcy5hZGRpdGlvbnMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBvYmplY3QuZWFjaCh0aGlzLmFkZGl0aW9ucywgZnVuY3Rpb24oa2V5LCBhZGRpdGlvbikge1xyXG4gICAgICAgIGlmKG9iamVjdC5pc0RlZmluZWQoYWRkaXRpb24pICYmIG9iamVjdC5pc0Z1bmN0aW9uKGFkZGl0aW9uW2Z1bmNdKSkge1xyXG4gICAgICAgICAgICBhZGRpdGlvbltmdW5jXS5hcHBseShhZGRpdGlvbiwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5FdmVudGFibGUucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uKGV2dCwgaGFuZGxlcikge1xyXG4gICAgaWYoIXRoaXMuZXZlbnRCYXNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ldmVudEJhc2UuJCgpLm9uZShldnQsIHRoaXMud3JhcChldnQsIGhhbmRsZXIpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRXZlbnRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2dCwgaGFuZGxlcikge1xyXG4gICAgaWYoIXRoaXMuZXZlbnRCYXNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ldmVudEJhc2UuJCgpLm9uKGV2dCwgdGhpcy53cmFwKGV2dCwgaGFuZGxlcikpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5FdmVudGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihldmVudFR5cGUsIGhhbmRsZXIpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZih0aGF0LmlzRXhlY3V0aW9uQWxsb3dlZChldmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkV2ZW50YWJsZS5wcm90b3R5cGUuaXNFeGVjdXRpb25BbGxvd2VkID0gZnVuY3Rpb24oZXZlbnRUeXBlKSB7XHJcbiAgICBpZih0aGlzLmZyZWV6ZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYoY29uZmlnLmlzKCdldmVudHNfcmVzdHJpY3RlZCcsIGZhbHNlKSAmJiAhdGhpcy5leGNsdWRlRXZlbnRSZXN0cmljdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRXZlbnRhYmxlLnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZnJlZXplZCA9IHRydWU7XHJcbiAgICB0aGlzLmV2ZW50QmFzZS5mcmVlemVkID0gdHJ1ZTtcclxufTtcclxuXHJcblxyXG5FdmVudGFibGUucHJvdG90eXBlLnVuZnJlZXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmZyZWV6ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuZXZlbnRCYXNlLmZyZWV6ZWQgPSB0cnVlO1xyXG59O1xyXG5cclxuRXZlbnRhYmxlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oZXZ0LCBhcmdzKSB7XHJcbiAgICBpZighdGhpcy5ldmVudEJhc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmV2ZW50QmFzZS4kKCkudHJpZ2dlcihldnQsIGFyZ3MpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5FdmVudGFibGUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2dCwgaGFuZGxlcikge1xyXG4gICAgaWYoIXRoaXMuZXZlbnRCYXNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ldmVudEJhc2UuJCgpLm9mZihldnQsIGhhbmRsZXIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudGFibGU7IiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi91dGlsL21hdGgnKS5WZWN0b3I7XHJcbnZhciBtYXRoID0gcmVxdWlyZSgnLi4vdXRpbC9tYXRoJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcclxuXHJcbnZhciBBYnN0cmFjdFBhdGhEYXRhVHlwZSA9IGZ1bmN0aW9uKHR5cGUsIGFic29sdXRlKSB7XHJcbiAgICB0aGlzLnZlY3RvciA9IG5ldyBWZWN0b3IoKTtcclxuICAgIHRoaXMudmVjdG9yLmFkZCh0eXBlKTtcclxuICAgIHRoaXMuYWJzb2x1dGUgPSBhYnNvbHV0ZSB8fCB0cnVlO1xyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoRGF0YVR5cGUucHJvdG90eXBlLnNldEFic29sdXRlID0gZnVuY3Rpb24oYWJzb2x1dGUpIHtcclxuICAgIHRoaXMuYWJzb2x1dGUgPSBhYnNvbHV0ZSB8fCB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhEYXRhVHlwZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHR5cGUgPSB0aGlzLnZhbHVlKDAsMCk7XHJcbiAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZSA/IHR5cGUudG9VcHBlckNhc2UoKSA6IHR5cGUudG9Mb3dlckNhc2UoKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aERhdGFUeXBlLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmVjdG9yLnZhbHVlKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RQYXRoRGF0YVR5cGUucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24ocGF0aEFyciwgdmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLnZlY3Rvci5zZXRWYWx1ZShwYXRoQXJyLCB2YWx1ZSk7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhEYXRhVHlwZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24ocGF0aEFyciwgdmFsdWVzKSB7XHJcbiAgICByZXR1cm4gdGhpcy52ZWN0b3Iuc2V0VmFsdWUocGF0aEFyciwgdmFsdWVzKTtcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aERhdGFUeXBlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS50b1VwcGVyQ2FzZSgpID09PSB0eXBlLnRvVXBwZXJDYXNlKCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhEYXRhVHlwZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbihwYXRoQXJyLCB2YWx1ZXMpIHtcclxuICAgIC8vQUJTVFJBQ1RcclxufTtcclxuXHJcbkFic3RyYWN0UGF0aERhdGFUeXBlLnByb3RvdHlwZS5wb2ludFRvU3RyaW5nID0gZnVuY3Rpb24ocCkge1xyXG4gICAgcmV0dXJuIHAueCArICcsJyArIHAueSsnICc7XHJcbn07XHJcblxyXG5BYnN0cmFjdFBhdGhEYXRhVHlwZS5wcm90b3R5cGUuZ2V0T3JTZXQgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgIGlmKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZShpbmRleCwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZShpbmRleCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWZWN0b3IgPSBbWydsJ10sIHt4OngsIHk6eX1dXHJcbiAqL1xyXG52YXIgTGluZVRvID0gZnVuY3Rpb24ocCwgYWJzb2x1dGUpIHtcclxuICAgIEFic3RyYWN0UGF0aERhdGFUeXBlLmNhbGwodGhpcywgJ2wnLCBhYnNvbHV0ZSk7XHJcbiAgICB0aGlzLnRvKHApO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhMaW5lVG8sIEFic3RyYWN0UGF0aERhdGFUeXBlKTtcclxuXHJcbkxpbmVUby5wcm90b3R5cGUudG8gPSBmdW5jdGlvbih4LHkpIHtcclxuICAgIHZhciBwID0gbWF0aC5nZXRQb2ludCh4LHkpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0T3JTZXQoMSxwKTtcclxufTtcclxuXHJcbkxpbmVUby5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSt0aGlzLnBvaW50VG9TdHJpbmcodGhpcy50bygpKTtcclxufTtcclxuXHJcbkxpbmVUby5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUoMSkueCA9IHZhbHVlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZSgxKS54O1xyXG59O1xyXG5cclxuTGluZVRvLnByb3RvdHlwZS55ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSgxKS55ID0gdmFsdWVcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnZhbHVlKDEpLnk7XHJcbn07XHJcblxyXG5MaW5lVG8ucHJvdG90eXBlLm1vdmVBbG9uZyA9IGZ1bmN0aW9uKGZyb20sIGRpc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gbWF0aC5MaW5lLm1vdmVBbG9uZyhmcm9tLCB0aGlzLnRvKCksIGRpc3RhbmNlKTtcclxufTtcclxuXHJcbkxpbmVUby5wcm90b3R5cGUuZ2V0TmVhcmVzdFBvaW50ID0gZnVuY3Rpb24oZnJvbSwgcG9zaXRpb24pIHtcclxuICAgIHJldHVybiBtYXRoLkxpbmUuZ2V0TmVhcmVzdFBvaW50KGZyb20sIHRoaXMudG8oKSwgcG9zaXRpb24pO1xyXG59O1xyXG5cclxudmFyIFFCZXppZXIgPSBmdW5jdGlvbihjb250cm9sUCwgdG9QLCBhYnNvbHV0ZSkge1xyXG4gICAgQWJzdHJhY3RQYXRoRGF0YVR5cGUuY2FsbCh0aGlzLCAncScsIGFic29sdXRlKTtcclxuICAgIHRoaXMuY29udHJvbChjb250cm9sUCk7XHJcbiAgICB0aGlzLnRvKHRvUCk7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKFFCZXppZXIsIEFic3RyYWN0UGF0aERhdGFUeXBlKTtcclxuXHJcblFCZXppZXIucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oeCx5KSB7XHJcbiAgICB2YXIgcCA9IG1hdGguZ2V0UG9pbnQoeCx5KTtcclxuICAgIHJldHVybiB0aGlzLmdldE9yU2V0KDIscCk7XHJcbn07XHJcblxyXG5RQmV6aWVyLnByb3RvdHlwZS5jb250cm9sID0gZnVuY3Rpb24oeCx5KSB7XHJcbiAgICB2YXIgcCA9IG1hdGguZ2V0UG9pbnQoeCx5KTtcclxuICAgIHJldHVybiB0aGlzLmdldE9yU2V0KDEscCk7XHJcbn07XHJcblxyXG5RQmV6aWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpK3RoaXMucG9pbnRUb1N0cmluZyh0aGlzLmNvbnRyb2woKSkrdGhpcy5wb2ludFRvU3RyaW5nKHRoaXMudG8oKSk7XHJcbn07XHJcblxyXG52YXIgQ0JlemllciA9IGZ1bmN0aW9uKGNvbnRyb2xQMSwgY29udHJvbFAyLCB0b1AsIGFic29sdXRlKSB7XHJcbiAgICBBYnN0cmFjdFBhdGhEYXRhVHlwZS5jYWxsKHRoaXMsICdjJywgYWJzb2x1dGUpO1xyXG4gICAgdGhpcy5jb250cm9sMShjb250cm9sUDEpO1xyXG4gICAgdGhpcy5jb250cm9sMihjb250cm9sUDIpO1xyXG4gICAgdGhpcy50byh0b1ApO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhDQmV6aWVyLCBBYnN0cmFjdFBhdGhEYXRhVHlwZSk7XHJcblxyXG5DQmV6aWVyLnByb3RvdHlwZS5jb250cm9sID0gZnVuY3Rpb24oeCx5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250cm9sMSh4LHkpO1xyXG59O1xyXG5cclxuQ0Jlemllci5wcm90b3R5cGUuY29udHJvbDEgPSBmdW5jdGlvbih4LHkpIHtcclxuICAgIHZhciBwID0gbWF0aC5nZXRQb2ludCh4LHkpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0T3JTZXQoMSxwKTtcclxufTtcclxuXHJcbkNCZXppZXIucHJvdG90eXBlLmNvbnRyb2wyID0gZnVuY3Rpb24oeCx5KSB7XHJcbiAgICB2YXIgcCA9IG1hdGguZ2V0UG9pbnQoeCx5KTtcclxuICAgIHJldHVybiB0aGlzLmdldE9yU2V0KDIscCk7XHJcbn07XHJcblxyXG5DQmV6aWVyLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgdmFyIHAgPSBtYXRoLmdldFBvaW50KHgseSk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRPclNldCgzLHApO1xyXG59O1xyXG5cclxuQ0Jlemllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSt0aGlzLnBvaW50VG9TdHJpbmcodGhpcy5jb250cm9sMSgpKSt0aGlzLnBvaW50VG9TdHJpbmcodGhpcy5jb250cm9sMigpKSt0aGlzLnBvaW50VG9TdHJpbmcodGhpcy50bygpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGVzIHRoZSBuZWFyZXN0IHBvaW50IG9mIHRoZSBiZXppZXIgY3VydmUgdG8gdGhlIGdpdmVuIHBvc2l0aW9uLiBzaW5jZSB0aGUgQ0JlemllciBkb2VzIG5vdCBrbm93IGl0cyBzdGFydFxyXG4gKiBwb2ludCwgd2UgaGF2ZSB0byBwcm92aWRlIHRoZSBmcm9tIHBvc2l0aW9uIGFzIHdlbGwgYXMgdGhlIHNlYXJjaCBiYXNlIHBvc2l0aW9uLlxyXG4gKiBAcGFyYW0gZnJvbVxyXG4gKiBAcGFyYW0gcG9zaXRpb25cclxuICogQHJldHVybnMge3twb2ludCwgbG9jYXRpb259fCp9XHJcbiAqL1xyXG5DQmV6aWVyLnByb3RvdHlwZS5nZXROZWFyZXN0UG9pbnQgPSBmdW5jdGlvbihmcm9tLCBwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIG1hdGguYmV6aWVyLm5lYXJlc3RQb2ludE9uQ3VydmUocG9zaXRpb24sIHRoaXMuZ2V0Q3VydmUoZnJvbSkpLnBvaW50O1xyXG59O1xyXG5cclxuQ0Jlemllci5wcm90b3R5cGUubW92ZUFsb25nID0gZnVuY3Rpb24oZnJvbSwgZGlzdGFuY2UpIHtcclxuICAgIHJldHVybiBtYXRoLmJlemllci5tb3ZlQWxvbmcodGhpcy5nZXRDdXJ2ZShmcm9tKSwgZGlzdGFuY2UpO1xyXG59O1xyXG5cclxuQ0Jlemllci5wcm90b3R5cGUuZ2V0Q3VydmUgPSBmdW5jdGlvbihmcm9tKSB7XHJcbiAgICByZXR1cm4gW2Zyb20sIHRoaXMuY29udHJvbDEoKSwgdGhpcy5jb250cm9sMigpLCB0aGlzLnRvKCldO1xyXG59O1xyXG5cclxudmFyIE1vdmVUbyA9IGZ1bmN0aW9uKHRvUCwgYWJzb2x1dGUpIHtcclxuICAgIEFic3RyYWN0UGF0aERhdGFUeXBlLmNhbGwodGhpcywgJ20nLCBhYnNvbHV0ZSk7XHJcbiAgICB0aGlzLnRvKHRvUCk7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKE1vdmVUbywgTGluZVRvKTtcclxuXHJcbnZhciBDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgQWJzdHJhY3RQYXRoRGF0YVR5cGUuY2FsbCh0aGlzLCAneicpO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhDb21wbGV0ZSwgQWJzdHJhY3RQYXRoRGF0YVR5cGUpO1xyXG5cclxuQ29tcGxldGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCk7XHJcbn07XHJcblxyXG52YXIgcGF0aFR5cGUgPSB7XHJcbiAgICB6IDogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgQ29tcGxldGUoKSB9LFxyXG4gICAgbSA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IE1vdmVUbyhhcmd1bWVudHNbMF0pOyB9LFxyXG4gICAgbCA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IExpbmVUbyhhcmd1bWVudHNbMF0pOyB9LFxyXG4gICAgcSA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFFCZXppZXIoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pOyB9LFxyXG4gICAgYyA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IENCZXppZXIoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sICBhcmd1bWVudHNbMl0pOyB9XHJcbn07XHJcblxyXG52YXIgUGF0aERhdGEgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgIHRoaXMuZGF0YSA9IG5ldyBWZWN0b3IoKTtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhkZWYpKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkRnJvbVN0cmluZyhkZWYpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmxvYWRGcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyVmFsKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAvLydNMTAwLDEwMCBRMjAwLDIwMCAzMDAsMzAwJyAtLT4gWydNMTAwLDEwMCAnLCAnUTIwMCwyMDAgMzAwLDMwMCddXHJcbiAgICB2YXIgZGVmaW5pdGlvbnMgPSBzdHJWYWwuc3BsaXQoLyg/PVtNbUxsSGhWdkNjU3NRcVR0QWFael0rKS8pO1xyXG4gICAgLy9FYWNoIGRUeXBlXHJcbiAgICAkLmVhY2goZGVmaW5pdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gdmFsdWUuY2hhckF0KDApO1xyXG4gICAgICAgIC8vJ1EyMDAsMjAwIDMwMCwzMDAgLT4gWycyMDAsMjAwJywgJzMwMCwzMDAnXVxyXG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZS5zdWJzdHJpbmcoMSx2YWx1ZS5sZW5ndGgpLnRyaW0oKS5zcGxpdCgnICcpO1xyXG4gICAgICAgIC8vWycyMDAsMjAwJywgJzMwMCwzMDAnXSAtPiBbe3g6MjAwLCB5OjIwMH0sIHt4OjMwMCwgeTozMDB9XVxyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAkLmVhY2godmFsdWVzLCBmdW5jdGlvbihpLCBjb29yZCkge1xyXG4gICAgICAgICAgICB2YXIgY29vcmRWYWxzID0gY29vcmQuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2gobWF0aC5nZXRQb2ludChwYXJzZUZsb2F0KGNvb3JkVmFsc1swXSksIHBhcnNlRmxvYXQoY29vcmRWYWxzWzFdKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoYXQuZGF0YS5hZGQocGF0aFR5cGVbdHlwZS50b0xvd2VyQ2FzZSgpXS5hcHBseSh1bmRlZmluZWQsIHBvaW50cykuc2V0QWJzb2x1dGUoKHR5cGUgPT0gdHlwZS50b1VwcGVyQ2FzZSgpKSkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRDb3JuZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgeE1pbiwgeE1heCwgeU1pbiwgeU1heDtcclxuICAgIHhNaW4gPSB5TWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgeE1heCA9IHlNYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcblxyXG4gICAgdGhpcy5kYXRhLmVhY2goZnVuY3Rpb24oaW5kZXgsIHBhdGhQYXJ0KSB7XHJcbiAgICAgICAgaWYocGF0aFBhcnQueCAmJiBwYXRoUGFydC55KSB7XHJcbiAgICAgICAgICAgIHhNaW4gPSAoeE1pbiA+IHBhdGhQYXJ0LngoKSkgPyBwYXRoUGFydC54KCkgOiB4TWluO1xyXG4gICAgICAgICAgICB5TWluID0gKHlNaW4gPiBwYXRoUGFydC55KCkpID8gcGF0aFBhcnQueSgpIDogeU1pbjtcclxuXHJcbiAgICAgICAgICAgIHhNYXggPSAoeE1heCA8IHBhdGhQYXJ0LngoKSkgPyBwYXRoUGFydC54KCkgOiB4TWF4O1xyXG4gICAgICAgICAgICB5TWF4ID0gKHlNYXggPCBwYXRoUGFydC55KCkpID8gcGF0aFBhcnQueSgpIDogeU1heDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHt4OnhNaW4sIHk6eU1pbn0sXHJcbiAgICAgICAge3g6eE1heCwgeTp5TWlufSxcclxuICAgICAgICB7eDp4TWF4LCB5OnlNYXh9LFxyXG4gICAgICAgIHt4OnhNaW4sIHk6eU1heH1cclxuICAgIF07XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29ybmVycygpWzBdLng7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29ybmVycygpWzBdLnk7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUucG9seW5vbXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMuZGF0YS52ZWN0b3JzLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpZih2YWx1ZS50bykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS50bygpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuc1xyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0UGF0aFBhcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgLy9XZSBzdGFydCBhdCBpbmRleCAxIGJlY2F1c2UgdGhlIDAgaW5kZXggb2YgdGhlIHZlY3RvciBjb250YWlucyB0aGUgcGF0aHBhcnQgdHlwZVxyXG4gICAgZm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLmxlbmd0aCgpIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZXRQYXRoUGFydChpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRQYXRoUGFydCA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICB2YXIgcGF0aFBhcnQgPSB0aGlzLnZhbHVlKGluZGV4KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhcnQ6IHRoaXMudmFsdWUoaW5kZXggLSAxKS50bygpLFxyXG4gICAgICAgIGVuZDogcGF0aFBhcnQudG8oKSxcclxuICAgICAgICB2YWx1ZTogcGF0aFBhcnRcclxuICAgIH07XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUubW92ZUFsb25nID0gZnVuY3Rpb24oaW5kZXgsIGRpc3RhbmNlLCBkaXJlY3Rpb24pIHtcclxuICAgIHZhciBwYXRoUGFydCA9IHRoaXMuZ2V0UGF0aFBhcnQoaW5kZXgpO1xyXG4gICAgaWYocGF0aFBhcnQudmFsdWUubW92ZUFsb25nKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhQYXJ0LnZhbHVlLm1vdmVBbG9uZyhwYXRoUGFydC5zdGFydCwgZGlzdGFuY2UsIGRpcmVjdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXRoLkxpbmUubW92ZUFsb25nKHBhdGhQYXJ0LnN0YXJ0LCBwYXRoUGFydC5lbmQsIGRpc3RhbmNlLCBkaXJlY3Rpb24pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHJvdWdoIGNlbnRlciBvZiB0aGUgcGF0aCBieSBjYWxjdWxhdGluZyB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBwYXRocGFydHMgKGFzIGRpcmVjdCBsaW5lcykgYW5kIG1vdmluZ1xyXG4gKiBhbG9uZyB0aG9zZSBsaW5lcyB0byB0aGUgY2VudGVyICh0b3RhbCBsZW5ndGggLyAyKS4gTm90ZSB3aXRoIHRoaXMgbWV0aG9kIHdlIGp1c3QgZ2V0IGEgZXhhY3QgcmVzdWx0IGZvciBzaW1wbGVcclxuICogbGluZSBwYXRocy4gSWYgdGhlIGNhbGN1bGF0ZWQgY2VudGVyIHBvc2l0aW9uIGlzIHdpdGhpbiBhIGN1YmljIGJlemllciBwYXRoIHBhcnQsIHdlIHJldHVybiB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgY3VydmVcclxuICogdG8gdGhlIGNhbGN1bGF0ZWQgY2VudGVyLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByZXN1bHREID0gdGhpcy5nZXREaXN0YW5jZSgpIC8gMjtcclxuICAgIHZhciBjdXJyZW50RCA9IDA7XHJcbiAgICB2YXIgY2VudGVyO1xyXG4gICAgb2JqZWN0LmVhY2godGhpcy5nZXRQYXRoUGFydHMoKSwgZnVuY3Rpb24oaW5kZXgsIHBhcnQpIHtcclxuICAgICAgICB2YXIgbGluZUQgPSBtYXRoLkxpbmUuY2FsY0Rpc3RhbmNlKHBhcnQuc3RhcnQsIHBhcnQuZW5kKTtcclxuICAgICAgICB2YXIgbmV4dEQgPSBjdXJyZW50RCArIGxpbmVEO1xyXG4gICAgICAgIGlmKG5leHREID4gcmVzdWx0RCkge1xyXG4gICAgICAgICAgICB2YXIgZGlmZkQgPSAgcmVzdWx0RCAtIGN1cnJlbnREO1xyXG4gICAgICAgICAgICBjZW50ZXIgPSBtYXRoLkxpbmUubW92ZUFsb25nKHBhcnQuc3RhcnQsIHBhcnQuZW5kLCBkaWZmRCk7XHJcblxyXG4gICAgICAgICAgICAvL0lmIHdlIGhhdmUgYSBjdWJpYyBiZXppZXIgcGF0aCBwYXJ0IHdlIGNhbGN1bGF0ZSB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgY3VydmVcclxuICAgICAgICAgICAgaWYocGFydC52YWx1ZS5pcygnYycpKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIgPSBwYXJ0LnZhbHVlLmdldE5lYXJlc3RQb2ludChwYXJ0LnN0YXJ0LCBjZW50ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEQgPSBuZXh0RDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNlbnRlcjtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMuZ2V0UGF0aFBhcnRzKCksIGZ1bmN0aW9uKGluZGV4LCBwYXJ0KSB7XHJcbiAgICAgICAgZGlzdGFuY2UgKz0gbWF0aC5MaW5lLmNhbGNEaXN0YW5jZShwYXJ0LnN0YXJ0LCBwYXJ0LmVuZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkaXN0YW5jZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBc3N1bWluZyB0aGVyZSBhcmUgb25seSEgY3ViaWMgYmV6aWVyIGN1cnZlZCBwYXRoIHBhcnRzIHRoaXMgZnVuY3Rpb24gcmVjYWxjdWxhdGVzIGFsbCBjb250cm9sIHBvaW50cyBvZiB0aGUgY3VydmVzXHJcbiAqIHRvIHNtb290aGVuIHRoZSBlbnRpcmUgcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBvbHlub21zXHJcbiAqL1xyXG5QYXRoRGF0YS5wcm90b3R5cGUuc21vb3RoZW4gPSBmdW5jdGlvbihwb2x5bm9tcykge1xyXG4gICAgaWYoIXBvbHlub21zKSB7XHJcbiAgICAgICAgcG9seW5vbXMgPSB0aGlzLnBvbHlub21zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHggPSBbXTtcclxuICAgIHZhciB5ID0gW107XHJcblxyXG4gICAgb2JqZWN0LmVhY2gocG9seW5vbXMsIGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHhbaW5kZXhdID0gdmFsdWUueDtcclxuICAgICAgICB5W2luZGV4XSA9IHZhbHVlLnk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgcHggPSBtYXRoLmJlemllci5jYWxjdWxhdGVTbW9vdGhDb250cm9sUG9pbnRzKHgpO1xyXG4gICAgdmFyIHB5ID0gbWF0aC5iZXppZXIuY2FsY3VsYXRlU21vb3RoQ29udHJvbFBvaW50cyh5KTtcclxuXHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBvYmplY3QuZWFjaChweC5wMSwgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhhdC52YWx1ZShpbmRleCArIDEpLmNvbnRyb2wxKHB4LnAxW2luZGV4XSwgcHkucDFbaW5kZXhdKTtcclxuICAgICAgICB0aGF0LnZhbHVlKGluZGV4ICsgMSkuY29udHJvbDIocHgucDJbaW5kZXhdLCBweS5wMltpbmRleF0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRMaW5lQnlQYXRoSW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgdmFyIHAxID0gdGhpcy52YWx1ZShpbmRleCAtIDEpLnRvKCk7XHJcbiAgICB2YXIgcDIgPSB0aGlzLnZhbHVlKGluZGV4KS50bygpO1xyXG4gICAgcmV0dXJuIG5ldyBtYXRoLkxpbmUocDEsIHAyKTtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXROZWFyZXN0UG9pbnQgPSBmdW5jdGlvbihwb2ludCkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRQYXRoSW5kZXhGb3JQb3NpdGlvbihwb2ludCk7XHJcbiAgICB2YXIgcGFydCA9IHRoaXMuZ2V0UGF0aFBhcnQoaW5kZXgpO1xyXG4gICAgaWYocGFydC52YWx1ZS5nZXROZWFyZXN0UG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gcGFydC52YWx1ZS5nZXROZWFyZXN0UG9pbnQocGFydC5zdGFydCwgcG9pbnQpO1xyXG4gICAgfTtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRQYXRoSW5kZXhGb3JQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvaW50KSB7XHJcblxyXG4gICAgaWYodGhpcy5sZW5ndGgoKSA9PT0gMikge1xyXG4gICAgICAgIC8vSWYgdGhlcmUgaXMganVzdCB0aGUgc3RhcnQgYW5kIGVuZCBkb2NraW5nIHdlIGtub3cgdGhlIG5ldyBpbmRleFxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkb2NraW5nSW5kZXggPSAxO1xyXG4gICAgdmFyIGNhbmRpZGF0ZSA9IFsxLE51bWJlci5QT1NJVElWRV9JTkZJTklUWSBdO1xyXG5cclxuICAgIG9iamVjdC5lYWNoKHRoaXMuZ2V0UGF0aFBhcnRzKCksIGZ1bmN0aW9uKGluZGV4LCBwYXJ0KSB7XHJcbiAgICAgICAgLy9Tb3J0IG91dCBwYXRocGFydHMgd2hpY2ggYXJlIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJ5IG9mIHN0YXJ0L2VuZCBwb2ludHMgd2l0aCBhIGxpdHRsZSB0b2xlcmFuY2Ugb2YgMTBweFxyXG4gICAgICAgIHZhciBwID0gbmV3IHV0aWwubWF0aC5Qb2ludChwb2ludCk7XHJcbiAgICAgICAgaWYocC5pc1dpdGhpblhJbnRlcnZhbChwYXJ0LnN0YXJ0LCBwYXJ0LmVuZCwgMTApKSB7XHJcbiAgICAgICAgICAgIHZhciBkO1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBtYXRoLkxpbmUocGFydC5zdGFydCwgcGFydC5lbmQpO1xyXG5cclxuICAgICAgICAgICAgaWYoIWxpbmUuaXNWZXJ0aWNhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkID0gTWF0aC5hYnMobGluZS5jYWxjRlgocG9pbnQueCkueSAtIHBvaW50LnkpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihwLmlzV2l0aGluWUludGVydmFsKHBhcnQuc3RhcnQsIHBhcnQuZW5kKSkge1xyXG4gICAgICAgICAgICAgICAgLy9TaW5jZSB0aGUgcG9pbnQgaXMgd2l0aGluIHggKHdpdGggdG9sZXJhbmNlKSBhbmQgeSBpbnRlcnZhbCB3ZSBjYWxjdWxhdGUgdGhlIHggZGlzdGFuY2VcclxuICAgICAgICAgICAgICAgIGQgPSBNYXRoLmFicyhwYXJ0LnN0YXJ0LnggLSBwLngpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlWzFdID4gZCkge1xyXG4gICAgICAgICAgICAgICAgLy9UaGUgcGF0aFBhcnRpbmRleCBpcyB0aGUgYXJyYXlpbmRleCArIDEgc2luY2Ugd2UgdXNlIHRoZSBlbmQgaW5kZXggb2YgdGhlIHBhdGggYXMgaWRlbnRpdHlcclxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVswXSA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVsxXSA9IGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVswXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qXHJcbiBMaW5lUGF0aE1hbmFnZXIucHJvdG90eXBlLmdldEdyYWRpZW4gPSBmdW5jdGlvbih4LHkpIHtcclxuIHZhciBwb3NpdGlvbiA9IHV0aWwubWF0aC5nZXRQb2ludCh4LHkpO1xyXG4gdmFyIGluZGV4ID0gdGhpcy50cmFuc2l0aW9uLmdldEtub2JJbmRleEZvclBvaW50KHBvc2l0aW9uKTtcclxuIHZhciBwMSA9IHRoaXMuZGF0YS5nZXREb2NraW5nQnlJbmRleChpbmRleCkucG9zaXRpb24oKTtcclxuIHZhciBwMiA9IHRoaXMuZGF0YS5nZXREb2NraW5nQnlJbmRleChpbmRleCArIDEpLnBvc2l0aW9uKCk7XHJcbiByZXR1cm4gdXRpbC5tYXRoLkxpbmUuY2FsY0dyYWRpZW50KHAxLCBwMik7XHJcbiB9O1xyXG5cclxuIExpbmVQYXRoTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JhZGllbnRCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuIHZhciBwMSA9IHRoaXMuZGF0YS5nZXREb2NraW5nQnlJbmRleChpbmRleCkucG9zaXRpb24oKTtcclxuIHZhciBwMiA9IHRoaXMuZGF0YS5nZXREb2NraW5nQnlJbmRleChpbmRleCArIDEpLnBvc2l0aW9uKCk7XHJcbiByZXR1cm4gdXRpbC5tYXRoLkxpbmUuY2FsY0dyYWRpZW50KHAxLCBwMik7XHJcbiB9O1xyXG5cclxuXHJcbiBMaW5lUGF0aE1hbmFnZXIucHJvdG90eXBlLmdldFZlY3RvckJ5SW5kZXggPSBmdW5jdGlvbihpbmRleCwgZnJvbUVuZCkge1xyXG4gdmFyIHAxLCBwMjtcclxuIGlmKGZyb21FbmQpIHtcclxuIHAxID0gdGhpcy5kYXRhLmdldERvY2tpbmdCeUVuZEluZGV4KGluZGV4ICsgMSkucG9zaXRpb24oKTtcclxuIHAyID0gdGhpcy5kYXRhLmdldERvY2tpbmdCeUVuZEluZGV4KGluZGV4KS5wb3NpdGlvbigpO1xyXG4gfSBlbHNlIHtcclxuIHAxID0gdGhpcy5kYXRhLmdldERvY2tpbmdCeUluZGV4KGluZGV4KS5wb3NpdGlvbigpO1xyXG4gcDIgPSB0aGlzLmRhdGEuZ2V0RG9ja2luZ0J5SW5kZXgoaW5kZXggKyAxKS5wb3NpdGlvbigpO1xyXG4gfVxyXG4gcmV0dXJuIHV0aWwubWF0aC5MaW5lLmNhbGNOb3JtYWxpemVkTGluZVZlY3RvcihwMSwgcDIpO1xyXG4gfTtcclxuICovXHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDb3JuZXJzKClbMF0ueTtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5nZXRSaWdodFggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29ybmVycygpWzFdLng7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuZ2V0Qm90dG9tWSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDb3JuZXJzKClbMl0ueTtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKG9iamVjdC5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRhdGEuY2xlYXIoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGgoKTtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnZhbHVlKGluZGV4KTtcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5sYXN0SW5kZXhPZlR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvcihpID0gdGhpcy5sZW5ndGgoKSAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZShpKTtcclxuICAgICAgICBpZih2YWx1ZS5pcyh0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUudmFsdWVzQnlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIG9iamVjdC5lYWNoKHRoaXMuZGF0YS52ZWN0b3JzLCBmdW5jdGlvbihpLCB2YWx1ZSkge1xyXG4gICAgICAgaWYodmFsdWUuaXModHlwZSkpIHtcclxuICAgICAgICAgICByZXN1bHQucHVzaCh7aW5kZXg6aSwgdmFsdWU6dmFsdWV9KTtcclxuICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihwLCBhYnNvbHV0ZSkge1xyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlKDApLnRvKCk7XHJcbiAgICB9IGVsc2UgaWYodGhpcy5sZW5ndGgoKSA+IDApIHtcclxuICAgICAgICB0aGlzLnZhbHVlKDApLnRvKHApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRhdGEuc2V0VmFsdWUoMCwgbmV3IE1vdmVUbyhwLCBhYnNvbHV0ZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sYXN0KCkudG8odmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3QoKS50bygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IHJlZmFjdG9yIHRvIHNldFRvXHJcbiAqIEBwYXJhbSBpbmRleFxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICogQHJldHVybnMge1BhdGhEYXRhfVxyXG4gKi9cclxuUGF0aERhdGEucHJvdG90eXBlLnNldFRvID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICB0aGlzLmRhdGEudmFsdWUoaW5kZXgpLnRvKHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLnJlbW92ZVBhdGggPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgdGhpcy5kYXRhLnJlbW92ZShpbmRleCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5kYXRhLmFkZChuZXcgQ29tcGxldGUoKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5saW5lID0gZnVuY3Rpb24oeCx5KSB7XHJcbiAgICB2YXIgcCA9IG1hdGguZ2V0UG9pbnQoeCx5KTtcclxuICAgIHRoaXMuZGF0YS5hZGQobmV3IExpbmVUbyhwLCB0cnVlKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5jQmV6aWVyID0gZnVuY3Rpb24oYzEsIGMyLCB0bykge1xyXG4gICAgdGhpcy5kYXRhLmFkZChuZXcgQ0JlemllcihjMSxjMiwgdG8sIHRydWUpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IExpbmUgdG9cclxuICogQHBhcmFtIGluZGV4XHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKiBAcGFyYW0gYWJzb2x1dGVcclxuICogQHJldHVybnMge1BhdGhEYXRhfVxyXG4gKi9cclxuUGF0aERhdGEucHJvdG90eXBlLmluc2VydExpbmUgPSBmdW5jdGlvbihpbmRleCwgdG8sIGFic29sdXRlKSB7XHJcbiAgICB0aGlzLmRhdGEuaW5zZXJ0KGluZGV4LCBuZXcgTGluZVRvKHRvLGFic29sdXRlKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5xQmV6aWVyID0gZnVuY3Rpb24oY29udHJvbFAsdG9QKSB7XHJcbiAgICB0aGlzLmRhdGEuYWRkKG5ldyBRQmV6aWVyKGNvbnRyb2xQLHRvUCwgdHJ1ZSkpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5QYXRoRGF0YS5wcm90b3R5cGUuaW5zZXJ0UUJlemllciA9IGZ1bmN0aW9uKGluZGV4LGMsIHRvLCBhYnNvbHV0ZSkge1xyXG4gICAgdGhpcy5kYXRhLmluc2VydChpbmRleCwgbmV3IFFCZXppZXIoYywgdG8sIGFic29sdXRlKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblBhdGhEYXRhLnByb3RvdHlwZS5pbnNlcnRDQmV6aWVyID0gZnVuY3Rpb24oaW5kZXgsIGMxLCBjMiwgdG8sIGFic29sdXRlKSB7XHJcbiAgICB0aGlzLmRhdGEuaW5zZXJ0KGluZGV4LCBuZXcgQ0JlemllcihjMSxjMiwgdG8sYWJzb2x1dGUpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUGF0aERhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGlzLmRhdGEuZWFjaChmdW5jdGlvbihpbmRleCwgcGF0aFBhcnQpIHtcclxuICAgICAgIHJlc3VsdCArPSBwYXRoUGFydC50b1N0cmluZygpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGF0aERhdGE7IiwidmFyIERvbUVsZW1lbnQgPSByZXF1aXJlKCcuLi9kb20vZG9tRWxlbWVudCcpO1xyXG52YXIgU3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBkb20gPSB1dGlsLmRvbTtcclxudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xyXG5cclxuLypcclxuICogQ29uc3RydWN0b3IgZm9yIFNWRyBFbGVtZW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3R5cGV9IG5hbWUgdGhlIGVsZW1lbnQgTmFtZSBlLmcuIHJlY3QsIGNpcmNsZSwgcGF0aC4uLlxyXG4gKiBAcGFyYW0ge3R5cGV9IGNmZyBhdHRyaWJ1dGVzIGFuZCBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb25zXHJcbiAqIEBwYXJhbSB7dHlwZX0gYXR0cmlidXRlU2V0dGVyIHlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgYXR0cmlidXRlIHNldHRlclxyXG4gKiBmb3Igc3BlY2lhbCBhdHRyaWJ1dGVzIGRlZmF1bHQgYXR0cmlidXRlIHNldHRlciBnaXZlbiBieSB0aGlzIGltcGVsZW1lbnRhdGlvblxyXG4gKiBhcmUgdHJhbnNmb3JtIGFuZCBzdHlsZSBzZXR0ZXJcclxuICovXHJcbnZhciBTVkdFbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgc3ZnLCBjZmcsIGF0dHJpYnV0ZVNldHRlcikge1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVTZXR0ZXIgPSBhdHRyaWJ1dGVTZXR0ZXIgfHwge307XHJcbiAgICB0aGlzLmF0dHJpYnV0ZVNldHRlci5zdHlsZSA9IHRoaXMuc3R5bGVBdHRyaWJ1dGVTZXR0ZXI7XHJcbiAgICB0aGlzLlNWR0VsZW1lbnQgPSB0cnVlO1xyXG5cclxuICAgIC8vIElmIGZpcnN0IGF0dHJpYnV0ZSBpcyBub3QgYSBzdHJpbmcgd2UgYXNzdW1lIGEgc3ZnIG5vZGUgY29uc3RydWN0b3IgY2FsbC5cclxuICAgIGlmKCFvYmplY3QuaXNTdHJpbmcobmFtZSkpIHtcclxuICAgICAgICB0aGlzLmluc3RhbmNlKG5hbWUpO1xyXG4gICAgICAgIGNmZyA9IGRvbS5nZXRBdHRyaWJ1dGVzKG5hbWUpO1xyXG4gICAgICAgIG5hbWUgPSBuYW1lLnRhZ05hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdmcgPSBzdmc7XHJcbiAgICB0aGlzLnJvb3QgPSBzdmcucm9vdCB8fCB0aGlzO1xyXG4gICAgRG9tRWxlbWVudC5jYWxsKHRoaXMsIG5hbWUsIGNmZywgdGhpcy5hdHRyaWJ1dGVTZXR0ZXIpO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhTVkdFbGVtZW50LCBEb21FbGVtZW50KTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLnN0eWxlQXR0cmlidXRlU2V0dGVyID0gZnVuY3Rpb24odHJuYXNmb3JtYXRpb25TdHJpbmcpIHtcclxuICAgIHJldHVybiBuZXcgU3R5bGUodHJuYXNmb3JtYXRpb25TdHJpbmcpO1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QuaW5zdGFuY2UoKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLmdldFNWR1Jvb3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3Q7XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICByZXN1bHQgPSBbXTtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgb2JqZWN0LmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihpbmRleCwgdmFsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuYXBwZW5kKHZhbCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJlc3VsdCA9ICB1dGlsLmRvbS5hcHBlbmRTVkdFbGVtZW50KHRoaXMuaW5zdGFuY2UoKSwgZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBvYmplY3QuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGluZGV4LCB2YWwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5wcmVwZW5kKHZhbCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJlc3VsdCA9ICB1dGlsLmRvbS5wcmVwZW5kU1ZHRWxlbWVudCh0aGlzLmluc3RhbmNlKCksIGFyZ3VtZW50c1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLiQoKS5yZW1vdmUoKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuc3ZnLmdldCh0aGlzLiQoKS5maW5kKHNlbGVjdG9yKSk7XHJcbiAgICByZXR1cm4gdXRpbC5vYmplY3QuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0IDogW3Jlc3VsdF07XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5maXJzdENoaWxkID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiAkLnN2Zyh0aGlzLiQoKS5jaGlsZHJlbihzZWxlY3RvcikuZmlyc3QoKSk7XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICByZXR1cm4gJC5zdmcodGhpcy4kKCkuY2hpbGRyZW4oc2VsZWN0b3IpKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICQuc3ZnKHRoaXMuJCgpLnBhcmVudCgpKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgIHZhciAkbm9kZSA9IHRoaXMuJCgpO1xyXG4gICAgJG5vZGUucHJldkFsbChzZWxlY3RvcikuZmlyc3QoKS5iZWZvcmUoJG5vZGUpO1xyXG59O1xyXG5cclxuU1ZHRWxlbWVudC5wcm90b3R5cGUubW92ZVVwID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgIHZhciAkbm9kZSA9IHRoaXMuJCgpO1xyXG4gICAgJG5vZGUubmV4dEFsbChzZWxlY3RvcikuZmlyc3QoKS5hZnRlcigkbm9kZSk7XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkb20ucHJlcGVuZFRvUm9vdCh0aGlzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNWRyBTdHlsZXNcclxuICovXHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgIGlmKCFvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSAmJiBvYmplY3QuaXNTdHJpbmcoa2V5KSAmJiBrZXkuaW5kZXhPZignOicpIDw9IDBcclxuICAgICAgICAmJiBvYmplY3QuaXNEZWZpbmVkKHRoaXMuYXR0cmlidXRlcy5zdHlsZSkpIHtcclxuICAgICAgICAvL0dFVFRFUiBDQUxMXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5zdHlsZS5nZXQoa2V5KTtcclxuICAgIH0gZWxzZSBpZighb2JqZWN0LmlzRGVmaW5lZCh0aGlzLmF0dHJpYnV0ZXMuc3R5bGUpICYmIG9iamVjdC5pc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnN0eWxlID0gbmV3IFN0eWxlKGtleSwgdmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLmRhbGEgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkYWxhOicra2V5LCB2YWx1ZSk7XHJcbn07XHJcblxyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5nZXRCQm94ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZSgpLmdldEJCb3goKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdXRpbC54bWwuc2VyaWFsaXplVG9TdHJpbmcodGhpcy5pbnN0YW5jZSgpKTtcclxufTtcclxuXHJcblNWR0VsZW1lbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kKCkuY2xvbmUoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHRWxlbWVudDtcclxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBTVkdFbGxpcHNlID0gcmVxdWlyZSgnLi9lbGxpcHNlJyk7XHJcbnZhciBTVkdTaGFwZSA9IHJlcXVpcmUoJy4vc3ZnU2hhcGUnKTtcclxuXHJcbnZhciBTVkdDaXJjbGUgPSBmdW5jdGlvbihzdmdSb290LCBjZmcpIHtcclxuICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgIFNWR1NoYXBlLmNhbGwodGhpcywgJ2NpcmNsZScsIHN2Z1Jvb3QsIGNmZyk7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKFNWR0NpcmNsZSwgU1ZHRWxsaXBzZSk7XHJcblxyXG5TVkdDaXJjbGUucHJvdG90eXBlLnIgPSBmdW5jdGlvbih2YWx1ZSwgbm9TY2FsZSkge1xyXG4gICAgdmFyIHNjYWxlID0gKG5vU2NhbGUpID8gMSA6IHRoaXMuc2NhbGUoKVsxXTtcclxuICAgIGlmKCghb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgb2JqZWN0LmlzQm9vbGVhbih2YWx1ZSkgJiYgIXZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJOdW1iZXIoJ3InKSAqIHNjYWxlO1xyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmF0dHJOdW1iZXIoJ3InKSArICh0aGlzLnN0cm9rZVdpZHRoKCkgLyAyKSkgKiBzY2FsZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hdHRyTnVtYmVyKCdyJywgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHQ2lyY2xlLnByb3RvdHlwZS5fc2V0SGVpZ2h0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHZhciB2ID0gdmFsdWUgLyAyO1xyXG4gICAgdGhpcy5jeSh2KS5jeCh2KS5yKHYpO1xyXG59O1xyXG5cclxuU1ZHQ2lyY2xlLnByb3RvdHlwZS5fc2V0V2lkdGggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGVpZ2h0KHZhbHVlKTtcclxufTtcclxuXHJcblNWR0NpcmNsZS5wcm90b3R5cGUucnggPSBmdW5jdGlvbih2YWx1ZSwgbm9TY2FsZSkge1xyXG4gICAgcmV0dXJuIHRoaXMucih2YWx1ZSwgbm9TY2FsZSk7XHJcbn07XHJcblxyXG5TVkdDaXJjbGUucHJvdG90eXBlLnJ5ID0gZnVuY3Rpb24odmFsdWUsIG5vU2NhbGUpIHtcclxuICAgIHJldHVybiB0aGlzLnIodmFsdWUsIG5vU2NhbGUpO1xyXG59O1xyXG5cclxuU1ZHQ2lyY2xlLnByb3RvdHlwZS5vdmVybGF5Q2hlY2sgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIG5ldyB1dGlsLm1hdGguQ2lyY2xlKHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMucigpKS5vdmVybGF5cyhwb3NpdGlvbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0NpcmNsZTsiLCJ2YXIgRHJhZ0NvbmZpZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5ob29rcyA9IHt9O1xyXG59O1xyXG5cclxuRHJhZ0NvbmZpZy5wcm90b3R5cGUueE9ubHkgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaG9va3MucmVzdHJpY3Rpb25ZID0gZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRHJhZ0NvbmZpZy5wcm90b3R5cGUueU9ubHkgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaG9va3MucmVzdHJpY3Rpb25YID0gZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRHJhZ0NvbmZpZy5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbihnc0hvb2spIHtcclxuICAgIHRoaXMuaG9va3MuZ2V0U2NhbGUgPSBnc0hvb2s7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkRyYWdDb25maWcucHJvdG90eXBlLmRyYWdNb3ZlID0gZnVuY3Rpb24oZHJtSG9vaykge1xyXG4gICAgdGhpcy5ob29rcy5kcmFnTW92ZSA9IGRybUhvb2s7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkRyYWdDb25maWcucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uKGRyc0hvb2spIHtcclxuICAgIHRoaXMuaG9va3MuZHJhZ1N0YXJ0ID0gZHJzSG9vaztcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRHJhZ0NvbmZpZy5wcm90b3R5cGUuZHJhZ0VuZCA9IGZ1bmN0aW9uKGRyZUhvb2spIHtcclxuICAgIHRoaXMuaG9va3MuZHJhZ0VuZCA9IGRyZUhvb2s7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkRyYWdDb25maWcucHJvdG90eXBlLnJlc3RyaWN0aW9uWCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaG9va3MucmVzdHJpY3Rpb25YO1xyXG59O1xyXG5cclxuRHJhZ0NvbmZpZy5wcm90b3R5cGUucmVzdHJpY3Rpb25ZID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ob29rcy5yZXN0cmljdGlvblk7XHJcbn07XHJcblxyXG5EcmFnQ29uZmlnLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmhvb2tzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEcmFnQ29uZmlnOyIsInZhciBTVkdTaGFwZSA9IHJlcXVpcmUoJy4vc3ZnU2hhcGUnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29yZS9jb25maWcnKTtcclxuXHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIGRvbSA9IHV0aWwuZG9tO1xyXG5cclxudmFyIFNoaWZ0RHJhZyA9IGZ1bmN0aW9uKGNmZykge1xyXG4gICAgdGhpcy5jZmcgPSBjZmc7XHJcbiAgICBpZighY2ZnLnJlc3RyaWN0aW9uWCAmJiAhY2ZnLnJlc3RyaWN0aW9uWSkge1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRpc2FibGUoKTtcclxuICAgIH1cclxufTtcclxuXHJcblNoaWZ0RHJhZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zdGF0ZSA9ICdpbml0JztcclxuICAgIHRoaXMueFNoaWZ0ID0ge1xyXG4gICAgICAgIHNoaWZ0QWxpZ24gOiAwLFxyXG4gICAgICAgIHVuc2hpZnRBbGlnbiA6IDBcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy55U2hpZnQgPSB7XHJcbiAgICAgICAgc2hpZnRBbGlnbiA6IDAsXHJcbiAgICAgICAgdW5zaGlmdEFsaWduIDogMFxyXG4gICAgfTtcclxufTtcclxuXHJcblNoaWZ0RHJhZy5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zdGF0ZSA9ICdkaXNhYmxlZCc7XHJcbn07XHJcblxyXG5TaGlmdERyYWcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGV2dCwgZHggLGR5KSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgJ2luaXQnIDpcclxuICAgICAgICAgICAgdGhpcy54U2hpZnQuc2hpZnRBbGlnbiArPSBkeDtcclxuICAgICAgICAgICAgdGhpcy55U2hpZnQuc2hpZnRBbGlnbiArPSBkeTtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuY2hlY2tTaGlmdEhvb2soZXZ0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnModGhpcy54U2hpZnQuc2hpZnRBbGlnbikgPiBNYXRoLmFicyh0aGlzLnlTaGlmdC5zaGlmdEFsaWduKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdHJpY3Rpb25YID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdHJpY3Rpb25ZID0gZnVuY3Rpb24oZXZ0LCBkeCAsZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2hpZnRSZXN0cmljdGlvbih0aGF0LnlTaGlmdCwgZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdzaGlmdGVkWCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdHJpY3Rpb25ZID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdHJpY3Rpb25YID0gZnVuY3Rpb24oZXZ0LCBkeCAsIGR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnNoaWZ0UmVzdHJpY3Rpb24odGhhdC54U2hpZnQsIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnc2hpZnRlZFknO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3NoaWZ0ZWRYJzpcclxuICAgICAgICAgICAgaWYoIWV2dC5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0cmljdGlvblkgPSBmdW5jdGlvbihldnQsIGR4LCBkeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnVuU2hpZnRSZXN0cmljdGlvbih0aGF0LnlTaGlmdCwgZHkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnaW5pdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc2hpZnRlZFknOlxyXG4gICAgICAgICAgICBpZighZXZ0LnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RyaWN0aW9uWCA9IGZ1bmN0aW9uKGV2dCwgZHggLGR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQudW5TaGlmdFJlc3RyaWN0aW9uKHRoYXQueFNoaWZ0LCBkeCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdpbml0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5TaGlmdERyYWcucHJvdG90eXBlLnNoaWZ0UmVzdHJpY3Rpb24gPSBmdW5jdGlvbihzaGlmdERhdGEsIGQpIHtcclxuICAgIC8vVXBkYXRlIHNoaWZ0ZWQgZFxyXG4gICAgc2hpZnREYXRhLnVuc2hpZnRBbGlnbiArPSBkO1xyXG4gICAgLy9BbGlnbiBzaGlmdCBkcmFnIGJhY2sgdG8gdGhlIHN0YXJ0IHBvc2l0aW9uXHJcbiAgICB2YXIgcmVzdWx0ID0gKE1hdGguYWJzKHNoaWZ0RGF0YS5zaGlmdEFsaWduKSA+IDApID8gc2hpZnREYXRhLnNoaWZ0QWxpZ24gKiAtMSA6IDA7XHJcbiAgICBzaGlmdERhdGEuc2hpZnRBbGlnbiA9IDA7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU2hpZnREcmFnLnByb3RvdHlwZS51blNoaWZ0UmVzdHJpY3Rpb24gPSBmdW5jdGlvbihzaGlmdERhdGEsIGQpIHtcclxuICAgIC8vQWxpZ24gc2hpZnQgZHJhZyBiYWNrIHRvIHRoZSBzdGFydCBwb3NpdGlvblxyXG4gICAgdmFyIHJlc3VsdCA9IHNoaWZ0RGF0YS51bnNoaWZ0QWxpZ24gKyBkO1xyXG4gICAgc2hpZnREYXRhLnVuc2hpZnRBbGlnbiA9IDA7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU2hpZnREcmFnLnByb3RvdHlwZS5jaGVja1NoaWZ0SG9vayA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgcmV0dXJuIGV2dC5zaGlmdEtleSAmJiAoTWF0aC5hYnModGhpcy54U2hpZnQuc2hpZnRBbGlnbikgPiA0IHx8IE1hdGguYWJzKHRoaXMueVNoaWZ0LnNoaWZ0QWxpZ24pID4gNCk7XHJcbn07XHJcblxyXG4vL1RPRE86IHRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHRvIHVzZSB0aGUgYWxpZ25tZW50IGFsaWduIGNlbnRlciB0byBjZW50ZXIueCBpZiBjaGVja1NoaWZ0SG9va1xyXG5cclxuU2hpZnREcmFnLnByb3RvdHlwZS5nZXRSZXN0cmljdGlvblggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmNmZy5yZXN0cmljdGlvblggfHwgdGhpcy5yZXN0cmljdGlvblg7XHJcbn07XHJcblxyXG5TaGlmdERyYWcucHJvdG90eXBlLmdldFJlc3RyaWN0aW9uWSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2ZnLnJlc3RyaWN0aW9uWSB8fCB0aGlzLnJlc3RyaWN0aW9uWTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5kcmFnZ2FibGUgPSBmdW5jdGlvbihjZmcsIGRyYWdFbGVtZW50KSB7XHJcbiAgICB2YXIgY2ZnID0gY2ZnIHx8IHt9O1xyXG5cclxuICAgIGlmKGRyYWdFbGVtZW50KSB7XHJcbiAgICAgICAgZHJhZ0VsZW1lbnQgPSB0aGlzLnN2Zy5nZXQoZHJhZ0VsZW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkcmFnRWxlbWVudCA9IHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIHZhciBkcmFnTW92ZSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGlmKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFldnQudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vdGhhdC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYWN0dWFsZHggPSAob2JqZWN0LmlzRGVmaW5lZChldnQuZHgpKSA/IGV2dC5keCA6IGV2dC5jbGllbnRYIC0gdGhhdC5kcmFnQ3VycmVudFg7XHJcbiAgICAgICAgdmFyIGFjdHVhbGR5ID0gKG9iamVjdC5pc0RlZmluZWQoZXZ0LmR5KSkgPyBldnQuZHkgOiBldnQuY2xpZW50WSAtIHRoYXQuZHJhZ0N1cnJlbnRZO1xyXG5cclxuICAgICAgICAvLyBEUkFHIEJFRk9SRSBIT09LXHJcbiAgICAgICAgaWYoY2ZnLmRyYWdCZWZvcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgIGNmZy5kcmFnQmVmb3JlTW92ZS5hcHBseSh0aGF0LCBbZXZ0LCBhY3R1YWxkeCwgYWN0dWFsZHldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERSQUcgQUxJR05NRU5UXHJcbiAgICAgICAgaWYoY2ZnLmRyYWdBbGlnbm1lbnQgJiYgIWV2dC50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGFsaWdubWVudCA9IGNmZy5kcmFnQWxpZ25tZW50LmNoZWNrKGFjdHVhbGR4LCBhY3R1YWxkeSk7XHJcbiAgICAgICAgICAgIGFjdHVhbGR4ID0gYWxpZ25tZW50LmR4O1xyXG4gICAgICAgICAgICBhY3R1YWxkeSA9IGFsaWdubWVudC5keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQ2hlY2sgZm9yIHNoaWZ0RHJhZyByZXN0cmljdGlvbiwgc2hpZnREcmFnIHdpbGwgb25seSBob29rIHVwIGlmIG5vIG90aGVyIHJlc3RyaWN0aW9uIGlzIHNldC5cclxuICAgICAgICAvL1NoaWZ0ZHJhZyBpcyBub3QgZ2l2ZW4gZm9yIHRyaWdnZXJkcmFnc1xyXG4gICAgICAgIGlmKHRoYXQuc2hpZnREcmFnICYmICFldnQudHJpZ2dlckV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2hpZnREcmFnLnVwZGF0ZShldnQsIGFjdHVhbGR4LCBhY3R1YWxkeSk7XHJcbiAgICAgICAgICAgIHZhciByZXN0cmljdGlvblggPSB0aGF0LnNoaWZ0RHJhZy5nZXRSZXN0cmljdGlvblgoKTtcclxuICAgICAgICAgICAgdmFyIHJlc3RyaWN0aW9uWSA9IHRoYXQuc2hpZnREcmFnLmdldFJlc3RyaWN0aW9uWSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRFJBRyBSRVNUUklDVElPTlxyXG4gICAgICAgIHZhciBkeCA9IChyZXN0cmljdGlvblggJiYgIWV2dC50cmlnZ2VyRXZlbnQpID8gcmVzdHJpY3Rpb25YLmFwcGx5KHRoYXQsIFtldnQsIGFjdHVhbGR4LCBhY3R1YWxkeV0pIDogYWN0dWFsZHg7XHJcbiAgICAgICAgdmFyIGR5ID0gKHJlc3RyaWN0aW9uWSAmJiAhZXZ0LnRyaWdnZXJFdmVudCkgPyByZXN0cmljdGlvblkuYXBwbHkodGhhdCwgW2V2dCwgYWN0dWFsZHgsIGFjdHVhbGR5XSkgOiBhY3R1YWxkeTtcclxuXHJcbiAgICAgICAgLy9UT0RPOiBzb21laG93IHRoZSBzY2FsZSBzaG91bGQgYmUgZGV0ZXJtaW5lZCBpbiBhIG1vcmUgZWxlZ2FudCB3YXkgcGVyaGFwcyBzdG9yZSBpdCBpbiBzdmcgaW5zdGFuY2UuLi5cclxuICAgICAgICBpZihjZmcuZ2V0U2NhbGUgJiYgIWV2dC50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlID0gY2ZnLmdldFNjYWxlKCk7XHJcbiAgICAgICAgICAgIGR4IC89IHNjYWxlO1xyXG4gICAgICAgICAgICBkeSAvPSBzY2FsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVYRUNVVEUgRFJBR1xyXG4gICAgICAgIGlmKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoYXQubW92ZShkeCwgZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGV2dERhdGEgPSBnZXRNb3VzZUV2ZW50RGF0YShldnQpO1xyXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBtb3VzZSBwb3NpdGlvblxyXG4gICAgICAgIHRoYXQuZHJhZ0N1cnJlbnRYID0gZXZ0RGF0YS5jbGllbnRYO1xyXG4gICAgICAgIHRoYXQuZHJhZ0N1cnJlbnRZID0gZXZ0RGF0YS5jbGllbnRZO1xyXG5cclxuICAgICAgICB0aGF0LmR4U3VtICs9IGR4O1xyXG4gICAgICAgIHRoYXQuZHlTdW0gKz0gZHk7XHJcblxyXG4gICAgICAgIC8vIERSQUcgTU9WRSBIT09LXHJcbiAgICAgICAgaWYoY2ZnLmRyYWdNb3ZlKSB7XHJcbiAgICAgICAgICAgIGNmZy5kcmFnTW92ZS5hcHBseSh0aGF0LCBbZXZ0LCBkeCwgZHldKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBkcmFnRW5kID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgLy9UdXJuIG9mZiBkcmFnIGV2ZW50c1xyXG4gICAgICAgIHRoYXQuZ2V0U1ZHUm9vdCgpLm9mZignbW91c2Vtb3ZlJyk7XHJcbiAgICAgICAgZXZlbnQub2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIGRyYWdFbmQpO1xyXG5cclxuICAgICAgICBpZihjZmcuZHJhZ0FsaWdubWVudCkge1xyXG4gICAgICAgICAgICBjZmcuZHJhZ0FsaWdubWVudC5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kcmFnID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmKGNmZy5jdXJzb3IpIHtcclxuICAgICAgICAgICAgJCgnYm9keScpLmNzcygnY3Vyc29yJywnZGVmYXVsdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRFJBRyBFTkQgSE9PS1xyXG4gICAgICAgIGlmKGNmZy5kcmFnRW5kKSB7XHJcbiAgICAgICAgICAgIGNmZy5kcmFnRW5kLmFwcGx5KHRoYXQsIFtldnRdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGhhdC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdhbGwnKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYoZHJhZ0VsZW1lbnQpIHtcclxuICAgICAgICB2YXIgbW91c2VEb3duSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYoZS5jdHJsS2V5IHx8ICF0aGF0LmlzVmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgLy8gV2Ugc3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24gdG8gcHJldmVudCB0aGUgZG9jdW1lbnQgbW91c2Vkb3duIGhhbmRsZXIgdG8gZmlyZVxyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgaW5pdERyYWdWYWx1ZXModGhhdCwgZSwgY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERSQUcgU1RBUlQgSE9PS1xyXG4gICAgICAgICAgICBpZihjZmcuZHJhZ1N0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBjZmcuZHJhZ1N0YXJ0LmFwcGx5KHRoYXQsIFtlXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGNmZy5jdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgICQoJ2JvZHknKS5jc3MoJ2N1cnNvcicsIGNmZy5jdXJzb3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGF0LmRyYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBldmVudC5vbih0aGF0LmdldFJvb3ROb2RlKCksICdtb3VzZW1vdmUnLCBkcmFnTW92ZSk7XHJcbiAgICAgICAgICAgIGV2ZW50Lm9uKGRvY3VtZW50LCAnbW91c2V1cCcsIGRyYWdFbmQpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZihjZmcub25jZSkge1xyXG4gICAgICAgICAgICBkcmFnRWxlbWVudC5vbignbW91c2Vkb3duJywgbW91c2VEb3duSGFuZGxlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZHJhZ0VsZW1lbnQub24oJ21vdXNlZG93bicsIG1vdXNlRG93bkhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1NpbXVsYXRlcyBhbiBkcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICB0aGlzLmluaXREcmFnID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZHJhZ0VsZW1lbnQudHJpZ2dlcignbW91c2Vkb3duJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vRm9yIG1hbnVhbCBkcmFnZ2luZyBhIHN2ZyBlbGVtZW50IHRoZSB0cmlnZ2VyRXZlbnQgaXMgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50IHdhcyB0cmlnZ2VyZWQgbWFudWFsbHlcclxuICAgIC8vU2VlIFNlbGVjdGlvbm1hbmFnZXIgc2V0Tm9kZVNlbGVjdGlvbiBkcmFnTW92ZSBoYW5kbGVyXHJcbiAgICB0aGlzLnRyaWdnZXJEcmFnID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICAgICAgZHJhZ01vdmUuYXBwbHkodGhpcyxbe2R4OmR4LCBkeTpkeSwgdHJpZ2dlckV2ZW50OnRydWV9XSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxudmFyIGluaXREcmFnVmFsdWVzID0gZnVuY3Rpb24odGhhdCwgZXZ0LCBjZmcpIHtcclxuICAgIHRoYXQuZHhTdW0gPSAwO1xyXG4gICAgdGhhdC5keVN1bSA9IDA7XHJcbiAgICB0aGF0LnNoaWZ0RHJhZyA9IG5ldyBTaGlmdERyYWcoY2ZnKTtcclxuICAgIHZhciBldnREYXRhID0gZ2V0TW91c2VFdmVudERhdGEoZXZ0KTtcclxuICAgIHRoYXQuZHJhZ0N1cnJlbnRYID0gZXZ0RGF0YS5jbGllbnRYO1xyXG4gICAgdGhhdC5kcmFnQ3VycmVudFkgPSBldnREYXRhLmNsaWVudFk7XHJcblxyXG4gICAgdGhhdC5kcmFnID0gdHJ1ZTtcclxufTtcclxuXHJcbnZhciBnZXRNb3VzZUV2ZW50RGF0YSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgaWYoIWV2dC5jbGllbnRYKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50Lm1vdXNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZ0O1xyXG59OyIsInZhciBzaGFwZXMgPSB7fVxyXG5zaGFwZXMuc3ZnID0gc2hhcGVzLlN2ZyA9IHJlcXVpcmUoJy4vc3ZnUm9vdCcpO1xyXG5zaGFwZXMuY2lyY2xlID0gc2hhcGVzLkNpcmNsZSA9IHJlcXVpcmUoJy4vY2lyY2xlJyk7XHJcbnNoYXBlcy5lbGxpcHNlID0gc2hhcGVzLkVsbGlwc2UgPSByZXF1aXJlKCcuL2VsbGlwc2UnKTtcclxuc2hhcGVzLnRleHQgPSBzaGFwZXMuVGV4dCA9IHJlcXVpcmUoJy4vdGV4dCcpO1xyXG5zaGFwZXMudHNwYW4gPSBzaGFwZXMuVFNwYW4gPSByZXF1aXJlKCcuL3RzcGFuJyk7XHJcbnNoYXBlcy5wYXRoID0gc2hhcGVzLlBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcclxuc2hhcGVzLnJlY3QgPSBzaGFwZXMuUmVjdCA9IHJlcXVpcmUoJy4vcmVjdCcpO1xyXG5zaGFwZXMuZyA9IHNoYXBlcy5Hcm91cCA9IHJlcXVpcmUoJy4vZ3JvdXAnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBzaGFwZXM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBTVkdTaGFwZSA9IHJlcXVpcmUoJy4vc3ZnU2hhcGUnKTtcclxuXHJcbnZhciBTVkdFbGxpcHNlID0gZnVuY3Rpb24oc3ZnUm9vdCwgY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICBTVkdTaGFwZS5jYWxsKHRoaXMsICdlbGxpcHNlJywgc3ZnUm9vdCwgY2ZnKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoU1ZHRWxsaXBzZSwgU1ZHU2hhcGUpO1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldFgoKTtcclxufTtcclxuXHJcblNWR0VsbGlwc2UucHJvdG90eXBlLnkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXRZKCk7XHJcbn07XHJcblxyXG5TVkdFbGxpcHNlLnByb3RvdHlwZS5fZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yeShmYWxzZSwgdHJ1ZSkgKiAyO1xyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUuX3NldEhlaWdodCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAvL1doZW4gc2V0dGluZyB0aGUgaGVpZ2h0IG9mIGFuIGVsbGlwc2Ugd2UgbW92ZSB0aGUgY2VudGVyIHRvIG5vdCBjaGFuZ2UgdGhlIHgveVxyXG4gICAgdmFyIHYgPSB2YWx1ZSAvIDI7XHJcbiAgICB0aGlzLmN5KHYpLnJ5KHYpO1xyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUuX2dldFdpZHRoID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLnJ4KGZhbHNlLCB0cnVlKSAqIDI7XHJcbn07XHJcblxyXG5TVkdFbGxpcHNlLnByb3RvdHlwZS5fc2V0V2lkdGggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgLy9XaGVuIHNldHRpbmcgdGhlIGhlaWdodCBvZiBhbiBlbGxpcHNlIHdlIG1vdmUgdGhlIGNlbnRlciB0byBub3QgY2hhbmdlIHRoZSB4L3lcclxuICAgIHZhciB2ID0gdmFsdWUgLyAyO1xyXG4gICAgdGhpcy5jeCh2KS5yeCh2KTtcclxufTtcclxuXHJcblNWR0VsbGlwc2UucHJvdG90eXBlLl9nZXRYID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jeCgpIC0gdGhpcy5yeCgpO1xyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUuX2dldFkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmN5KCkgLSB0aGlzLnJ5KCk7XHJcbn07XHJcblxyXG5TVkdFbGxpcHNlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IHRoaXMuY3goKSxcclxuICAgICAgICB5IDogdGhpcy5jeSgpXHJcbiAgICB9O1xyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUuYm90dG9tWSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY3koKSArIHRoaXMucnkoKTtcclxufTtcclxuXHJcblNWR0VsbGlwc2UucHJvdG90eXBlLmN4ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKCF2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZWRYKHRoaXMuYXR0ck51bWJlcignY3gnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYXR0cignY3gnLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdFbGxpcHNlLnByb3RvdHlwZS5jeSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZighdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVkWSh0aGlzLmF0dHJOdW1iZXIoJ2N5JykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmF0dHIoJ2N5JywgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUucnggPSBmdW5jdGlvbih2YWx1ZSwgbm9TY2FsZSkge1xyXG4gICAgdmFyIHNjYWxlID0gKG5vU2NhbGUpID8gMSA6IHRoaXMuc2NhbGUoKVswXTtcclxuICAgIGlmKCghb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgb2JqZWN0LmlzQm9vbGVhbih2YWx1ZSkgJiYgIXZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJOdW1iZXIoJ3J4JykgKiBzY2FsZTtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNCb29sZWFuKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5hdHRyTnVtYmVyKCdyeCcpICsgKHRoaXMuc3Ryb2tlV2lkdGgoKSAvIDIpKSAqIHNjYWxlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmF0dHJOdW1iZXIoJ3J4JywgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUucnkgPSBmdW5jdGlvbih2YWx1ZSwgbm9TY2FsZSkge1xyXG4gICAgdmFyIHNjYWxlID0gKG5vU2NhbGUpID8gMSA6IHRoaXMuc2NhbGUoKVsxXTtcclxuICAgIGlmKCghb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgb2JqZWN0LmlzQm9vbGVhbih2YWx1ZSkgJiYgIXZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJOdW1iZXIoJ3J5JykgKiBzY2FsZTtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNCb29sZWFuKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5hdHRyTnVtYmVyKCdyeScpICsgKHRoaXMuc3Ryb2tlV2lkdGgoKSAvIDIpKSAqIHNjYWxlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmF0dHJOdW1iZXIoJ3J5JywgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHRWxsaXBzZS5wcm90b3R5cGUub3ZlcmxheUNoZWNrID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiBuZXcgdXRpbC5tYXRoLkVsbGlwc2UodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5yeCgpLCB0aGlzLnJ5KCkpLm92ZXJsYXlzKHBvc2l0aW9uKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHRWxsaXBzZTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIFNWR1NoYXBlID0gcmVxdWlyZSgnLi9zdmdTaGFwZScpO1xyXG5cclxudmFyIFNWR0dyb3VwID0gZnVuY3Rpb24oc3ZnUm9vdCwgY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICBTVkdTaGFwZS5jYWxsKHRoaXMsICdnJywgc3ZnUm9vdCwgY2ZnKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoU1ZHR3JvdXAsIFNWR1NoYXBlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHR3JvdXA7IiwidmFyIEhlbHBlciA9IGZ1bmN0aW9uKHN2Zykge1xyXG4gICAgdGhpcy5zdmcgPSBzdmc7XHJcbiAgICB0aGlzLnBvaW50cyA9IHt9O1xyXG59O1xyXG5cclxuSGVscGVyLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKGlkLCBwLCBjb2xvciwgcHJldlRleHQpIHtcclxuICAgIGNvbG9yID0gY29sb3IgfHwgJ3JlZCc7XHJcbiAgICB2YXIgdGV4dCA9IGlkKycoeDonK3AueCArICcgeTonK3AueSsnKSc7XHJcbiAgICBpZighdGhpcy5wb2ludHNbaWRdKSB7XHJcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5zdmcuY2lyY2xlKHtcclxuICAgICAgICAgICAgcjoyLFxyXG4gICAgICAgICAgICBzdHlsZTonZmlsbDonK2NvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN2Zy50ZXh0KHRleHQpLmZpbGwoY29sb3IpO1xyXG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuc3ZnLmcoe2lkOidoZWxwZXJfJytpZH0sIHQsIHBvaW50KTtcclxuICAgICAgICB0aGlzLnBvaW50c1tpZF0gPSB7XHJcbiAgICAgICAgICAgIGdyb3VwIDogZ3JvdXAsXHJcbiAgICAgICAgICAgIHRleHQgOiB0LFxyXG4gICAgICAgICAgICBwb2ludCA6IHBvaW50XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihwcmV2VGV4dCkge1xyXG4gICAgICAgICAgICB0LmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wb2ludHNbaWRdLnBvaW50Lm1vdmVUbyhwKTtcclxuICAgIHRoaXMucG9pbnRzW2lkXS50ZXh0LiQoKS50ZXh0KHRleHQpO1xyXG4gICAgdGhpcy5wb2ludHNbaWRdLnRleHQubW92ZVRvKHApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZWxwZXI7XHJcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgU1ZHU2hhcGUgPSByZXF1aXJlKCcuL3N2Z1NoYXBlJyk7XHJcbnZhciBQYXRoRGF0YSA9IHJlcXVpcmUoJy4vcGF0aERhdGEnKTtcclxuXHJcbnZhciBTVkdQYXRoID0gZnVuY3Rpb24oc3ZnUm9vdCwgY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICB0aGlzLmF0dHJpYnV0ZVNldHRlciA9IHsgZCA6IFNWR1BhdGgucGF0aERhdGFBdHRyaWJ1dGVTZXR0ZXJ9O1xyXG4gICAgU1ZHU2hhcGUuY2FsbCh0aGlzLCAncGF0aCcsIHN2Z1Jvb3QsIGNmZywgdGhpcy5hdHRyaWJ1dGVTZXR0ZXIpO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhTVkdQYXRoLCBTVkdTaGFwZSk7XHJcblxyXG5TVkdQYXRoLnBhdGhEYXRhQXR0cmlidXRlU2V0dGVyID0gZnVuY3Rpb24ocGF0aERhdGFTdHJpbmcpIHtcclxuICAgIHJldHVybiBuZXcgUGF0aERhdGEocGF0aERhdGFTdHJpbmcpO1xyXG59O1xyXG5cclxuU1ZHUGF0aC5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZCgpLmdldFgoKTtcclxufTtcclxuXHJcblNWR1BhdGgucHJvdG90eXBlLnkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmQoKS5nZXRZKCk7XHJcbn07XHJcblxyXG5TVkdQYXRoLnByb3RvdHlwZS5kID0gZnVuY3Rpb24ocGF0aERhdGEpIHtcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhwYXRoRGF0YSkpIHtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuZCA9IG5ldyBQYXRoRGF0YShwYXRoRGF0YSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoJ2QnKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNEZWZpbmVkKHBhdGhEYXRhKSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5kID0gcGF0aERhdGFcclxuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSgnZCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIGlmKCFvYmplY3QuaXNEZWZpbmVkKHRoaXMuYXR0cmlidXRlcy5kKSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5kID0gbmV3IFBhdGhEYXRhKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1BhdGg7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBTVkdTaGFwZSA9IHJlcXVpcmUoJy4vc3ZnU2hhcGUnKTtcclxuXHJcbnZhciBTVkdSZWN0ID0gZnVuY3Rpb24oc3ZnUm9vdCwgY2ZnKSB7XHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcbiAgICBTVkdTaGFwZS5jYWxsKHRoaXMsICdyZWN0Jywgc3ZnUm9vdCwgY2ZnKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoU1ZHUmVjdCwgU1ZHU2hhcGUpO1xyXG5cclxuU1ZHUmVjdC5wcm90b3R5cGUuX2dldFkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHJOdW1iZXIoJ3knKSB8fCAwO1xyXG59O1xyXG5cclxuU1ZHUmVjdC5wcm90b3R5cGUuX2dldFggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHJOdW1iZXIoJ3gnKSB8fCAwO1xyXG59O1xyXG5cclxuU1ZHUmVjdC5wcm90b3R5cGUuX2dldEhlaWdodCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyTnVtYmVyKCdoZWlnaHQnKTtcclxufTtcclxuXHJcblNWR1JlY3QucHJvdG90eXBlLl9zZXRIZWlnaHQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgdGhpcy5hdHRyKCdoZWlnaHQnLHZhbHVlKTtcclxufTtcclxuXHJcblNWR1JlY3QucHJvdG90eXBlLl9nZXRXaWR0aCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyTnVtYmVyKCd3aWR0aCcpO1xyXG59O1xyXG5cclxuU1ZHUmVjdC5wcm90b3R5cGUuX3NldFdpZHRoID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHRoaXMuYXR0cignd2lkdGgnLHZhbHVlKTtcclxufTtcclxuXHJcblNWR1JlY3QucHJvdG90eXBlLm92ZXJsYXlDaGVjayA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gcG9zaXRpb24ueCA+PSB0aGlzLngoKSAmJiBwb3NpdGlvbi54IDw9IHRoaXMuZ2V0UmlnaHRYKClcclxuICAgICAgICAmJiBwb3NpdGlvbi55ID49IHRoaXMueSgpICYmIHBvc2l0aW9uLnkgPD0gdGhpcy5nZXRCb3R0b21ZKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1JlY3Q7IiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlsL3N0cmluZycpO1xyXG5cclxudmFyIFJFR0VYUF9QUk9QRVJUWV9TVUZGSVggPSAnOlthLXpBLVowLTkjLFxcLl0qKDt8JCknO1xyXG5cclxudmFyIFN0eWxlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYob2JqZWN0LmlzU3RyaW5nKGtleSkgJiYgIW9iamVjdC5pc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGtleTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZXQoa2V5LHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuXHJcblN0eWxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICBpZihvYmplY3QuaXNPYmplY3Qoa2V5KSkge1xyXG4gICAgICAgIG9iamVjdC5lYWNoKGtleSwgZnVuY3Rpb24ob2JqS2V5LCB2YWwpIHtcclxuICAgICAgICAgICAgaWYoa2V5Lmhhc093blByb3BlcnR5KG9iaktleSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KG9iaktleSx2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYob2JqZWN0LmlzU3RyaW5nKGtleSkgJiYgb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICBpZighb2JqZWN0LmlzRGVmaW5lZCh0aGlzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMudmFsdWUuaW5kZXhPZihrZXkrJzonKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKGtleStSRUdFWFBfUFJPUEVSVFlfU1VGRklYLCAnZ2knKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUucmVwbGFjZShyZWdFeHAsIHRoaXMuY3JlYXRlVmFsdWVTdHJpbmcoa2V5LHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSArPSAoIXN0cmluZy5lbmRzV2l0aCh0aGlzLnZhbHVlLCc7JykgJiYgdGhpcy52YWx1ZS5sZW5ndGggPiAwKSA/ICc7JyArIHRoaXMuY3JlYXRlVmFsdWVTdHJpbmcoa2V5LHZhbHVlKSA6IHRoaXMuY3JlYXRlVmFsdWVTdHJpbmcoa2V5LHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYob2JqZWN0LmlzU3RyaW5nKGtleSkpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0ga2V5O1xyXG4gICAgfVxyXG59O1xyXG5cclxuU3R5bGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgdmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoa2V5K1JFR0VYUF9QUk9QRVJUWV9TVUZGSVgsICdnaScpO1xyXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudmFsdWUubWF0Y2gocmVnRXhwKTtcclxuICAgIGlmKG9iamVjdC5pc0FycmF5KHJlc3VsdCkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHRbMF07XHJcbiAgICAgICAgdmFyIHNwbGl0dGVkID0gdmFsdWUuc3BsaXQoJzonKTtcclxuICAgICAgICBpZihzcGxpdHRlZC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzcGxpdHRlZFsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIChzdHJpbmcuZW5kc1dpdGgocmVzdWx0LCAnOycpKT8gcmVzdWx0LnN1YnN0cmluZygwLHJlc3VsdC5sZW5ndGggLTEpIDogcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblN0eWxlLnByb3RvdHlwZS5jcmVhdGVWYWx1ZVN0cmluZyA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgIHJldHVybiBrZXkrJzonK3ZhbHVlKyc7JztcclxufTtcclxuXHJcblN0eWxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xyXG4iLCIvKipcclxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGFjY2Vzc2luZyBTVkcgZWxlbWVudHMuXHJcbiAqIEFsbCBTVkcgZWxlbWVudHMgY3JlYXRlZCB3aXRoIHRoaXMgbW9kdWxlIGNhbiBiZSBhY2Nlc3NlZCBieSBJRCB0aHJvdWdoIHRoZSBpbnN0YW5jZSBvYmplY3QuXHJcbiAqXHJcbiAqIEFuIFNWRyBlbGVtZW50IGNyZWF0ZWQgd2l0aCB0aGlzIG1vZHVsZSBjYW4gYmUgc2VwZXJhdGVkIGludG8gbXVsdGlwbGUgcGFydHMgd2hpY2ggY2FuIGJlIG1hbmFnZWQgc3BlcmF0bHkuXHJcbiAqIFRoZSAncm9vdCcgcGFydCB3aWxsIGJlIGNyZWF0ZWQgYnkgZGVmYXVsdC4gV2hlbiBjcmVhdGluZyBhIG5ldyBzdmcgcGFydCB5b3UgY2FuIHNldCBpdCBhcyBkZWZhdWx0IHBhcnQsIHNvIGFsbCBhY3Rpb25zXHJcbiAqIGxpa2UgaW5zZXJ0aW9ucyB3aWxsIGJlIGV4ZWN1dGVkIG9uIHRoZSBkZWZhdWx0IHBhcnQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgcGFydCBhcyBhcmd1bWVudC5cclxuICovXHJcbnZhciBTVkdHZW5lcmljU2hhcGUgPSByZXF1aXJlKCcuL3N2Z1NoYXBlJyk7XHJcbnJlcXVpcmUoJy4vZHJhZ2dhYmxlJyk7XHJcbnZhciBzaGFwZXMgPSByZXF1aXJlKCcuL2VsZW1lbnRzJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XHJcblxyXG52YXIgZG9tID0gdXRpbC5kb207XHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyJyk7XHJcblxyXG52YXIgTkFNRVNQQUNFX1NWRyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbnZhciBOQU1FU1BBQ0VfWExJTksgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcblxyXG52YXIgaW5zdGFuY2VzID0ge307XHJcblxyXG4vKipcclxuICogVGhlIGNvbnN0cnVjdG9yIGluaXRpYWxpemVzIGEgbmV3IFNWRyBlbGVtZW50IHdpdGhpbiB0aGUgZ2l2ZW4gY29udGFpbmVySWQuXHJcbiAqIFRoZSBjb25zdHJ1Y3RvciBhY2NlcHRzIHRoZSBjb250YWluZXJJZCBlaXRoZXIgYXMgc2VsZWN0b3IgJyNjb250YWluZXJJZCcgb3IgYXMgaWQgc3RyaW5nICdjb250YWluZXJJZCcuXHJcbiAqXHJcbiAqIFRoZSBpZCBvZiB0aGUgbncgU1ZHIGVsZW1lbnQgd2lsbCBiZSB0aGUgY29udGFpbmVySWQgd2l0aCB0aGUgc3VmZml4ICdfc3ZnJyAtPiAnY29udGFpbmVySWRfc3ZnJy5cclxuICpcclxuICogQXR0cmlidXRlcyBvZiB0aGUgbmV3IFNWRyBlbGVtbnQgY2FuIGJlIHNldCB0aHJvdWdoIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudCAnY2ZnJy5cclxuICpcclxuICogVGhlIFNWRyBjYW4gYmUgc2VwZXJhdGVkIGluIG11bHRpcGxlIHBhcnRzIHNvIHlvdSBjYW4gZWFzaWx5IGFwcGVuZCBlbGVtZW50cyB0byB0aGUgZGlmZmVyZW50IHBhcnQuXHJcbiAqIFRoZSBjb25zdHJ1Y3RvciBjcmVhdGVzIGEgJ3Jvb3QnIHBhcnQgYXMgZGVmYXVsdC5cclxuICpcclxuICogQHBhcmFtIGNvbnRhaW5lcklkXHJcbiAqIEBwYXJhbSBjZmdcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgU1ZHID0gZnVuY3Rpb24oY29udGFpbmVySWQsIGNmZykge1xyXG4gICAgaWYoISh0aGlzIGluc3RhbmNlb2YgU1ZHKSkge1xyXG4gICAgICAgIHJldHVybiBTVkcuZ2V0KGNvbnRhaW5lcklkKTtcclxuICAgIH1cclxuXHJcbiAgICBjZmcgPSBjZmcgfHwge307XHJcblxyXG4gICAgLy9HZXQgaWQgZnJvbSBzZWxlY3RvciBpZiBpdHMgYW4gc2VsZWN0b3JcclxuICAgIHRoaXMuY29udGFpbmVySWQgPSBkb20uZ2V0UmF3SWQoY29udGFpbmVySWQpO1xyXG4gICAgdGhpcy4kY29udGFpbmVyID0gJC5xQ2FjaGUoJyMnK3RoaXMuY29udGFpbmVySWQpLmdldCgwKTtcclxuXHJcbiAgICBpZighdGhpcy4kY29udGFpbmVyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdCB0byBpbml0aWF0ZSBzdmcgc3RhZ2UgZm9yIGludmFsaWQgY29udGFpbmVySWQ6ICcrdGhpcy5jb250YWluZXJJZCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3ZnSWQgPSB0aGlzLmNvbnRhaW5lcklkKydfc3ZnJztcclxuXHJcbiAgICAvLyBDcmVhdGUgU1ZHIHJvb3QgZWxlbWVudCB3aXRoIGdpdmVuIHNldHRpbmdzLlxyXG4gICAgdGhpcy5yb290ID0gbmV3IHNoYXBlcy5TdmcodGhpcywge2lkIDogdGhpcy5zdmdJZH0pO1xyXG5cclxuICAgIGNmZy5oZWlnaHQgPSBjZmcuaGVpZ2h0IHx8ICcxMDAlJztcclxuICAgIGNmZy53aWR0aCA9IGNmZy53aWR0aCAgfHwgJzEwMCUnO1xyXG5cclxuICAgIC8vIFNldCBjZmcgdmFsdWVzIGFzIHN2ZyByb290IGF0dHJpYnV0ZXNcclxuICAgIHRoaXMucm9vdC5hdHRyKGNmZyk7XHJcblxyXG4gICAgLy8gQXBwZW5kIHRoZSBzdmcgcm9vdCBlbGVtZW50IHRvIHRoZSBjb250YWluZXJub2RlXHJcbiAgICBkb20uYXBwZW5kU1ZHRWxlbWVudCh0aGlzLiRjb250YWluZXIsIHRoaXMucm9vdCk7XHJcblxyXG4gICAgLy8gVGhlIHJvb3QgcGFydCBpcyB0aGUgc3ZnIGVsZW1lbnQgaXRzZWxmXHJcbiAgICB0aGlzLnN2Z1BhcnRzID0geydyb290Jzp0aGlzLnJvb3R9O1xyXG4gICAgdGhpcy5kZWZhdWx0UGFydCA9IHRoaXMucm9vdDtcclxuXHJcbiAgICBpbnN0YW5jZXNbdGhpcy5zdmdJZF0gPSB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN2ZyByb290IGRvbU5vZGUuXHJcbiAqIEByZXR1cm5zIHsqfSBzdmcgcm9vdCBkb21Ob2RlXHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmdldFJvb3ROb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gKHRoaXMucm9vdCkgPyB0aGlzLnJvb3QuaW5zdGFuY2UoKSA6IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY2FjaGVkIGpRdWVyeSBvYmplY3Qgb2YgdGhlIHJvb3Qgbm9kZS5cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLiQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAkLnFDYWNoZSgnIycrdGhpcy5zdmdJZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB1c2VkIGZvciBpbXBvcnRpbmcgZGlhZ3JhbXMgaW50byB0aGUgc3ZnIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZWxlbWVudFxyXG4gKi9cclxuU1ZHLnByb3RvdHlwZS5zZXRSb290ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgdmFyIG5ld0lkID0gJChlbGVtZW50KS5hdHRyKCdpZCcpO1xyXG4gICAgdGhpcy5yb290Lmluc3RhbmNlKGVsZW1lbnQpO1xyXG4gICAgdGhpcy5yb290LmF0dHIoe2lkIDogbmV3SWR9KTtcclxuICAgIGluc3RhbmNlc1tuZXdJZF0gPSB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHJvb3QgZWxlbWVudCBhcyBTVkdFbGVtZW50XHJcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fGV4cG9ydHN8bW9kdWxlLmV4cG9ydHN8Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlZmF1bHRQYXJ0XHJcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fGV4cG9ydHN8bW9kdWxlLmV4cG9ydHN8Kn0gY3VycmVudCBkZWZhdWx0UGFydFxyXG4gKi9cclxuU1ZHLnByb3RvdHlwZS5nZXREZWZhdWx0UGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBzdmcgcGFydCB3aGljaCBpcyByZXByZXNlbnRlZCBieSBhIG5ldyBncm91cCB3aXRoaW4gdGhlIHJvb3QuXHJcbiAqIFRoZSBwYXJ0IGlkIGlzIGNvbXBvc2l0ZSBvZiB0aGUgc3ZnIHJvb3QgaWQgYW5kIHRoZSBwYXJ0SWQuXHJcbiAqIEJ5IHNldHRpbmcgdGhlIGlzRGVmYXVsdCBhcmd1bWVudCBhcyB0cnVlIHRoZSBuZXcgcGFydCB3aWxsIGJlIHNldCBhcyBkZWZhdWx0IHBhcnQuXHJcbiAqIEBwYXJhbSBwYXJ0SWRcclxuICogQHBhcmFtIGlzRGVmYXVsdFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuY3JlYXRlUGFydCA9IGZ1bmN0aW9uKHBhcnRJZCwgaXNEZWZhdWx0KSB7XHJcbiAgICAvL05ldyBwYXJ0cyBhcmUgYWx3YXlzIGFkZGVkIHRvIHRoZSByb290IHBhcnRcclxuICAgIHRoaXMuc3ZnUGFydHNbcGFydElkXSA9IHRoaXMuZyh7aWQ6IHRoaXMuc3ZnSWQrJ18nK3BhcnRJZCwgcGFyZW50UGFydDogJ3Jvb3QnfSk7XHJcbiAgICBpZihpc0RlZmF1bHQpIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHRQYXJ0ID0gdGhpcy5zdmdQYXJ0c1twYXJ0SWRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuc3ZnUGFydHNbcGFydElkXTtcclxufTtcclxuXHJcblNWRy5wcm90b3R5cGUucGFydCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdmdQYXJ0c1tpZF07XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBzdmcgZWxlbWVudCB0byB0aGUgZ2l2ZW4gcGFydC5cclxuICpcclxuICogQHBhcmFtIHBhcnRcclxuICogQHBhcmFtIGVsZW1lbnRcclxuICovXHJcblNWRy5wcm90b3R5cGUuYWRkVG9QYXJ0ID0gZnVuY3Rpb24ocGFydCwgZWxlbWVudCkge1xyXG4gICAgdGhpcy5hZGRUb0dyb3VwKHRoaXMuc3ZnUGFydHNbcGFydF0sIGVsZW1lbnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gYXBwZW5kIG9yIHByZXBlbmQgZWxlbWVudHMgd2l0aCB0ZXh0IHRvIHRoZSBzdmcgcm9vdC5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnRcclxuICogQHBhcmFtIHByZXBlbmRcclxuICogQHBhcmFtIHRleHRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmFkZFRvUm9vdCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByZXBlbmQsIHRleHQpIHtcclxuICAgIGlmKHByZXBlbmQpIHtcclxuICAgICAgICByZXR1cm4gZG9tLnByZXBlbmRTVkdFbGVtZW50KHRoaXMuZ2V0Um9vdCgpLCBlbGVtZW50LCB0ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRvbS5hcHBlbmRTVkdFbGVtZW50KHRoaXMuZ2V0Um9vdCgpLCBlbGVtZW50LCB0ZXh0KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGFwcGVuZC9wcmVwZW5kIGVsZW1lbnRzIHdpdGggdGV4dCB0byBhIGdpdmVuIChvciBkZWZhdWx0KSBzdmcgcGFydC5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnRcclxuICogQHBhcmFtIHBhcnRcclxuICogQHBhcmFtIHByZXBlbmRcclxuICogQHBhcmFtIHRleHRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHBhcnQsIHByZXBlbmQsIHRleHQpIHtcclxuICAgIHBhcnQgPSBwYXJ0IHx8IHRoaXMuZ2V0RGVmYXVsdFBhcnQoKTtcclxuICAgIGVsZW1lbnQucGFyZW50ID0gcGFydDtcclxuICAgIGlmKHByZXBlbmQpIHtcclxuICAgICAgICByZXR1cm4gZG9tLnByZXBlbmRTVkdFbGVtZW50KHBhcnQsIGVsZW1lbnQsIHRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZG9tLmFwcGVuZFNWR0VsZW1lbnQocGFydCwgZWxlbWVudCwgdGV4dCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogSW1wb3J0cyBhbiB4bWwgZG9jdW1lbnQgdG8gdGhlIGdpdmVuIHN2ZyBwYXJ0LlxyXG4gKiBAcGFyYW0gZWxlbWVudFhNTFxyXG4gKiBAcGFyYW0gcGFydFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUuaW1wb3J0ID0gZnVuY3Rpb24oc3ZnU3RyLCBwYXJ0LCBwcmVwZW5kKSB7XHJcbiAgICBwYXJ0ID0gdGhpcy5zdmdQYXJ0c1twYXJ0XSB8fCB0aGlzLmdldERlZmF1bHRQYXJ0KCk7XHJcbiAgICByZXR1cm4gU1ZHLmdldChkb20uaW1wb3J0U1ZHKHBhcnQsIHN2Z1N0ciwgcHJlcGVuZCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW5kIHJldHVybnMgYSBuZXdseSBjcmVhdGVkIHN2ZyBSZWN0IHdpdGggdGhlIGdpdmVuIHNldHRpbmdzIHRvIHRoZSBnaXZlbiAob3IgZGVmYXVsdCkgcGFydC5cclxuICogQHBhcmFtIGNmZ1xyXG4gKiBAcGFyYW0gcGFydFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKGNmZywgcGFydCkge1xyXG4gICAgcGFydCA9IHRoaXMuc3ZnUGFydHNbcGFydF0gfHwgdGhpcy5nZXREZWZhdWx0UGFydCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKG5ldyBzaGFwZXMuUmVjdCh0aGlzLCBjZmcpLCBwYXJ0KTtcclxufTtcclxuXHJcblNWRy5wcm90b3R5cGUuaGVscGVyID0gZnVuY3Rpb24oY2ZnLCBwYXJ0KSB7XHJcbiAgICBpZighdGhpcy5faGVscGVyKSB7XHJcbiAgICAgICAgdGhpcy5faGVscGVyID0gbmV3IEhlbHBlcih0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9oZWxwZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbmQgcmV0dXJucyBhIG5ld2x5IGNyZWF0ZWQgc3ZnIFRleHQgd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZ3MgdG8gdGhlIGdpdmVuIChvciBkZWZhdWx0KSBwYXJ0LlxyXG4gKiBAcGFyYW0gY2ZnXHJcbiAqIEBwYXJhbSBwYXJ0XHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuU1ZHLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCwgY2ZnLCBwYXJ0KSB7XHJcbiAgICBwYXJ0ID0gdGhpcy5zdmdQYXJ0c1twYXJ0XSB8fCB0aGlzLmdldERlZmF1bHRQYXJ0KCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQobmV3IHNoYXBlcy5UZXh0KHRoaXMsIGNmZyksIHBhcnQsIGZhbHNlKS5jb250ZW50KHRleHQpO1xyXG59O1xyXG5cclxuU1ZHLnByb3RvdHlwZS50c3BhbiA9IGZ1bmN0aW9uKHRleHQsIGNmZywgcGFydCkge1xyXG4gICAgcGFydCA9IHRoaXMuc3ZnUGFydHNbcGFydF0gfHwgdGhpcy5nZXREZWZhdWx0UGFydCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKG5ldyBzaGFwZXMuVFNwYW4odGhpcywgY2ZnKSwgcGFydCwgZmFsc2UpLmNvbnRlbnQodGV4dCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbmQgcmV0dXJucyBhIG5ld2x5IGNyZWF0ZWQgc3ZnIENpcmNsZSB3aXRoIHRoZSBnaXZlbiBzZXR0aW5ncyB0byB0aGUgZ2l2ZW4gKG9yIGRlZmF1bHQpIHBhcnQuXHJcbiAqIEBwYXJhbSBjZmdcclxuICogQHBhcmFtIHBhcnRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmNpcmNsZSA9IGZ1bmN0aW9uKGNmZywgcGFydCkge1xyXG4gICAgcGFydCA9IHRoaXMuc3ZnUGFydHNbcGFydF0gfHwgdGhpcy5nZXREZWZhdWx0UGFydCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKG5ldyBzaGFwZXMuQ2lyY2xlKHRoaXMsIGNmZyksIHBhcnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW5kIHJldHVybnMgYSBuZXdseSBjcmVhdGVkIHN2ZyBDaXJjbGUgd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZ3MgdG8gdGhlIGdpdmVuIChvciBkZWZhdWx0KSBwYXJ0LlxyXG4gKiBAcGFyYW0gY2ZnXHJcbiAqIEBwYXJhbSBwYXJ0XHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuU1ZHLnByb3RvdHlwZS5lbGxpcHNlID0gZnVuY3Rpb24oY2ZnLCBwYXJ0KSB7XHJcbiAgICBwYXJ0ID0gdGhpcy5zdmdQYXJ0c1twYXJ0XSB8fCB0aGlzLmdldERlZmF1bHRQYXJ0KCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQobmV3IHNoYXBlcy5FbGxpcHNlKHRoaXMsIGNmZyksIHBhcnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW5kIHJldHVybnMgYSBuZXdseSBjcmVhdGVkIHN2ZyBHcm91cCB3aXRoIHRoZSBnaXZlbiBzZXR0aW5ncyB0byB0aGUgZ2l2ZW4gKG9yIGRlZmF1bHQpIHBhcnQuXHJcbiAqIEBwYXJhbSBjZmdcclxuICogQHBhcmFtIHBhcnRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmcgPSBmdW5jdGlvbihjZmcpIHtcclxuICAgIHZhciBjZmcgPSBjZmcgfHx7fTtcclxuXHJcbiAgICB2YXIgcGFyZW50UGFydCA9IHRoaXMuc3ZnUGFydHNbY2ZnLnBhcmVudFBhcnRdIHx8IHRoaXMuZ2V0RGVmYXVsdFBhcnQoKTtcclxuXHJcbiAgICBkZWxldGUgY2ZnLnBhcnQ7XHJcblxyXG4gICAgdmFyIGdyb3VwID0gdGhpcy5hZGQobmV3IHNoYXBlcy5Hcm91cCh0aGlzLCBjZmcpLCBwYXJlbnRQYXJ0KTtcclxuXHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDE7aSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWRkVG9Hcm91cDogJytncm91cC5hdHRyKCdpZCcpKycgLSAnKyBhcmd1bWVudHNbaV0uYXR0cignaWQnKSk7XHJcbiAgICAgICAgICAgIGRvbS5hcHBlbmRTVkdFbGVtZW50KGdyb3VwLmluc3RhbmNlKCksIGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdyb3VwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW5kcyBhbiBzdmcgZWxlbWVudCBvdCB0aGUgZ2l2ZW4gZ3JvdXAuXHJcbiAqIEBwYXJhbSBjZmdcclxuICogQHBhcmFtIHBhcnRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5TVkcucHJvdG90eXBlLmFkZFRvR3JvdXAgPSBmdW5jdGlvbihncm91cCwgZWxlbWVudCkge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGlmKG9iamVjdC5pc0FycmF5KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gW107XHJcbiAgICAgICAgb2JqZWN0LmVhY2goZWxlbWVudCwgZnVuY3Rpb24oaW5kZXgsIHZhbCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChkb20uYXBwZW5kU1ZHRWxlbWVudChncm91cC5pbnN0YW5jZSgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRvbS5hcHBlbmRTVkdFbGVtZW50KGdyb3VwLmluc3RhbmNlKCksIGVsZW1lbnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW5kIHJldHVybnMgYSBuZXdseSBjcmVhdGVkIHN2ZyBQYXRoIHdpdGggdGhlIGdpdmVuIHNldHRpbmdzIHRvIHRoZSBnaXZlbiAob3IgZGVmYXVsdCkgcGFydC5cclxuICogQHBhcmFtIGNmZ1xyXG4gKiBAcGFyYW0gcGFydFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblNWRy5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uKGNmZywgcGFydCkge1xyXG4gICAgdmFyIHBhcnQgPSB0aGlzLnN2Z1BhcnRzW3BhcnRdIHx8IHRoaXMuZ2V0RGVmYXVsdFBhcnQoKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChuZXcgc2hhcGVzLlBhdGgodGhpcywgY2ZnKSwgcGFydCk7XHJcbn07XHJcblxyXG5TVkcucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAkKHRoaXMucm9vdC5pbnN0YW5jZSgpKS5lbXB0eSgpO1xyXG59O1xyXG5cclxuU1ZHLnByb3RvdHlwZS5hc1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC50b1N0cmluZygpO1xyXG59O1xyXG5cclxuU1ZHLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucm9vdC5jbG9uZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuIFNWR0VsZW1lbnQgb3V0IG9mIHRoZSBnaXZlbiBpZCBzZWxlY3RvciBlbGVtZW50LlxyXG4gKiBAcGFyYW0gc2VsZWN0b3JcclxuICogQHJldHVybnMge1NWR0VsZW1lbnR8ZXhwb3J0c3xtb2R1bGUuZXhwb3J0c31cclxuICovXHJcblNWRy5nZXQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgaWYoc2VsZWN0b3IuU1ZHRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcclxuICAgIH1cclxuICAgIC8vVE9ETzpcclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyhzZWxlY3RvcikpIHtcclxuICAgICAgICAkbm9kZSA9ICQoZG9tLmdldElkU2VsZWN0b3Ioc2VsZWN0b3IpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJG5vZGUgPSAkKHNlbGVjdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBpZighJG5vZGUubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdjYWxsIFNWRy5nZXQgb24gYSBub24gZXhpc3Rpbmcgbm9kZTogJytzZWxlY3Rvcik7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSBlbHNlIGlmKCRub2RlLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAvL1JldHVybiBsaXN0IG9mIFNWR0VsZW1lbnRzXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICRub2RlLmVhY2goZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFNWRy5nZXQodGhpcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vUmV0dXJuIHNpbmdsZSBTVmdFbGVtZW50XHJcbiAgICAgICAgdmFyICRzdmdSb290Tm9kZSA9ICQoJG5vZGUuZ2V0KDApLm93bmVyU1ZHRWxlbWVudCk7XHJcbiAgICAgICAgaWYoJHN2Z1Jvb3ROb2RlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgc3ZnSW5zdGFuY2UgPSBpbnN0YW5jZXNbJHN2Z1Jvb3ROb2RlLmF0dHIoJ2lkJyldO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gU1ZHLl9zdmdJbnN0YW5jZSgkbm9kZSwgc3ZnSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAvL1RoaXMgZW5hYmxlcyAkLmVhY2ggZm9yIHNpbmdsZSByZXN1bHRzLlxyXG4gICAgICAgICAgICByZXN1bHRbMF0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIHJlc3VsdC5sZW5ndGggPSAxO1xyXG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlID0gZnVuY3Rpb24oKSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NhbGwgU1ZHLmdldCBvbiBub2RlIHdpdGggbm8gc3ZnIHJvb3QnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkcuX3N2Z0luc3RhbmNlID0gZnVuY3Rpb24oJG5vZGUsIHN2Zykge1xyXG4gICAgdmFyIFNWR1NoYXBlID0gU1ZHLmdldFNoYXBlQnlOYW1lKCRub2RlLmdldCgwKS5ub2RlTmFtZSk7XHJcbiAgICByZXR1cm4gKFNWR1NoYXBlKSA/IG5ldyBTVkdTaGFwZShzdmcpLmluc3RhbmNlKCRub2RlLmdldCgwKSkgOiBuZXcgU1ZHR2VuZXJpY1NoYXBlKCRub2RlLmdldCgwKSwgc3ZnKTtcclxufTtcclxuXHJcblNWRy5nZXRTaGFwZUJ5TmFtZSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHZhciByZXN1bHQgPSBzaGFwZXNbdHlwZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5TVkcucHJvdG90eXBlLmdldCA9IFNWRy5nZXQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWRztcclxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcbnZhciBTVkdFbGVtZW50ID0gcmVxdWlyZSgnLi9zdmdFbGVtZW50Jyk7XHJcblxyXG52YXIgTkFNRVNQQUNFX1NWRyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbnZhciBOQU1FU1BBQ0VfWExJTksgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcbnZhciBTVkdfVkVSU0lPTiA9ICcxLjEnO1xyXG5cclxudmFyIFNWR1Jvb3QgPSBmdW5jdGlvbihzdmcsIGNmZykge1xyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgY2ZnWyd4bWxucyddID0gTkFNRVNQQUNFX1NWRztcclxuICAgIGNmZ1sneG1sbnM6eGxpbmsnXSA9IE5BTUVTUEFDRV9YTElOSztcclxuICAgIGNmZ1sndmVyc2lvbiddID0gU1ZHX1ZFUlNJT047XHJcbiAgICBTVkdFbGVtZW50LmNhbGwodGhpcywgJ3N2ZycsIHN2ZywgY2ZnKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoU1ZHUm9vdCwgU1ZHRWxlbWVudCk7XHJcblxyXG5TVkdSb290LnByb3RvdHlwZS54ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiAodmFsdWUpID8gdGhpcy5hdHRyTnVtYmVyKCd4JywgdmFsdWUpIDogdGhpcy5hdHRyTnVtYmVyKCd4JykgfHwgMCA7XHJcbn07XHJcblxyXG5TVkdSb290LnByb3RvdHlwZS55ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiAodmFsdWUpID8gdGhpcy5hdHRyTnVtYmVyKCd5JywgdmFsdWUpIDogdGhpcy5hdHRyTnVtYmVyKCd5JykgfHwgMCA7XHJcbn07XHJcblxyXG5TVkdSb290LnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogdGhpcy54KCkgKyBNYXRoLmZsb29yKHRoaXMud2lkdGgoKSAvIDIpLFxyXG4gICAgICAgIHk6IHRoaXMueSgpICsgTWF0aC5mbG9vcih0aGlzLmhlaWdodCgpIC8gMilcclxuICAgIH07XHJcbn07XHJcblxyXG5TVkdSb290LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoIXZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJCgpLmhlaWdodCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmF0dHIoJ2hlaWdodCcsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuXHJcblNWR1Jvb3QucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKCF2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiQoKS53aWR0aCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmF0dHIoJ3dpZHRoJywgdmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdSb290OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlsL29iamVjdCcpO1xyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0nKTtcclxuXHJcbnZhciBTVkdFbGVtZW50ID0gcmVxdWlyZSgnLi9TVkdFbGVtZW50Jyk7XHJcblxyXG52YXIgU1ZHU2hhcGUgPSBmdW5jdGlvbihuYW1lLCBzdmdSb290LCBjZmcsIGF0dHJpYnV0ZVNldHRlcikge1xyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVTZXR0ZXIgPSBhdHRyaWJ1dGVTZXR0ZXIgfHwge307XHJcbiAgICB0aGlzLmF0dHJpYnV0ZVNldHRlci50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybWF0aW9uQXR0cmlidXRlU2V0dGVyO1xyXG4gICAgU1ZHRWxlbWVudC5jYWxsKHRoaXMsIG5hbWUsIHN2Z1Jvb3QsIGNmZywgYXR0cmlidXRlU2V0dGVyKTtcclxufTtcclxuXHJcbnV0aWwuaW5oZXJpdHMoU1ZHU2hhcGUsIFNWR0VsZW1lbnQpO1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnRyYW5zZm9ybWF0aW9uQXR0cmlidXRlU2V0dGVyID0gZnVuY3Rpb24odHJuYXNmb3JtYXRpb25TdHJpbmcpIHtcclxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHRybmFzZm9ybWF0aW9uU3RyaW5nKTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYoIXRoaXMuYXR0cmlidXRlcy50cmFuc2Zvcm0pIHtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSgpO1xyXG4gICAgfSBlbHNlIGlmKG9iamVjdC5pc1N0cmluZyh0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtKSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKHRoaXMuYXR0cmlidXRlcy50cmFuc2Zvcm0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy50cmFuc2Zvcm07XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUudHJhbnNmb3JtZWRYID0gZnVuY3Rpb24ocHgpIHtcclxuICAgIHJldHVybiB0aGlzLnNjYWxlZFgodGhpcy50cmFuc2xhdGVkWChweCkpO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnRyYW5zZm9ybWVkWSA9IGZ1bmN0aW9uKHB4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2FsZWRZKHRoaXMudHJhbnNsYXRlZFkocHgpKTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5zY2FsZWRYID0gZnVuY3Rpb24ocHgpIHtcclxuICAgIHJldHVybiBweCAqIHRoaXMuc2NhbGUoKVswXVxyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnNjYWxlZFkgPSBmdW5jdGlvbihweSkge1xyXG4gICAgcmV0dXJuIHB5ICogdGhpcy5zY2FsZSgpWzFdXHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24odmFsKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbigpLnJvdGF0ZSh2YWwpO1xyXG5cclxuICAgIGlmKHJlc3VsdCBpbnN0YW5jZW9mIFRyYW5zZm9ybSkge1xyXG4gICAgICAgIC8vIFRoZSBzY2FsZSBzZXR0ZXIgcmV0dXJucyB0aGUgVHJhbnNmb3JtIGl0c2VsZiBvYmplY3Qgc28gd2UgcmVzZXQgdGhlIHNjYWxlXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGF0dHJpYnV0ZSBpbiBkb20gKHNldHRlciB3YXMgY2FsbGVkKVxyXG4gICAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGdldHRlciBqdXN0IHJldHVybnMgdGhlIHgseSB2YWx1ZXMgb2YgdGhlIHRyYW5zbGF0ZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbihzeCwgc3kpIHtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLmdldFRyYW5zZm9ybWF0aW9uKCkuc2NhbGUoc3gsIHN5KTtcclxuXHJcbiAgICBpZihyZXN1bHQgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pIHtcclxuICAgICAgICAvLyBUaGUgc2NhbGUgc2V0dGVyIHJldHVybnMgdGhlIFRyYW5zZm9ybSBpdHNlbGYgb2JqZWN0IHNvIHdlIHJlc2V0IHRoZSBzY2FsZVxyXG4gICAgICAgIC8vIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaW4gZG9tIChzZXR0ZXIgd2FzIGNhbGxlZClcclxuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBnZXR0ZXIganVzdCByZXR1cm5zIHRoZSB4LHkgdmFsdWVzIG9mIHRoZSB0cmFuc2xhdGUgdHJhbnNmb3JtYXRpb25cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHZhciByZXN1bHQgPSB0aGlzLmdldFRyYW5zZm9ybWF0aW9uKCkudHJhbnNsYXRlKHgseSk7XHJcblxyXG4gICAgaWYocmVzdWx0IGluc3RhbmNlb2YgVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgLy8gVGhlIHRybmFzbGF0ZSBzZXR0ZXIgcmV0dXJucyB0aGUgVHJhbnNmb3JtIG9iamVjdCBzbyB3ZSByZXNldCB0aGVcclxuICAgICAgICAvLyB0cmFuc2Zvcm0gYXR0cmlidXRlIGluIGRvbSAoc2V0dGVyIHdhcyBjYWxsZWQpXHJcbiAgICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUaGUgZ2V0dGVyIGp1c3QgcmV0dXJucyB0aGUgeCx5IHZhbHVlcyBvZiB0aGUgdHJhbnNsYXRlIHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS50cmFuc2xhdGVkID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLmdldFRyYW5zZm9ybWF0aW9uKCkudHJhbnNsYXRlKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHggOiB0cmFuc2xhdGUueCArIHBvc2l0aW9uLngsXHJcbiAgICAgICAgeSA6IHRyYW5zbGF0ZS55ICsgcG9zaXRpb24ueVxyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnRyYW5zbGF0ZWRYID0gZnVuY3Rpb24ocHgpIHtcclxuICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLmdldFRyYW5zZm9ybWF0aW9uKCkudHJhbnNsYXRlKCk7XHJcbiAgICBweCA9IChvYmplY3QuaXNEZWZpbmVkKHB4KSkgPyBweCA6IDA7XHJcbiAgICByZXR1cm4gdHJhbnNsYXRlLnggKyBweDtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS50cmFuc2xhdGVkWSA9IGZ1bmN0aW9uKHB5KSB7XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbigpLnRyYW5zbGF0ZSgpO1xyXG4gICAgcHkgPSAob2JqZWN0LmlzRGVmaW5lZChweSkpID8gcHkgOiAwO1xyXG4gICAgcmV0dXJuIHRyYW5zbGF0ZS55ICsgcHk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuaGFzVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbih0cmFuc2Zvcm1hdGlvbikge1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZCh0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtKSkge1xyXG4gICAgICAgIHJldHVybiAob2JqZWN0LmlzRGVmaW5lZCh0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtW3RyYW5zZm9ybWF0aW9uXSkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbihjb2xvcikge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2ZpbGwnLCBjb2xvcik7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuZmlsbE9wYWNpdHkgPSBmdW5jdGlvbihvcGFjaXR5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZSgnZmlsbC1vcGFjaXR5Jywgb3BhY2l0eSk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuc3Ryb2tlT3BhY2l0eSA9IGZ1bmN0aW9uKG9wYWNpdHkpIHtcclxuICAgIHJldHVybiB0aGlzLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIG9wYWNpdHkpO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9yLCB3aWR0aCkge1xyXG4gICAgaWYod2lkdGgpIHtcclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoKHdpZHRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnN0eWxlKCdzdHJva2UnLCBjb2xvcik7XHJcblxyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnN0cm9rZURhc2hhcnJheSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIGlmKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcclxuICAgIH1cclxuICAgIGlmKG9iamVjdC5pc1N0cmluZyh0eXBlKSkge1xyXG4gICAgICAgIHRoaXMuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknLCB0eXBlKTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnN0cm9rZURhc2hUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgaWYoIXR5cGUpIHtcclxuICAgICAgICBzd2l0Y2godGhpcy5zdHJva2VEYXNoYXJyYXkoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiNSw1XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgY2FzZSBcIjEwLDEwXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgY2FzZSBcIjIwLDEwLDUsNSw1LDEwXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnMSc6XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlRGFzaGFycmF5KFwiNSw1XCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJzInOlxyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZURhc2hhcnJheShcIjEwLDEwXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJzMnOlxyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZURhc2hhcnJheShcIjIwLDEwLDUsNSw1LDEwXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZURhc2hhcnJheShcIm5vbmVcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuc3Ryb2tlV2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgcmV0dXJuIHV0aWwuYXBwLnBhcnNlTnVtYmVyU3RyaW5nKHRoaXMuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKSkgfHwgMDtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAoIXRoaXMuZmlsbE9wYWNpdHkoKSB8fCB0aGlzLmZpbGxPcGFjaXR5KCkgPiAwKVxyXG4gICAgICAgICYmICghdGhpcy5zdHJva2VPcGFjaXR5KCkgfHwgdGhpcy5zdHJva2VPcGFjaXR5KCkgPiAwKTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmZpbGxPcGFjaXR5KDApO1xyXG4gICAgdGhpcy5zdHJva2VPcGFjaXR5KDApO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbihvcGFjaXR5KSB7XHJcbiAgICBvcGFjaXR5ID0gb2JqZWN0LmlzRGVmaW5lZChvcGFjaXR5KSA/IG9wYWNpdHkgOiAxO1xyXG4gICAgdGhpcy5maWxsT3BhY2l0eShvcGFjaXR5KTtcclxuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eShvcGFjaXR5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHRoZSBsb2NhdGlvbiBvZiBhIGdpdmVuIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdmcgZWxlbWVudC5cclxuICogICAgICBfdF9cclxuICogICAgfFxcICAgL3xcclxuICogIGwgfCAgYyAgfCByXHJcbiAqICAgIHwvX19fXFx8XHJcbiAqICAgICAgIGJcclxuICogQHBhcmFtIG5vZGVcclxuICogQHBhcmFtIHBvc2l0aW9uXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuU1ZHU2hhcGUucHJvdG90eXBlLmdldFJlbGF0aXZlTG9jYXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgLy9GaXJzdCB3ZSBjaGVjayBpZiB0aGUgcG9pbnQgbGllcyBkaXJlY3Qgb24gdGhlIGJvdW5kYXJ5XHJcbiAgICBpZihwb3NpdGlvbi54ID09PSB0aGlzLngoKSkge1xyXG4gICAgICAgIHJldHVybiAnbGVmdCc7XHJcbiAgICB9IGVsc2UgaWYocG9zaXRpb24ueSA9PT0gdGhpcy55KCkpIHtcclxuICAgICAgICByZXR1cm4gJ3RvcCc7XHJcbiAgICB9IGVsc2UgaWYocG9zaXRpb24ueCA9PT0gdGhpcy5nZXRSaWdodFgoKSkge1xyXG4gICAgICAgIHJldHVybiAncmlnaHQnO1xyXG4gICAgfSBlbHNlIGlmKHBvc2l0aW9uLnkgPT09IHRoaXMuZ2V0Qm90dG9tWSgpKSB7XHJcbiAgICAgICAgcmV0dXJuICdib3R0b20nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vSWYgaXRzIG5vdCBvbiB0aGUgYm91bmRhcnkgd2UgY2hlY2sgdGhlIGxvY2F0aW9uIGJ5IG1lYW5zIG9mIHRoZSBsaW5lIGdyYWRpZW50XHJcbiAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgIHZhciBnID0gdXRpbC5tYXRoLkxpbmUuY2FsY0dyYWRpZW50KGNlbnRlciwgcG9zaXRpb24pO1xyXG4gICAgaWYocG9zaXRpb24ueSA8IGNlbnRlci55KSB7IC8vcG9zaXRpb24gb3ZlciBlbGVtZW50Y2VudGVyXHJcbiAgICAgICAgaWYgKHBvc2l0aW9uLnggPj0gY2VudGVyLngpIHsgLy9wb3NpdGlvbiByaWdodCAob3IgZXEpIG9mIGVsZW1lbnRjZW50ZXJcclxuICAgICAgICAgICAgcmV0dXJuIChnID4gLTEpID8gJ3JpZ2h0JyA6ICd0b3AnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZyA8IDEpIHsvL3Bvc2l0aW9uIGxlZnQgYW5kIG92ZXIgb2YgZWxlbWVudGNlbnRlclxyXG4gICAgICAgICAgICByZXR1cm4gKGcgPCAxKSA/ICdsZWZ0JyA6ICd0b3AnO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZihwb3NpdGlvbi54ID49IGNlbnRlci54KSB7IC8vcG9zaXRpb24gdW5kZXIgKG9yIGVxKSBhbmQgcmlnaHQgKG9yIGVxKSBvZiBlbGVtZW50Y2VudGVyXHJcbiAgICAgICAgcmV0dXJuIChnIDwgMSkgPyAncmlnaHQnIDogJ2JvdHRvbSc7XHJcbiAgICB9IGVsc2UgeyAvL3Bvc2l0aW9uIHVuZGVyIGFuZCBsZWZ0IG9mIGVsZW1lbnRjZW50ZXJcclxuICAgICAgICByZXR1cm4gKGcgPCAtMSkgPyAnYm90dG9tJyA6ICdsZWZ0JztcclxuICAgIH1cclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS54ID0gZnVuY3Rpb24od2l0aFN0cm9rZSkge1xyXG4gICAgcmV0dXJuICh3aXRoU3Ryb2tlKSA/IHRoaXMudHJhbnNsYXRlZFgodGhpcy5fZ2V0WCgpKSAtIHRoaXMuc2NhbGVkWCh0aGlzLnN0cm9rZVdpZHRoKCkpIC8gMiA6IHRoaXMudHJhbnNsYXRlZFgodGhpcy5fZ2V0WCgpKTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5fZ2V0WCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUueSA9IGZ1bmN0aW9uKHdpdGhTdHJva2UpIHtcclxuICAgIHJldHVybiAod2l0aFN0cm9rZSkgPyB0aGlzLnRyYW5zbGF0ZWRZKHRoaXMuX2dldFkoKSkgLSB0aGlzLnNjYWxlZFkodGhpcy5zdHJva2VXaWR0aCgpKSAvIDIgOiB0aGlzLnRyYW5zbGF0ZWRZKHRoaXMuX2dldFkoKSk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuX2dldFkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAwO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24od2l0aFN0cm9rZSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4IDogdGhhdC54KHdpdGhTdHJva2UpLFxyXG4gICAgICAgIHkgOiB0aGF0Lnkod2l0aFN0cm9rZSlcclxuICAgIH07XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUudG9wTGVmdCA9IGZ1bmN0aW9uKHdpdGhTdHJva2UpIHtcclxuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uKHdpdGhTdHJva2UpO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLnRvcFJpZ2h0ID0gZnVuY3Rpb24od2l0aFN0cm9rZSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4IDogdGhhdC5nZXRSaWdodFgod2l0aFN0cm9rZSksXHJcbiAgICAgICAgeSA6IHRoYXQueSh3aXRoU3Ryb2tlKVxyXG4gICAgfTtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5ib3R0b21SaWdodCA9IGZ1bmN0aW9uKHdpdGhTdHJva2UpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IHRoYXQuZ2V0UmlnaHRYKHdpdGhTdHJva2UpLFxyXG4gICAgICAgIHkgOiB0aGF0LmdldEJvdHRvbVkod2l0aFN0cm9rZSlcclxuICAgIH07XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuYm90dG9tTGVmdCA9IGZ1bmN0aW9uKHdpdGhTdHJva2UpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IHRoYXQueCh3aXRoU3Ryb2tlKSxcclxuICAgICAgICB5IDogdGhhdC5nZXRCb3R0b21ZKHdpdGhTdHJva2UpXHJcbiAgICB9O1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGMgPSB7XHJcbiAgICAgICAgeDogdGhpcy54KCkgKyBNYXRoLmZsb29yKHRoaXMud2lkdGgoKSAvIDIpLFxyXG4gICAgICAgIHk6IHRoaXMueSgpICsgTWF0aC5mbG9vcih0aGlzLmhlaWdodCgpIC8gMilcclxuICAgIH07XHJcbiAgICByZXR1cm4gdXRpbC5tYXRoLnJvdGF0ZShjLCB0aGlzLnBvc2l0aW9uKCksIHRoaXMucm90YXRlKCkpO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLm92ZXJsYXlzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBvYmplY3QuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGluZGV4LCBwb3NpdGlvbikge1xyXG4gICAgICAgIGlmKHRoYXQub3ZlcmxheUNoZWNrKHBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vVE8gYnJlYWsgdGhlIGVhY2ggbG9vcFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy9jb25zb2xlLmxvZygncmVzdWx0OicrcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIGNoZWNraW5nIGlmIGEgZ2l2ZW4gcG9zaXRpb24gbGllcyB3aXRoaW4gdGhlIHN2Z0VsZW1lbnQuXHJcbiAqIFRoaXMgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IHNoYXBlcyBsaWtlIGNpcmNsZXMgYW5kIGVsbGlwc2UuLlxyXG4gKi9cclxuU1ZHU2hhcGUucHJvdG90eXBlLm92ZXJsYXlDaGVjayA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gcG9zaXRpb24ueCA+PSB0aGlzLngoKSAmJiBwb3NpdGlvbi54IDw9IHRoaXMuZ2V0UmlnaHRYKClcclxuICAgICAgICAmJiBwb3NpdGlvbi55ID49IHRoaXMueSgpICYmIHBvc2l0aW9uLnkgPD0gdGhpcy5nZXRCb3R0b21ZKCk7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgdmFyIHRyYW5zbGF0ZSA9IHRoaXMudHJhbnNsYXRlKCk7XHJcbiAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGUueCArIGR4LCB0cmFuc2xhdGUueSArIGR5KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHZhciBwID0gdXRpbC5tYXRoLmdldFBvaW50KHgseSk7XHJcblxyXG4gICAgdmFyIHRyYW5zbGF0ZSA9IHRoaXMudHJhbnNsYXRlKCk7XHJcbiAgICBpZih0aGlzLngoKSAhPT0gcC54IHx8IHRoaXMueSgpICE9PSBwLnkpIHtcclxuICAgICAgICAvL1RPRE86IHRoaXMgZG9lcyBub3QgY29uc2lkZXIgeC95IGF0dHJpYnV0ZSBzZXR0aW5nc1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlKHApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUubW92ZVggPSBmdW5jdGlvbih4KSB7XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGUoKTtcclxuICAgIGlmKHRyYW5zbGF0ZS54ICE9PSB4KSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGUoeCwgdHJhbnNsYXRlLnkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUubW92ZVkgPSBmdW5jdGlvbih5KSB7XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGUoKTtcclxuICAgIGlmKHRyYW5zbGF0ZS55ICE9PSB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0ZS54LCB5KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vdGU6IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBnZXRCQm94IGRpZmZlcnMgYmV0d2VlbiBicm93c2VycyBzb21lIGFkZCB0aGUgc3Jva2Utd2lkdGggYW5kIHNvbWUgZG8gbm90IGFkZCBzdHJva2Utd2lkdGhcclxuICovXHJcblNWR1NoYXBlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpICYmIHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlZFkodGhpcy5fZ2V0SGVpZ2h0KCkpICsgdGhpcy5zY2FsZWRZKHRoaXMuc3Ryb2tlV2lkdGgoKSk7XHJcbiAgICB9IGVsc2UgaWYoIW9iamVjdC5pc0RlZmluZWQodmFsdWUpIHx8IChvYmplY3QuaXNCb29sZWFuKHZhbHVlKSAmJiAhdmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVkWSh0aGlzLl9nZXRIZWlnaHQoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3NldEhlaWdodCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuX2dldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QkJveCgpLmhlaWdodDtcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5fc2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvL0FCU1RSQUNUXHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYoKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpICYmIHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlZFgodGhpcy5fZ2V0V2lkdGgoKSkgKyB0aGlzLnNjYWxlZFgodGhpcy5zdHJva2VXaWR0aCgpKTtcclxuICAgIH0gZWxzZSBpZighb2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkgfHwgKG9iamVjdC5pc0Jvb2xlYW4odmFsdWUpICYmICF2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZWRYKHRoaXMuX2dldFdpZHRoKCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9zZXRXaWR0aCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuX2dldFdpZHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRCQm94KCkud2lkdGg7XHJcbn07XHJcblxyXG5TVkdTaGFwZS5wcm90b3R5cGUuX3NldFdpZHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgIC8vQUJTVFJBQ1RcclxufTtcclxuXHJcblNWR1NoYXBlLnByb3RvdHlwZS5nZXRCb3R0b21ZID0gZnVuY3Rpb24od2l0aFN0cm9rZSkge1xyXG4gICAgcmV0dXJuIHRoaXMueSh3aXRoU3Ryb2tlKSArIHRoaXMuaGVpZ2h0KHdpdGhTdHJva2UpO1xyXG59O1xyXG5cclxuU1ZHU2hhcGUucHJvdG90eXBlLmdldFJpZ2h0WCA9IGZ1bmN0aW9uKHdpdGhTdHJva2UpIHtcclxuICAgIHJldHVybiB0aGlzLngod2l0aFN0cm9rZSkgKyB0aGlzLndpZHRoKHdpdGhTdHJva2UpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdTaGFwZTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIFNWR1NoYXBlID0gcmVxdWlyZSgnLi9zdmdTaGFwZScpO1xyXG5cclxudmFyIERFRkFVTFRfRk9OVF9TSVpFID0gMTE7XHJcbnZhciBERUZBVUxUX0ZPTlRfRkFNSUxZID0gXCJIZWx2ZXRpY2FcIjsgLy9WZXJkYW5hLCBBcmlhbCwgc2Fucy1zZXJpZiA/XHJcbnZhciBERUZBVUxUX1RFWFRfQU5DSE9SID0gXCJzdGFydFwiO1xyXG52YXIgREVGQVVMVF9ET01JTkFOVF9CQVNFTElORSA9IFwiaGFuZ2luZ1wiO1xyXG5cclxudmFyIERFRkFVTFRfU1BBTl9QQURESU5HID0gMDtcclxuXHJcbnZhciBTVkdUZXh0ID0gZnVuY3Rpb24oc3ZnUm9vdCwgY2ZnLCBhdHRyaWJ1dGVTZXR0ZXIpIHtcclxuICAgIGNmZyA9IGNmZyB8fCB7fTtcclxuICAgIGNmZ1snZm9udC1mYW1pbHknXSA9IGNmZ1snZm9udC1zaXplJ10gfHwgREVGQVVMVF9GT05UX0ZBTUlMWTtcclxuICAgIGNmZ1snZm9udC1zaXplJ10gPSBjZmdbJ2ZvbnQtc2l6ZSddIHx8IERFRkFVTFRfRk9OVF9TSVpFO1xyXG4gICAgY2ZnWyd0ZXh0LWFuY2hvciddID0gY2ZnWyd0ZXh0LWFuY2hvciddIHx8IERFRkFVTFRfVEVYVF9BTkNIT1I7XHJcbiAgICBjZmdbJ2RvbWluYW50LWJhc2VsaW5lJ10gPSBjZmdbJ2RvbWluYW50LWJhc2VsaW5lJ10gfHwgREVGQVVMVF9ET01JTkFOVF9CQVNFTElORTtcclxuXHJcbiAgICB0aGlzLnNwYW5QYWRkaW5nID0gY2ZnWydwYWRkaW5nJ10gfHwgREVGQVVMVF9TUEFOX1BBRERJTkc7XHJcblxyXG4gICAgU1ZHU2hhcGUuY2FsbCh0aGlzLCAndGV4dCcsIHN2Z1Jvb3QsIGNmZywgYXR0cmlidXRlU2V0dGVyKTtcclxuICAgIC8vVE9ETzogU3BhbiAvIG11bHRpIGxpbmUgdGV4dFxyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhTVkdUZXh0LCBTVkdTaGFwZSk7XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKG9iamVjdC5pc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy5zcGFuUGFkZGluZyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2V0U3BhbkF0dHIoJ3gnLCB2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNwYW5QYWRkaW5nO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuZm9udEZhbWlseSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdmb250LWZhbWlseScsIHZhbHVlKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmZvbnRXZWlnaHQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywgdmFsdWUpO1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuZm9udFNpemUgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYodmFsdWUpIHtcclxuICAgICAgICB2YWx1ZSA9IG9iamVjdC5pc051bWJlcih2YWx1ZSkgPyB2YWx1ZSsncHgnIDogdmFsdWU7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5hdHRyTnVtYmVyKCdmb250LXNpemUnLCB2YWx1ZSk7XHJcbiAgICBpZih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc2V0U3BhbkF0dHIoJ2R5JywgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuc2V0U3BhbkF0dHIgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICB0aGlzLiQoKS5jaGlsZHJlbigndHNwYW4nKS5hdHRyKGtleSwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS54ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiAob2JqZWN0LmlzRGVmaW5lZCh2YWx1ZSkpID8gdGhpcy5hdHRyTnVtYmVyKCd4JywgdmFsdWUpIDogdGhpcy50cmFuc2xhdGVkWCh0aGlzLmF0dHJOdW1iZXIoJ3gnLCB2YWx1ZSkpIHx8IDAgO1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUueSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKG9iamVjdC5pc0RlZmluZWQodmFsdWUpKSA/IHRoaXMuYXR0ck51bWJlcigneScsIHZhbHVlKSA6IHRoaXMudHJhbnNsYXRlZFkodGhpcy5hdHRyTnVtYmVyKCd5JywgdmFsdWUpKSB8fCAwIDtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmR4ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHJOdW1iZXIoJ2R4JywgdmFsdWUpO1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuZHkgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0ck51bWJlcignZHknLCB2YWx1ZSk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICBTVkdUZXh0LnN1cGVyXy5wcm90b3R5cGUubW92ZS5hcHBseSh0aGlzLCBbZHgsIGR5XSk7XHJcbiAgICB0aGlzLmFsaWduQmFja2dyb3VuZCgpO1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgU1ZHVGV4dC5zdXBlcl8ucHJvdG90eXBlLm1vdmVUby5hcHBseSh0aGlzLCBbeCwgeV0pO1xyXG4gICAgdGhpcy5hbGlnbkJhY2tncm91bmQoKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICBpZighdGV4dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRleHQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0ZXh0ID0gdGV4dC50b1N0cmluZygpO1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHZhciBoZWlnaHQ7XHJcbiAgICB0aGlzLiQoKS5lbXB0eSgpO1xyXG4gICAgJC5lYWNoKHRleHQuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgdFNwYW4gPSB0aGF0LnN2Zy50c3Bhbih2YWx1ZSkueCh0aGF0LnNwYW5QYWRkaW5nKTtcclxuICAgICAgICAgICAgdGhhdC5hcHBlbmQodFNwYW4pO1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRTcGFuLmR5KGhlaWdodCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0U3Bhbi5oZWlnaHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB2YXIgJGNoaWxkcmVuID0gdGhpcy4kKCkuY2hpbGRyZW4oJ3RzcGFuJyk7XHJcbiAgICAkY2hpbGRyZW4uZWFjaChmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICByZXN1bHQgKz0gJCh0aGlzKS50ZXh0KCk7XHJcbiAgICAgICAgaWYoaW5kZXggIT0gJGNoaWxkcmVuLmxlbmd0aCAtMSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuc3dpdGNoQW5jaG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICBzd2l0Y2godGhpcy5hbmNob3IoKSkge1xyXG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgICBjYXNlICdlbmQnOlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5nZXRFeHRlbnRPZkNoYXIgPSBmdW5jdGlvbihjaGFyTnVtKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZSgpLmdldEV4dGVudE9mQ2hhcihjaGFyTnVtKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmdldENoYXJIZWlnaHQgPSBmdW5jdGlvbihjaGFyTnVtKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRFeHRlbnRPZkNoYXIoY2hhck51bSkuaGVpZ2h0O1xyXG59O1xyXG5cclxuU1ZHVGV4dC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmFuY2hvcignc3RhcnQnKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yKCdlbmQnKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLm1pZGRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yKCdtaWRkbGUnKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLmFuY2hvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd0ZXh0LWFuY2hvcicsIHZhbHVlKTtcclxufTtcclxuXHJcblNWR1RleHQucHJvdG90eXBlLnRTcGFuID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLnN2Zy5nZXQodGhpcy4kKCkuY2hpbGRyZW4oJ3RzcGFuJykuZ2V0KGluZGV4KSk7XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5oYW5naW5nID0gZnVuY3Rpb24oaGFuZ2luZykge1xyXG4gICAgdmFyIGhhbmdpbmcgPSBvYmplY3QuaXNEZWZpbmVkKGhhbmdpbmcpID8gaGFuZ2luZyA6IHRydWU7XHJcbiAgICB2YXIgdmFsdWUgPSBoYW5naW5nID8gJ2hhbmdpbmcnIDogJ2Jhc2VsaW5lJztcclxuICAgIHRoaXMuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCB2YWx1ZSk7XHJcbiAgICB2YXIgZmlyc3RTcGFuID0gdGhpcy50U3BhbigwKTtcclxuICAgIHZhciBkeSA9IChoYW5naW5nKSA/IDAgOiBmaXJzdFNwYW4uaGVpZ2h0KCkgKyB0aGlzLmdldEJCb3goKS55O1xyXG4gICAgZmlyc3RTcGFuLmR5KGR5KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vdGU6IHRoZSBiYWNrZ3JvdW5kIHdvbid0IGFsaWduIHdoZW4gdGhlIHRleHQgaXMgZHJhZ2dlZC4gUGVyaGFwcyBhZGQgZHJhZyBob29rXHJcbiAqIEBwYXJhbSBjb2xvclxyXG4gKi9cclxuU1ZHVGV4dC5wcm90b3R5cGUuYmFja2dyb3VuZCA9IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgICB2YXIgc3ZnQmFja2dyb3VuZCA9IHRoaXMuZ2V0QmFja2dyb3VuZCgpO1xyXG4gICAgaWYoY29sb3IpIHtcclxuICAgICAgICBpZighc3ZnQmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICBzdmdCYWNrZ3JvdW5kID0gdGhpcy5zdmcucmVjdCh7J2NsYXNzJzondGV4dEJhY2tncm91bmQnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN2Z0JhY2tncm91bmQuZmlsbChjb2xvcik7XHJcbiAgICAgICAgc3ZnQmFja2dyb3VuZC4kKCkuYWZ0ZXIodGhpcy4kKCkpO1xyXG4gICAgICAgIHRoaXMuYWxpZ25CYWNrZ3JvdW5kKCk7XHJcbiAgICB9IGVsc2UgaWYoc3ZnQmFja2dyb3VuZCkge1xyXG4gICAgICAgIHN2Z0JhY2tncm91bmQuZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogIFRPRE86IHByb2JhYmx5IGp1c3Qgd29ya3MgZm9yIGhhbmdpbmcgdGV4dHMgYmVjYXVzZSBvZiB0aGUgb2Zmc2V0Li4uXHJcbiAqL1xyXG5TVkdUZXh0LnByb3RvdHlwZS5hbGlnbkJhY2tncm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzdmdCYWNrZ3JvdW5kID0gdGhpcy5nZXRCYWNrZ3JvdW5kKCk7XHJcbiAgICBpZihzdmdCYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgdmFyIGJnSGVpZ2h0ID0gdGhpcy5oZWlnaHQoKSArIHRoaXMuZ2V0QkJveCgpLnk7IC8vcmVtb3ZlIHRleHQgb2Zmc2V0XHJcbiAgICAgICAgc3ZnQmFja2dyb3VuZC5oZWlnaHQoYmdIZWlnaHQpLndpZHRoKHRoaXMud2lkdGgoKSkudHJhbnNsYXRlKHRoaXMueCgpLCB0aGlzLnkoKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5nZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih0aGlzLmJhY2tncm91bmRTVkcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kU1ZHO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2ID0gdGhpcy4kKCkucHJldigpO1xyXG4gICAgaWYocHJldi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIHN2Z0JhY2sgPSB0aGlzLnN2Zy5nZXQocHJldik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZFNWRyA9IChzdmdCYWNrLmhhc0NsYXNzKCd0ZXh0QmFja2dyb3VuZCcpKSA/IHN2Z0JhY2sgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdUZXh0LnByb3RvdHlwZS5kb21pbmFudEJhc2VsaW5lID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgdmFsdWUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdUZXh0OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XHJcbnZhciBvYmplY3QgPSB1dGlsLm9iamVjdDtcclxudmFyIERvbUVsZW1lbnQgPSByZXF1aXJlKCcuLi9kb20vZG9tRWxlbWVudCcpO1xyXG5cclxudmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgaWYodHlwZW9mIGRlZiAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzU3RyaW5nKGRlZikpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXREZWZpbml0aW9uRnJvbVN0cmluZyhkZWYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZjtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IHt9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZWZpbml0aW9uRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZighdGhpcy5kZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXh0cmFjdCAndHJhbnNsYXRlKDIwMCAyMDApIHJvdGF0ZSg0NSA1MCA1MCknIHRvIFwidHJhbnNsYXRlXCIgXCIyMDAgMjAwXCIgXCIgcm90YXRlXCIgXCI0NSA1MCA1MFwiIFwiXCJcclxuICAgIHZhciB0cmFuc2Zvcm1hdGlvbnMgPSB2YWx1ZS5zcGxpdCgvW1xcKFxcKV0rLyk7XHJcbiAgICBmb3IodmFyIGkgPSAwO2kgPCB0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbnNbaV0udHJpbSgpO1xyXG4gICAgICAgIGlmKHRyYW5zZm9ybWF0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IERvbUVsZW1lbnQuZ2V0QXR0cmlidXRlVmFsdWVGcm9tU3RyaW5nTGlzdCh0cmFuc2Zvcm1hdGlvbnNbaSsxXSk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHByZWZlciBmbG9hdCB2YWx1ZXMgZm9yIGNhbGN1bGF0aW9uc1xyXG4gICAgICAgICAgICAgICAgaWYoIWlzTmFOKHZhbHVlc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbal0gPSBwYXJzZUZsb2F0KHZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uW3RyYW5zZm9ybWF0aW9uXSA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICBmb3IodmFyIGtleSBpbiB0aGlzLmRlZmluaXRpb24pIHtcclxuICAgICAgICBpZih0aGlzLmRlZmluaXRpb24uaGFzT3duUHJvcGVydHkoKGtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIGZpcnN0IHdlIGFzc2FtYmxlIGFsbCB0cmFuc2Zvcm1hdGlvbnMgaW4gYW4gYXJyYXkgWyd0cmFuc2xhdGUoMzApJywncm90YXRlKDQ1IDUwIDUwKSddXHJcbiAgICAgICAgICAgIHZhciBzaW5nbGVUcmFuc2Zvcm1hdGlvbiA9IGtleSsnKCcrRG9tRWxlbWVudC5nZXRBdHRyaWJ1dGVTdHJpbmcodGhpcy5kZWZpbml0aW9uW2tleV0pKycpJztcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goc2luZ2xlVHJhbnNmb3JtYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG1lcmdlIHRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gb25lIGF0dHJpYnV0ZXN0cmluZ1xyXG4gICAgdmFyIHZhbHVlU3RyID0gRG9tRWxlbWVudC5nZXRBdHRyaWJ1dGVTdHJpbmcodmFsdWVzKTtcclxuXHJcbiAgICBpZih2YWx1ZVN0ci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSB0cmFuc29ybWF0aW9ucyBzZXQgd2UganVzdCByZXR1cm4gYW4gZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5oYXNUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgdGhpcy5kZWZpbml0aW9uW2tleV0gIT09ICd1bmRlZmluZWQnKTtcclxufTtcclxuXHJcblxyXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgaWYob2JqZWN0LmlzRGVmaW5lZCh2YWwpKSB7XHJcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uLnJvdGF0ZSA9IHZhbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbi5yb3RhdGUgfHwgMDtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbihzeCwgc3kpIHtcclxuICAgIHN5ID0gc3kgfHwgc3g7XHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHN4KSkge1xyXG4gICAgICAgIGlmKCF0aGlzLmRlZmluaXRpb24uc2NhbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uLnNjYWxlID0gW3N4LCBzeV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uLnNjYWxlWzBdID0gc3g7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbi5zY2FsZVsxXSA9IHN5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZGVmaW5pdGlvbi5zY2FsZTtcclxuICAgICAgICBpZihyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdFswXSwgcmVzdWx0WzBdXTtcclxuICAgICAgICB9IGVsc2UgaWYocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHRbMF0sIHJlc3VsdFsxXV1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gWzEsMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgaWYoaW5kZXggPCAyICYmIHRoaXMuZGVmaW5pdGlvbi5zY2FsZSkge1xyXG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbi5zY2FsZVtpbmRleF0gPSB2YWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIHAgPSB1dGlsLm1hdGguZ2V0UG9pbnQoeCx5KTtcclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHApKSB7XHJcbiAgICAgICAgaWYoIXRoaXMuZGVmaW5pdGlvbi50cmFuc2xhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uLnRyYW5zbGF0ZSA9IFtwLngsIHAueV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uLnRyYW5zbGF0ZVswXSA9IHAueDtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uLnRyYW5zbGF0ZVsxXSA9IHAueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmKHRoaXMuZGVmaW5pdGlvbi50cmFuc2xhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHggOiB0aGlzLmRlZmluaXRpb24udHJhbnNsYXRlWzBdLFxyXG4gICAgICAgICAgICAgICAgeSA6IHRoaXMuZGVmaW5pdGlvbi50cmFuc2xhdGVbMV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeCA6IDAsXHJcbiAgICAgICAgICAgICAgICB5IDogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIFNWR1NoYXBlID0gcmVxdWlyZSgnLi9zdmdTaGFwZScpO1xyXG52YXIgU1ZHVGV4dCA9IHJlcXVpcmUoJy4vdGV4dCcpO1xyXG5cclxudmFyIERFRkFVTFRfRE9NSU5BTlRfQkFTRUxJTkUgPSAnaW5oZXJpdCdcclxuXHJcbnZhciBTVkdUU3BhbiA9IGZ1bmN0aW9uKHN2Z1Jvb3QsIGNmZykge1xyXG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xyXG4gICAgY2ZnWydkb21pbmFudC1iYXNlbGluZSddID0gY2ZnWydkb21pbmFudC1iYXNlbGluZSddIHx8IERFRkFVTFRfRE9NSU5BTlRfQkFTRUxJTkU7XHJcbiAgICBTVkdTaGFwZS5jYWxsKHRoaXMsICd0c3BhbicsIHN2Z1Jvb3QsIGNmZyk7XHJcbn07XHJcblxyXG51dGlsLmluaGVyaXRzKFNWR1RTcGFuLCBTVkdUZXh0KTtcclxuXHJcblNWR1RTcGFuLnByb3RvdHlwZS5nZXRDb250YWluZXJUZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQoKTtcclxuICAgIGlmKHBhcmVudC50YWdOYW1lID09PSAndGV4dCcpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50O1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHVFNwYW4ucHJvdG90eXBlLmZvbnRTaXplID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFNWR1RTcGFuLnN1cGVyXy5wcm90b3R5cGUuZm9udFNpemUuYXBwbHkodGhpcywgW3ZhbHVlXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBTVkdUU3Bhbi5zdXBlcl8ucHJvdG90eXBlLmZvbnRTaXplLmFwcGx5KHRoaXMpO1xyXG4gICAgICAgIGlmKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclRleHQgPSB0aGlzLmdldENvbnRhaW5lclRleHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIChjb250YWluZXJUZXh0KSA/IGNvbnRhaW5lclRleHQuZm9udFNpemUoKSA6IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdUU3Bhbi5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuJCgpLnRleHQodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kKCkudGV4dCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHVFNwYW4ucHJvdG90eXBlLmdldEJCb3ggPSBmdW5jdGlvbigpIHtcclxuICAgIC8vc29tZSBicm93c2VyIChlLmcuIGZpcmVmb3gpIGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2V0QkJveCBmb3IgdHNwYW4gZWxlbWVudHMuXHJcbiAgICByZXR1cm4gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHVFNwYW47IiwidmFyIGRvbSA9IHJlcXVpcmUoJy4uL2RvbS9kb20nKTtcclxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvb2JqZWN0Jyk7XHJcblxyXG5FZGl0UGFuZWwgPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuRWRpdFBhbmVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ocGFnZVgsIHBhZ2VZLCBvbmNsb3NlKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGlzLmNsb3NlKCk7XHJcblxyXG4gICAgdGhpcy5vbmNsb3NlID0gb25jbG9zZTtcclxuXHJcbiAgICAvL0luaXQgRm9ybVxyXG4gICAgdGhpcy4kZm9ybSA9IGRvbS5jcmVhdGUoJ2Zvcm0nLCB7YWN0aW9uIDogJ2phdmFzY3JpcHQ6dm9pZCgwKTsnfSlcclxuICAgICAgICAub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0LmNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgLy9Jbml0IENvbnRhaW5lclxyXG4gICAgdGhpcy4kZWRpdERpdiA9IGRvbS5jcmVhdGUoJ2RpdicsIHtpZDonZWRpdFBhbmVsJ30pXHJcbiAgICAgICAgLm9mZnNldCh7dG9wOiBwYWdlWSwgbGVmdDogKHBhZ2VYKzUpfSlcclxuICAgICAgICAuY3NzKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXHJcbiAgICAgICAgLmNzcygnYmFja2dyb3VuZC1jb2xvcicsICdzaWx2ZXInKVxyXG4gICAgICAgIC5hcHBlbmQodGhpcy4kZm9ybSk7XHJcblxyXG4gICAgLy9BcHBlbmQgdG8gYm9keVxyXG4gICAgJCgnYm9keScpLmFwcGVuZCh0aGlzLiRlZGl0RGl2KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRWRpdFBhbmVsLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5vbmNsb3NlKSB7XHJcbiAgICAgICAgdGhpcy5vbmNsb3NlLmFwcGx5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy4kZWRpdERpdikge1xyXG4gICAgICAgIHRoaXMuJGVkaXREaXYucmVtb3ZlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkVkaXRQYW5lbC5wcm90b3R5cGUuY3JlYXRlVGV4dEVkaXQgPSBmdW5jdGlvbihwYWdlWCAscGFnZVksIGdldHRlciwgc2V0dGVyKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB2YXIgJGlucHV0ID0gZG9tLmNyZWF0ZSgnaW5wdXQnLCB7dHlwZTondGV4dCcsIHZhbHVlIDogZ2V0dGVyKCl9KVxyXG4gICAgICAgIC5mb2N1cygpXHJcbiAgICAgICAgLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdibHVyJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHRoYXQuY2xvc2UoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignY2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHNldHRlcigkaW5wdXQudmFsKCkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIHRoaXMuaW5pdChwYWdlWCAscGFnZVkpO1xyXG4gICAgdGhpcy4kZm9ybS5hcHBlbmQoJGlucHV0KTtcclxuICAgICRpbnB1dC5mb2N1cygpO1xyXG59O1xyXG5cclxuRWRpdFBhbmVsLnByb3RvdHlwZS5jcmVhdGVUZXh0QXJlYUVkaXQgPSBmdW5jdGlvbihwYWdlWCAscGFnZVksIGdldHRlciwgc2V0dGVyKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB2YXIgJGlucHV0ID0gZG9tLmNyZWF0ZSgndGV4dGFyZWEnKVxyXG4gICAgICAgIC52YWwoZ2V0dGVyKCkpXHJcbiAgICAgICAgLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgc2V0dGVyKCRpbnB1dC52YWwoKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2JsdXInLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgdGhhdC5jbG9zZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIHRoaXMuaW5pdChwYWdlWCAscGFnZVkpO1xyXG4gICAgdGhpcy4kZm9ybS5hcHBlbmQoJGlucHV0KTtcclxuICAgICRpbnB1dC5mb2N1cygpO1xyXG59O1xyXG5cclxuRWRpdFBhbmVsLnByb3RvdHlwZS5zZXRUZXh0QXJlYUNvbnRlbnQgPSBmdW5jdGlvbigkdGV4dEFyZWFOb2RlLCB0eHRBcmVhQ29udGVudCkge1xyXG4gICAgJHRleHRBcmVhTm9kZS5lbXB0eSgpO1xyXG4gICAgLy9UT0RPOiB3ZSBkbyBub3QgY29uc2lkZXIgdGhlIHRleHQgc2l6ZSBmb3IgZHkgIVxyXG4gICAgdmFyIGR5ID0gMTE7XHJcbiAgICAkLmVhY2godHh0QXJlYUNvbnRlbnQuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBpZihvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBkb20uYXBwZW5kU1ZHRWxlbWVudCgkdGV4dEFyZWFOb2RlLmdldCgwKSwge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA6ICd0c3BhbicsXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGR5IDogZHksXHJcbiAgICAgICAgICAgICAgICAgICAgeCA6IDJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuRWRpdFBhbmVsLnByb3RvdHlwZS5nZXRUZXh0QXJlYUNvbnRlbnQgPSBmdW5jdGlvbigkdGV4dEFyZWFOb2RlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAkdGV4dEFyZWFOb2RlLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXN1bHQgKz0gJCh0aGlzKS50ZXh0KCkrJ1xcbic7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVkaXRQYW5lbDsiLCJ2YXIgU1ZHID0gcmVxdWlyZSgnLi4vc3ZnL3N2ZycpO1xyXG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJpbmcnKTtcclxudmFyIHF1ZXJ5Q2FjaGUgPSByZXF1aXJlKCcuLi9jb3JlL2NhY2hlJyk7XHJcblxyXG4kLmZuLnN2ZyA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICBpZihzZWxlY3RvciAmJiBzZWxlY3Rvci5TVkdFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xyXG4gICAgfSBlbHNlIGlmKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuICQoc2VsZWN0b3IpLnN2ZygpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCF0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH0gZWxzZSBpZih0aGlzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBTVkcuZ2V0KHRoaXMpO1xyXG4gICAgfSBlbHNlIGlmKHRoaXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAgW107XHJcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChTVkcuZ2V0KHRoaXMpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuJC5zdmcgPSAkLmZuLnN2ZztcclxuXHJcbiQucUNhY2hlID0gZnVuY3Rpb24oc2VsZWN0b3IsIHByZXZlbnRDYWNoZSkge1xyXG4gICAgaWYoc2VsZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gcXVlcnlDYWNoZS4kKHNlbGVjdG9yLCBwcmV2ZW50Q2FjaGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcXVlcnlDYWNoZTtcclxuICAgIH1cclxufTtcclxuXHJcbiQucVVuY2FjaGUgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIHF1ZXJ5Q2FjaGUucmVtb3ZlKHNlbGVjdG9yKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcHJvYmxlbSB3aXRoIHVpLXNlbGVjdG1lbnUgaXMgdGhhdCBpdCBjYXVzZXMgYSBzZWNvbmQga2V5ZG93biB0cmlnZ2VyIGV2ZW50IHdoZW4gZm9jdXNlZC5cclxuICogU28gZ2xvYmFsIGtleWRvd24gZXZlbnRzIGFyZSB0cmlnZ2VyZWQgdHdpY2hlIGxpa2UgZG8vdW5kbyBpZiBmb2N1c2VkLiBUaGUgZm9sbG93aW5nIGV2ZW50XHJcbiAqIHByZXZlbnRzIHRoZSBwcm9wYWdhdGlvbiBpZiB0aGUgY29udHJvbCBrZXkgaXMgcHJlc3NlZC5cclxuICovXHJcbiQoZG9jdW1lbnQsICcudWktc2VsZWN0bWVudS1idXR0b24nKS5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgaWYoZXZ0LmN0cmxLZXkpIHtcclxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuJC5mbi5ncm93bCA9IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgdmFyICRyb290ID0gdGhpcztcclxuXHJcbiAgICAvLyB0b29sdGlwIGNvbnRlbnQgYW5kIHN0eWxpbmdcclxuICAgIHZhciAkY29udGVudCA9ICQoXHJcbiAgICAgICAgJzxhIGNsYXNzPVwiaWNvbi1jbG9zZVwiIGhyZWY9XCIjXCI+PC9hPicrXHJcbiAgICAgICAgJzxoMSBzdHlsZT1cImNvbG9yOiB3aGl0ZTsgZm9udC1zaXplOiAxMnB0OyBmb250LXdlaWdodDogYm9sZDsgcGFkZGluZy1ib3R0b206IDVweDtcIj4nICsgcGFyYW1zLnRpdGxlICsgJzwvaDE+JyArXHJcbiAgICAgICAgJzxwIHN0eWxlPVwibWFyZ2luOiAwOyBwYWRkaW5nOiA1cHggMCA1cHggMDsgZm9udC1zaXplOiAxMHB0O1wiPicgKyBwYXJhbXMudGV4dCArICc8L3A+Jyk7XHJcblxyXG4gICAgLy8gYWRkICdDbG9zZScgYnV0dG9uIGZ1bmN0aW9uYWxpdHlcclxuICAgIHZhciAkY2xvc2UgPSAkKCRjb250ZW50WzBdKTtcclxuICAgICRjbG9zZS5jbGljayhmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgJHJvb3QudWl0b29sdGlwKCdjbG9zZScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gcHJldmVudCBzdGFuZGFyZCB0b29sdGlwIGZyb20gY2xvc2luZ1xyXG4gICAgJHJvb3QuYmluZCgnZm9jdXNvdXQgbW91c2VsZWF2ZScsIGZ1bmN0aW9uKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyByZXR1cm4gZmFsc2U7IH0pO1xyXG5cclxuICAgIC8vIGJ1aWxkIHRvb2x0aXBcclxuICAgICRyb290LnVpdG9vbHRpcCh7XHJcbiAgICAgICAgY29udGVudDogZnVuY3Rpb24oKSB7IHJldHVybiAkY29udGVudDsgfSxcclxuICAgICAgICBpdGVtczogJHJvb3Quc2VsZWN0b3IsXHJcbiAgICAgICAgdG9vbHRpcENsYXNzOiAnZ3Jvd2wgJyArIHBhcmFtcy5ncm93bENsYXNzLFxyXG4gICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgIG15OiAncmlnaHQgdG9wJyxcclxuICAgICAgICAgICAgYXQ6ICdyaWdodC0xMCB0b3ArMTAnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcclxuICAgICAgICAgICAgJHJvb3QudWl0b29sdGlwKCdkZXN0cm95Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSkudWl0b29sdGlwKCdvcGVuJyk7XHJcblxyXG4gICAgaWYocGFyYW1zLmNsb3NlQWZ0ZXIpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICRyb290LnVpdG9vbHRpcCgnY2xvc2UnKTsgfSwgcGFyYW1zLmNsb3NlQWZ0ZXIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuaWYoJC51aSkge1xyXG4gICAgJC53aWRnZXQoIFwiY3VzdG9tLmljb25zZWxlY3RtZW51XCIsICQudWkuc2VsZWN0bWVudSwge1xyXG4gICAgICAgIF9yZW5kZXJJdGVtOiBmdW5jdGlvbiggdWwsIGl0ZW0gKSB7XHJcbiAgICAgICAgICAgIHZhciBsaSA9ICQoIFwiPGxpPlwiLCB7IHRleHQ6IGl0ZW0ubGFiZWwgfSApO1xyXG4gICAgICAgICAgICBpZiAoIGl0ZW0uZGlzYWJsZWQgKSB7XHJcbiAgICAgICAgICAgICAgICBsaS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJCggXCI8c3Bhbj5cIiwge1xyXG4gICAgICAgICAgICAgICAgc3R5bGU6IGl0ZW0uZWxlbWVudC5hdHRyKCBcImRhdGEtc3R5bGVcIiApLFxyXG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcInVpLWljb24gXCIgKyBpdGVtLmVsZW1lbnQuYXR0ciggXCJkYXRhLWNsYXNzXCIgKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKCBsaSApO1xyXG4gICAgICAgICAgICByZXR1cm4gbGkuYXBwZW5kVG8oIHVsICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwidmFyIGV2ZW50ID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9vYmplY3QnKTtcclxudmFyIGNsaWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvY2xpZW50Jyk7XHJcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcclxudmFyIERhbGFFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9lcnJvcicpO1xyXG5cclxudmFyIFBBVEhfTE9HSU4gPSAnL3VzZXIvbG9naW4nO1xyXG52YXIgU0VMX0xPR0dFRF9PVVQgPSAnLmxvZ2dlZE91dCc7XHJcbnZhciBTRUxfTE9HR0VEX0lOID0gJy5sb2dnZWRJbic7XHJcbnZhciBTRUxfVVNFUl9MSU5LX1RYVCA9ICcjdXNlci1saW5rLXRleHQnO1xyXG5cclxudmFyIHVzZXI7XHJcblxyXG52YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZXZlbnQubGlzdGVuKCd1c2VyX2xvZ2dlZGluJywgdXNlckxvZ2luKTtcclxuICAgIGV2ZW50Lmxpc3RlbigndXNlcl9sb2dnZWRvdXQnLCB1c2VyTG9nb3V0KTtcclxuICAgIGxvZ291dEhhbmRsZXIodHJ1ZSk7XHJcbn07XHJcblxyXG52YXIgbG9naW4gPSBmdW5jdGlvbihlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0ge1xyXG4gICAgICAgICAgICBlbWFpbCA6IGVtYWlsLFxyXG4gICAgICAgICAgICBwYXNzd29yZCA6IHBhc3N3b3JkXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY2xpZW50LnBvc3QoUEFUSF9MT0dJTiwgdmFsdWVzLCB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VkSW5IYW5kbGVyKHJlc3BvbnNlLmRhdGEucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvciA6IGZ1bmN0aW9uKGVycm9yLCBlcnJvckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaChlcnJvckNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERhbGFFcnJvci5DT0RFUy5VU0VSX0xPR0lOX0lOQ09SUkVDVF9QQVNTV09SRDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQudHJpZ2dlcignZXJyb3InLCAnTG9naW4gZmFpbGVkOiBJbnZhbGlkIHBhc3N3b3JkIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERhbGFFcnJvci5DT0RFUy5VU0VSX0xPR0lOX0lOVkFMSURfRU1BSUw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnRyaWdnZXIoJ2Vycm9yJywgJ0xvZ2luIGZhaWxlZDogSW52YWxpZCBlbWFpbCBhZGRyZXNzLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC50cmlnZ2VyKCdlcnJvcicsICdMb2dpbiBmYWlsZWQ6IFNvbWV0aGluZyB3ZW50IHdyb25nLCBwbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdWNjZXNzTWVzc2FnZSA6ICdMb2dpbiB3YXMgc3VjY2Vzc2Z1bCEnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciBsb2dnZWRJbkhhbmRsZXIgPSBmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICQoU0VMX0xPR0dFRF9PVVQpLmhpZGUoKTtcclxuICAgICQoU0VMX0xPR0dFRF9JTikuc2hvdygpO1xyXG4gICAgJChTRUxfVVNFUl9MSU5LX1RYVCkudGV4dChyZXN1bHQudXNlci5lbWFpbCk7XHJcbiAgICBldmVudC50cmlnZ2VyKCd1c2VyX2xvZ2dlZGluJywgcmVzdWx0KTtcclxufTtcclxuXHJcbnZhciBsb2dvdXRIYW5kbGVyID0gZnVuY3Rpb24ocHJldlRyaWdnZXIpIHtcclxuICAgICQoU0VMX0xPR0dFRF9JTikuaGlkZSgpO1xyXG4gICAgJChTRUxfTE9HR0VEX09VVCkuc2hvdygpO1xyXG4gICAgJChTRUxfVVNFUl9MSU5LX1RYVCkudGV4dCgnJyk7XHJcbiAgICBpZighcHJldlRyaWdnZXIpIHtcclxuICAgICAgICBldmVudC50cmlnZ2VyKCd1c2VyX2xvZ2dlZG91dCcpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIHVzZXJMb2dpbiA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgdXNlciA9IGV2dC5kYXRhLnVzZXI7XHJcbn1cclxuXHJcbnZhciBpc0xvZ2dlZEluID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gb2JqZWN0LmlzRGVmaW5lZCh1c2VyKTtcclxufVxyXG5cclxudmFyIHVzZXJMb2dvdXQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGRlbGV0ZSB1c2VyO1xyXG59XHJcblxyXG52YXIgZ2V0VXNlcklkID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih1c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIHVzZXIuaWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgaW5pdDogaW5pdCxcclxuICAgIGxvZ2luIDogbG9naW4sXHJcbiAgICBpc0xvZ2dlZEluIDogaXNMb2dnZWRJbixcclxuICAgIGdldFVzZXJJZCA6IGdldFVzZXJJZFxyXG59OyIsInZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIG9iamVjdDogcmVxdWlyZSgnLi9vYmplY3QnKSxcclxuICAgIHN0cmluZzogcmVxdWlyZSgnLi9zdHJpbmcnKSxcclxuICAgIGRvbTogcmVxdWlyZSgnLi8uLi9kb20vZG9tJyksXHJcbiAgICBhcHA6IHJlcXVpcmUoJy4vYXBwJyksXHJcbiAgICBtYXRoOiByZXF1aXJlKCcuL21hdGgnKSxcclxuICAgIHhtbCA6IHJlcXVpcmUoJy4veG1sJyksXHJcbiAgICBpbmhlcml0czogdXRpbC5pbmhlcml0c1xyXG59IiwiLyoqXHJcbiAqIFRoaXMgbW9kdWxlIHNlcnZlcyBhcyBhbiB3cmFwcGVyIGZvciBkb20gbWFuaXB1bGF0aW9uIGZ1bmN0aW9uYWxpdHkuIEl0IGlzXHJcbiAqIGhpZ2hseSBwcmVmZXJlZCB0byB1c2UgdGhpcyBtb2R1bGUgaW5zdGVhZCBvZiBqcXVlcnkgZGlyZWN0bHkgd2l0aGluIG90aGVyXHJcbiAqIG1vZHVsZXMuXHJcbiAqL1xyXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcclxuXHJcbnZhciBwYXJzZUZlYXR1cmVTdHJpbmdzID0gZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWwpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJyAnKTtcclxuICAgIG9iamVjdC5lYWNoKHZhbHVlLCBmdW5jdGlvbihpbmRleCwgZmVhdHVyZSkge1xyXG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBwYXJzZUZlYXR1cmVTdHJpbmcoZmVhdHVyZSwgZGVmYXVsdFZhbCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogcGFyc2UgYSBmZWF0dXJlc3RpbnJnIGluIHRoZSBmb3JtIG9mXHJcbiAqICAnZmVhdHVyZW5hbWUoMzAsMzApJyBvciAnZmVhdHVyZW5hbWUoMzAuNCkgb3IgZmVhdHVyZW5hbWVcclxuICpcclxuICogVGhlIHJlc3VsdCBpcyB3b3VsZCBiZVxyXG4gKiAgICAgIHsgdHlwZSA6ICdmZWF0dXJlbmFtZScsIHZhbHVlIDogWzMwLDMwXSB9XHJcbiAqICAgICAgeyB0eXBlIDogJ2ZlYXR1cmVuYW1lJywgdmFsdWUgOiAzMC40IH1cclxuICogICAgICB7IHR5cGUgOiAnZmVhdHVyZW5hbWUnLCB2YWx1ZSA6IHVuZGVmaW5lZCB9XHJcbiAqIEBwYXJhbSB7dHlwZX0gZmVhdHVyZVxyXG4gKiBAcmV0dXJucyB7QXBwX0w2LnBhcnNlRmVhdHVyZVN0cmluZy5yZXN1bHR9XHJcbiAqL1xyXG52YXIgcGFyc2VGZWF0dXJlU3RyaW5nID0gZnVuY3Rpb24oZmVhdHVyZSwgZGVmYXVsdFZhbCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYoZmVhdHVyZS5pbmRleE9mKCcoJykgPiAtMSkge1xyXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IGZlYXR1cmUuc3BsaXQoJygnKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdHRlZFsxXS5zdWJzdHJpbmcoMCwgc3BsaXR0ZWRbMV0uaW5kZXhPZignKScpKTtcclxuXHJcbiAgICAgICAgaWYodmFsdWUuaW5kZXhPZignLCcpID4gLTEpIHsgLy8gbXVsdGlwbGUgYXJnc1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgIG9iamVjdC5lYWNoKHZhbHVlLCBmdW5jdGlvbihpbmRleCwgdikge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gcGFyc2VOdW1iZXJTdHJpbmcodik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIHNpbmdsZSBhcmdcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU51bWJlclN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC50eXBlID0gc3BsaXR0ZWRbMF07XHJcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC50eXBlID0gZmVhdHVyZTtcclxuICAgICAgICByZXN1bHQudmFsdWUgPSBkZWZhdWx0VmFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnZhciBwYXJzZU51bWJlclN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZighb2JqZWN0LmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvL0N1dCB1bml0cyAxLjJlbSAtPiAxLjJcclxuICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoLyg/PVthLXosQS1aXSspLylbMF07XHJcblxyXG4gICAgaWYoIWlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgIGlmKHZhbHVlLmluZGV4T2YoJy4nKSA+IC0xKSB7IC8vZmxvYXRcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgeyAvL2ludFxyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG52YXIgY3JlYXRlRmVhdHVyZVN0cmluZyA9IGZ1bmN0aW9uKGZlYXR1cmUsIHZhbHVlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZmVhdHVyZTtcclxuXHJcbiAgICBpZihvYmplY3QuaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgIHJlc3VsdCArPSAnKCc7XHJcbiAgICAgICAgaWYob2JqZWN0LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIG9iamVjdC5lYWNoKHZhbHVlLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoaW5kZXggIT09IDApID8gJywnK3ZhbHVlIDogdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ICs9ICcpJztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgaXNNaW5EaXN0ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG1pbkRpc3QpIHtcclxuICAgIHJldHVybiBNYXRoLmFicyh0by54IC0gZnJvbS54KSA+IG1pbkRpc3QgfHwgTWF0aC5hYnModG8ueSAtIGZyb20ueSkgPiBtaW5EaXN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBwYXJzZUZlYXR1cmVTdHJpbmc6cGFyc2VGZWF0dXJlU3RyaW5nLFxyXG4gICAgY3JlYXRlRmVhdHVyZVN0cmluZzpjcmVhdGVGZWF0dXJlU3RyaW5nLFxyXG4gICAgcGFyc2VGZWF0dXJlU3RyaW5nczpwYXJzZUZlYXR1cmVTdHJpbmdzLFxyXG4gICAgcGFyc2VOdW1iZXJTdHJpbmcgOiBwYXJzZU51bWJlclN0cmluZyxcclxuICAgIGlzTWluRGlzdCA6IGlzTWluRGlzdFxyXG59O1xyXG4iLCIvKipcclxuICogbW9zdCBCZXppZXIgaGVscHRlciBmdW5jdGlvbnMgYXJlIHRha2VuIGZyb20ganNCZXppZXIgbGlicmFyeSBodHRwczovL2dpdGh1Yi5jb20vanNwbHVtYi9qc0Jlemllci9ibG9iL21hc3Rlci9qcy8wLjYvanNCZXppZXItMC42LmpzXHJcbiAqIGNoZWNrIC9saWJzL2pzQmV6aWVyLmpzIGZvciBtb3JlIGZ1bmN0aW9ucyBpZiByZXF1aXJlZC5cclxuICpcclxuICpcclxuICovXHJcblxyXG5pZiAodHlwZW9mIE1hdGguc2duID09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIE1hdGguc2duID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4geCA9PSAwID8gMCA6IHggPiAwID8gMSA6IC0xO1xyXG4gICAgfTtcclxufVxyXG5cclxudmFyIFZlY3RvcnMgPSB7XHJcbiAgICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt4OiB2MS54IC0gdjIueCwgeTogdjEueSAtIHYyLnl9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZG90UHJvZHVjdDogZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgICAgICAgICByZXR1cm4gKHYxLnggKiB2Mi54KSArICh2MS55ICogdjIueSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcXVhcmU6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHYueCAqIHYueCkgKyAodi55ICogdi55KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKHYsIHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt4OiB2LnggKiBzLCB5OiB2LnkgKiBzfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1heFJlY3Vyc2lvbiA9IDY0LFxyXG4gICAgZmxhdG5lc3NUb2xlcmFuY2UgPSBNYXRoLnBvdygyLjAsIC1tYXhSZWN1cnNpb24gLSAxKTtcclxuXHJcbi8qKlxyXG4gKiBmaW5kcyB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgY3VydmUgdG8gdGhlIGdpdmVuIHBvaW50LlxyXG4gKi9cclxudmFyIF9uZWFyZXN0UG9pbnRPbkN1cnZlID0gZnVuY3Rpb24gKHBvaW50LCBjdXJ2ZSkge1xyXG4gICAgdmFyIHRkID0gX2Rpc3RhbmNlRnJvbUN1cnZlKHBvaW50LCBjdXJ2ZSk7XHJcbiAgICByZXR1cm4ge3BvaW50OiBfYmV6aWVyKGN1cnZlLCBjdXJ2ZS5sZW5ndGggLSAxLCB0ZC5sb2NhdGlvbiwgbnVsbCwgbnVsbCksIGxvY2F0aW9uOiB0ZC5sb2NhdGlvbn07XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgdGhhdCB0aGUgcG9pbnQgbGllcyBmcm9tIHRoZSBjdXJ2ZS5cclxuICpcclxuICogQHBhcmFtIHBvaW50IGEgcG9pbnQgaW4gdGhlIGZvcm0ge3g6NTY3LCB5OjMzNDJ9XHJcbiAqIEBwYXJhbSBjdXJ2ZSBhIEJlemllciBjdXJ2ZSBpbiB0aGUgZm9ybSBbe3g6Li4uLCB5Oi4uLn0sIHt4Oi4uLiwgeTouLi59LCB7eDouLi4sIHk6Li4ufSwge3g6Li4uLCB5Oi4uLn1dLiAgbm90ZSB0aGF0IHRoaXMgaXMgY3VycmVudGx5XHJcbiAqIGhhcmRjb2RlZCB0byBhc3N1bWUgY3ViaXogYmV6aWVycywgYnV0IHdvdWxkIGJlIGJldHRlciBvZmYgc3VwcG9ydGluZyBhbnkgZGVncmVlLlxyXG4gKiBAcmV0dXJuIGEgSlMgb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyBsb2NhdGlvbiBhbmQgZGlzdGFuY2UsIGZvciBleGFtcGxlOiB7bG9jYXRpb246MC4zNSwgZGlzdGFuY2U6MTB9LiAgTG9jYXRpb24gaXMgYW5hbG9nb3VzIHRvIHRoZSBsb2NhdGlvblxyXG4gKiBhcmd1bWVudCB5b3UgcGFzcyB0byB0aGUgcG9pbnRPblBhdGggZnVuY3Rpb246IGl0IGlzIGEgcmF0aW8gb2YgZGlzdGFuY2UgdHJhdmVsbGVkIGFsb25nIHRoZSBjdXJ2ZS4gIERpc3RhbmNlIGlzIHRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgZnJvbVxyXG4gKiB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLlxyXG4gKi9cclxudmFyIF9kaXN0YW5jZUZyb21DdXJ2ZSA9IGZ1bmN0aW9uIChwb2ludCwgY3VydmUpIHtcclxuICAgIHZhciBjYW5kaWRhdGVzID0gW10sXHJcbiAgICAgICAgdyA9IF9jb252ZXJ0VG9CZXppZXIocG9pbnQsIGN1cnZlKSxcclxuICAgICAgICBkZWdyZWUgPSBjdXJ2ZS5sZW5ndGggLSAxLCBoaWdoZXJEZWdyZWUgPSAoMiAqIGRlZ3JlZSkgLSAxLFxyXG4gICAgICAgIG51bVNvbHV0aW9ucyA9IF9maW5kUm9vdHModywgaGlnaGVyRGVncmVlLCBjYW5kaWRhdGVzLCAwKSxcclxuICAgICAgICB2ID0gVmVjdG9ycy5zdWJ0cmFjdChwb2ludCwgY3VydmVbMF0pLCBkaXN0ID0gVmVjdG9ycy5zcXVhcmUodiksIHQgPSAwLjA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Tb2x1dGlvbnM7IGkrKykge1xyXG4gICAgICAgIHYgPSBWZWN0b3JzLnN1YnRyYWN0KHBvaW50LCBfYmV6aWVyKGN1cnZlLCBkZWdyZWUsIGNhbmRpZGF0ZXNbaV0sIG51bGwsIG51bGwpKTtcclxuICAgICAgICB2YXIgbmV3RGlzdCA9IFZlY3RvcnMuc3F1YXJlKHYpO1xyXG4gICAgICAgIGlmIChuZXdEaXN0IDwgZGlzdCkge1xyXG4gICAgICAgICAgICBkaXN0ID0gbmV3RGlzdDtcclxuICAgICAgICAgICAgdCA9IGNhbmRpZGF0ZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdiA9IFZlY3RvcnMuc3VidHJhY3QocG9pbnQsIGN1cnZlW2RlZ3JlZV0pO1xyXG4gICAgbmV3RGlzdCA9IFZlY3RvcnMuc3F1YXJlKHYpO1xyXG4gICAgaWYgKG5ld0Rpc3QgPCBkaXN0KSB7XHJcbiAgICAgICAgZGlzdCA9IG5ld0Rpc3Q7XHJcbiAgICAgICAgdCA9IDEuMDtcclxuICAgIH1cclxuICAgIHJldHVybiB7bG9jYXRpb246IHQsIGRpc3RhbmNlOiBkaXN0fTtcclxufTtcclxuXHJcbnZhciBfY29udmVydFRvQmV6aWVyID0gZnVuY3Rpb24gKHBvaW50LCBjdXJ2ZSkge1xyXG4gICAgdmFyIGRlZ3JlZSA9IGN1cnZlLmxlbmd0aCAtIDEsIGhpZ2hlckRlZ3JlZSA9ICgyICogZGVncmVlKSAtIDEsXHJcbiAgICAgICAgYyA9IFtdLCBkID0gW10sIGNkVGFibGUgPSBbXSwgdyA9IFtdLFxyXG4gICAgICAgIHogPSBbWzEuMCwgMC42LCAwLjMsIDAuMV0sIFswLjQsIDAuNiwgMC42LCAwLjRdLCBbMC4xLCAwLjMsIDAuNiwgMS4wXV07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGVncmVlOyBpKyspIGNbaV0gPSBWZWN0b3JzLnN1YnRyYWN0KGN1cnZlW2ldLCBwb2ludCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkZWdyZWUgLSAxOyBpKyspIHtcclxuICAgICAgICBkW2ldID0gVmVjdG9ycy5zdWJ0cmFjdChjdXJ2ZVtpICsgMV0sIGN1cnZlW2ldKTtcclxuICAgICAgICBkW2ldID0gVmVjdG9ycy5zY2FsZShkW2ldLCAzLjApO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDw9IGRlZ3JlZSAtIDE7IHJvdysrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDw9IGRlZ3JlZTsgY29sdW1uKyspIHtcclxuICAgICAgICAgICAgaWYgKCFjZFRhYmxlW3Jvd10pIGNkVGFibGVbcm93XSA9IFtdO1xyXG4gICAgICAgICAgICBjZFRhYmxlW3Jvd11bY29sdW1uXSA9IFZlY3RvcnMuZG90UHJvZHVjdChkW3Jvd10sIGNbY29sdW1uXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8PSBoaWdoZXJEZWdyZWU7IGkrKykge1xyXG4gICAgICAgIGlmICghd1tpXSkgd1tpXSA9IFtdO1xyXG4gICAgICAgIHdbaV0ueSA9IDAuMDtcclxuICAgICAgICB3W2ldLnggPSBwYXJzZUZsb2F0KGkpIC8gaGlnaGVyRGVncmVlO1xyXG4gICAgfVxyXG4gICAgdmFyIG4gPSBkZWdyZWUsIG0gPSBkZWdyZWUgLSAxO1xyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPD0gbiArIG07IGsrKykge1xyXG4gICAgICAgIHZhciBsYiA9IE1hdGgubWF4KDAsIGsgLSBtKSxcclxuICAgICAgICAgICAgdWIgPSBNYXRoLm1pbihrLCBuKTtcclxuICAgICAgICBmb3IgKGkgPSBsYjsgaSA8PSB1YjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGogPSBrIC0gaTtcclxuICAgICAgICAgICAgd1tpICsgal0ueSArPSBjZFRhYmxlW2pdW2ldICogeltqXVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdztcclxufTtcclxuLyoqXHJcbiAqIGNvdW50cyBob3cgbWFueSByb290cyB0aGVyZSBhcmUuXHJcbiAqL1xyXG52YXIgX2ZpbmRSb290cyA9IGZ1bmN0aW9uICh3LCBkZWdyZWUsIHQsIGRlcHRoKSB7XHJcbiAgICB2YXIgbGVmdCA9IFtdLCByaWdodCA9IFtdLFxyXG4gICAgICAgIGxlZnRfY291bnQsIHJpZ2h0X2NvdW50LFxyXG4gICAgICAgIGxlZnRfdCA9IFtdLCByaWdodF90ID0gW107XHJcblxyXG4gICAgc3dpdGNoIChfZ2V0Q3Jvc3NpbmdDb3VudCh3LCBkZWdyZWUpKSB7XHJcbiAgICAgICAgY2FzZSAwIDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDEgOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRlcHRoID49IG1heFJlY3Vyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdFswXSA9ICh3WzBdLnggKyB3W2RlZ3JlZV0ueCkgLyAyLjA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX2lzRmxhdEVub3VnaCh3LCBkZWdyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0WzBdID0gX2NvbXB1dGVYSW50ZXJjZXB0KHcsIGRlZ3JlZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYmV6aWVyKHcsIGRlZ3JlZSwgMC41LCBsZWZ0LCByaWdodCk7XHJcbiAgICBsZWZ0X2NvdW50ID0gX2ZpbmRSb290cyhsZWZ0LCBkZWdyZWUsIGxlZnRfdCwgZGVwdGggKyAxKTtcclxuICAgIHJpZ2h0X2NvdW50ID0gX2ZpbmRSb290cyhyaWdodCwgZGVncmVlLCByaWdodF90LCBkZXB0aCArIDEpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0X2NvdW50OyBpKyspIHRbaV0gPSBsZWZ0X3RbaV07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpZ2h0X2NvdW50OyBpKyspIHRbaSArIGxlZnRfY291bnRdID0gcmlnaHRfdFtpXTtcclxuICAgIHJldHVybiAobGVmdF9jb3VudCArIHJpZ2h0X2NvdW50KTtcclxufTtcclxudmFyIF9nZXRDcm9zc2luZ0NvdW50ID0gZnVuY3Rpb24gKGN1cnZlLCBkZWdyZWUpIHtcclxuICAgIHZhciBuX2Nyb3NzaW5ncyA9IDAsIHNpZ24sIG9sZF9zaWduO1xyXG4gICAgc2lnbiA9IG9sZF9zaWduID0gTWF0aC5zZ24oY3VydmVbMF0ueSk7XHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xyXG4gICAgICAgIHNpZ24gPSBNYXRoLnNnbihjdXJ2ZVtpXS55KTtcclxuICAgICAgICBpZiAoc2lnbiAhPSBvbGRfc2lnbikgbl9jcm9zc2luZ3MrKztcclxuICAgICAgICBvbGRfc2lnbiA9IHNpZ247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbl9jcm9zc2luZ3M7XHJcbn07XHJcbnZhciBfaXNGbGF0RW5vdWdoID0gZnVuY3Rpb24gKGN1cnZlLCBkZWdyZWUpIHtcclxuICAgIHZhciBlcnJvcixcclxuICAgICAgICBpbnRlcmNlcHRfMSwgaW50ZXJjZXB0XzIsIGxlZnRfaW50ZXJjZXB0LCByaWdodF9pbnRlcmNlcHQsXHJcbiAgICAgICAgYSwgYiwgYywgZGV0LCBkSW52LCBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyO1xyXG4gICAgYSA9IGN1cnZlWzBdLnkgLSBjdXJ2ZVtkZWdyZWVdLnk7XHJcbiAgICBiID0gY3VydmVbZGVncmVlXS54IC0gY3VydmVbMF0ueDtcclxuICAgIGMgPSBjdXJ2ZVswXS54ICogY3VydmVbZGVncmVlXS55IC0gY3VydmVbZGVncmVlXS54ICogY3VydmVbMF0ueTtcclxuXHJcbiAgICB2YXIgbWF4X2Rpc3RhbmNlX2Fib3ZlID0gbWF4X2Rpc3RhbmNlX2JlbG93ID0gMC4wO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZGVncmVlOyBpKyspIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhICogY3VydmVbaV0ueCArIGIgKiBjdXJ2ZVtpXS55ICsgYztcclxuICAgICAgICBpZiAodmFsdWUgPiBtYXhfZGlzdGFuY2VfYWJvdmUpXHJcbiAgICAgICAgICAgIG1heF9kaXN0YW5jZV9hYm92ZSA9IHZhbHVlO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgbWF4X2Rpc3RhbmNlX2JlbG93KVxyXG4gICAgICAgICAgICBtYXhfZGlzdGFuY2VfYmVsb3cgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBhMSA9IDAuMDtcclxuICAgIGIxID0gMS4wO1xyXG4gICAgYzEgPSAwLjA7XHJcbiAgICBhMiA9IGE7XHJcbiAgICBiMiA9IGI7XHJcbiAgICBjMiA9IGMgLSBtYXhfZGlzdGFuY2VfYWJvdmU7XHJcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIgKiBiMTtcclxuICAgIGRJbnYgPSAxLjAgLyBkZXQ7XHJcbiAgICBpbnRlcmNlcHRfMSA9IChiMSAqIGMyIC0gYjIgKiBjMSkgKiBkSW52O1xyXG4gICAgYTIgPSBhO1xyXG4gICAgYjIgPSBiO1xyXG4gICAgYzIgPSBjIC0gbWF4X2Rpc3RhbmNlX2JlbG93O1xyXG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyICogYjE7XHJcbiAgICBkSW52ID0gMS4wIC8gZGV0O1xyXG4gICAgaW50ZXJjZXB0XzIgPSAoYjEgKiBjMiAtIGIyICogYzEpICogZEludjtcclxuICAgIGxlZnRfaW50ZXJjZXB0ID0gTWF0aC5taW4oaW50ZXJjZXB0XzEsIGludGVyY2VwdF8yKTtcclxuICAgIHJpZ2h0X2ludGVyY2VwdCA9IE1hdGgubWF4KGludGVyY2VwdF8xLCBpbnRlcmNlcHRfMik7XHJcbiAgICBlcnJvciA9IHJpZ2h0X2ludGVyY2VwdCAtIGxlZnRfaW50ZXJjZXB0O1xyXG4gICAgcmV0dXJuIChlcnJvciA8IGZsYXRuZXNzVG9sZXJhbmNlKSA/IDEgOiAwO1xyXG59O1xyXG52YXIgX2NvbXB1dGVYSW50ZXJjZXB0ID0gZnVuY3Rpb24gKGN1cnZlLCBkZWdyZWUpIHtcclxuICAgIHZhciBYTEsgPSAxLjAsIFlMSyA9IDAuMCxcclxuICAgICAgICBYTk0gPSBjdXJ2ZVtkZWdyZWVdLnggLSBjdXJ2ZVswXS54LCBZTk0gPSBjdXJ2ZVtkZWdyZWVdLnkgLSBjdXJ2ZVswXS55LFxyXG4gICAgICAgIFhNSyA9IGN1cnZlWzBdLnggLSAwLjAsIFlNSyA9IGN1cnZlWzBdLnkgLSAwLjAsXHJcbiAgICAgICAgZGV0ID0gWE5NICogWUxLIC0gWU5NICogWExLLCBkZXRJbnYgPSAxLjAgLyBkZXQsXHJcbiAgICAgICAgUyA9IChYTk0gKiBZTUsgLSBZTk0gKiBYTUspICogZGV0SW52O1xyXG4gICAgcmV0dXJuIDAuMCArIFhMSyAqIFM7XHJcbn07XHJcblxyXG52YXIgX2JlemllciA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGVncmVlLCB0LCBsZWZ0LCByaWdodCkge1xyXG4gICAgdmFyIHRlbXAgPSBbW11dO1xyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlOyBqKyspIHRlbXBbMF1bal0gPSBjdXJ2ZVtqXTtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGRlZ3JlZTsgaSsrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGVtcFtpXSkgdGVtcFtpXSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoIXRlbXBbaV1bal0pIHRlbXBbaV1bal0gPSB7fTtcclxuICAgICAgICAgICAgdGVtcFtpXVtqXS54ID0gKDEuMCAtIHQpICogdGVtcFtpIC0gMV1bal0ueCArIHQgKiB0ZW1wW2kgLSAxXVtqICsgMV0ueDtcclxuICAgICAgICAgICAgdGVtcFtpXVtqXS55ID0gKDEuMCAtIHQpICogdGVtcFtpIC0gMV1bal0ueSArIHQgKiB0ZW1wW2kgLSAxXVtqICsgMV0ueTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdCAhPSBudWxsKVxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPD0gZGVncmVlOyBqKyspIGxlZnRbal0gPSB0ZW1wW2pdWzBdO1xyXG4gICAgaWYgKHJpZ2h0ICE9IG51bGwpXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8PSBkZWdyZWU7IGorKykgcmlnaHRbal0gPSB0ZW1wW2RlZ3JlZSAtIGpdW2pdO1xyXG5cclxuICAgIHJldHVybiAodGVtcFtkZWdyZWVdWzBdKTtcclxufTtcclxuXHJcbnZhciBfY3VydmVGdW5jdGlvbkNhY2hlID0ge307XHJcbnZhciBfZ2V0Q3VydmVGdW5jdGlvbnMgPSBmdW5jdGlvbiAob3JkZXIpIHtcclxuICAgIHZhciBmbnMgPSBfY3VydmVGdW5jdGlvbkNhY2hlW29yZGVyXTtcclxuICAgIGlmICghZm5zKSB7XHJcbiAgICAgICAgZm5zID0gW107XHJcbiAgICAgICAgdmFyIGZfdGVybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyh0LCBvcmRlcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsX3Rlcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coKDEgLSB0KSwgb3JkZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY190ZXJtID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdF90ZXJtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbmVfbWludXNfdF90ZXJtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLSB0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX3Rlcm1GdW5jID0gZnVuY3Rpb24gKHRlcm1zKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykgcCA9IHAgKiB0ZXJtc1tpXSh0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIGZucy5wdXNoKG5ldyBmX3Rlcm0oKSk7ICAvLyBmaXJzdCBpcyB0IHRvIHRoZSBwb3dlciBvZiB0aGUgY3VydmUgb3JkZXJcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9yZGVyOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHRlcm1zID0gW25ldyBjX3Rlcm0ob3JkZXIpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAob3JkZXIgLSBpKTsgaisrKSB0ZXJtcy5wdXNoKG5ldyB0X3Rlcm0oKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB0ZXJtcy5wdXNoKG5ldyBvbmVfbWludXNfdF90ZXJtKCkpO1xyXG4gICAgICAgICAgICBmbnMucHVzaChuZXcgX3Rlcm1GdW5jKHRlcm1zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZucy5wdXNoKG5ldyBsX3Rlcm0oKSk7ICAvLyBsYXN0IGlzICgxLXQpIHRvIHRoZSBwb3dlciBvZiB0aGUgY3VydmUgb3JkZXJcclxuXHJcbiAgICAgICAgX2N1cnZlRnVuY3Rpb25DYWNoZVtvcmRlcl0gPSBmbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZucztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogY2FsY3VsYXRlcyBhIHBvaW50IG9uIHRoZSBjdXJ2ZSwgZm9yIGEgQmV6aWVyIG9mIGFyYml0cmFyeSBvcmRlci5cclxuICogQHBhcmFtIGN1cnZlIGFuIGFycmF5IG9mIGNvbnRyb2wgcG9pbnRzLCBlZyBbe3g6MTAseToyMH0sIHt4OjUwLHk6NTB9LCB7eDoxMDAseToxMDB9LCB7eDoxMjAseToxMDB9XS4gIEZvciBhIGN1YmljIGJlemllciB0aGlzIHNob3VsZCBoYXZlIGZvdXIgcG9pbnRzLlxyXG4gKiBAcGFyYW0gbG9jYXRpb24gYSBkZWNpbWFsIGluZGljYXRpbmcgdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSB0aGUgcG9pbnQgc2hvdWxkIGJlIGxvY2F0ZWQgYXQuICB0aGlzIGlzIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgYXMgaXQgdHJhdmVscywgdGFraW5nIHRoZSB3YXkgaXQgYmVuZHMgaW50byBhY2NvdW50LiAgc2hvdWxkIGJlIGEgbnVtYmVyIGZyb20gMCB0byAxLCBpbmNsdXNpdmUuXHJcbiAqL1xyXG52YXIgX3BvaW50T25QYXRoID0gZnVuY3Rpb24gKGN1cnZlLCBsb2NhdGlvbikge1xyXG4gICAgdmFyIGNjID0gX2dldEN1cnZlRnVuY3Rpb25zKGN1cnZlLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgIF94ID0gMCwgX3kgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIF94ID0gX3ggKyAoY3VydmVbaV0ueCAqIGNjW2ldKGxvY2F0aW9uKSk7XHJcbiAgICAgICAgX3kgPSBfeSArIChjdXJ2ZVtpXS55ICogY2NbaV0obG9jYXRpb24pKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge3g6IF94LCB5OiBfeX07XHJcbn07XHJcblxyXG52YXIgX2Rpc3QgPSBmdW5jdGlvbiAocDEsIHAyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XHJcbn07XHJcblxyXG52YXIgX2lzUG9pbnQgPSBmdW5jdGlvbiAoY3VydmUpIHtcclxuICAgIHJldHVybiBjdXJ2ZVswXS54ID09IGN1cnZlWzFdLnggJiYgY3VydmVbMF0ueSA9PSBjdXJ2ZVsxXS55O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGZpbmRzIHRoZSBwb2ludCB0aGF0IGlzICdkaXN0YW5jZScgYWxvbmcgdGhlIHBhdGggZnJvbSAnbG9jYXRpb24nLiAgdGhpcyBtZXRob2QgcmV0dXJucyBib3RoIHRoZSB4LHkgbG9jYXRpb24gb2YgdGhlIHBvaW50IGFuZCBhbHNvXHJcbiAqIGl0cyAnbG9jYXRpb24nIChwcm9wb3J0aW9uIG9mIHRyYXZlbCBhbG9uZyB0aGUgcGF0aCk7IHRoZSBtZXRob2QgYmVsb3cgLSBfcG9pbnRBbG9uZ1BhdGhGcm9tIC0gY2FsbHMgdGhpcyBtZXRob2QgYW5kIGp1c3QgcmV0dXJucyB0aGVcclxuICogcG9pbnQuXHJcbiAqL1xyXG52YXIgX3BvaW50QWxvbmdQYXRoID0gZnVuY3Rpb24gKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpIHtcclxuXHJcbiAgICBpZiAoX2lzUG9pbnQoY3VydmUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcG9pbnQ6IGN1cnZlWzBdLFxyXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2ID0gX3BvaW50T25QYXRoKGN1cnZlLCBsb2NhdGlvbiksXHJcbiAgICAgICAgdGFsbHkgPSAwLFxyXG4gICAgICAgIGN1ckxvYyA9IGxvY2F0aW9uLFxyXG4gICAgICAgIGRpcmVjdGlvbiA9IGRpc3RhbmNlID4gMCA/IDEgOiAtMSxcclxuICAgICAgICBjdXIgPSBudWxsO1xyXG5cclxuICAgIHdoaWxlICh0YWxseSA8IE1hdGguYWJzKGRpc3RhbmNlKSkge1xyXG4gICAgICAgIGN1ckxvYyArPSAoMC4wMDUgKiBkaXJlY3Rpb24pO1xyXG4gICAgICAgIGN1ciA9IF9wb2ludE9uUGF0aChjdXJ2ZSwgY3VyTG9jKTtcclxuICAgICAgICB0YWxseSArPSBfZGlzdChjdXIsIHByZXYpO1xyXG4gICAgICAgIHByZXYgPSBjdXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge3BvaW50OiBjdXIsIGxvY2F0aW9uOiBjdXJMb2N9O1xyXG59O1xyXG5cclxudmFyIF9sZW5ndGggPSBmdW5jdGlvbiAoY3VydmUpIHtcclxuICAgIGlmIChfaXNQb2ludChjdXJ2ZSkpIHJldHVybiAwO1xyXG5cclxuICAgIHZhciBwcmV2ID0gX3BvaW50T25QYXRoKGN1cnZlLCAwKSxcclxuICAgICAgICB0YWxseSA9IDAsXHJcbiAgICAgICAgY3VyTG9jID0gMCxcclxuICAgICAgICBkaXJlY3Rpb24gPSAxLFxyXG4gICAgICAgIGN1ciA9IG51bGw7XHJcblxyXG4gICAgd2hpbGUgKGN1ckxvYyA8IDEpIHtcclxuICAgICAgICBjdXJMb2MgKz0gKDAuMDA1ICogZGlyZWN0aW9uKTtcclxuICAgICAgICBjdXIgPSBfcG9pbnRPblBhdGgoY3VydmUsIGN1ckxvYyk7XHJcbiAgICAgICAgdGFsbHkgKz0gX2Rpc3QoY3VyLCBwcmV2KTtcclxuICAgICAgICBwcmV2ID0gY3VyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhbGx5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGZpbmRzIHRoZSBwb2ludCB0aGF0IGlzICdkaXN0YW5jZScgYWxvbmcgdGhlIHBhdGggZnJvbSAnbG9jYXRpb24nLlxyXG4gKi9cclxudmFyIF9wb2ludEFsb25nUGF0aEZyb20gPSBmdW5jdGlvbiAoY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSkge1xyXG4gICAgcmV0dXJuIF9wb2ludEFsb25nUGF0aChjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKS5wb2ludDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBmaW5kcyB0aGUgbG9jYXRpb24gdGhhdCBpcyAnZGlzdGFuY2UnIGFsb25nIHRoZSBwYXRoIGZyb20gJ2xvY2F0aW9uJy5cclxuICovXHJcbnZhciBfbG9jYXRpb25BbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24gKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpIHtcclxuICAgIHJldHVybiBfcG9pbnRBbG9uZ1BhdGgoY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSkubG9jYXRpb247XHJcbn07XHJcblxyXG4vKipcclxuICogcmV0dXJucyB0aGUgZ3JhZGllbnQgb2YgdGhlIGN1cnZlIGF0IHRoZSBnaXZlbiBsb2NhdGlvbiwgd2hpY2ggaXMgYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqIHRoYW5rcyAvLyBodHRwOi8vYmltaXh1YWwub3JnL0FuaW1hdGlvbkxpYnJhcnkvYmV6aWVydGFuZ2VudHMuaHRtbFxyXG4gKi9cclxudmFyIF9ncmFkaWVudEF0UG9pbnQgPSBmdW5jdGlvbiAoY3VydmUsIGxvY2F0aW9uKSB7XHJcbiAgICB2YXIgcDEgPSBfcG9pbnRPblBhdGgoY3VydmUsIGxvY2F0aW9uKSxcclxuICAgICAgICBwMiA9IF9wb2ludE9uUGF0aChjdXJ2ZS5zbGljZSgwLCBjdXJ2ZS5sZW5ndGggLSAxKSwgbG9jYXRpb24pLFxyXG4gICAgICAgIGR5ID0gcDIueSAtIHAxLnksIGR4ID0gcDIueCAtIHAxLng7XHJcbiAgICByZXR1cm4gZHkgPT0gMCA/IEluZmluaXR5IDogTWF0aC5hdGFuKGR5IC8gZHgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiByZXR1cm5zIHRoZSBncmFkaWVudCBvZiB0aGUgY3VydmUgYXQgdGhlIHBvaW50IHdoaWNoIGlzICdkaXN0YW5jZScgZnJvbSB0aGUgZ2l2ZW4gbG9jYXRpb24uXHJcbiBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgdGhhbiBsb2NhdGlvbiAxLCB0aGUgZ3JhZGllbnQgYXQgbG9jYXRpb24gMSBpcyByZXR1cm5lZC5cclxuIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIGxvY2F0aW9uIDAsIHRoZSBncmFkaWVudCBhdCBsb2NhdGlvbiAwIGlzIHJldHVybmVkLlxyXG4gKi9cclxudmFyIF9ncmFkaWVudEF0UG9pbnRBbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24gKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpIHtcclxuICAgIHZhciBwID0gX3BvaW50QWxvbmdQYXRoKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpO1xyXG4gICAgaWYgKHAubG9jYXRpb24gPiAxKSBwLmxvY2F0aW9uID0gMTtcclxuICAgIGlmIChwLmxvY2F0aW9uIDwgMCkgcC5sb2NhdGlvbiA9IDA7XHJcbiAgICByZXR1cm4gX2dyYWRpZW50QXRQb2ludChjdXJ2ZSwgcC5sb2NhdGlvbik7XHJcbn07XHJcblxyXG4vKipcclxuICogY2FsY3VsYXRlcyBhIGxpbmUgdGhhdCBpcyAnbGVuZ3RoJyBwaXhlbHMgbG9uZywgcGVycGVuZGljdWxhciB0bywgYW5kIGNlbnRlcmVkIG9uLCB0aGUgcGF0aCBhdCAnZGlzdGFuY2UnIHBpeGVscyBmcm9tIHRoZSBnaXZlbiBsb2NhdGlvbi5cclxuICogaWYgZGlzdGFuY2UgaXMgbm90IHN1cHBsaWVkLCB0aGUgcGVycGVuZGljdWxhciBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uIGlzIGNvbXB1dGVkIChpZS4gd2Ugc2V0IGRpc3RhbmNlIHRvIHplcm8pLlxyXG4gKi9cclxudmFyIF9wZXJwZW5kaWN1bGFyVG9QYXRoQXQgPSBmdW5jdGlvbiAoY3VydmUsIGxvY2F0aW9uLCBsZW5ndGgsIGRpc3RhbmNlKSB7XHJcbiAgICBkaXN0YW5jZSA9IGRpc3RhbmNlID09IG51bGwgPyAwIDogZGlzdGFuY2U7XHJcbiAgICB2YXIgcCA9IF9wb2ludEFsb25nUGF0aChjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKSxcclxuICAgICAgICBtID0gX2dyYWRpZW50QXRQb2ludChjdXJ2ZSwgcC5sb2NhdGlvbiksXHJcbiAgICAgICAgX3RoZXRhMiA9IE1hdGguYXRhbigtMSAvIG0pLFxyXG4gICAgICAgIHkgPSBsZW5ndGggLyAyICogTWF0aC5zaW4oX3RoZXRhMiksXHJcbiAgICAgICAgeCA9IGxlbmd0aCAvIDIgKiBNYXRoLmNvcyhfdGhldGEyKTtcclxuICAgIHJldHVybiBbe3g6IHAucG9pbnQueCArIHgsIHk6IHAucG9pbnQueSArIHl9LCB7eDogcC5wb2ludC54IC0geCwgeTogcC5wb2ludC55IC0geX1dO1xyXG59O1xyXG5cclxudmFyIF9jYWxjdWxhdGVTbW9vdGhDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oSykge1xyXG4gICAgdmFyIHJlc3VsdFAxID0gW107XHJcbiAgICB2YXIgcmVzdWx0UDIgPSBbXTtcclxuICAgIHZhciBuID0gSy5sZW5ndGgtMTtcclxuXHJcbiAgICAvKnJocyB2ZWN0b3IgaW5pdCBsZWZ0IG1vc3Qgc2VnbWVudCovXHJcbiAgICB2YXIgYSA9IFswXTtcclxuICAgIHZhciBiID0gWzJdO1xyXG4gICAgdmFyIGMgPSBbMV07XHJcbiAgICB2YXIgciA9IFtLWzBdICsgMiAqIEtbMV1dO1xyXG5cclxuICAgIC8qaW50ZXJuYWwgc2VnbWVudHMqL1xyXG4gICAgZm9yKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgIGFbaV0gPSAxO1xyXG4gICAgICAgIGJbaV0gPSA0O1xyXG4gICAgICAgIGNbaV0gPSAxO1xyXG4gICAgICAgIHJbaV0gPSA0ICogS1tpXSArIDIgKiBLW2krMV07XHJcbiAgICB9XHJcblxyXG4gICAgLypyaWdodCBzZWdtZW50Ki9cclxuICAgIGFbbi0xXSA9IDI7XHJcbiAgICBiW24tMV0gPSA3O1xyXG4gICAgY1tuLTFdID0gMDtcclxuICAgIHJbbi0xXSA9IDggKiBLW24tMV0gKyBLW25dO1xyXG5cclxuICAgIC8qc29sdmVzIEF4PWIgd2l0aCB0aGUgVGhvbWFzIGFsZ29yaXRobSovXHJcbiAgICBmb3IoaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBtID0gYVtpXSAvIGJbaS0xXTtcclxuICAgICAgICBiW2ldID0gYltpXSAtIG0gKiBjW2kgLSAxXTtcclxuICAgICAgICByW2ldID0gcltpXSAtIG0gKiByW2ktMV07XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdWx0UDFbbi0xXSA9IHJbbi0xXSAvIGJbbi0xXTtcclxuICAgIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIHJlc3VsdFAxW2ldID0gKHJbaV0gLSBjW2ldICogcmVzdWx0UDFbaSArIDFdKSAvIGJbaV07XHJcbiAgICB9XHJcblxyXG4gICAgLyp3ZSBoYXZlIHAxLCBub3cgY29tcHV0ZSBwMiovXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdFAyW2ldID0gMiAqIEtbaSArIDFdIC0gcmVzdWx0UDFbaSArIDFdO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdFAyW24tMV0gPSAwLjUgKiAoS1tuXSArIHJlc3VsdFAxW24tMV0pO1xyXG5cclxuICAgIHJldHVybiB7cDE6cmVzdWx0UDEsIHAyOnJlc3VsdFAyfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNb3ZlcyBhIHBvaW50IGFsb25nIHRoZSBnaXZlbiBjdXJ2ZVxyXG4gKiBAcGFyYW0gY3VydmVcclxuICogQHBhcmFtIGRpc3RhbmNlXHJcbiAqIEByZXR1cm5zIHsqfHt4LCB5fX1cclxuICovXHJcbnZhciBtb3ZlQWxvbmcgPSBmdW5jdGlvbihjdXJ2ZSwgZGlzdGFuY2UpIHtcclxuICAgIC8vIFNvbWVob3cgdGhlIHBvaW50QWxvbmdQYXRoIGNhbGN1bGF0ZXMgaW4gdGhlIHdyb25nIGRpcmVjdGlvbiBzbyB3ZSBzd2l0Y2ggdGhlIGJhaGF2aW91ciBieSBzZXR0aW5nXHJcbiAgICAvLyB0aGUgbG9jYXRpb24gdG8gMSAoZW5kKSBmb3IgcG9zaXRpdmUgZGlzdGFuY2VzLlxyXG4gICAgLy8gYW5kIG5lZ290aWF0ZSB0aGUgZGlzdGFuY2UgdmFsdWUuXHJcbiAgICB2YXIgbG9jYXRpb24gPSBkaXN0YW5jZSA+IDAgPyAxIDogMDtcclxuICAgIHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlICogLTE7XHJcbiAgICByZXR1cm4gX3BvaW50QWxvbmdQYXRoKGN1cnZlLGxvY2F0aW9uLCBkaXN0YW5jZSkucG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIG5lYXJlc3RQb2ludE9uQ3VydmUgOiBfbmVhcmVzdFBvaW50T25DdXJ2ZSxcclxuICAgIGNhbGN1bGF0ZVNtb290aENvbnRyb2xQb2ludHMgOiBfY2FsY3VsYXRlU21vb3RoQ29udHJvbFBvaW50cyxcclxuICAgIG1vdmVBbG9uZyA6IG1vdmVBbG9uZyxcclxuICAgIGxlbmd0aCA6IF9sZW5ndGhcclxufVxyXG5cclxuIiwidmFyIG9iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0Jyk7XHJcbnZhciBiZXppZXIgPSByZXF1aXJlKCcuL2JlemllcicpO1xyXG5cclxudmFyIGNhbGNMaW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24ocGExLCBwYTIsIHBiMSwgcGIyKSB7XHJcbiAgICByZXR1cm4gbmV3IExpbmUocGExLHBhMikuY2FsY0xpbmVJbnRlcmNlcHQobmV3IExpbmUocGIxLHBiMikpO1xyXG59O1xyXG5cclxudmFyIFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIHAgPSBnZXRQb2ludCh4LHkpO1xyXG4gICAgdGhpcy54ID0gcC54O1xyXG4gICAgdGhpcy55ID0gcC55O1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLmlzV2l0aGluSW50ZXJ2YWwgPSBmdW5jdGlvbihzdGFydCwgZW5kLCB0b2xlcmFuY2UpIHtcclxuICAgIHJldHVybiBpc1BvaW50SW5JbnRlcnZhbCh0aGlzLCBzdGFydCwgZW5kLCB0b2xlcmFuY2UpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLmlzV2l0aGluWEludGVydmFsID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgdG9sZXJhbmNlKSB7XHJcbiAgICByZXR1cm4gX2luSW50ZXJ2YWwodGhpcywgc3RhcnQsIGVuZCwgdG9sZXJhbmNlLCAneCcpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLmlzV2l0aGluWUludGVydmFsID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgdG9sZXJhbmNlKSB7XHJcbiAgICByZXR1cm4gX2luSW50ZXJ2YWwodGhpcywgc3RhcnQsIGVuZCwgdG9sZXJhbmNlLCAneScpO1xyXG59OztcclxuXHJcbnZhciBpc1BvaW50SW5JbnRlcnZhbCA9IGZ1bmN0aW9uKHBvaW50LCBzdGFydCwgZW5kLCB0b2xlcmFuY2UpIHtcclxuICAgIHJldHVybiBfaW5JbnRlcnZhbChwb2ludCwgc3RhcnQsIGVuZCwgdG9sZXJhbmNlLCAneCcpICYmIF9pc1BvaW50SW5JbnRlcnZhbChwb2ludCwgc3RhcnQsIGVuZCwgdG9sZXJhbmNlLCAneScpO1xyXG59O1xyXG5cclxudmFyIF9pbkludGVydmFsID0gZnVuY3Rpb24ocCwgc3RhcnQsIGVuZCwgdG9sZXJhbmNlLCBkaW1lbnNpb24pIHtcclxuICAgIHRvbGVyYW5jZSA9IHRvbGVyYW5jZSB8fCAwO1xyXG4gICAgdmFyIGJvdW5kYXJ5ID0gbWluTWF4KHN0YXJ0W2RpbWVuc2lvbl0sIGVuZFtkaW1lbnNpb25dKTtcclxuICAgIGJvdW5kYXJ5Lm1pbiAtPSB0b2xlcmFuY2U7XHJcbiAgICBib3VuZGFyeS5tYXggKz0gdG9sZXJhbmNlO1xyXG4gICAgcmV0dXJuIChwW2RpbWVuc2lvbl0gPD0gYm91bmRhcnkubWF4ICYmIHBbZGltZW5zaW9uXSA+PSBib3VuZGFyeS5taW4pO1xyXG59O1xyXG5cclxudmFyIG1pbk1heCA9IGZ1bmN0aW9uKHZhbDEsIHZhbDIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWluIDogIE1hdGgubWluKHZhbDEsIHZhbDIpLFxyXG4gICAgICAgIG1heCA6IE1hdGgubWF4KHZhbDEsIHZhbDIpXHJcbiAgICB9O1xyXG59O1xyXG5cclxudmFyIExpbmUgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuICAgIC8veSA9IG14ICsgdFxyXG4gICAgaWYocDEueCkge1xyXG4gICAgICAgIHRoaXMub3AxID0gcDE7XHJcbiAgICAgICAgdGhpcy5vcDIgPSBwMjtcclxuICAgICAgICB0aGlzLnAxID0gKHAxLnggPD0gcDIueCk/IHAxIDogcDI7XHJcbiAgICAgICAgdGhpcy5wMiA9IChwMS54ID4gcDIueCk/IHAxIDogcDI7XHJcbiAgICAgICAgdGhpcy5tID0gdGhpcy5jYWxjR3JhZGllbnQoKTtcclxuICAgICAgICB0aGlzLnQgPSB0aGlzLmNhbGNZSW50ZXJjZXB0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubSA9IHAxO1xyXG4gICAgICAgIHRoaXMudCA9IHAyO1xyXG4gICAgfVxyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuY2FsY1lJbnRlcmNlcHQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIHkgPSBtICogeCArIHQgPT4gdCA9IC1teCArIHlcclxuICAgIHJldHVybiAoLTEgKiB0aGlzLm0gKiB0aGlzLnAxLngpICsgdGhpcy5wMS55O1xyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuZ2V0T3J0aG9nb25hbCA9IGZ1bmN0aW9uKHApIHtcclxuICAgIC8vXHJcbiAgICB2YXIgbmV3TSA9IC0xIC8gdGhpcy5tO1xyXG4gICAgdmFyIHQgPSBwLnkgLSAobmV3TSAqIHAueCk7XHJcbiAgICByZXR1cm4gbmV3IExpbmUobmV3TSx0KTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNhbGNHcmFkaWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIExpbmUuY2FsY0dyYWRpZW50KHRoaXMucDEsIHRoaXMucDIpO1xyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuY2FsY05vcm1hbGl6ZWRMaW5lVmVjdG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gTGluZS5jYWxjTm9ybWFsaXplZExpbmVWZWN0b3IodGhpcy5wMSwgdGhpcy5wMik7XHJcbn07XHJcblxyXG5MaW5lLnByb3RvdHlwZS5pc0x0UiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3AxLnggPCB0aGlzLm9wMi54O1xyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuaXNUdEIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm9wMS55IDwgdGhpcy5vcDIueTtcclxufTtcclxuXHJcblxyXG5MaW5lLmNhbGNOb3JtYWxpemVkTGluZVZlY3RvciA9IGZ1bmN0aW9uKHAxLCBwMikge1xyXG4gICAgdmFyIHZlY3RvciA9IHtcclxuICAgICAgICB4IDogcDIueCAtIHAxLngsXHJcbiAgICAgICAgeSA6IHAyLnkgLSBwMS55XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodmVjdG9yLngqdmVjdG9yLnggKyB2ZWN0b3IueSp2ZWN0b3IueSk7XHJcblxyXG4gICAgdmVjdG9yLnggPSB2ZWN0b3IueCAvIGxlbmd0aDtcclxuICAgIHZlY3Rvci55ID0gdmVjdG9yLnkgLyBsZW5ndGg7XHJcbiAgICByZXR1cm4gdmVjdG9yO1xyXG59O1xyXG5cclxuLypcclxuICogIFRPRE86IHRoaXMgaXMgd29ya2luZyBpZiB5b3UgcHJvdmlkZSBzdGFydC9lbmQgYW5kIGRpc3RhbmNlIChuZWdhdGl2ZSBvciBwb3NpdGl2ZSkgYnV0IG5vdCB0ZXN0ZWQgKGFuZCBwcmVzdW1hYmx5IG5vdCB3b3JraW5nKVxyXG4gKiAgd2hlbiBnaXZlbiBzdGFydC9lbmQgZGlzdCBhbmQgZGlyZWN0aW9uIGUuZyBtb3ZlIGZyb20gc3RhcnQgcG9pbnQgLTMwIGJhY2suXHJcbiAqL1xyXG5MaW5lLm1vdmVBbG9uZyA9IGZ1bmN0aW9uKHAxLHAyLCBkaXN0LCBkaXJlY3Rpb24pIHtcclxuICAgIHZhciB2ZWN0b3IgPSBMaW5lLmNhbGNOb3JtYWxpemVkTGluZVZlY3RvcihwMSxwMik7XHJcblxyXG4gICAgLy9JZiB0aGVyZSBpcyBubyBkaXJlY3Rpb24gZ2l2ZW4gd2UgaGFuZGxlIG5lZ2F0aXZlIGRpc3RhbmNlcyBhcyBkaXJlY3Rpb24gLTEgKGZyb20gZW5kIHRvIHN0YXJ0KVxyXG4gICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IChkaXN0IDwgMCkgPyAtMSA6IDE7XHJcblxyXG4gICAgaWYoZGlyZWN0aW9uIDwgMSkge1xyXG4gICAgICAgIGRpc3QgPSBMaW5lLmNhbGNEaXN0YW5jZShwMSxwMikgKyBkaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IHAxLnggKyB2ZWN0b3IueCAqIGRpc3QsXHJcbiAgICAgICAgeSA6IHAxLnkgKyB2ZWN0b3IueSAqIGRpc3RcclxuICAgIH07XHJcbn07XHJcblxyXG5MaW5lLnByb3RvdHlwZS5tb3ZlQWxvbmcgPSBmdW5jdGlvbihkaXN0LCBkaXJlY3Rpb24pIHtcclxuICAgIC8vVE9ETzogbm90ZSB0aGlzIGlzIGp1c3Qgd29ya2luZyBpZiB3ZSBhcmUgaW5pdGlhdGluZyB0aGUgbGluZSB3aXRoIHR3byBwb2ludHMuLi5cclxuICAgIHJldHVybiBMaW5lLm1vdmVBbG9uZyh0aGlzLnAxLCB0aGlzLnAyLCBkaXN0LCBkaXJlY3Rpb24pO1xyXG59O1xyXG5cclxuTGluZS5jYWxjR3JhZGllbnQgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuICAgIHJldHVybiAocDIueSAtIHAxLnkpIC8gKHAyLnggLSBwMS54KTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNhbGNGWCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHZhciB5ID0gKHRoaXMubSkgKiB4ICsgdGhpcy50O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4IDogeCxcclxuICAgICAgICB5IDogeVxyXG4gICAgfTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNhbGNNaWRQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIExpbmUuY2FsY01pZFBvaW50KHRoaXMucDEsIHRoaXMucDIpO1xyXG59O1xyXG5cclxuTGluZS5jYWxjTWlkUG9pbnQgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IChwMS54K3AyLngpIC8gMixcclxuICAgICAgICB5IDogKHAxLnkrcDIueSkgLyAyXHJcbiAgICB9O1xyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuaXNWZXJ0aWNhbCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiAhaXNGaW5pdGUodGhpcy5tKTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmlzSG9yaXpvbnRhbCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiB0aGlzLm0gPT09IDA7XHJcbn07XHJcblxyXG5MaW5lLnByb3RvdHlwZS5jYWxjTGluZUludGVyY2VwdCA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAvL214KDEpICsgdCgxKSA9IG14KDIpICt0KDIpXHJcbiAgICB2YXIgbSA9IG90aGVyLm0gKyAoLTEgKiB0aGlzLm0pO1xyXG4gICAgdmFyIHQgPSB0aGlzLnQgKyAoLTEgKiBvdGhlci50KTtcclxuICAgIHZhciB4ID0gKG0gIT09IDApID8gdCAvIG0gOiB0O1xyXG4gICAgcmV0dXJuIHRoaXMuY2FsY0ZYKHgpO1xyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuZ2V0TmVhcmVzdFBvaW50ID0gZnVuY3Rpb24ocCkge1xyXG4gICAgcmV0dXJuIExpbmUuZ2V0TmVhcmVzdFBvaW50KHRoaXMucDEsIHRoaXMucDIsIHApO1xyXG59O1xyXG5cclxuTGluZS5nZXROZWFyZXN0UG9pbnQgPSBmdW5jdGlvbihhLCBiLCBwKSB7XHJcbiAgICB2YXIgQVAgPSBbcC54IC0gYS54LCBwLnkgLSBhLnldOyAvLyB2ZWN0b3IgQS0+UFxyXG4gICAgdmFyIEFCID0gW2IueCAtIGEueCwgYi55IC0gYS55XTsgLy8gdmVjdG9yIEEtPkJcclxuICAgIHZhciBtYWduaXR1ZGUgPSBBQlswXSAqIEFCWzBdICsgQUJbMV0gKiBBQlsxXSAvL0FCLkxlbmd0aFNxdWFyZWRcclxuXHJcbiAgICB2YXIgQVBfRE9UX0FCID0gQVBbMF0gKiBBQlswXSArIEFQWzFdICogQUJbMV07XHJcblxyXG4gICAgdmFyIGRpc3RhbmNlID0gQVBfRE9UX0FCIC8gbWFnbml0dWRlO1xyXG5cclxuICAgIGlmKGRpc3RhbmNlIDwgMCkge1xyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA+IDEpIHtcclxuICAgICAgICByZXR1cm4gYjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogYS54ICsgQUJbMF0gKiBkaXN0YW5jZSxcclxuICAgICAgICAgICAgeTogYS55ICsgQUJbMV0gKiBkaXN0YW5jZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkxpbmUuY2FsY0Rpc3RhbmNlID0gZnVuY3Rpb24ocDEsIHAyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KChwMi55IC0gcDEueSksMikgKyBNYXRoLnBvdygocDIueCAtIHAxLngpLDIpKTtcclxufVxyXG5cclxudmFyIFNpbXBsZVZlY3RvciA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG59O1xyXG5cclxuU2ltcGxlVmVjdG9yLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbih0aGF0KSB7XHJcbiAgICByZXR1cm4gdGhpcy54KnRoYXQueCArIHRoaXMueSp0aGF0Lnk7XHJcbn07XHJcblxyXG5TaW1wbGVWZWN0b3IuZnJvbVBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMikge1xyXG4gICAgcmV0dXJuIG5ldyBTaW1wbGVWZWN0b3IoXHJcbiAgICAgICAgcDIueCAtIHAxLngsXHJcbiAgICAgICAgcDIueSAtIHAxLnlcclxuICAgICk7XHJcbn07XHJcblxyXG5TaW1wbGVWZWN0b3IucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24odGhhdCkge1xyXG4gICAgcmV0dXJuIG5ldyBTaW1wbGVWZWN0b3IodGhpcy54IC0gdGhhdC54LCB0aGlzLnkgLSB0aGF0LnkpO1xyXG59O1xyXG5cclxudmFyIEVsbGlwc2UgPSBmdW5jdGlvbihjeCwgY3ksIHJ4LCByeSkge1xyXG4gICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuYyA9IHt4OmN4LHk6Y3l9O1xyXG4gICAgICAgICAgICB0aGlzLnJ4ID0gcng7XHJcbiAgICAgICAgICAgIHRoaXMucnkgPSByeTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICB0aGlzLmMgPSBjeDtcclxuICAgICAgICAgICAgdGhpcy5yeCA9IGN5O1xyXG4gICAgICAgICAgICB0aGlzLnJ5ID0gcng7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRWxsaXBzZS5wcm90b3R5cGUuY2FsY0xpbmVJbnRlcmNlcHQgPSBmdW5jdGlvbihwMSxwMikge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBwMiA9IHAxLnAyO1xyXG4gICAgICAgIHAxID0gcDEucDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9yaWdpbiA9IG5ldyBTaW1wbGVWZWN0b3IocDEueCwgcDEueSk7XHJcbiAgICB2YXIgZGlyID0gU2ltcGxlVmVjdG9yLmZyb21Qb2ludHMocDEsIHAyKTtcclxuICAgIHZhciBjZW50ZXIgPSBuZXcgU2ltcGxlVmVjdG9yKHRoaXMuYy54LCB0aGlzLmMueSk7XHJcbiAgICB2YXIgZGlmZiA9IG9yaWdpbi5zdWJ0cmFjdChjZW50ZXIpO1xyXG4gICAgdmFyIG1EaXIgPSBuZXcgU2ltcGxlVmVjdG9yKGRpci54Lyh0aGlzLnJ4KnRoaXMucngpLCAgZGlyLnkvKHRoaXMucnkqdGhpcy5yeSkpO1xyXG4gICAgdmFyIG1EaWZmID0gbmV3IFNpbXBsZVZlY3RvcihkaWZmLngvKHRoaXMucngqdGhpcy5yeCksIGRpZmYueS8odGhpcy5yeSp0aGlzLnJ5KSk7XHJcblxyXG4gICAgdmFyIGFEaWZmID0gZGlyLmRvdChtRGlyKTtcclxuICAgIHZhciBiRGlmZiA9IGRpci5kb3QobURpZmYpO1xyXG4gICAgdmFyIGNEaWZmID0gZGlmZi5kb3QobURpZmYpIC0gMS4wO1xyXG4gICAgdmFyIGREaWZmID0gYkRpZmYqYkRpZmYgLSBhRGlmZipjRGlmZjtcclxuXHJcbiAgICBpZiAoZERpZmYgPiAwKSB7XHJcbiAgICAgICAgdmFyIHJvb3QgPSBNYXRoLnNxcnQoZERpZmYpO1xyXG4gICAgICAgIHZhciB0QSAgPSAoLWJEaWZmIC0gcm9vdCkgLyBhRGlmZjtcclxuICAgICAgICB2YXIgdEIgID0gKC1iRGlmZiArIHJvb3QpIC8gYURpZmY7XHJcblxyXG4gICAgICAgIGlmICghKCh0QSA8IDAgfHwgMSA8IHRBKSAmJiAodEIgPCAwIHx8IDEgPCB0QikpKSB7XHJcbiAgICAgICAgICAgIGlmICgwIDw9IHRBICYmIHRBIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlcnAocDEsIHAyLCB0QSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggMCA8PSB0QiAmJiB0QiA8PSAxICkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVycChwMSwgcDIsIHRCKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciB0ID0gLWJEaWZmL2FEaWZmO1xyXG4gICAgICAgIGlmICgwIDw9IHQgJiYgdCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlcnAocDEuIGEyLCB0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5FbGxpcHNlLnByb3RvdHlwZS5vdmVybGF5cyA9IGZ1bmN0aW9uKHApIHtcclxuICAgIHZhciBieCA9IE1hdGgucG93KChwLnggLSB0aGlzLmMueCksIDIpIC8gTWF0aC5wb3codGhpcy5yeCwgMik7XHJcbiAgICB2YXIgYnkgPSBNYXRoLnBvdygocC55IC0gdGhpcy5jLnkpLCAyKSAvIE1hdGgucG93KHRoaXMucnksIDIpO1xyXG4gICAgcmV0dXJuIGJ4ICsgYnkgPD0gMVxyXG59O1xyXG5cclxudmFyIENpcmNsZSA9IGZ1bmN0aW9uKGN4LCBjeSwgcikge1xyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHRoaXMuYyA9IGN4O1xyXG4gICAgICAgIHRoaXMuciA9IGN5O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmMgPSB7eDogY3gsIHkgOiBjeX07XHJcbiAgICAgICAgdGhpcy5yID0gcjtcclxuICAgIH1cclxufTtcclxuXHJcbkNpcmNsZS5wcm90b3R5cGUub3ZlcmxheXMgPSBmdW5jdGlvbihwKSB7XHJcbiAgICB2YXIgYnggPSBNYXRoLnBvdygocC54IC0gdGhpcy5jLngpLCAyKTtcclxuICAgIHZhciBieSA9IE1hdGgucG93KChwLnkgLSB0aGlzLmMueSksIDIpO1xyXG4gICAgcmV0dXJuIGJ4ICsgYnkgPCBNYXRoLnBvdyh0aGlzLnIsIDIpO1xyXG59O1xyXG5cclxuQ2lyY2xlLnByb3RvdHlwZS5jYWxjTGluZUludGVyY2VwdCA9IGZ1bmN0aW9uKHAxLCBwMikge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBwMiA9IHAxLnAyO1xyXG4gICAgICAgIHAxID0gcDEucDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGEgPSAocDIueCAtIHAxLngpICogKHAyLnggLSBwMS54KVxyXG4gICAgICAgICsgKHAyLnkgLSBwMS55KSAqIChwMi55IC0gcDEueSk7XHJcbiAgICB2YXIgYiAgPSAyICogKChwMi54IC0gcDEueCkgKiAocDEueCAtIHRoaXMuYy54KVxyXG4gICAgICAgICsgKHAyLnkgLSBwMS55KSAqIChwMS55IC0gdGhpcy5jLnkpICAgKTtcclxuICAgIHZhciBjYyA9IHRoaXMuYy54KnRoaXMuYy54ICsgdGhpcy5jLnkqdGhpcy5jLnkgKyBwMS54KnAxLnggKyBwMS55KnAxLnkgLVxyXG4gICAgICAgIDIgKiAodGhpcy5jLnggKiBwMS54ICsgdGhpcy5jLnkgKiBwMS55KSAtIHRoaXMucip0aGlzLnI7XHJcbiAgICB2YXIgZGV0ZXIgPSBiKmIgLSA0KmEqY2M7XHJcblxyXG4gICAgaWYoZGV0ZXIgPiAwKSB7XHJcbiAgICAgICAgdmFyIHJvb3QgID0gTWF0aC5zcXJ0KGRldGVyKTtcclxuICAgICAgICB2YXIgdEEgPSAoLWIgKyByb290KSAvICgyKmEpO1xyXG4gICAgICAgIHZhciB0QiA9ICgtYiAtIHJvb3QpIC8gKDIqYSk7XHJcblxyXG4gICAgICAgIGlmICghKCh0QSA8IDAgfHwgdEEgPiAxKSAmJiAodEIgPCAwIHx8IHRCID4gMSkpKSB7XHJcbiAgICAgICAgICAgIGlmICgwIDw9IHRBICYmIHRBIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlcnAocDEsIHAyLCB0QSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoMCA8PSB0QiAmJiB0QiA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsZXJwKHAxLCBwMiwgdEIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgbGVycCA9IGZ1bmN0aW9uKGEsIGIsIHQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeCA6IGEueCArIChiLnggLSBhLngpICogdCxcclxuICAgICAgICB5IDogYS55ICsgKGIueSAtIGEueSkgKiB0XHJcbiAgICB9O1xyXG59O1xyXG5cclxudmFyIFZlY3RvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy52ZWN0b3JzID0gW107XHJcbiAgICB2YXIgY3VycmVudEFycjtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZihvYmplY3QuaXNBcnJheShhcmd1bWVudHNbaV0pKSB7XHJcbiAgICAgICAgICAgIGlmKGN1cnJlbnRBcnIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGN1cnJlbnRBcnIpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFyciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcnIgPSBjdXJyZW50QXJyIHx8IFtdO1xyXG4gICAgICAgICAgICBjdXJyZW50QXJyLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmKGN1cnJlbnRBcnIpIHtcclxuICAgICAgICB0aGlzLmFkZChjdXJyZW50QXJyKTtcclxuICAgICAgICBkZWxldGUgY3VycmVudEFycjtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgdmVjdG9yIHZhbHVlIGVpdGhlciBieSBwcm92aWRpbmcgc2VwZXJhdGVkIGFyZ3VtZW50cyBvciBhbiBhcnJheSBvZiB2YWx1ZXNcclxuICovXHJcblZlY3Rvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWU7XHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHZhbHVlID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcclxuICAgIH1cclxuICAgIHRoaXMudmVjdG9ycy5wdXNoKHZhbHVlKTtcclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBvYmplY3QuaXNBcnJheShhcmd1bWVudHNbMF0pID8gYXJndW1lbnRzWzBdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gZ2V0VmVjdG9yVmFsdWUodGhpcy52ZWN0b3JzLCBwYXRoKTtcclxuICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dldCB2YWx1ZSB2ZWN0b3IgZmFpbGVkIC0gJyt0aGlzLnZlY3RvcnMrJyBhcmdzOiAnK2FyZ3VtZW50cyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5WZWN0b3IucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnZlY3RvcnMgPSBbXTtcclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbihwYXRoQXJyLCB2YWx1ZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBwYXRoQXJyID0gIW9iamVjdC5pc0FycmF5KHBhdGhBcnIpID8gW3BhdGhBcnJdIDogcGF0aEFycjtcclxuICAgICAgICB2YXIgcGFyZW50UGF0aCA9IHBhdGhBcnIuc3BsaWNlKDAsIHBhdGhBcnIubGVuZ3RoIC0xKTtcclxuICAgICAgICB0aGlzLnZhbHVlKHBhcmVudFBhdGgpW3BhdGhBcnJbcGF0aEFyci5sZW5ndGggLTFdXSA9IHZhbHVlO1xyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignc2V0IHZhbHVlIHZlY3RvciBmYWlsZWQgLSAnK3RoaXMudmVjdG9ycysnIGFyZ3M6ICcrYXJndW1lbnRzKTtcclxuICAgIH1cclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24ocGF0aEFyciwgdmFsdWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcGF0aEFyciA9ICFvYmplY3QuaXNBcnJheShwYXRoQXJyKSA/IFtwYXRoQXJyXSA6IHBhdGhBcnI7XHJcbiAgICAgICAgdmFyIHBhcmVudFBhdGggPSBwYXRoQXJyLnNwbGljZSgwLCBwYXRoQXJyLmxlbmd0aCAtMSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZShwYXJlbnRQYXRoKS5zcGxpY2UocGF0aEFycltwYXRoQXJyLmxlbmd0aCAtMV0sIDAsIHZhbHVlKTtcclxuICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NldCB2YWx1ZSB2ZWN0b3IgZmFpbGVkIC0gJyt0aGlzLnZlY3RvcnMrJyBhcmdzOiAnK2FyZ3VtZW50cyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5WZWN0b3IucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmVjdG9ycy5sZW5ndGg7XHJcbn1cclxuXHJcblZlY3Rvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocGF0aEFycikge1xyXG4gICAgcGF0aEFyciA9ICFvYmplY3QuaXNBcnJheShwYXRoQXJyKSA/IFtwYXRoQXJyXSA6IHBhdGhBcnI7XHJcbiAgICB2YXIgcGFyZW50UGF0aCA9IHBhdGhBcnIuc3BsaWNlKDAsIHBhdGhBcnIubGVuZ3RoIC0xKTtcclxuICAgIHRoaXMudmFsdWUocGFyZW50UGF0aCkuc3BsaWNlKHBhdGhBcnJbcGF0aEFyci5sZW5ndGggLTFdLCAxKTtcclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmVjdG9yc1t0aGlzLnZlY3RvcnMubGVuZ3RoIC0xXTtcclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcclxuICAgIG9iamVjdC5lYWNoKHRoaXMudmVjdG9ycywgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgaGFuZGxlcihpbmRleCx2YWx1ZSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3RlIHRoZSBpbmRleGVzIGNhbiBiZSBuZWdhdGl2ZSB0byByZXRyaWV2ZSB2YWx1ZXMgZnJvbSB0aGUgZW5kIG9mIHRoZSB2ZWN0b3IgZS5nLiAtMSBpcyB0aGUgbGFzdFxyXG4gKiBAcGFyYW0gdmVjdG9yQXJyXHJcbiAqIEBwYXJhbSBhcmdzXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxudmFyIGdldFZlY3RvclZhbHVlID0gZnVuY3Rpb24odmVjdG9yQXJyLCBhcmdzKSB7XHJcbiAgICBpZighYXJncykge1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3JBcnI7XHJcbiAgICB9ZWxzZSBpZihvYmplY3QuaXNBcnJheShhcmdzKSkge1xyXG4gICAgICAgIHN3aXRjaChhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjdG9yQXJyO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LnZhbHVlQnlJbmRleCh2ZWN0b3JBcnIsIGFyZ3NbMF0pO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRWZWN0b3JWYWx1ZSh2ZWN0b3JBcnJbaW5kZXhdLCBhcmdzLnNwbGljZSgxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gb2JqZWN0LnZhbHVlQnlJbmRleCh2ZWN0b3JBcnIsIGFyZ3MpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHNvdXJjZSBhbmQgdGFyZ2V0IHZhbHVlIGlzIGxvd2VyIHRoYW4gdGhlIGdpdmVuIHJhbmdlIHZhbHVlXHJcbiAqL1xyXG52YXIgY2hlY2tSYW5nZURpZmYgPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCwgcmFuZ2UpIHtcclxuICAgIHJldHVybiBpc0luRGlmZlJhbmdlKHRhcmdldCwgc291cmNlLCByYW5nZSk7XHJcbn07XHJcblxyXG52YXIgaXNJbkRpZmZSYW5nZSA9IGZ1bmN0aW9uKHAxLCBwMiwgcmFuZ2UpIHtcclxuICAgIHJldHVybiBNYXRoLmFicyhwMSAtIHAyKSA8IHJhbmdlO1xyXG59O1xyXG5cclxudmFyIGdldFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGlmKHggJiYgb2JqZWN0LmlzRGVmaW5lZCh4LngpICYmIG9iamVjdC5pc0RlZmluZWQoeC55KSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHg7XHJcbiAgICB9IGVsc2UgaWYoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgeCA6IHgsXHJcbiAgICAgICAgICAgIHkgOiB5XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZihvYmplY3QuaXNEZWZpbmVkKHgpICYmIG9iamVjdC5pc0RlZmluZWQoeSkpIHtcclxuICAgICAgICByZXN1bHQgPSB0b1BvaW50KHgseSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIHRvUG9pbnQgPSBmdW5jdGlvbih4LHkpIHtcclxuICAgIHggPSAob2JqZWN0LmlzU3RyaW5nKHgpKSA/IHBhcnNlRmxvYXQoeCkgOiB4O1xyXG4gICAgeSA9IChvYmplY3QuaXNTdHJpbmcoeSkpID8gcGFyc2VGbG9hdCh5KSA6IHk7XHJcblxyXG4gICAgcmV0dXJuIHt4OngseTp5fTtcclxufTtcclxuXHJcbnZhciB0b1JhZGlhbnMgPSBmdW5jdGlvbiAoYW5nbGUpIHtcclxuICAgIHJldHVybiBhbmdsZSAqIChNYXRoLlBJIC8gMTgwKTtcclxufTtcclxuXHJcbnZhciB0b0RlZ3JlZXMgPSBmdW5jdGlvbihhbmdsZSkge1xyXG4gICAgcmV0dXJuIGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xyXG59O1xyXG5cclxudmFyIHJvdGF0ZSA9IGZ1bmN0aW9uKHAsIHJvdENlbnRlciwgYW5nbGUpIHtcclxuICAgIGlmKGFuZ2xlID09PSAwIHx8IChwLnggPT09IHJvdENlbnRlci54ICYmIHAueSA9PT0gcm90Q2VudGVyLnkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJvdGF0ZWQgPSB7fTtcclxuICAgIHZhciByYWQgPSB0b1JhZGlhbnMoYW5nbGUpO1xyXG4gICAgcm90YXRlZC54ID0gKHAueCAtIHJvdENlbnRlci54KSAqIE1hdGguY29zKHJhZCkgLSAocC55IC0gcm90Q2VudGVyLnkpICogTWF0aC5zaW4ocmFkKSArIHJvdENlbnRlci54O1xyXG4gICAgcm90YXRlZC55ID0gKHAueSAtIHJvdENlbnRlci55KSAqIE1hdGguY29zKHJhZCkgKyAocC54IC0gcm90Q2VudGVyLngpICogTWF0aC5zaW4ocmFkKSArIHJvdENlbnRlci55O1xyXG4gICAgcC54ID0gcm90YXRlZC54O1xyXG4gICAgcC55ID0gcm90YXRlZC55O1xyXG4gICAgcmV0dXJuIHA7XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBjYWxjTGluZUludGVyc2VjdGlvbiA6IGNhbGNMaW5lSW50ZXJzZWN0aW9uLFxyXG4gICAgTGluZSA6IExpbmUsXHJcbiAgICBDaXJjbGUgOiBDaXJjbGUsXHJcbiAgICBFbGxpcHNlIDogRWxsaXBzZSxcclxuICAgIFZlY3RvciA6IFZlY3RvcixcclxuICAgIFBvaW50IDogUG9pbnQsXHJcbiAgICBpc1BvaW50SW5JbnRlcnZhbCA6IGlzUG9pbnRJbkludGVydmFsLFxyXG4gICAgbWluTWF4IDogbWluTWF4LFxyXG4gICAgY2hlY2tSYW5nZURpZmYgOiBjaGVja1JhbmdlRGlmZixcclxuICAgIGdldFBvaW50IDogZ2V0UG9pbnQsXHJcbiAgICBiZXppZXIgOiBiZXppZXIsXHJcbiAgICB0b1JhZGlhbnMgOiB0b1JhZGlhbnMsXHJcbiAgICB0b0RlZ3JlZXMgOiB0b0RlZ3JlZXMsXHJcbiAgICByb3RhdGUgOiByb3RhdGVcclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGVhY2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAkLmVhY2goYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdyZXA6IGZ1bmN0aW9uKGFyciwgZmlsdGVyLCBpbnZlcnQpIHtcclxuICAgICAgICByZXR1cm4gJC5ncmVwKGFyciwgZmlsdGVyLCBpbnZlcnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc09uZU9mOiBmdW5jdGlvbihzZWFyY2gpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IoaSA9IDE7aSA8IGFyZ3VtZW50cy5sZW5ndGg7aSsrKSB7XHJcbiAgICAgICAgICBpZihzZWFyY2ggPT09IGFyZ3VtZW50c1tpXSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIHJldHVybiAkLmlzQXJyYXkob2JqKTtcclxuICAgIH0sXHJcblxyXG4gICAgdG9BcnJheSA6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIHJldHVybiAkLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3ZhbHVlXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlRnJvbUFycmF5OiBmdW5jdGlvbihhcnIsIGl0ZW0pIHtcclxuICAgICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcclxuICAgICAgICBpZihpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaXplOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IDAsIGtleTtcclxuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSBzaXplKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfSxcclxuXHJcbiAgICBzb3J0OiBmdW5jdGlvbihvYmosIHNvcnQpIHtcclxuICAgICAgICB2YXIgYXJyO1xyXG4gICAgICAgIGlmKCFvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICBhcnIgPSBvYmo7XHJcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgICAgICBhcnIgPSAkLm1hcChvYmosIGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW3ZhbF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5zb3J0KHNvcnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICB2YWx1ZUJ5SW5kZXg6IGZ1bmN0aW9uKGFyciwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KGFycixpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIGFycltpbmRleF07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEluZGV4OiBmdW5jdGlvbihhcnIsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGluZGV4O1xyXG4gICAgICAgIC8vIGZvciBuZWdhdGl2ZSBpbmRleGVzIHdlIHJldHVybiB2YWx1ZXMgY291bnRlZCBmcm9tIHRoZSBvdGhlciBzaWRlIHNvIC0xIGlzIHRoZSBsYXN0IGluZGV4XHJcbiAgICAgICAgLy8gaWYgdGhlIG5lZ2F0aXZlIGluZGV4IGlzIG91dCBvZiByYW5nZSB3ZSByZXR1cm4gdGhlIGxhc3QgaW5kZXguXHJcbiAgICAgICAgaWYoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyci5sZW5ndGggKyBpbmRleDtcclxuICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA+IGFyci5sZW5ndGggLTEgfHwgcmVzdWx0IDwgMCkgPyBhcnIubGVuZ3RoIC0xIDogcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gJC5pc1BsYWluT2JqZWN0KG9iaik7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzSlF1ZXJ5OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqLmpxdWVyeTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcclxuICAgIH0sXHJcblxyXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnYm9vbGVhbic7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZighdGhhdC5pc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJztcclxuICAgIH0sXHJcblxyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKHRhcmdldCwgdG9NZXJnZSkge1xyXG4gICAgICAgIHJldHVybiAkLm1lcmdlKHRhcmdldCwgdG9NZXJnZSk7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBhZGRWYWx1ZTogZnVuY3Rpb24odGFyZ2V0LCBuZXdWYWwpIHtcclxuICAgICAgICBpZihpc0FycmF5KG5ld1ZhbCkpIHtcclxuICAgICAgICAgICAgbWVyZ2UodGFyZ2V0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXQucHVzaChuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQsIG9iajEsIG9iajIpIHtcclxuICAgICAgICByZXR1cm4gJC5leHRlbmQodGFyZ2V0LG9iajEsb2JqMik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lQXJyYXk6IGZ1bmN0aW9uKGFycikge1xyXG4gICAgICAgIHJldHVybiBhcnIuc2xpY2UoMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lT2JqZWN0OiBmdW5jdGlvbihvbGRPYmplY3QsIGRlZXApIHtcclxuICAgICAgICBkZWVwID0gZGVlcCB8fCBmYWxzZTtcclxuICAgICAgICByZXR1cm4gJC5leHRlbmQoZGVlcCwge30sIG9sZE9iamVjdCk7XHJcbiAgICB9XHJcbiAgICBcclxufTsiLCJ2YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcclxuXHJcbmV4cG9ydHMuZW5kc1dpdGggPSBmdW5jdGlvbih2YWwsIHN1ZmZpeCkge1xyXG4gICAgaWYoIW9iamVjdC5pc0RlZmluZWQodmFsKSB8fCAhb2JqZWN0LmlzRGVmaW5lZChzdWZmaXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbC5pbmRleE9mKHN1ZmZpeCwgdmFsLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcclxufTtcclxuXHJcbmV4cG9ydHMuY3V0cHJlZml4ID0gZnVuY3Rpb24odmFsLCBwcmVmaXgpIHtcclxuICAgcmV0dXJuIHZhbC5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCwgdmFsLmxlbmd0aCk7XHJcbn07XHJcblxyXG5leHBvcnRzLmN1dHN1ZmZpeCA9IGZ1bmN0aW9uKHZhbCwgc3VmZml4KSB7XHJcbiAgICByZXR1cm4gdmFsLnNsaWNlKDAsIHN1ZmZpeC5sZW5ndGggKiAtMSk7XHJcbn07XHJcblxyXG5leHBvcnRzLnN0YXJ0c1dpdGggPSBmdW5jdGlvbih2YWwsIHByZWZpeCkge1xyXG4gICAgaWYoIW9iamVjdC5pc0RlZmluZWQodmFsKSB8fCAhb2JqZWN0LmlzRGVmaW5lZChwcmVmaXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbC5pbmRleE9mKHByZWZpeCkgPT09IDA7XHJcbn07IiwidmFyIHN0cmluZyA9IHJlcXVpcmUoJy4vc3RyaW5nJyk7XHJcblxyXG52YXIgc2VyaWFsaXplVG9TdHJpbmcgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICB2YXIgcyA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XHJcbiAgICBub2RlID0gKG5vZGUualF1ZXJ5KSA/IG5vZGVbMF0gOiBub2RlO1xyXG4gICAgcmV0dXJuIHMuc2VyaWFsaXplVG9TdHJpbmcobm9kZSk7XHJcbn07XHJcblxyXG52YXIgcGFyc2VYTUwgPSBmdW5jdGlvbihzdHJEYXRhKSB7XHJcbiAgICByZXR1cm4gJC5wYXJzZVhNTChzdHJEYXRhKTtcclxufTtcclxuXHJcbnZhciBmb3JtYXQgPSBmdW5jdGlvbiAoeG1sKSB7XHJcbiAgICB2YXIgaW50ZW5kID0gLTE7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB4bWwgPSB4bWwucmVwbGFjZSgvKFxcclxcbnxcXG58XFxyKS9nbSxcIlwiKTtcclxuICAgIHZhciBsYXN0V2FzQ2xvc2UgPSBmYWxzZTtcclxuICAgIHZhciBsYXN0SGFkVGV4dCA9IGZhbHNlO1xyXG4gICAgJC5lYWNoKHhtbC5zcGxpdCgnPCcpLCBmdW5jdGlvbihpbmRleCwgbm9kZSkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlLnRyaW0oKTtcclxuICAgICAgICBpZihub2RlKSB7XHJcbiAgICAgICAgICAgIGlmKG5vZGUuaW5kZXhPZignLycpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZighbGFzdFdhc0Nsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZW5kKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdEhhZFRleHQgPSAhc3RyaW5nLmVuZHNXaXRoKG5vZGUsICc+Jyk7XHJcbiAgICAgICAgICAgICAgICBsYXN0V2FzQ2xvc2UgPSBzdHJpbmcuZW5kc1dpdGgobm9kZSwgJy8+Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZighbGFzdEhhZFRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0V2FzQ2xvc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVuZC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdEhhZFRleHQgPSAhc3RyaW5nLmVuZHNXaXRoKG5vZGUsICc+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gJyc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmcgKz0gJyAgJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHRleHQ7XHJcbiAgICAgICAgICAgIGlmKGxhc3RIYWRUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXR0ZWQgPSBub2RlLnNwbGl0KCc+Jyk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gc3BsaXR0ZWRbMF0gKyAnPic7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gc3BsaXR0ZWRbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9IHBhZGRpbmcgKyAnPCcrbm9kZSsnXFxyXFxuJztcclxuXHJcbiAgICAgICAgICAgIGlmKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwYWRkaW5nICsgJyAgJyArIHRleHQrJ1xcclxcbic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzZXJpYWxpemVUb1N0cmluZyA6IHNlcmlhbGl6ZVRvU3RyaW5nLFxyXG4gICAgcGFyc2VYTUwgOiBwYXJzZVhNTCxcclxuICAgIGZvcm1hdDogZm9ybWF0XHJcbn07IiwidmFyIEVSUk9SX0NPREVTID0gcmVxdWlyZSgnLi9lcnJvckNvZGVzJyk7XHJcblxyXG52YXIgRGFsYUVycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgY29kZSwgdHJpZ2dlckVycm9yKSB7XHJcbiAgICB0aGlzLm5hbWUgPSAnRGFsYUVycm9yJztcclxuICAgIHRoaXMuZGFsYUVycm9yID0gdHJ1ZTtcclxuICAgIHRoaXMuZXJyb3IgPSB0cmlnZ2VyRXJyb3JcclxuICAgIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgdGhpcy5jb2RlID0gY29kZSB8fCBFUlJPUl9DT0RFUy5VTktOT1dOX0FQUF9FUlJPUjtcclxufTtcclxuXHJcbkRhbGFFcnJvci5DT0RFUyA9IEVSUk9SX0NPREVTO1xyXG5EYWxhRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5EYWxhRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGFsYUVycm9yO1xyXG5cclxuRGFsYUVycm9yLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbigpIHtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhbGFFcnJvcjsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFVOS05PV05fQVBQX0VSUk9SIDogMSxcclxuICAgIFVOS05PV05fREJfRVJST1IgOiAyLFxyXG4gICAgRklMRVNZU1RFTV9FUlJPUjogMyxcclxuICAgIExPR0lOX1JFUVVJUkVEIDogMTAwLFxyXG4gICAgQUNDRVNTX0RFTklFRCA6IDEwMSxcclxuICAgIFVTRVJfTE9HSU5fSU5DT1JSRUNUX1BBU1NXT1JEIDogMTAwMCxcclxuICAgIFVTRVJfTE9HSU5fSU5WQUxJRF9FTUFJTCA6IDEwMDEsXHJcbiAgICBEQl9EVVBMSUNBVEUgOiAxMTAwMCAvL1dlIGp1c3QgYWRvcHQgdGhlIG1vbmdvb3NlIGR1cGxpY2F0ZSBlcnJvcmNvZGVcclxufTsiLCIvKiBAcHJlc2VydmVcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxOCBQZXRrYSBBbnRvbm92XG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKiBcbiAqL1xuLyoqXG4gKiBibHVlYmlyZCBidWlsZCB2ZXJzaW9uIDMuNS4yXG4gKiBGZWF0dXJlcyBlbmFibGVkOiBjb3JlLCByYWNlLCBjYWxsX2dldCwgZ2VuZXJhdG9ycywgbWFwLCBub2RlaWZ5LCBwcm9taXNpZnksIHByb3BzLCByZWR1Y2UsIHNldHRsZSwgc29tZSwgdXNpbmcsIHRpbWVycywgZmlsdGVyLCBhbnksIGVhY2hcbiovXG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5Qcm9taXNlPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiBfZGVyZXFfPT1cImZ1bmN0aW9uXCImJl9kZXJlcV87aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIF9kZXJlcV89PVwiZnVuY3Rpb25cIiYmX2RlcmVxXztmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciBTb21lUHJvbWlzZUFycmF5ID0gUHJvbWlzZS5fU29tZVByb21pc2VBcnJheTtcbmZ1bmN0aW9uIGFueShwcm9taXNlcykge1xuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIHJldC5zZXRIb3dNYW55KDEpO1xuICAgIHJldC5zZXRVbndyYXAoKTtcbiAgICByZXQuaW5pdCgpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLmFueSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBhbnkocHJvbWlzZXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbnkodGhpcyk7XG59O1xuXG59O1xuXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGZpcnN0TGluZUVycm9yO1xudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge2ZpcnN0TGluZUVycm9yID0gZTt9XG52YXIgc2NoZWR1bGUgPSBfZGVyZXFfKFwiLi9zY2hlZHVsZVwiKTtcbnZhciBRdWV1ZSA9IF9kZXJlcV8oXCIuL3F1ZXVlXCIpO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBBc3luYygpIHtcbiAgICB0aGlzLl9jdXN0b21TY2hlZHVsZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZSA9IG5ldyBRdWV1ZSgxNik7XG4gICAgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXMgPSBmYWxzZTtcbiAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IHRydWU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZHJhaW5RdWV1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2RyYWluUXVldWVzKCk7XG4gICAgfTtcbiAgICB0aGlzLl9zY2hlZHVsZSA9IHNjaGVkdWxlO1xufVxuXG5Bc3luYy5wcm90b3R5cGUuc2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcHJldiA9IHRoaXMuX3NjaGVkdWxlO1xuICAgIHRoaXMuX3NjaGVkdWxlID0gZm47XG4gICAgdGhpcy5fY3VzdG9tU2NoZWR1bGVyID0gdHJ1ZTtcbiAgICByZXR1cm4gcHJldjtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5oYXNDdXN0b21TY2hlZHVsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VzdG9tU2NoZWR1bGVyO1xufTtcblxuQXN5bmMucHJvdG90eXBlLmVuYWJsZVRyYW1wb2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IHRydWU7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmhhc0RldlRvb2xzKSB7XG4gICAgICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLmhhdmVJdGVtc1F1ZXVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNUaWNrVXNlZCB8fCB0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcztcbn07XG5cblxuQXN5bmMucHJvdG90eXBlLmZhdGFsRXJyb3IgPSBmdW5jdGlvbihlLCBpc05vZGUpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKFwiRmF0YWwgXCIgKyAoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5zdGFjayA6IGUpICtcbiAgICAgICAgICAgIFwiXFxuXCIpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aHJvd0xhdGVyKGUpO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS50aHJvd0xhdGVyID0gZnVuY3Rpb24oZm4sIGFyZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFyZyA9IGZuO1xuICAgICAgICBmbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgYXJnOyB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB0cnkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQXN5bmNJbnZva2VMYXRlcihmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX2xhdGVRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuZnVuY3Rpb24gQXN5bmNJbnZva2UoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuZnVuY3Rpb24gQXN5bmNTZXR0bGVQcm9taXNlcyhwcm9taXNlKSB7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUuX3B1c2hPbmUocHJvbWlzZSk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmlmICghdXRpbC5oYXNEZXZUb29scykge1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IEFzeW5jSW52b2tlTGF0ZXI7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IEFzeW5jSW52b2tlO1xuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IEFzeW5jU2V0dGxlUHJvbWlzZXM7XG59IGVsc2Uge1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jSW52b2tlTGF0ZXIuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNJbnZva2UuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jU2V0dGxlUHJvbWlzZXMuY2FsbCh0aGlzLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIF9kcmFpblF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCgpID4gMCkge1xuICAgICAgICBfZHJhaW5RdWV1ZVN0ZXAocXVldWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2RyYWluUXVldWVTdGVwKHF1ZXVlKSB7XG4gICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZm4uX3NldHRsZVByb21pc2VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGFyZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgfVxufVxuXG5Bc3luYy5wcm90b3R5cGUuX2RyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgIF9kcmFpblF1ZXVlKHRoaXMuX25vcm1hbFF1ZXVlKTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gdHJ1ZTtcbiAgICBfZHJhaW5RdWV1ZSh0aGlzLl9sYXRlUXVldWUpO1xufTtcblxuQXN5bmMucHJvdG90eXBlLl9xdWV1ZVRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1RpY2tVc2VkKSB7XG4gICAgICAgIHRoaXMuX2lzVGlja1VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLmRyYWluUXVldWVzKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzVGlja1VzZWQgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXN5bmM7XG5tb2R1bGUuZXhwb3J0cy5maXJzdExpbmVFcnJvciA9IGZpcnN0TGluZUVycm9yO1xuXG59LHtcIi4vcXVldWVcIjoyNixcIi4vc2NoZWR1bGVcIjoyOSxcIi4vdXRpbFwiOjM2fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKSB7XG52YXIgY2FsbGVkQmluZCA9IGZhbHNlO1xudmFyIHJlamVjdFRoaXMgPSBmdW5jdGlvbihfLCBlKSB7XG4gICAgdGhpcy5fcmVqZWN0KGUpO1xufTtcblxudmFyIHRhcmdldFJlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgY29udGV4dC5iaW5kaW5nUHJvbWlzZS5fdGhlbihyZWplY3RUaGlzLCByZWplY3RUaGlzLCBudWxsLCB0aGlzLCBlKTtcbn07XG5cbnZhciBiaW5kaW5nUmVzb2x2ZWQgPSBmdW5jdGlvbih0aGlzQXJnLCBjb250ZXh0KSB7XG4gICAgaWYgKCgodGhpcy5fYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayhjb250ZXh0LnRhcmdldCk7XG4gICAgfVxufTtcblxudmFyIGJpbmRpbmdSZWplY3RlZCA9IGZ1bmN0aW9uKGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIWNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCkgdGhpcy5fcmVqZWN0KGUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgaWYgKCFjYWxsZWRCaW5kKSB7XG4gICAgICAgIGNhbGxlZEJpbmQgPSB0cnVlO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGRlYnVnLnByb3BhZ2F0ZUZyb21GdW5jdGlvbigpO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGRlYnVnLmJvdW5kVmFsdWVGdW5jdGlvbigpO1xuICAgIH1cbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzQXJnKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fcHJvcGFnYXRlRnJvbSh0aGlzLCAxKTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgcmV0Ll9zZXRCb3VuZFRvKG1heWJlUHJvbWlzZSk7XG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBwcm9taXNlUmVqZWN0aW9uUXVldWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHByb21pc2U6IHJldCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgYmluZGluZ1Byb21pc2U6IG1heWJlUHJvbWlzZVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuX3RoZW4oSU5URVJOQUwsIHRhcmdldFJlamVjdGVkLCB1bmRlZmluZWQsIHJldCwgY29udGV4dCk7XG4gICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgIGJpbmRpbmdSZXNvbHZlZCwgYmluZGluZ1JlamVjdGVkLCB1bmRlZmluZWQsIHJldCwgY29udGV4dCk7XG4gICAgICAgIHJldC5fc2V0T25DYW5jZWwobWF5YmVQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQuX3Jlc29sdmVDYWxsYmFjayh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEJvdW5kVG8gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyMDk3MTUyO1xuICAgICAgICB0aGlzLl9ib3VuZFRvID0gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjIwOTcxNTIpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyMDk3MTUyKSA9PT0gMjA5NzE1Mjtcbn07XG5cblByb21pc2UuYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnLCB2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLmJpbmQodGhpc0FyZyk7XG59O1xufTtcblxufSx7fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBvbGQ7XG5pZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIpIG9sZCA9IFByb21pc2U7XG5mdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgIHRyeSB7IGlmIChQcm9taXNlID09PSBibHVlYmlyZCkgUHJvbWlzZSA9IG9sZDsgfVxuICAgIGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBibHVlYmlyZDtcbn1cbnZhciBibHVlYmlyZCA9IF9kZXJlcV8oXCIuL3Byb21pc2VcIikoKTtcbmJsdWViaXJkLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xubW9kdWxlLmV4cG9ydHMgPSBibHVlYmlyZDtcblxufSx7XCIuL3Byb21pc2VcIjoyMn1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY3IgPSBPYmplY3QuY3JlYXRlO1xuaWYgKGNyKSB7XG4gICAgdmFyIGNhbGxlckNhY2hlID0gY3IobnVsbCk7XG4gICAgdmFyIGdldHRlckNhY2hlID0gY3IobnVsbCk7XG4gICAgY2FsbGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IGdldHRlckNhY2hlW1wiIHNpemVcIl0gPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgaXNJZGVudGlmaWVyID0gdXRpbC5pc0lkZW50aWZpZXI7XG5cbnZhciBnZXRNZXRob2RDYWxsZXI7XG52YXIgZ2V0R2V0dGVyO1xuaWYgKCF0cnVlKSB7XG52YXIgbWFrZU1ldGhvZENhbGxlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImVuc3VyZU1ldGhvZFwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBlbnN1cmVNZXRob2Qob2JqLCAnbWV0aG9kTmFtZScpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSk7ICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSk7ICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSk7ICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoubWV0aG9kTmFtZS5hcHBseShvYmosIHRoaXMpOyAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoL21ldGhvZE5hbWUvZywgbWV0aG9kTmFtZSkpKGVuc3VyZU1ldGhvZCk7XG59O1xuXG52YXIgbWFrZUdldHRlciA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwib2JqXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIG9iai5wcm9wZXJ0eU5hbWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcInByb3BlcnR5TmFtZVwiLCBwcm9wZXJ0eU5hbWUpKTtcbn07XG5cbnZhciBnZXRDb21waWxlZCA9IGZ1bmN0aW9uKG5hbWUsIGNvbXBpbGVyLCBjYWNoZSkge1xuICAgIHZhciByZXQgPSBjYWNoZVtuYW1lXTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBjb21waWxlcihuYW1lKTtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSByZXQ7XG4gICAgICAgIGNhY2hlW1wiIHNpemVcIl0rKztcbiAgICAgICAgaWYgKGNhY2hlW1wiIHNpemVcIl0gPiA1MTIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkgZGVsZXRlIGNhY2hlW2tleXNbaV1dO1xuICAgICAgICAgICAgY2FjaGVbXCIgc2l6ZVwiXSA9IGtleXMubGVuZ3RoIC0gMjU2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5nZXRNZXRob2RDYWxsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VNZXRob2RDYWxsZXIsIGNhbGxlckNhY2hlKTtcbn07XG5cbmdldEdldHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZUdldHRlciwgZ2V0dGVyQ2FjaGUpO1xufTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBmbjtcbiAgICBpZiAob2JqICE9IG51bGwpIGZuID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiT2JqZWN0IFwiICsgdXRpbC5jbGFzc1N0cmluZyhvYmopICsgXCIgaGFzIG5vIG1ldGhvZCAnXCIgK1xuICAgICAgICAgICAgdXRpbC50b1N0cmluZyhtZXRob2ROYW1lKSArIFwiJ1wiO1xuICAgICAgICB0aHJvdyBuZXcgUHJvbWlzZS5UeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY2FsbGVyKG9iaikge1xuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5wb3AoKTtcbiAgICB2YXIgZm4gPSBlbnN1cmVNZXRob2Qob2JqLCBtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCB0aGlzKTtcbn1cblByb21pc2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOztcbiAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVDYWxsZXIgPSBnZXRNZXRob2RDYWxsZXIobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVDYWxsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFyZ3MucHVzaChtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihjYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xufTtcblxuZnVuY3Rpb24gbmFtZWRHZXR0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9ialt0aGlzXTtcbn1cbmZ1bmN0aW9uIGluZGV4ZWRHZXR0ZXIob2JqKSB7XG4gICAgdmFyIGluZGV4ID0gK3RoaXM7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBNYXRoLm1heCgwLCBpbmRleCArIG9iai5sZW5ndGgpO1xuICAgIHJldHVybiBvYmpbaW5kZXhdO1xufVxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIHZhciBpc0luZGV4ID0gKHR5cGVvZiBwcm9wZXJ0eU5hbWUgPT09IFwibnVtYmVyXCIpO1xuICAgIHZhciBnZXR0ZXI7XG4gICAgaWYgKCFpc0luZGV4KSB7XG4gICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgdmFyIG1heWJlR2V0dGVyID0gZ2V0R2V0dGVyKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBnZXR0ZXIgPSBtYXliZUdldHRlciAhPT0gbnVsbCA/IG1heWJlR2V0dGVyIDogbmFtZWRHZXR0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXR0ZXIgPSBuYW1lZEdldHRlcjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGluZGV4ZWRHZXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKGdldHRlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5TmFtZSwgdW5kZWZpbmVkKTtcbn07XG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIGRlYnVnKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuXG5Qcm9taXNlLnByb3RvdHlwZVtcImJyZWFrXCJdID0gUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFkZWJ1Zy5jYW5jZWxsYXRpb24oKSkgcmV0dXJuIHRoaXMuX3dhcm4oXCJjYW5jZWxsYXRpb24gaXMgZGlzYWJsZWRcIik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNoaWxkID0gcHJvbWlzZTtcbiAgICB3aGlsZSAocHJvbWlzZS5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIGlmICghcHJvbWlzZS5fY2FuY2VsQnkoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2NhbmNlbEJyYW5jaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnQgPSBwcm9taXNlLl9jYW5jZWxsYXRpb25QYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCB8fCAhcGFyZW50Ll9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9pc0ZvbGxvd2luZygpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHByb21pc2UuX2ZvbGxvd2VlKCkuY2FuY2VsKCk7XG4gICAgICAgICAgICBwcm9taXNlLl9zZXRXaWxsQmVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJvbWlzZTtcbiAgICAgICAgICAgIHByb21pc2UgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYnJhbmNoSGFzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbC0tO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA8PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJ5ID0gZnVuY3Rpb24oY2FuY2VsbGVyKSB7XG4gICAgaWYgKGNhbmNlbGxlciA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gMDtcbiAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYnJhbmNoSGFzQ2FuY2VsbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxCcmFuY2hlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybjtcbiAgICB0aGlzLl9zZXRDYW5jZWxsZWQoKTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fY2FuY2VsUHJvbWlzZXMsIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsUHJvbWlzZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGVuZ3RoKCkgPiAwKSB0aGlzLl9zZXR0bGVQcm9taXNlcygpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0T25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5faXNDYW5jZWxsZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2RvSW52b2tlT25DYW5jZWwgPSBmdW5jdGlvbihvbkNhbmNlbENhbGxiYWNrLCBpbnRlcm5hbE9ubHkpIHtcbiAgICBpZiAodXRpbC5pc0FycmF5KG9uQ2FuY2VsQ2FsbGJhY2spKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25DYW5jZWxDYWxsYmFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbChvbkNhbmNlbENhbGxiYWNrW2ldLCBpbnRlcm5hbE9ubHkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvbkNhbmNlbENhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbENhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxPbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0cnlDYXRjaChvbkNhbmNlbENhbGxiYWNrKS5jYWxsKHRoaXMuX2JvdW5kVmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZS5lKTtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlLmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uQ2FuY2VsQ2FsbGJhY2suX3Jlc3VsdENhbmNlbGxlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbkNhbmNlbENhbGxiYWNrID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICB0aGlzLl91bnNldE9uQ2FuY2VsKCk7XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2RvSW52b2tlT25DYW5jZWwsIHRoaXMsIG9uQ2FuY2VsQ2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZUludGVybmFsT25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIHRoaXMuX2RvSW52b2tlT25DYW5jZWwodGhpcy5fb25DYW5jZWwoKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Vuc2V0T25DYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbn07XG5cbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihORVhUX0ZJTFRFUikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGdldEtleXMgPSBfZGVyZXFfKFwiLi9lczVcIikua2V5cztcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuXG5mdW5jdGlvbiBjYXRjaEZpbHRlcihpbnN0YW5jZXMsIGNiLCBwcm9taXNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGJvdW5kVG8gPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgIHByZWRpY2F0ZUxvb3A6IGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGluc3RhbmNlc1tpXTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IEVycm9yIHx8XG4gICAgICAgICAgICAgICAgKGl0ZW0gIT0gbnVsbCAmJiBpdGVtLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXNQcmVkaWNhdGUgPSB0cnlDYXRjaChpdGVtKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzUHJlZGljYXRlID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1ByZWRpY2F0ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXNQcmVkaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbC5pc09iamVjdChlKSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gZ2V0S2V5cyhpdGVtKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtW2tleV0gIT0gZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBwcmVkaWNhdGVMb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTkVYVF9GSUxURVI7XG4gICAgfTtcbn1cblxucmV0dXJuIGNhdGNoRmlsdGVyO1xufTtcblxufSx7XCIuL2VzNVwiOjEzLFwiLi91dGlsXCI6MzZ9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG52YXIgY29udGV4dFN0YWNrID0gW107XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBmdW5jdGlvbigpIHtyZXR1cm4gbnVsbDt9O1xuUHJvbWlzZS5fcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBmdW5jdGlvbigpIHt9O1xuXG5mdW5jdGlvbiBDb250ZXh0KCkge1xuICAgIHRoaXMuX3RyYWNlID0gbmV3IENvbnRleHQuQ2FwdHVyZWRUcmFjZShwZWVrQ29udGV4dCgpKTtcbn1cbkNvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl90cmFjZS5fcHJvbWlzZUNyZWF0ZWQgPSBudWxsO1xuICAgICAgICBjb250ZXh0U3RhY2sucHVzaCh0aGlzLl90cmFjZSk7XG4gICAgfVxufTtcblxuQ29udGV4dC5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmV0ID0gdHJhY2UuX3Byb21pc2VDcmVhdGVkO1xuICAgICAgICB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoKSB7XG4gICAgaWYgKGxvbmdTdGFja1RyYWNlcykgcmV0dXJuIG5ldyBDb250ZXh0KCk7XG59XG5cbmZ1bmN0aW9uIHBlZWtDb250ZXh0KCkge1xuICAgIHZhciBsYXN0SW5kZXggPSBjb250ZXh0U3RhY2subGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRTdGFja1tsYXN0SW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gbnVsbDtcbkNvbnRleHQuY3JlYXRlID0gY3JlYXRlQ29udGV4dDtcbkNvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge307XG5Db250ZXh0LmFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFByb21pc2VfcHVzaENvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcG9wQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX1BlZWtDb250ZXh0ID0gUHJvbWlzZS5fcGVla0NvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcHJvbWlzZUNyZWF0ZWQgPSBQcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IFByb21pc2VfcHVzaENvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gUHJvbWlzZV9wb3BDb250ZXh0O1xuICAgICAgICBQcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2VfUGVla0NvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IFByb21pc2VfcGVla0NvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IFByb21pc2VfcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgIGxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xuICAgIH07XG4gICAgbG9uZ1N0YWNrVHJhY2VzID0gdHJ1ZTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcHVzaENvbnRleHQ7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dDtcbiAgICBQcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IHBlZWtDb250ZXh0O1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fcGVla0NvbnRleHQoKTtcbiAgICAgICAgaWYgKGN0eCAmJiBjdHguX3Byb21pc2VDcmVhdGVkID09IG51bGwpIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPSB0aGlzO1xuICAgIH07XG59O1xucmV0dXJuIENvbnRleHQ7XG59O1xuXG59LHt9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBDb250ZXh0KSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG52YXIgV2FybmluZyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5XYXJuaW5nO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNVwiKTtcbnZhciBjYW5BdHRhY2hUcmFjZSA9IHV0aWwuY2FuQXR0YWNoVHJhY2U7XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZDtcbnZhciBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbjtcbnZhciBibHVlYmlyZEZyYW1lUGF0dGVybiA9XG4gICAgL1tcXFxcXFwvXWJsdWViaXJkW1xcXFxcXC9danNbXFxcXFxcL10ocmVsZWFzZXxkZWJ1Z3xpbnN0cnVtZW50ZWQpLztcbnZhciBub2RlRnJhbWVQYXR0ZXJuID0gL1xcKCg/OnRpbWVyc1xcLmpzKTpcXGQrOlxcZCtcXCkvO1xudmFyIHBhcnNlTGluZVBhdHRlcm4gPSAvW1xcLzxcXChdKC4rPyk6KFxcZCspOihcXGQrKVxcKT9cXHMqJC87XG52YXIgc3RhY2tGcmFtZVBhdHRlcm4gPSBudWxsO1xudmFyIGZvcm1hdFN0YWNrID0gbnVsbDtcbnZhciBpbmRlbnRTdGFja0ZyYW1lcyA9IGZhbHNlO1xudmFyIHByaW50V2FybmluZztcbnZhciBkZWJ1Z2dpbmcgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX0RFQlVHXCIpICE9IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZW52KFwiTk9ERV9FTlZcIikgPT09IFwiZGV2ZWxvcG1lbnRcIikpO1xuXG52YXIgd2FybmluZ3MgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpICE9IDAgJiZcbiAgICAoZGVidWdnaW5nIHx8IHV0aWwuZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIikpKTtcblxudmFyIGxvbmdTdGFja1RyYWNlcyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfTE9OR19TVEFDS19UUkFDRVNcIikgIT0gMCAmJlxuICAgIChkZWJ1Z2dpbmcgfHwgdXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSkpO1xuXG52YXIgd0ZvcmdvdHRlblJldHVybiA9IHV0aWwuZW52KFwiQkxVRUJJUkRfV19GT1JHT1RURU5fUkVUVVJOXCIpICE9IDAgJiZcbiAgICAod2FybmluZ3MgfHwgISF1dGlsLmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSk7XG5cblByb21pc2UucHJvdG90eXBlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX2JpdEZpZWxkID0gKCh0YXJnZXQuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KSkgfFxuICAgICAgICAgICAgICAgICAgICAgIDUyNDI4OCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgodGhpcy5fYml0RmllbGQgJiA1MjQyODgpICE9PSAwKSByZXR1cm47XG4gICAgdGhpcy5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uKCk7XG4gICAgfSwgMSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGZpcmVSZWplY3Rpb25FdmVudChcInJlamVjdGlvbkhhbmRsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkLCB1bmRlZmluZWQsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2ODQzNTQ1Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXR1cm5lZE5vblVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjg0MzU0NTYpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNSZWplY3Rpb25VbmhhbmRsZWQoKSkge1xuICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG4gICAgICAgIHRoaXMuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgZmlyZVJlamVjdGlvbkV2ZW50KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uLCByZWFzb24sIHRoaXMpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyNjIxNDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjI2MjE0NCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjYyMTQ0KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEwNDg1NzY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KTtcbiAgICBpZiAodGhpcy5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCgpKSB7XG4gICAgICAgIHRoaXMuX3Vuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICB0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNSZWplY3Rpb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEwNDg1NzYpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl93YXJuID0gZnVuY3Rpb24obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UpIHtcbiAgICByZXR1cm4gd2FybihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSB8fCB0aGlzKTtcbn07XG5cblByb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9XG4gICAgICAgIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gKGRvbWFpbiA9PT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLm9uVW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID1cbiAgICAgICAgdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyAoZG9tYWluID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UubG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSAmJiAhY29uZmlnLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5hYmxlIGxvbmcgc3RhY2sgdHJhY2VzIGFmdGVyIHByb21pc2VzIGhhdmUgYmVlbiBjcmVhdGVkXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKCFjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdmFyIFByb21pc2VfY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgIHZhciBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgdmFyIFByb21pc2VfZGVyZWZlcmVuY2VUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9kZXJlZmVyZW5jZVRyYWNlO1xuICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gdHJ1ZTtcbiAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZGVyZWZlcmVuY2VUcmFjZSA9IFByb21pc2VfZGVyZWZlcmVuY2VUcmFjZTtcbiAgICAgICAgICAgIENvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICAgICAgYXN5bmMuZW5hYmxlVHJhbXBvbGluZSgpO1xuICAgICAgICAgICAgY29uZmlnLmxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBsb25nU3RhY2tUcmFjZXNDYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZGVyZWZlcmVuY2VUcmFjZSA9IGxvbmdTdGFja1RyYWNlc0RlcmVmZXJlbmNlVHJhY2U7XG4gICAgICAgIENvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgYXN5bmMuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSgpO1xuICAgIH1cbn07XG5cblByb21pc2UuaGFzTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCk7XG59O1xuXG52YXIgZmlyZURvbUV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREYXRhLCBcInByb21pc2VcIiwge3ZhbHVlOiBldmVudC5wcm9taXNlfSk7XG4gICAgICAgICAgICAgICAgZXM1LmRlZmluZVByb3BlcnR5KGV2ZW50RGF0YSwgXCJyZWFzb25cIiwge3ZhbHVlOiBldmVudC5yZWFzb259KTtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCBldmVudERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gbmV3IEV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9tRXZlbnQuZGV0YWlsID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgZXM1LmRlZmluZVByb3BlcnR5KGRvbUV2ZW50LCBcInByb21pc2VcIiwge3ZhbHVlOiBldmVudC5wcm9taXNlfSk7XG4gICAgICAgICAgICAgICAgZXM1LmRlZmluZVByb3BlcnR5KGRvbUV2ZW50LCBcInJlYXNvblwiLCB7dmFsdWU6IGV2ZW50LnJlYXNvbn0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChcInRlc3Rpbmd0aGVldmVudFwiLCBmYWxzZSwgdHJ1ZSwge30pO1xuICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgICAgIGRvbUV2ZW50LmluaXRDdXN0b21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIGZhbHNlLCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59KSgpO1xuXG52YXIgZmlyZUdsb2JhbEV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmlzTm9kZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbWl0LmFwcGx5KHByb2Nlc3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF1dGlsLmdsb2JhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gXCJvblwiICsgbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHV0aWwuZ2xvYmFsW21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseSh1dGlsLmdsb2JhbCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0KG5hbWUsIHByb21pc2UpIHtcbiAgICByZXR1cm4ge3Byb21pc2U6IHByb21pc2V9O1xufVxuXG52YXIgZXZlbnRUb09iamVjdEdlbmVyYXRvciA9IHtcbiAgICBwcm9taXNlQ3JlYXRlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUZ1bGZpbGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZVJlamVjdGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlUmVzb2x2ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VDYW5jZWxsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VDaGFpbmVkOiBmdW5jdGlvbihuYW1lLCBwcm9taXNlLCBjaGlsZCkge1xuICAgICAgICByZXR1cm4ge3Byb21pc2U6IHByb21pc2UsIGNoaWxkOiBjaGlsZH07XG4gICAgfSxcbiAgICB3YXJuaW5nOiBmdW5jdGlvbihuYW1lLCB3YXJuaW5nKSB7XG4gICAgICAgIHJldHVybiB7d2FybmluZzogd2FybmluZ307XG4gICAgfSxcbiAgICB1bmhhbmRsZWRSZWplY3Rpb246IGZ1bmN0aW9uIChuYW1lLCByZWFzb24sIHByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHtyZWFzb246IHJlYXNvbiwgcHJvbWlzZTogcHJvbWlzZX07XG4gICAgfSxcbiAgICByZWplY3Rpb25IYW5kbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdFxufTtcblxudmFyIGFjdGl2ZUZpcmVFdmVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGdsb2JhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxFdmVudEZpcmVkID0gZmlyZUdsb2JhbEV2ZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgICAgICBnbG9iYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZG9tRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGRvbUV2ZW50RmlyZWQgPSBmaXJlRG9tRXZlbnQobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUb09iamVjdEdlbmVyYXRvcltuYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgICAgIGRvbUV2ZW50RmlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkb21FdmVudEZpcmVkIHx8IGdsb2JhbEV2ZW50RmlyZWQ7XG59O1xuXG5Qcm9taXNlLmNvbmZpZyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBvcHRzID0gT2JqZWN0KG9wdHMpO1xuICAgIGlmIChcImxvbmdTdGFja1RyYWNlc1wiIGluIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLmxvbmdTdGFja1RyYWNlcyAmJiBQcm9taXNlLmhhc0xvbmdTdGFja1RyYWNlcygpKSB7XG4gICAgICAgICAgICBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFwid2FybmluZ3NcIiBpbiBvcHRzKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc09wdGlvbiA9IG9wdHMud2FybmluZ3M7XG4gICAgICAgIGNvbmZpZy53YXJuaW5ncyA9ICEhd2FybmluZ3NPcHRpb247XG4gICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4gPSBjb25maWcud2FybmluZ3M7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNPYmplY3Qod2FybmluZ3NPcHRpb24pKSB7XG4gICAgICAgICAgICBpZiAoXCJ3Rm9yZ290dGVuUmV0dXJuXCIgaW4gd2FybmluZ3NPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB3Rm9yZ290dGVuUmV0dXJuID0gISF3YXJuaW5nc09wdGlvbi53Rm9yZ290dGVuUmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChcImNhbmNlbGxhdGlvblwiIGluIG9wdHMgJiYgb3B0cy5jYW5jZWxsYXRpb24gJiYgIWNvbmZpZy5jYW5jZWxsYXRpb24pIHtcbiAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJjYW5ub3QgZW5hYmxlIGNhbmNlbGxhdGlvbiBhZnRlciBwcm9taXNlcyBhcmUgaW4gdXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEgPVxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uQ2xlYXJDYW5jZWxsYXRpb25EYXRhO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb207XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9vbkNhbmNlbCA9IGNhbmNlbGxhdGlvbk9uQ2FuY2VsO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0T25DYW5jZWwgPSBjYW5jZWxsYXRpb25TZXRPbkNhbmNlbDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrID1cbiAgICAgICAgICAgIGNhbmNlbGxhdGlvbkF0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGNhbmNlbGxhdGlvbkV4ZWN1dGU7XG4gICAgICAgIHByb3BhZ2F0ZUZyb21GdW5jdGlvbiA9IGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb207XG4gICAgICAgIGNvbmZpZy5jYW5jZWxsYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoXCJtb25pdG9yaW5nXCIgaW4gb3B0cykge1xuICAgICAgICBpZiAob3B0cy5tb25pdG9yaW5nICYmICFjb25maWcubW9uaXRvcmluZykge1xuICAgICAgICAgICAgY29uZmlnLm1vbml0b3JpbmcgPSB0cnVlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGFjdGl2ZUZpcmVFdmVudDtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0cy5tb25pdG9yaW5nICYmIGNvbmZpZy5tb25pdG9yaW5nKSB7XG4gICAgICAgICAgICBjb25maWcubW9uaXRvcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGRlZmF1bHRGaXJlRXZlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2U7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0RmlyZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGRlZmF1bHRGaXJlRXZlbnQ7XG5Qcm9taXNlLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uKGV4ZWN1dG9yLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufTtcblByb21pc2UucHJvdG90eXBlLl9vbkNhbmNlbCA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gZnVuY3Rpb24gKGhhbmRsZXIpIHsgOyB9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24ob25DYW5jZWwpIHtcbiAgICA7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2RlcmVmZXJlbmNlVHJhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBmdW5jdGlvbiAocGFyZW50LCBmbGFncykge1xuICAgIDtcbiAgICA7XG59O1xuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25FeGVjdXRlKGV4ZWN1dG9yLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0LCBmdW5jdGlvbihvbkNhbmNlbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9uQ2FuY2VsIG11c3QgYmUgYSBmdW5jdGlvbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnRvU3RyaW5nKG9uQ2FuY2VsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCkge1xuICAgIGlmICghdGhpcy5faXNDYW5jZWxsYWJsZSgpKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBwcmV2aW91c09uQ2FuY2VsID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICBpZiAocHJldmlvdXNPbkNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh1dGlsLmlzQXJyYXkocHJldmlvdXNPbkNhbmNlbCkpIHtcbiAgICAgICAgICAgIHByZXZpb3VzT25DYW5jZWwucHVzaChvbkNhbmNlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChbcHJldmlvdXNPbkNhbmNlbCwgb25DYW5jZWxdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldE9uQ2FuY2VsKG9uQ2FuY2VsKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbk9uQ2FuY2VsKCkge1xuICAgIHJldHVybiB0aGlzLl9vbkNhbmNlbEZpZWxkO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25TZXRPbkNhbmNlbChvbkNhbmNlbCkge1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSBvbkNhbmNlbDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uQ2xlYXJDYW5jZWxsYXRpb25EYXRhKCkge1xuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tKHBhcmVudCwgZmxhZ3MpIHtcbiAgICBpZiAoKGZsYWdzICYgMSkgIT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gcGFyZW50O1xuICAgICAgICB2YXIgYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IHBhcmVudC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbDtcbiAgICAgICAgaWYgKGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCArIDE7XG4gICAgfVxuICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kaW5nUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgaWYgKChmbGFncyAmIDIpICE9PSAwICYmIHBhcmVudC5faXNCb3VuZCgpKSB7XG4gICAgICAgIHRoaXMuX3NldEJvdW5kVG8ocGFyZW50Ll9ib3VuZFRvKTtcbiAgICB9XG59XG52YXIgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uID0gYmluZGluZ1Byb3BhZ2F0ZUZyb207XG5cbmZ1bmN0aW9uIGJvdW5kVmFsdWVGdW5jdGlvbigpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5fYm91bmRUbztcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXQuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQudmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNDYXB0dXJlU3RhY2tUcmFjZSgpIHtcbiAgICB0aGlzLl90cmFjZSA9IG5ldyBDYXB0dXJlZFRyYWNlKHRoaXMuX3BlZWtDb250ZXh0KCkpO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlKGVycm9yLCBpZ25vcmVTZWxmKSB7XG4gICAgaWYgKGNhbkF0dGFjaFRyYWNlKGVycm9yKSkge1xuICAgICAgICB2YXIgdHJhY2UgPSB0aGlzLl90cmFjZTtcbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmVTZWxmKSB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNlLmF0dGFjaEV4dHJhVHJhY2UoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLFxuICAgICAgICAgICAgICAgIHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzRGVyZWZlcmVuY2VUcmFjZSgpIHtcbiAgICB0aGlzLl90cmFjZSA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHJldHVyblZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgbmFtZSwgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQpIHtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcm9taXNlQ3JlYXRlZCAhPT0gbnVsbCAmJlxuICAgICAgICB3Rm9yZ290dGVuUmV0dXJuKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBwYXJlbnQuX3JldHVybmVkTm9uVW5kZWZpbmVkKCkpIHJldHVybjtcbiAgICAgICAgaWYgKChwcm9taXNlLl9iaXRGaWVsZCAmIDY1NTM1KSA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChuYW1lKSBuYW1lID0gbmFtZSArIFwiIFwiO1xuICAgICAgICB2YXIgaGFuZGxlckxpbmUgPSBcIlwiO1xuICAgICAgICB2YXIgY3JlYXRvckxpbmUgPSBcIlwiO1xuICAgICAgICBpZiAocHJvbWlzZUNyZWF0ZWQuX3RyYWNlKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2VMaW5lcyA9IHByb21pc2VDcmVhdGVkLl90cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGNsZWFuU3RhY2sodHJhY2VMaW5lcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lUGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckxpbmUgID0gXCJhdCBcIiArIGxpbmVNYXRjaGVzWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjpcIiArIGxpbmVNYXRjaGVzWzJdICsgXCI6XCIgKyBsaW5lTWF0Y2hlc1szXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RVc2VyTGluZSA9IHN0YWNrWzBdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VMaW5lcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFjZUxpbmVzW2ldID09PSBmaXJzdFVzZXJMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdG9yTGluZSA9IFwiXFxuXCIgKyB0cmFjZUxpbmVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZyA9IFwiYSBwcm9taXNlIHdhcyBjcmVhdGVkIGluIGEgXCIgKyBuYW1lICtcbiAgICAgICAgICAgIFwiaGFuZGxlciBcIiArIGhhbmRsZXJMaW5lICsgXCJidXQgd2FzIG5vdCByZXR1cm5lZCBmcm9tIGl0LCBcIiArXG4gICAgICAgICAgICBcInNlZSBodHRwOi8vZ29vLmdsL3JScU1Vd1wiICtcbiAgICAgICAgICAgIGNyZWF0b3JMaW5lO1xuICAgICAgICBwcm9taXNlLl93YXJuKG1zZywgdHJ1ZSwgcHJvbWlzZUNyZWF0ZWQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lLCByZXBsYWNlbWVudCkge1xuICAgIHZhciBtZXNzYWdlID0gbmFtZSArXG4gICAgICAgIFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiO1xuICAgIGlmIChyZXBsYWNlbWVudCkgbWVzc2FnZSArPSBcIiBVc2UgXCIgKyByZXBsYWNlbWVudCArIFwiIGluc3RlYWQuXCI7XG4gICAgcmV0dXJuIHdhcm4obWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UpIHtcbiAgICBpZiAoIWNvbmZpZy53YXJuaW5ncykgcmV0dXJuO1xuICAgIHZhciB3YXJuaW5nID0gbmV3IFdhcm5pbmcobWVzc2FnZSk7XG4gICAgdmFyIGN0eDtcbiAgICBpZiAoc2hvdWxkVXNlT3duVHJhY2UpIHtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh3YXJuaW5nKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgKGN0eCA9IFByb21pc2UuX3BlZWtDb250ZXh0KCkpKSB7XG4gICAgICAgIGN0eC5hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVN0YWNrQW5kTWVzc2FnZSh3YXJuaW5nKTtcbiAgICAgICAgd2FybmluZy5zdGFjayA9IHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGlmICghYWN0aXZlRmlyZUV2ZW50KFwid2FybmluZ1wiLCB3YXJuaW5nKSkge1xuICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcih3YXJuaW5nLCBcIlwiLCB0cnVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHN0YWNrc1tpXS5wdXNoKFwiRnJvbSBwcmV2aW91cyBldmVudDpcIik7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IHN0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHN0YWNrc1tpXS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICgoaSArIDEgPCBzdGFja3MubGVuZ3RoKSAmJiBzdGFja3NbaV1bMF0gPT09IHN0YWNrc1tpKzFdWzBdKSkge1xuICAgICAgICAgICAgc3RhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBzdGFja3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHByZXYgPSBzdGFja3NbaV07XG4gICAgICAgIHZhciBjdXJyZW50TGFzdEluZGV4ID0gY3VycmVudC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudExhc3RMaW5lID0gY3VycmVudFtjdXJyZW50TGFzdEluZGV4XTtcbiAgICAgICAgdmFyIGNvbW1vblJvb3RNZWV0UG9pbnQgPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBqID0gcHJldi5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgaWYgKHByZXZbal0gPT09IGN1cnJlbnRMYXN0TGluZSkge1xuICAgICAgICAgICAgICAgIGNvbW1vblJvb3RNZWV0UG9pbnQgPSBqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbW1vblJvb3RNZWV0UG9pbnQ7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHByZXZbal07XG4gICAgICAgICAgICBpZiAoY3VycmVudFtjdXJyZW50TGFzdEluZGV4XSA9PT0gbGluZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExhc3RJbmRleC0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gcHJldjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RhY2soc3RhY2spIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICB2YXIgaXNUcmFjZUxpbmUgPSBcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHxcbiAgICAgICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSk7XG4gICAgICAgIHZhciBpc0ludGVybmFsRnJhbWUgPSBpc1RyYWNlTGluZSAmJiBzaG91bGRJZ25vcmUobGluZSk7XG4gICAgICAgIGlmIChpc1RyYWNlTGluZSAmJiAhaXNJbnRlcm5hbEZyYW1lKSB7XG4gICAgICAgICAgICBpZiAoaW5kZW50U3RhY2tGcmFtZXMgJiYgbGluZS5jaGFyQXQoMCkgIT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IFwiICAgIFwiICsgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoL1xccyskL2csIFwiXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZSB8fCBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDAgJiYgZXJyb3IubmFtZSAhPSBcIlN5bnRheEVycm9yXCIpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0YWNrQW5kTWVzc2FnZShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICBzdGFjayA9IHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIiAmJiBzdGFjay5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIDogW1wiICAgIChObyBzdGFjayB0cmFjZSlcIl07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IGVycm9yLm5hbWUgPT0gXCJTeW50YXhFcnJvclwiID8gc3RhY2sgOiBjbGVhblN0YWNrKHN0YWNrKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFuZExvZ0Vycm9yKGVycm9yLCB0aXRsZSwgaXNTb2Z0KSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBpZiAodXRpbC5pc09iamVjdChlcnJvcikpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRpdGxlICsgZm9ybWF0U3RhY2soc3RhY2ssIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIFN0cmluZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcmludFdhcm5pbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGlzU29mdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpcmVSZWplY3Rpb25FdmVudChuYW1lLCBsb2NhbEhhbmRsZXIsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgIHZhciBsb2NhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2NhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikge1xuICAgICAgICBpZiAoIWFjdGl2ZUZpcmVFdmVudChuYW1lLCByZWFzb24sIHByb21pc2UpICYmICFsb2NhbEV2ZW50RmlyZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdEFuZExvZ0Vycm9yKHJlYXNvbiwgXCJVbmhhbmRsZWQgcmVqZWN0aW9uIFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUZpcmVFdmVudChuYW1lLCBwcm9taXNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE5vbkVycm9yKG9iaikge1xuICAgIHZhciBzdHI7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzdHIgPSBcIltmdW5jdGlvbiBcIiArXG4gICAgICAgICAgICAob2JqLm5hbWUgfHwgXCJhbm9ueW1vdXNcIikgK1xuICAgICAgICAgICAgXCJdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gb2JqICYmIHR5cGVvZiBvYmoudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBvYmoudG9TdHJpbmcoKSA6IHV0aWwudG9TdHJpbmcob2JqKTtcbiAgICAgICAgdmFyIHJ1c2VsZXNzVG9TdHJpbmcgPSAvXFxbb2JqZWN0IFthLXpBLVowLTkkX10rXFxdLztcbiAgICAgICAgaWYgKHJ1c2VsZXNzVG9TdHJpbmcudGVzdChzdHIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgICAgIHN0ciA9IG5ld1N0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSBcIihlbXB0eSBhcnJheSlcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFwiKDxcIiArIHNuaXAoc3RyKSArIFwiPiwgbm8gc3RhY2sgdHJhY2UpXCIpO1xufVxuXG5mdW5jdGlvbiBzbmlwKHN0cikge1xuICAgIHZhciBtYXhDaGFycyA9IDQxO1xuICAgIGlmIChzdHIubGVuZ3RoIDwgbWF4Q2hhcnMpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbWF4Q2hhcnMgLSAzKSArIFwiLi4uXCI7XG59XG5cbmZ1bmN0aW9uIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxudmFyIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG52YXIgcGFyc2VMaW5lSW5mb1JlZ2V4ID0gL1tcXC88XFwoXShbXjpcXC9dKyk6KFxcZCspOig/OlxcZCspXFwpP1xccyokLztcbmZ1bmN0aW9uIHBhcnNlTGluZUluZm8obGluZSkge1xuICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChwYXJzZUxpbmVJbmZvUmVnZXgpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgICAgIGxpbmU6IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0Qm91bmRzKGZpcnN0TGluZUVycm9yLCBsYXN0TGluZUVycm9yKSB7XG4gICAgaWYgKCFsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpKSByZXR1cm47XG4gICAgdmFyIGZpcnN0U3RhY2tMaW5lcyA9IGZpcnN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBsYXN0U3RhY2tMaW5lcyA9IGxhc3RMaW5lRXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGZpcnN0SW5kZXggPSAtMTtcbiAgICB2YXIgbGFzdEluZGV4ID0gLTE7XG4gICAgdmFyIGZpcnN0RmlsZU5hbWU7XG4gICAgdmFyIGxhc3RGaWxlTmFtZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0U3RhY2tMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhmaXJzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBmaXJzdEZpbGVOYW1lID0gcmVzdWx0LmZpbGVOYW1lO1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0U3RhY2tMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhsYXN0U3RhY2tMaW5lc1tpXSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGxhc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpcnN0SW5kZXggPCAwIHx8IGxhc3RJbmRleCA8IDAgfHwgIWZpcnN0RmlsZU5hbWUgfHwgIWxhc3RGaWxlTmFtZSB8fFxuICAgICAgICBmaXJzdEZpbGVOYW1lICE9PSBsYXN0RmlsZU5hbWUgfHwgZmlyc3RJbmRleCA+PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGJsdWViaXJkRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgaW5mbyA9IHBhcnNlTGluZUluZm8obGluZSk7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5maWxlTmFtZSA9PT0gZmlyc3RGaWxlTmFtZSAmJlxuICAgICAgICAgICAgICAgIChmaXJzdEluZGV4IDw9IGluZm8ubGluZSAmJiBpbmZvLmxpbmUgPD0gbGFzdEluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBDYXB0dXJlZFRyYWNlKHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9wcm9taXNlc0NyZWF0ZWQgPSAwO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGggPSAxICsgKHBhcmVudCA9PT0gdW5kZWZpbmVkID8gMCA6IHBhcmVudC5fbGVuZ3RoKTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDYXB0dXJlZFRyYWNlKTtcbiAgICBpZiAobGVuZ3RoID4gMzIpIHRoaXMudW5jeWNsZSgpO1xufVxudXRpbC5pbmhlcml0cyhDYXB0dXJlZFRyYWNlLCBFcnJvcik7XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBDYXB0dXJlZFRyYWNlO1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS51bmN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBzdGFja1RvSW5kZXggPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBub2RlID0gdGhpczsgbm9kZSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuX3BhcmVudDtcbiAgICB9XG4gICAgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gaTtcbiAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gbm9kZXNbaV0uc3RhY2s7XG4gICAgICAgIGlmIChzdGFja1RvSW5kZXhbc3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrVG9JbmRleFtzdGFja10gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICB2YXIgaW5kZXggPSBzdGFja1RvSW5kZXhbY3VycmVudFN0YWNrXTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tpbmRleCAtIDFdLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzW2ldLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBub2Rlc1tpXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHZhciBjeWNsZUVkZ2VOb2RlID0gaSA+IDAgPyBub2Rlc1tpIC0gMV0gOiB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gbm9kZXNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQudW5jeWNsZSgpO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudC5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudENoaWxkTGVuZ3RoID0gY3ljbGVFZGdlTm9kZS5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gMjsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tqXS5fbGVuZ3RoID0gY3VycmVudENoaWxkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGlsZExlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUuYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHJldHVybjtcbiAgICB0aGlzLnVuY3ljbGUoKTtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgIHZhciBtZXNzYWdlID0gcGFyc2VkLm1lc3NhZ2U7XG4gICAgdmFyIHN0YWNrcyA9IFtwYXJzZWQuc3RhY2tdO1xuXG4gICAgdmFyIHRyYWNlID0gdGhpcztcbiAgICB3aGlsZSAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFja3MucHVzaChjbGVhblN0YWNrKHRyYWNlLnN0YWNrLnNwbGl0KFwiXFxuXCIpKSk7XG4gICAgICAgIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKTtcbiAgICByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKTtcbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcInN0YWNrXCIsIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJfX3N0YWNrQ2xlYW5lZF9fXCIsIHRydWUpO1xufTtcblxudmFyIGNhcHR1cmVTdGFja1RyYWNlID0gKGZ1bmN0aW9uIHN0YWNrRGV0ZWN0aW9uKCkge1xuICAgIHZhciB2OHN0YWNrRnJhbWVQYXR0ZXJuID0gL15cXHMqYXRcXHMqLztcbiAgICB2YXIgdjhzdGFja0Zvcm1hdHRlciA9IGZ1bmN0aW9uKHN0YWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgaWYgKGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlO1xuXG4gICAgICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVjZWl2ZXIsIGlnbm9yZVVudGlsKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgIGNhcHR1cmVTdGFja1RyYWNlKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCk7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgLT0gNjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuXG4gICAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgZXJyLnN0YWNrLnNwbGl0KFwiXFxuXCIpWzBdLmluZGV4T2YoXCJzdGFja0RldGVjdGlvbkBcIikgPj0gMCkge1xuICAgICAgICBzdGFja0ZyYW1lUGF0dGVybiA9IC9ALztcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICBpbmRlbnRTdGFja0ZyYW1lcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBvLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGhhc1N0YWNrQWZ0ZXJUaHJvdztcbiAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgaGFzU3RhY2tBZnRlclRocm93ID0gKFwic3RhY2tcIiBpbiBlKTtcbiAgICB9XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIGVycikgJiYgaGFzU3RhY2tBZnRlclRocm93ICYmXG4gICAgICAgIHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgICAgICAgICBjYXRjaChlKSB7IG8uc3RhY2sgPSBlLnN0YWNrOyB9XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgLT0gNjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3JtYXRTdGFjayA9IGZ1bmN0aW9uKHN0YWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICAgZXJyb3IubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIHJldHVybiBudWxsO1xuXG59KShbXSk7XG5cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgaWYgKHV0aWwuaXNOb2RlICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGlzU29mdCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaXNTb2Z0ID8gXCJcXHUwMDFiWzMzbVwiIDogXCJcXHUwMDFiWzMxbVwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbG9yICsgbWVzc2FnZSArIFwiXFx1MDAxYlswbVxcblwiKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCF1dGlsLmlzTm9kZSAmJiB0eXBlb2YgKG5ldyBFcnJvcigpLnN0YWNrKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIiVjXCIgKyBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTb2Z0ID8gXCJjb2xvcjogZGFya29yYW5nZVwiIDogXCJjb2xvcjogcmVkXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGNvbmZpZyA9IHtcbiAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgbG9uZ1N0YWNrVHJhY2VzOiBmYWxzZSxcbiAgICBjYW5jZWxsYXRpb246IGZhbHNlLFxuICAgIG1vbml0b3Jpbmc6IGZhbHNlXG59O1xuXG5pZiAobG9uZ1N0YWNrVHJhY2VzKSBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuXG5yZXR1cm4ge1xuICAgIGxvbmdTdGFja1RyYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzO1xuICAgIH0sXG4gICAgd2FybmluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLndhcm5pbmdzO1xuICAgIH0sXG4gICAgY2FuY2VsbGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jYW5jZWxsYXRpb247XG4gICAgfSxcbiAgICBtb25pdG9yaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5tb25pdG9yaW5nO1xuICAgIH0sXG4gICAgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByb3BhZ2F0ZUZyb21GdW5jdGlvbjtcbiAgICB9LFxuICAgIGJvdW5kVmFsdWVGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBib3VuZFZhbHVlRnVuY3Rpb247XG4gICAgfSxcbiAgICBjaGVja0ZvcmdvdHRlblJldHVybnM6IGNoZWNrRm9yZ290dGVuUmV0dXJucyxcbiAgICBzZXRCb3VuZHM6IHNldEJvdW5kcyxcbiAgICB3YXJuOiB3YXJuLFxuICAgIGRlcHJlY2F0ZWQ6IGRlcHJlY2F0ZWQsXG4gICAgQ2FwdHVyZWRUcmFjZTogQ2FwdHVyZWRUcmFjZSxcbiAgICBmaXJlRG9tRXZlbnQ6IGZpcmVEb21FdmVudCxcbiAgICBmaXJlR2xvYmFsRXZlbnQ6IGZpcmVHbG9iYWxFdmVudFxufTtcbn07XG5cbn0se1wiLi9lcnJvcnNcIjoxMixcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiByZXR1cm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cbmZ1bmN0aW9uIHRocm93ZXIoKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG59XG5cblByb21pc2UucHJvdG90eXBlW1wicmV0dXJuXCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgcmV0dXJuZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7dmFsdWU6IHZhbHVlfSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlW1widGhyb3dcIl0gPVxuUHJvbWlzZS5wcm90b3R5cGUudGhlblRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICB0aHJvd2VyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhyb3dlciwgdW5kZWZpbmVkLCB7cmVhc29uOiByZWFzb259LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVhc29uID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge3Rocm93IF9yZWFzb247fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHJlYXNvbiwgaGFuZGxlcik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hSZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0dXJuZXIsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKF92YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIF92YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtyZXR1cm4gX3ZhbHVlO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodCh2YWx1ZSwgaGFuZGxlcik7XG4gICAgfVxufTtcbn07XG5cbn0se31dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VSZWR1Y2UgPSBQcm9taXNlLnJlZHVjZTtcbnZhciBQcm9taXNlQWxsID0gUHJvbWlzZS5hbGw7XG5cbmZ1bmN0aW9uIHByb21pc2VBbGxUaGlzKCkge1xuICAgIHJldHVybiBQcm9taXNlQWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlTWFwU2VyaWVzKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgMClcbiAgICAgICAgICAgICAgLl90aGVuKHByb21pc2VBbGxUaGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcFNlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5tYXBTZXJpZXMgPSBQcm9taXNlTWFwU2VyaWVzO1xufTtcblxuXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG52YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIG5hbWVQcm9wZXJ0eSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaGVyaXRzKFN1YkVycm9yLCBFcnJvcik7XG4gICAgcmV0dXJuIFN1YkVycm9yO1xufVxuXG52YXIgX1R5cGVFcnJvciwgX1JhbmdlRXJyb3I7XG52YXIgV2FybmluZyA9IHN1YkVycm9yKFwiV2FybmluZ1wiLCBcIndhcm5pbmdcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBzdWJFcnJvcihcIkNhbmNlbGxhdGlvbkVycm9yXCIsIFwiY2FuY2VsbGF0aW9uIGVycm9yXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IHN1YkVycm9yKFwiVGltZW91dEVycm9yXCIsIFwidGltZW91dCBlcnJvclwiKTtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IHN1YkVycm9yKFwiQWdncmVnYXRlRXJyb3JcIiwgXCJhZ2dyZWdhdGUgZXJyb3JcIik7XG50cnkge1xuICAgIF9UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgX1JhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xufSBjYXRjaChlKSB7XG4gICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xufVxuXG52YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICtcbiAgICBcImV2ZXJ5IG1hcCBpbmRleE9mIGxhc3RJbmRleE9mIHJlZHVjZSByZWR1Y2VSaWdodCBzb3J0IHJldmVyc2VcIikuc3BsaXQoXCIgXCIpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVttZXRob2RzW2ldXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXTtcbiAgICB9XG59XG5cbmVzNS5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZTogMCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG52YXIgbGV2ZWwgPSAwO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIHZhciByZXQgPSBcIlxcblwiICsgaW5kZW50ICsgXCJBZ2dyZWdhdGVFcnJvciBvZjpcIiArIFwiXFxuXCI7XG4gICAgbGV2ZWwrKztcbiAgICBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNbaV0gPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IHRoaXNbaV0gKyBcIlwiO1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGxpbmVzW2pdID0gaW5kZW50ICsgbGluZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0ICs9IHN0ciArIFwiXFxuXCI7XG4gICAgfVxuICAgIGxldmVsLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBcIk9wZXJhdGlvbmFsRXJyb3JcIik7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBtZXNzYWdlO1xuICAgIHRoaXNbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwic3RhY2tcIiwgbWVzc2FnZS5zdGFjayk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbn1cbmluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxudmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG5pZiAoIWVycm9yVHlwZXMpIHtcbiAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgIH0pO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShFcnJvciwgXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCIsIHtcbiAgICAgICAgdmFsdWU6IGVycm9yVHlwZXMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuXG59LHtcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0VTNSA9IChmdW5jdGlvbigpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzID09PSB1bmRlZmluZWQ7XG59KSgpO1xuXG5pZiAoaXNFUzUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZnJlZXplOiBPYmplY3QuZnJlZXplLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgIHJldHVybiAhISghZGVzY3JpcHRvciB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG59IGVsc2Uge1xuICAgIHZhciBoYXMgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgc3RyID0ge30udG9TdHJpbmc7XG4gICAgdmFyIHByb3RvID0ge30uY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgdmFyIE9iamVjdEtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwobywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldERlc2NyaXB0b3IgPSBmdW5jdGlvbihvLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogb1trZXldfTtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG8sIGtleSwgZGVzYykge1xuICAgICAgICBvW2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChvYmopLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBBcnJheUlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNBcnJheTogQXJyYXlJc0FycmF5LFxuICAgICAgICBrZXlzOiBPYmplY3RLZXlzLFxuICAgICAgICBuYW1lczogT2JqZWN0S2V5cyxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3RHZXREZXNjcmlwdG9yLFxuICAgICAgICBmcmVlemU6IE9iamVjdEZyZWV6ZSxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdEdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbn0se31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VNYXAgPSBQcm9taXNlLm1hcDtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAodGhpcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZmlsdGVyID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcbn07XG5cbn0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBORVhUX0ZJTFRFUikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcjtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgY2F0Y2hGaWx0ZXIgPSBfZGVyZXFfKFwiLi9jYXRjaF9maWx0ZXJcIikoTkVYVF9GSUxURVIpO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0KHByb21pc2UsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmNhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsUHJvbWlzZSA9IG51bGw7XG59XG5cblBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQucHJvdG90eXBlLmlzRmluYWxseUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAwO1xufTtcblxuZnVuY3Rpb24gRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbihmaW5hbGx5SGFuZGxlcikge1xuICAgIHRoaXMuZmluYWxseUhhbmRsZXIgPSBmaW5hbGx5SGFuZGxlcjtcbn1cblxuRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGNoZWNrQ2FuY2VsKHRoaXMuZmluYWxseUhhbmRsZXIpO1xufTtcblxuZnVuY3Rpb24gY2hlY2tDYW5jZWwoY3R4LCByZWFzb24pIHtcbiAgICBpZiAoY3R4LmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2FuY2VsUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN1Y2NlZWQoKSB7XG4gICAgcmV0dXJuIGZpbmFsbHlIYW5kbGVyLmNhbGwodGhpcywgdGhpcy5wcm9taXNlLl90YXJnZXQoKS5fc2V0dGxlZFZhbHVlKCkpO1xufVxuZnVuY3Rpb24gZmFpbChyZWFzb24pIHtcbiAgICBpZiAoY2hlY2tDYW5jZWwodGhpcywgcmVhc29uKSkgcmV0dXJuO1xuICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgcmV0dXJuIGVycm9yT2JqO1xufVxuZnVuY3Rpb24gZmluYWxseUhhbmRsZXIocmVhc29uT3JWYWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuXG4gICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICB0aGlzLmNhbGxlZCA9IHRydWU7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmlzRmluYWxseUhhbmRsZXIoKVxuICAgICAgICAgICAgPyBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpKVxuICAgICAgICAgICAgOiBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCByZWFzb25PclZhbHVlKTtcbiAgICAgICAgaWYgKHJldCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkKCk7XG4gICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXQsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZS5faXNDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gcmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VlZCwgZmFpbCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIGNoZWNrQ2FuY2VsKHRoaXMpO1xuICAgICAgICBlcnJvck9iai5lID0gcmVhc29uT3JWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrQ2FuY2VsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVhc29uT3JWYWx1ZTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLl9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uKGhhbmRsZXIsIHR5cGUsIHN1Y2Nlc3MsIGZhaWwpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRoaXMudGhlbigpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgZmFpbCxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQodGhpcywgdHlwZSwgaGFuZGxlciksXG4gICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmxhc3RseSA9XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xufTtcblxuXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLCAxLCBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50YXBDYXRjaCA9IGZ1bmN0aW9uIChoYW5kbGVyT3JQcmVkaWNhdGUpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXJPclByZWRpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgIHZhciBjYXRjaEluc3RhbmNlcyA9IG5ldyBBcnJheShsZW4gLSAxKSxcbiAgICAgICAgICAgIGogPSAwLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgY2F0Y2hJbnN0YW5jZXNbaisrXSA9IGl0ZW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcInRhcENhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiXG4gICAgICAgICAgICAgICAgICAgICsgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2hJbnN0YW5jZXMubGVuZ3RoID0gajtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChjYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgaGFuZGxlciwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xuICAgIH1cblxufTtcblxucmV0dXJuIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQ7XG59O1xuXG59LHtcIi4vY2F0Y2hfZmlsdGVyXCI6NyxcIi4vdXRpbFwiOjM2fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb3h5YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcpIHtcbnZhciBlcnJvcnMgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIik7XG52YXIgVHlwZUVycm9yID0gZXJyb3JzLlR5cGVFcnJvcjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIHlpZWxkSGFuZGxlcnMgPSBbXTtcblxuZnVuY3Rpb24gcHJvbWlzZUZyb21ZaWVsZEhhbmRsZXIodmFsdWUsIHlpZWxkSGFuZGxlcnMsIHRyYWNlUGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB5aWVsZEhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRyYWNlUGFyZW50Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goeWllbGRIYW5kbGVyc1tpXSkodmFsdWUpO1xuICAgICAgICB0cmFjZVBhcmVudC5fcG9wQ29udGV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB0cmFjZVBhcmVudC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXN1bHQsIHRyYWNlUGFyZW50KTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBtYXliZVByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlU3Bhd24oZ2VuZXJhdG9yRnVuY3Rpb24sIHJlY2VpdmVyLCB5aWVsZEhhbmRsZXIsIHN0YWNrKSB7XG4gICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgdmFyIF9maW5hbGx5UHJvbWlzZSA9IHRoaXMuX2ZpbmFsbHlQcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gaW50ZXJuYWwubGFzdGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9maW5hbGx5UHJvbWlzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGludGVybmFsLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICBpbnRlcm5hbC5fc2V0T25DYW5jZWwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIH1cbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuY3Rpb247XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5feWllbGRIYW5kbGVycyA9IHR5cGVvZiB5aWVsZEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IFt5aWVsZEhhbmRsZXJdLmNvbmNhdCh5aWVsZEhhbmRsZXJzKVxuICAgICAgICA6IHlpZWxkSGFuZGxlcnM7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFByb21pc2VTcGF3biwgUHJveHlhYmxlKTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5faXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlID09PSBudWxsO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Byb21pc2UgPSB0aGlzLl9nZW5lcmF0b3IgPSBudWxsO1xuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSAmJiB0aGlzLl9maW5hbGx5UHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9maW5hbGx5UHJvbWlzZS5fZnVsZmlsbCgpO1xuICAgICAgICB0aGlzLl9maW5hbGx5UHJvbWlzZSA9IG51bGw7XG4gICAgfVxufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB2YXIgaW1wbGVtZW50c1JldHVybiA9IHR5cGVvZiB0aGlzLl9nZW5lcmF0b3JbXCJyZXR1cm5cIl0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmICghaW1wbGVtZW50c1JldHVybikge1xuICAgICAgICB2YXIgcmVhc29uID0gbmV3IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IoXG4gICAgICAgICAgICBcImdlbmVyYXRvciAucmV0dXJuKCkgc2VudGluZWxcIik7XG4gICAgICAgIFByb21pc2UuY29yb3V0aW5lLnJldHVyblNlbnRpbmVsID0gcmVhc29uO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInRocm93XCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJyZXR1cm5cIl0pLmNhbGwodGhpcy5fZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB9XG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UgPSB0cnVlO1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9jb250aW51ZShyZXN1bHQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvci5uZXh0KS5jYWxsKHRoaXMuX2dlbmVyYXRvciwgdmFsdWUpO1xuICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB0aGlzLl9jb250aW51ZShyZXN1bHQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSlcbiAgICAgICAgLmNhbGwodGhpcy5fZ2VuZXJhdG9yLCByZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB0aGlzLl9jb250aW51ZShyZXN1bHQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3lpZWxkZWRQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3lpZWxkZWRQcm9taXNlO1xuICAgICAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHByb21pc2UuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uLmNhbGwodGhpcy5fcmVjZWl2ZXIpO1xuICAgIHRoaXMuX3JlY2VpdmVyID1cbiAgICAgICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCh1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fY29udGludWUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgIGlmIChyZXN1bHQuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgcHJvbWlzZUZyb21ZaWVsZEhhbmRsZXIobWF5YmVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkSGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdGVkKFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJBIHZhbHVlICVzIHdhcyB5aWVsZGVkIHRoYXQgY291bGQgbm90IGJlIHRyZWF0ZWQgYXMgYSBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVxcdTAwMGFcIi5yZXBsYWNlKFwiJXNcIiwgU3RyaW5nKHZhbHVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJGcm9tIGNvcm91dGluZTpcXHUwMDBhXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSwgLTcpLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHZhciBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIDtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHkodGhpcywgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIFByb21pc2UuX2FzeW5jLmludm9rZShcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3ZhbHVlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIFByb21pc2UuX2FzeW5jLmludm9rZShcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ZWQsIHRoaXMsIG1heWJlUHJvbWlzZS5fcmVhc29uKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlQ2FuY2VsbGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLmNvcm91dGluZSA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHlpZWxkSGFuZGxlciA9IE9iamVjdChvcHRpb25zKS55aWVsZEhhbmRsZXI7XG4gICAgdmFyIFByb21pc2VTcGF3biQgPSBQcm9taXNlU3Bhd247XG4gICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IGdlbmVyYXRvckZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBzcGF3biA9IG5ldyBQcm9taXNlU3Bhd24kKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB5aWVsZEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrKTtcbiAgICAgICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICAgICAgc3Bhd24uX2dlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgc3Bhd24uX3Byb21pc2VGdWxmaWxsZWQodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUuYWRkWWllbGRIYW5kbGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHlpZWxkSGFuZGxlcnMucHVzaChmbik7XG59O1xuXG5Qcm9taXNlLnNwYXduID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2Uuc3Bhd24oKVwiLCBcIlByb21pc2UuY29yb3V0aW5lKClcIik7XG4gICAgaWYgKHR5cGVvZiBnZW5lcmF0b3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCB0aGlzKTtcbiAgICB2YXIgcmV0ID0gc3Bhd24ucHJvbWlzZSgpO1xuICAgIHNwYXduLl9ydW4oUHJvbWlzZS5zcGF3bik7XG4gICAgcmV0dXJuIHJldDtcbn07XG59O1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgYXN5bmMsXG4gICAgICAgICBnZXREb21haW4pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciByZWplY3Q7XG5cbmlmICghdHJ1ZSkge1xuaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgdmFyIHRoZW5DYWxsYmFjayA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLmNoZWNrRnVsZmlsbG1lbnQodGhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvbWlzZVNldHRlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInByb21pc2VcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2VuZXJhdGVIb2xkZXJDbGFzcyA9IGZ1bmN0aW9uKHRvdGFsKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IG5ldyBBcnJheSh0b3RhbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHByb3BzW2ldID0gXCJ0aGlzLnBcIiArIChpKzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJvcHMuam9pbihcIiA9IFwiKSArIFwiID0gbnVsbDtcIjtcbiAgICAgICAgdmFyIGNhbmNlbGxhdGlvbkNvZGU9IFwidmFyIHByb21pc2U7XFxuXCIgKyBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gXCIgKyBwcm9wICsgXCI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhbmNlbCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCI7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHZhciBwYXNzZWRBcmd1bWVudHMgPSBwcm9wcy5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBuYW1lID0gXCJIb2xkZXIkXCIgKyB0b3RhbDtcblxuXG4gICAgICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYykgeyAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZnVuY3Rpb24gW1RoZU5hbWVdKGZuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtUaGVQcm9wZXJ0aWVzXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuZm4gPSBmbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuYXN5bmNOZWVkZWQgPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fY2FsbEZ1bmN0aW9uID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cnlDYXRjaCh0aGlzLmZuKShbVGhlUGFzc2VkQXJndW1lbnRzXSk7ICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3BvcENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXQuZSwgZmFsc2UpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2socmV0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5jaGVja0Z1bGZpbGxtZW50ID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciBub3cgPSArK3RoaXMubm93OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChub3cgPT09IFtUaGVUb3RhbF0pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY05lZWRlZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMuaW52b2tlKHRoaXMuX2NhbGxGdW5jdGlvbiwgdGhpcywgcHJvbWlzZSk7ICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEZ1bmN0aW9uKHByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDYW5jZWxsYXRpb25Db2RlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIFtUaGVOYW1lXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9KHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIjtcblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXFtUaGVOYW1lXFxdL2csIG5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlVG90YWxcXF0vZywgdG90YWwpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlUGFzc2VkQXJndW1lbnRzXFxdL2csIHBhc3NlZEFyZ3VtZW50cylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQcm9wZXJ0aWVzXFxdL2csIGFzc2lnbm1lbnQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbQ2FuY2VsbGF0aW9uQ29kZVxcXS9nLCBjYW5jZWxsYXRpb25Db2RlKTtcblxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidHJ5Q2F0Y2hcIiwgXCJlcnJvck9ialwiLCBcIlByb21pc2VcIiwgXCJhc3luY1wiLCBjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpO1xuICAgIH07XG5cbiAgICB2YXIgaG9sZGVyQ2xhc3NlcyA9IFtdO1xuICAgIHZhciB0aGVuQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIHByb21pc2VTZXR0ZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICBob2xkZXJDbGFzc2VzLnB1c2goZ2VuZXJhdGVIb2xkZXJDbGFzcyhpICsgMSkpO1xuICAgICAgICB0aGVuQ2FsbGJhY2tzLnB1c2godGhlbkNhbGxiYWNrKGkgKyAxKSk7XG4gICAgICAgIHByb21pc2VTZXR0ZXJzLnB1c2gocHJvbWlzZVNldHRlcihpICsgMSkpO1xuICAgIH1cblxuICAgIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbn19XG5cblByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBmbjtcbiAgICBpZiAobGFzdCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1tsYXN0XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IDggJiYgY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgSG9sZGVyQ2xhc3MgPSBob2xkZXJDbGFzc2VzW2xhc3QgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gbmV3IEhvbGRlckNsYXNzKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGNhbGxiYWNrc1tpXSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJldCwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlU2V0dGVyc1tpXShtYXliZVByb21pc2UsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmFzeW5jTmVlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuYXN5bmNOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm4gPSB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBob2xkZXIuZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwoaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTs7XG4gICAgaWYgKGZuKSBhcmdzLnBvcCgpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUFycmF5KGFyZ3MpLnByb21pc2UoKTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IHJldC5zcHJlYWQoZm4pIDogcmV0O1xufTtcblxufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcblxuZnVuY3Rpb24gTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgdGhpcy5fcHJlc2VydmVkVmFsdWVzID0gX2ZpbHRlciA9PT0gSU5URVJOQUxcbiAgICAgICAgPyBuZXcgQXJyYXkodGhpcy5sZW5ndGgoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgdGhpcy5faW5GbGlnaHQgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2FzeW5jSW5pdCwgdGhpcywgdW5kZWZpbmVkKTtcbn1cbnV0aWwuaW5oZXJpdHMoTWFwcGluZ1Byb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2FzeW5jSW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTIpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB2YXIgcHJlc2VydmVkVmFsdWVzID0gdGhpcy5fcHJlc2VydmVkVmFsdWVzO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IChpbmRleCAqIC0xKSAtIDE7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2luRmxpZ2h0LS07XG4gICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW1pdCA+PSAxICYmIHRoaXMuX2luRmxpZ2h0ID49IGxpbWl0KSB7XG4gICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlc2VydmVkVmFsdWVzICE9PSBudWxsKSBwcmVzZXJ2ZWRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2goY2FsbGJhY2spLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBwcm9taXNlQ3JlYXRlZCxcbiAgICAgICAgICAgIHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCA/IFwiUHJvbWlzZS5maWx0ZXJcIiA6IFwiUHJvbWlzZS5tYXBcIixcbiAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChyZXQuZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+PSAxKSB0aGlzLl9pbkZsaWdodCsrO1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCAoaW5kZXggKyAxKSAqIC0xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF5YmVQcm9taXNlLl92YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcih2YWx1ZXMsIHByZXNlcnZlZFZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faW5GbGlnaHQgPCBsaW1pdCkge1xuICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgIHZhciBpbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZmlsdGVyID0gZnVuY3Rpb24gKGJvb2xlYW5zLCB2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGJvb2xlYW5zW2ldKSByZXRbaisrXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0Lmxlbmd0aCA9IGo7XG4gICAgdGhpcy5fcmVzb2x2ZShyZXQpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUucHJlc2VydmVkVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG59O1xuXG5mdW5jdGlvbiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cblxuICAgIHZhciBsaW1pdCA9IDA7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbmN1cnJlbmN5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHlwZUVycm9yKFwiJ2NvbmN1cnJlbmN5JyBtdXN0IGJlIGEgbnVtYmVyIGJ1dCBpdCBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMuY29uY3VycmVuY3kpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdCA9IG9wdGlvbnMuY29uY3VycmVuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QgYnV0IGl0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhvcHRpb25zKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbWl0ID0gdHlwZW9mIGxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIGlzRmluaXRlKGxpbWl0KSAmJiBsaW1pdCA+PSAxID8gbGltaXQgOiAwO1xuICAgIHJldHVybiBuZXcgTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKS5wcm9taXNlKCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBtYXAodGhpcywgZm4sIG9wdGlvbnMsIG51bGwpO1xufTtcblxuUHJvbWlzZS5tYXAgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgcmV0dXJuIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpO1xufTtcblxuXG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zykge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuUHJvbWlzZS5tZXRob2QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNhdGNoKGZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UubWV0aG9kXCIsIHJldCk7XG4gICAgICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiY2FsbGluZyBQcm9taXNlLnRyeSB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50XCIpO1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgY3R4ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YWx1ZSA9IHV0aWwuaXNBcnJheShhcmcpID8gdHJ5Q2F0Y2goZm4pLmFwcGx5KGN0eCwgYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ5Q2F0Y2goZm4pLmNhbGwoY3R4LCBhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdHJ5Q2F0Y2goZm4pKCk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHJldC5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudHJ5XCIsIHJldCk7XG4gICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdXRpbC5lcnJvck9iaikge1xuICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayh2YWx1ZS5lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcbiAgICB9XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpO1xudmFyIE9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG5cbmZ1bmN0aW9uIGlzVW50eXBlZEVycm9yKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gRXJyb3IucHJvdG90eXBlO1xufVxuXG52YXIgckVycm9yS2V5ID0gL14oPzpuYW1lfG1lc3NhZ2V8c3RhY2t8Y2F1c2UpJC87XG5mdW5jdGlvbiB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG9iaikge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKGlzVW50eXBlZEVycm9yKG9iaikpIHtcbiAgICAgICAgcmV0ID0gbmV3IE9wZXJhdGlvbmFsRXJyb3Iob2JqKTtcbiAgICAgICAgcmV0Lm5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgcmV0Lm1lc3NhZ2UgPSBvYmoubWVzc2FnZTtcbiAgICAgICAgcmV0LnN0YWNrID0gb2JqLnN0YWNrO1xuICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXJFcnJvcktleS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncykge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gd3JhcEFzT3BlcmF0aW9uYWxFcnJvcihtYXliZVdyYXBBc0Vycm9yKGVycikpO1xuICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh3cmFwcGVkKTtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh3cmFwcGVkKTtcbiAgICAgICAgfSBlbHNlIGlmICghbXVsdGlBcmdzKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOztcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub2RlYmFja0ZvclByb21pc2U7XG5cbn0se1wiLi9lcnJvcnNcIjoxMixcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuXG5mdW5jdGlvbiBzcHJlYWRBZGFwdGVyKHZhbCwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCF1dGlsLmlzQXJyYXkodmFsKSkgcmV0dXJuIHN1Y2Nlc3NBZGFwdGVyLmNhbGwocHJvbWlzZSwgdmFsLCBub2RlYmFjayk7XG4gICAgdmFyIHJldCA9XG4gICAgICAgIHRyeUNhdGNoKG5vZGViYWNrKS5hcHBseShwcm9taXNlLl9ib3VuZFZhbHVlKCksIFtudWxsXS5jb25jYXQodmFsKSk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdWNjZXNzQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciByZWNlaXZlciA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICB2YXIgcmV0ID0gdmFsID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB0cnlDYXRjaChub2RlYmFjaykuY2FsbChyZWNlaXZlciwgbnVsbClcbiAgICAgICAgOiB0cnlDYXRjaChub2RlYmFjaykuY2FsbChyZWNlaXZlciwgbnVsbCwgdmFsKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvckFkYXB0ZXIocmVhc29uLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKHJlYXNvbiArIFwiXCIpO1xuICAgICAgICBuZXdSZWFzb24uY2F1c2UgPSByZWFzb247XG4gICAgICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgcmVhc29uKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLmFzQ2FsbGJhY2sgPSBQcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygbm9kZWJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhZGFwdGVyID0gc3VjY2Vzc0FkYXB0ZXI7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0KG9wdGlvbnMpLnNwcmVhZCkge1xuICAgICAgICAgICAgYWRhcHRlciA9IHNwcmVhZEFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGhlbihcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICBlcnJvckFkYXB0ZXIsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbm9kZWJhY2tcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbnZhciBtYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIHJlZmxlY3RIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xuZnVuY3Rpb24gUHJveHlhYmxlKCkge31cbnZhciBVTkRFRklORURfQklORElORyA9IHt9O1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG52YXIgZ2V0RG9tYWluO1xuaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSBwcm9jZXNzLmRvbWFpbjtcbiAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSByZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLCBcIl9nZXREb21haW5cIiwgZ2V0RG9tYWluKTtcblxudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNVwiKTtcbnZhciBBc3luYyA9IF9kZXJlcV8oXCIuL2FzeW5jXCIpO1xudmFyIGFzeW5jID0gbmV3IEFzeW5jKCk7XG5lczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZSwgXCJfYXN5bmNcIiwge3ZhbHVlOiBhc3luY30pO1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBQcm9taXNlLlR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5Qcm9taXNlLlJhbmdlRXJyb3IgPSBlcnJvcnMuUmFuZ2VFcnJvcjtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG5Qcm9taXNlLlRpbWVvdXRFcnJvciA9IGVycm9ycy5UaW1lb3V0RXJyb3I7XG5Qcm9taXNlLk9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuUmVqZWN0aW9uRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuQWdncmVnYXRlRXJyb3IgPSBlcnJvcnMuQWdncmVnYXRlRXJyb3I7XG52YXIgSU5URVJOQUwgPSBmdW5jdGlvbigpe307XG52YXIgQVBQTFkgPSB7fTtcbnZhciBORVhUX0ZJTFRFUiA9IHt9O1xudmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSBfZGVyZXFfKFwiLi90aGVuYWJsZXNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xudmFyIFByb21pc2VBcnJheSA9XG4gICAgX2RlcmVxXyhcIi4vcHJvbWlzZV9hcnJheVwiKShQcm9taXNlLCBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSk7XG52YXIgQ29udGV4dCA9IF9kZXJlcV8oXCIuL2NvbnRleHRcIikoUHJvbWlzZSk7XG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbnZhciBjcmVhdGVDb250ZXh0ID0gQ29udGV4dC5jcmVhdGU7XG52YXIgZGVidWcgPSBfZGVyZXFfKFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKFByb21pc2UsIENvbnRleHQpO1xudmFyIENhcHR1cmVkVHJhY2UgPSBkZWJ1Zy5DYXB0dXJlZFRyYWNlO1xudmFyIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQgPVxuICAgIF9kZXJlcV8oXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgTkVYVF9GSUxURVIpO1xudmFyIGNhdGNoRmlsdGVyID0gX2RlcmVxXyhcIi4vY2F0Y2hfZmlsdGVyXCIpKE5FWFRfRklMVEVSKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSBfZGVyZXFfKFwiLi9ub2RlYmFja1wiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuZnVuY3Rpb24gY2hlY2soc2VsZiwgZXhlY3V0b3IpIHtcbiAgICBpZiAoc2VsZiA9PSBudWxsIHx8IHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhleGVjdXRvcikpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICBjaGVjayh0aGlzLCBleGVjdXRvcik7XG4gICAgfVxuICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXNvbHZlRnJvbUV4ZWN1dG9yKGV4ZWN1dG9yKTtcbiAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDcmVhdGVkXCIsIHRoaXMpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcIkNhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBmbiwgdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgZm4pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVmbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihyZWZsZWN0SGFuZGxlcixcbiAgICAgICAgcmVmbGVjdEhhbmRsZXIsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgaWYgKGRlYnVnLndhcm5pbmdzKCkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgdHlwZW9mIGRpZEZ1bGZpbGwgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZGlkUmVqZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiLnRoZW4oKSBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGJ1dCB3YXMgcGFzc2VkOiBcIiArXG4gICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhkaWRGdWxmaWxsKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIsIFwiICsgdXRpbC5jbGFzc1N0cmluZyhkaWRSZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dhcm4obXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPVxuICAgICAgICB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgcHJvbWlzZS5fc2V0SXNGaW5hbCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGwoKS5fdGhlbihmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIEFQUExZLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXQgPSB7XG4gICAgICAgIGlzRnVsZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgIGZ1bGZpbGxtZW50VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgcmV0LmZ1bGZpbGxtZW50VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHJldC5pc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXQucmVqZWN0aW9uUmVhc29uID0gdGhpcy5yZWFzb24oKTtcbiAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl93YXJuKFwiLmFsbCgpIHdhcyBwYXNzZWQgYXJndW1lbnRzIGJ1dCBpdCBkb2VzIG5vdCB0YWtlIGFueVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5jYXVnaHQodXRpbC5vcmlnaW5hdGVzRnJvbVJlamVjdGlvbiwgZm4pO1xufTtcblxuUHJvbWlzZS5nZXROZXdMaWJyYXJ5Q29weSA9IG1vZHVsZS5leHBvcnRzO1xuXG5Qcm9taXNlLmlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xufTtcblxuUHJvbWlzZS5mcm9tTm9kZSA9IFByb21pc2UuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAhIU9iamVjdChhcmd1bWVudHNbMV0pLm11bHRpQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChmbikobm9kZWJhY2tGb3JQcm9taXNlKHJldCwgbXVsdGlBcmdzKSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5jYXN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXQgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaik7XG4gICAgaWYgKCEocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHJldC5fc2V0RnVsZmlsbGVkKCk7XG4gICAgICAgIHJldC5fcmVqZWN0aW9uSGFuZGxlcjAgPSBvYmo7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBQcm9taXNlLmZ1bGZpbGxlZCA9IFByb21pc2UuY2FzdDtcblxuUHJvbWlzZS5yZWplY3QgPSBQcm9taXNlLnJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzeW5jLnNldFNjaGVkdWxlcihmbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGhlbiA9IGZ1bmN0aW9uIChcbiAgICBkaWRGdWxmaWxsLFxuICAgIGRpZFJlamVjdCxcbiAgICBfLCAgICByZWNlaXZlcixcbiAgICBpbnRlcm5hbERhdGFcbikge1xuICAgIHZhciBoYXZlSW50ZXJuYWxEYXRhID0gaW50ZXJuYWxEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBoYXZlSW50ZXJuYWxEYXRhID8gaW50ZXJuYWxEYXRhIDogbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB2YXIgYml0RmllbGQgPSB0YXJnZXQuX2JpdEZpZWxkO1xuXG4gICAgaWYgKCFoYXZlSW50ZXJuYWxEYXRhKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odGhpcywgMyk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgIT09IDApKSB7XG4gICAgICAgICAgICBpZiAoISgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGFyZ2V0ID09PSB0aGlzID8gdW5kZWZpbmVkIDogdGhpcy5fYm91bmRUbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2hhaW5lZFwiLCB0aGlzLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgaGFuZGxlciwgdmFsdWUsIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VDdHg7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXQuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZEZ1bGZpbGw7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgICAgIHRhcmdldC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGxlciA9IHRhcmdldC5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlcjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICB0YXJnZXQuX2F0dGFjaEV4dHJhVHJhY2UodmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jLmludm9rZShzZXR0bGVyLCB0YXJnZXQsIHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGRvbWFpbiA9PT0gbnVsbCA/IGhhbmRsZXJcbiAgICAgICAgICAgICAgICA6ICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZG9tYWluQmluZChkb21haW4sIGhhbmRsZXIpKSxcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICByZWNlaXZlcjogcmVjZWl2ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Ll9hZGRDYWxsYmFja3MoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgZG9tYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdEZpZWxkICYgNjU1MzU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGYXRlU2VhbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA2NzEwODg2NCkgPT09IDY3MTA4ODY0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9ICh0aGlzLl9iaXRGaWVsZCAmIC02NTUzNikgfFxuICAgICAgICAobGVuICYgNjU1MzUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMzM1NTQ0MzI7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUZ1bGZpbGxlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTY3NzcyMTY7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlamVjdGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjcxMDg4NjQ7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlc29sdmVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDQxOTQzMDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NjU1MzYpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NTUzNjtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2FuY2VsbGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFdpbGxCZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA4Mzg4NjA4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEFzeW5jR3VhcmFudGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhc3luYy5oYXNDdXN0b21TY2hlZHVsZXIoKSkgcmV0dXJuO1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzQyMTc3Mjg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVjZWl2ZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciByZXQgPSBpbmRleCA9PT0gMCA/IHRoaXMuX3JlY2VpdmVyMCA6IHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgM107XG4gICAgaWYgKHJldCA9PT0gVU5ERUZJTkVEX0JJTkRJTkcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJldCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzQm91bmQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMF07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0aW9uSGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMV07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCkge307XG5cblByb21pc2UucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2swID0gZnVuY3Rpb24gKGZvbGxvd2VyKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gZm9sbG93ZXIuX2JpdEZpZWxkO1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgdmFyIHJlamVjdCA9IGZvbGxvd2VyLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlMDtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdCgwKTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrQXQgPSBmdW5jdGlvbiAoZm9sbG93ZXIsIGluZGV4KSB7XG4gICAgdmFyIGZ1bGZpbGwgPSBmb2xsb3dlci5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaW5kZXgpO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciByZWNlaXZlciA9IGZvbGxvd2VyLl9yZWNlaXZlckF0KGluZGV4KTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYWRkQ2FsbGJhY2tzID0gZnVuY3Rpb24gKFxuICAgIGZ1bGZpbGwsXG4gICAgcmVqZWN0LFxuICAgIHByb21pc2UsXG4gICAgcmVjZWl2ZXIsXG4gICAgZG9tYWluXG4pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSA2NTUzNSAtIDQpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UwID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIwID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNCAtIDQ7XG4gICAgICAgIHRoaXNbYmFzZSArIDJdID0gcHJvbWlzZTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpc1tiYXNlICsgMV0gPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0TGVuZ3RoKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKHByb3h5YWJsZSwgYXJnKSB7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcsIHByb3h5YWJsZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUNhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUsIHNob3VsZEJpbmQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDApKSByZXR1cm47XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0Q2FsbGJhY2sobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSwgZmFsc2UpO1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzKTtcbiAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkgcmV0dXJuIHRoaXMuX2Z1bGZpbGwodmFsdWUpO1xuXG4gICAgaWYgKHNob3VsZEJpbmQpIHRoaXMuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCAyKTtcblxuICAgIHZhciBwcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcblxuICAgIGlmIChwcm9taXNlID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW4gPiAwKSBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2swKHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2tBdCh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGb2xsb3dpbmcoKTtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgICAgICB0aGlzLl9zZXRGb2xsb3dlZShwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGwocHJvbWlzZS5fdmFsdWUoKSk7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QocHJvbWlzZS5fcmVhc29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0Q2FsbGJhY2sgPVxuZnVuY3Rpb24ocmVhc29uLCBzeW5jaHJvbm91cywgaWdub3JlTm9uRXJyb3JXYXJuaW5ncykge1xuICAgIHZhciB0cmFjZSA9IHV0aWwuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICB2YXIgaGFzU3RhY2sgPSB0cmFjZSA9PT0gcmVhc29uO1xuICAgIGlmICghaGFzU3RhY2sgJiYgIWlnbm9yZU5vbkVycm9yV2FybmluZ3MgJiYgZGVidWcud2FybmluZ3MoKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiYSBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgbm9uLWVycm9yOiBcIiArXG4gICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3dhcm4obWVzc2FnZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UsIHN5bmNocm9ub3VzID8gaGFzU3RhY2sgOiBmYWxzZSk7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21FeGVjdXRvciA9IGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgIGlmIChleGVjdXRvciA9PT0gSU5URVJOQUwpIHJldHVybjtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzLl9leGVjdXRlKGV4ZWN1dG9yLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cyk7XG4gICAgfSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHIsIHRydWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIgPSBmdW5jdGlvbiAoXG4gICAgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlXG4pIHtcbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gZXJyb3JPYmo7XG4gICAgICAgICAgICB4LmUgPSBuZXcgVHlwZUVycm9yKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmFwcGx5KHRoaXMuX2JvdW5kVmFsdWUoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG5cbiAgICBpZiAoeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHggPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHguZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh4LCBwcm9taXNlQ3JlYXRlZCwgXCJcIiwgIHByb21pc2UsIHRoaXMpO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlID0gZnVuY3Rpb24ocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKSB7XG4gICAgdmFyIGlzUHJvbWlzZSA9IHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIHZhciBhc3luY0d1YXJhbnRlZWQgPSAoKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMCk7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UpIHByb21pc2UuX2ludm9rZUludGVybmFsT25DYW5jZWwoKTtcblxuICAgICAgICBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ICYmXG4gICAgICAgICAgICByZWNlaXZlci5pc0ZpbmFsbHlIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PT0gcmVmbGVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwocmVmbGVjdEhhbmRsZXIuY2FsbChyZWNlaXZlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUNhbmNlbGxlZChwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UgfHwgcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2VBcnJheSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3h5YWJsZSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VSZWplY3RlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBoYW5kbGVyID0gY3R4LmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBjdHgucHJvbWlzZTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBjdHgucmVjZWl2ZXI7XG4gICAgdmFyIHZhbHVlID0gY3R4LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUN0eCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UoY3R4LnByb21pc2UsIGN0eC5oYW5kbGVyLCBjdHgucmVjZWl2ZXIsIGN0eC52YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZTAgPSBmdW5jdGlvbihoYW5kbGVyLCB2YWx1ZSwgYml0RmllbGQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UwO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoMCk7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICB0aGlzW2Jhc2UgKyAyXSA9XG4gICAgdGhpc1tiYXNlICsgM10gPVxuICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICB0aGlzW2Jhc2UgKyAxXSA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAxMTc1MDYwNDgpID4+PiAxNikpIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlO1xuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlcmVmZXJlbmNlVHJhY2UoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgMTE3NTA2MDQ4KSA+Pj4gMTYpKSByZXR1cm47XG4gICAgdGhpcy5fc2V0UmVqZWN0ZWQoKTtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gcmVhc29uO1xuXG4gICAgaWYgKHRoaXMuX2lzRmluYWwoKSkge1xuICAgICAgICByZXR1cm4gYXN5bmMuZmF0YWxFcnJvcihyZWFzb24sIHV0aWwuaXNOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoKGJpdEZpZWxkICYgNjU1MzUpID4gMCkge1xuICAgICAgICBhc3luYy5zZXR0bGVQcm9taXNlcyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZnVsZmlsbFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgdmFsdWUpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaSk7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZUF0KGkpO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9yZWNlaXZlckF0KGkpO1xuICAgICAgICB0aGlzLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXgoaSk7XG4gICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0UHJvbWlzZXMgPSBmdW5jdGlvbiAobGVuLCByZWFzb24pIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fcmVqZWN0aW9uSGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCByZWFzb24pO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICB2YXIgbGVuID0gKGJpdEZpZWxkICYgNjU1MzUpO1xuXG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxNjg0Mjc1MikgIT09IDApKSB7XG4gICAgICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwLCByZWFzb24sIGJpdEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdFByb21pc2VzKGxlbiwgcmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZTAodGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCwgdmFsdWUsIGJpdEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhsZW4sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuICAgIHRoaXMuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZWRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBkZWZlclJlc29sdmUodikge3RoaXMucHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHYpO31cbmZ1bmN0aW9uIGRlZmVyUmVqZWN0KHYpIHt0aGlzLnByb21pc2UuX3JlamVjdENhbGxiYWNrKHYsIGZhbHNlKTt9XG5cblByb21pc2UuZGVmZXIgPSBQcm9taXNlLnBlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiUHJvbWlzZS5kZWZlclwiLCBcIm5ldyBQcm9taXNlXCIpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgIHJlc29sdmU6IGRlZmVyUmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBkZWZlclJlamVjdFxuICAgIH07XG59O1xuXG51dGlsLm5vdEVudW1lcmFibGVQcm9wKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgIFwiX21ha2VTZWxmUmVzb2x1dGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgIG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKTtcblxuX2RlcmVxXyhcIi4vbWV0aG9kXCIpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sXG4gICAgZGVidWcpO1xuX2RlcmVxXyhcIi4vYmluZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgZGVidWcpO1xuX2RlcmVxXyhcIi4vY2FuY2VsXCIpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zyk7XG5fZGVyZXFfKFwiLi9kaXJlY3RfcmVzb2x2ZVwiKShQcm9taXNlKTtcbl9kZXJlcV8oXCIuL3N5bmNocm9ub3VzX2luc3BlY3Rpb25cIikoUHJvbWlzZSk7XG5fZGVyZXFfKFwiLi9qb2luXCIpKFxuICAgIFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGFzeW5jLCBnZXREb21haW4pO1xuUHJvbWlzZS5Qcm9taXNlID0gUHJvbWlzZTtcblByb21pc2UudmVyc2lvbiA9IFwiMy41LjJcIjtcbl9kZXJlcV8oJy4vbWFwLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5fZGVyZXFfKCcuL2NhbGxfZ2V0LmpzJykoUHJvbWlzZSk7XG5fZGVyZXFfKCcuL3VzaW5nLmpzJykoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBjcmVhdGVDb250ZXh0LCBJTlRFUk5BTCwgZGVidWcpO1xuX2RlcmVxXygnLi90aW1lcnMuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xuX2RlcmVxXygnLi9nZW5lcmF0b3JzLmpzJykoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgUHJveHlhYmxlLCBkZWJ1Zyk7XG5fZGVyZXFfKCcuL25vZGVpZnkuanMnKShQcm9taXNlKTtcbl9kZXJlcV8oJy4vcHJvbWlzaWZ5LmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xuX2RlcmVxXygnLi9wcm9wcy5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbl9kZXJlcV8oJy4vcmFjZS5qcycpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pO1xuX2RlcmVxXygnLi9yZWR1Y2UuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbl9kZXJlcV8oJy4vc2V0dGxlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBkZWJ1Zyk7XG5fZGVyZXFfKCcuL3NvbWUuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbik7XG5fZGVyZXFfKCcuL2ZpbHRlci5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbl9kZXJlcV8oJy4vZWFjaC5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbl9kZXJlcV8oJy4vYW55LmpzJykoUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMoUHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UucHJvdG90eXBlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZ1bmN0aW9uIGZpbGxUeXBlcyh2YWx1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcHJvbWlzZTAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3JlY2VpdmVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAvLyBDb21wbGV0ZSBzbGFjayB0cmFja2luZywgb3B0IG91dCBvZiBmaWVsZC10eXBlIHRyYWNraW5nIGFuZCAgICAgICAgICAgXG4gICAgLy8gc3RhYmlsaXplIG1hcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YTogMX0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2I6IDJ9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtjOiAzfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcygxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZnVuY3Rpb24oKXt9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHVuZGVmaW5lZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyhmYWxzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMobmV3IFByb21pc2UoSU5URVJOQUwpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZGVidWcuc2V0Qm91bmRzKEFzeW5jLmZpcnN0TGluZUVycm9yLCB1dGlsLmxhc3RMaW5lRXJyb3IpOyAgICAgICAgICAgICAgIFxuICAgIHJldHVybiBQcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxufTtcblxufSx7XCIuL2FueS5qc1wiOjEsXCIuL2FzeW5jXCI6MixcIi4vYmluZFwiOjMsXCIuL2NhbGxfZ2V0LmpzXCI6NSxcIi4vY2FuY2VsXCI6NixcIi4vY2F0Y2hfZmlsdGVyXCI6NyxcIi4vY29udGV4dFwiOjgsXCIuL2RlYnVnZ2FiaWxpdHlcIjo5LFwiLi9kaXJlY3RfcmVzb2x2ZVwiOjEwLFwiLi9lYWNoLmpzXCI6MTEsXCIuL2Vycm9yc1wiOjEyLFwiLi9lczVcIjoxMyxcIi4vZmlsdGVyLmpzXCI6MTQsXCIuL2ZpbmFsbHlcIjoxNSxcIi4vZ2VuZXJhdG9ycy5qc1wiOjE2LFwiLi9qb2luXCI6MTcsXCIuL21hcC5qc1wiOjE4LFwiLi9tZXRob2RcIjoxOSxcIi4vbm9kZWJhY2tcIjoyMCxcIi4vbm9kZWlmeS5qc1wiOjIxLFwiLi9wcm9taXNlX2FycmF5XCI6MjMsXCIuL3Byb21pc2lmeS5qc1wiOjI0LFwiLi9wcm9wcy5qc1wiOjI1LFwiLi9yYWNlLmpzXCI6MjcsXCIuL3JlZHVjZS5qc1wiOjI4LFwiLi9zZXR0bGUuanNcIjozMCxcIi4vc29tZS5qc1wiOjMxLFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCI6MzIsXCIuL3RoZW5hYmxlc1wiOjMzLFwiLi90aW1lcnMuanNcIjozNCxcIi4vdXNpbmcuanNcIjozNSxcIi4vdXRpbFwiOjM2fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgIGFwaVJlamVjdGlvbiwgUHJveHlhYmxlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcblxuZnVuY3Rpb24gdG9SZXNvbHV0aW9uVmFsdWUodmFsKSB7XG4gICAgc3dpdGNoKHZhbCkge1xuICAgIGNhc2UgLTI6IHJldHVybiBbXTtcbiAgICBjYXNlIC0zOiByZXR1cm4ge307XG4gICAgY2FzZSAtNjogcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcHJvcGFnYXRlRnJvbSh2YWx1ZXMsIDMpO1xuICAgIH1cbiAgICBwcm9taXNlLl9zZXRPbkNhbmNlbCh0aGlzKTtcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkID0gMDtcbiAgICB0aGlzLl9pbml0KHVuZGVmaW5lZCwgLTIpO1xufVxudXRpbC5pbmhlcml0cyhQcm9taXNlQXJyYXksIFByb3h5YWJsZSk7XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChfLCByZXNvbHZlVmFsdWVJZkVtcHR5KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpcy5fdmFsdWVzLCB0aGlzLl9wcm9taXNlKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuX3RhcmdldCgpO1xuICAgICAgICB2YXIgYml0RmllbGQgPSB2YWx1ZXMuX2JpdEZpZWxkO1xuICAgICAgICA7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcblxuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5fdGhlbihcbiAgICAgICAgICAgICAgICBpbml0LFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVJZkVtcHR5XG4gICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5fdmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdCh2YWx1ZXMuX3JlYXNvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXMgPSB1dGlsLmFzQXJyYXkodmFsdWVzKTtcbiAgICBpZiAodmFsdWVzID09PSBudWxsKSB7XG4gICAgICAgIHZhciBlcnIgPSBhcGlSZWplY3Rpb24oXG4gICAgICAgICAgICBcImV4cGVjdGluZyBhbiBhcnJheSBvciBhbiBpdGVyYWJsZSBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcodmFsdWVzKSkucmVhc29uKCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3JlamVjdENhbGxiYWNrKGVyciwgZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHJlc29sdmVWYWx1ZUlmRW1wdHkgPT09IC01KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRW1wdHlBcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0b1Jlc29sdXRpb25WYWx1ZShyZXNvbHZlVmFsdWVJZkVtcHR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pdGVyYXRlKHZhbHVlcyk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMuZ2V0QWN0dWFsTGVuZ3RoKHZhbHVlcy5sZW5ndGgpO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcbiAgICB0aGlzLl92YWx1ZXMgPSB0aGlzLnNob3VsZENvcHlWYWx1ZXMoKSA/IG5ldyBBcnJheShsZW4pIDogdGhpcy5fdmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLl9wcm9taXNlO1xuICAgIHZhciBpc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgdmFyIGJpdEZpZWxkID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlc1tpXSwgcmVzdWx0KTtcblxuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJpdEZpZWxkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpZiAoYml0RmllbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2Uuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYml0RmllbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHkodGhpcywgaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2ldID0gbWF5YmVQcm9taXNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VSZWplY3RlZChtYXliZVByb21pc2UuX3JlYXNvbigpLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VDYW5jZWxsZWQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZChtYXliZVByb21pc2UsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNSZXNvbHZlZCkgcmVzdWx0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyA9PT0gbnVsbDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSB8fCAhdGhpcy5fcHJvbWlzZS5faXNDYW5jZWxsYWJsZSgpKSByZXR1cm47XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9jYW5jZWwoKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgZmFsc2UpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkKys7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YWx1ZXMuY2FuY2VsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbjtcbn07XG5cbnJldHVybiBQcm9taXNlQXJyYXk7XG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgVEhJUyA9IHt9O1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IF9kZXJlcV8oXCIuL25vZGViYWNrXCIpO1xudmFyIHdpdGhBcHBlbmRlZCA9IHV0aWwud2l0aEFwcGVuZGVkO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIFR5cGVFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG52YXIgZGVmYXVsdFN1ZmZpeCA9IFwiQXN5bmNcIjtcbnZhciBkZWZhdWx0UHJvbWlzaWZpZWQgPSB7X19pc1Byb21pc2lmaWVkX186IHRydWV9O1xudmFyIG5vQ29weVByb3BzID0gW1xuICAgIFwiYXJpdHlcIiwgICAgXCJsZW5ndGhcIixcbiAgICBcIm5hbWVcIixcbiAgICBcImFyZ3VtZW50c1wiLFxuICAgIFwiY2FsbGVyXCIsXG4gICAgXCJjYWxsZWVcIixcbiAgICBcInByb3RvdHlwZVwiLFxuICAgIFwiX19pc1Byb21pc2lmaWVkX19cIlxuXTtcbnZhciBub0NvcHlQcm9wc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgbm9Db3B5UHJvcHMuam9pbihcInxcIikgKyBcIikkXCIpO1xuXG52YXIgZGVmYXVsdEZpbHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdXRpbC5pc0lkZW50aWZpZXIobmFtZSkgJiZcbiAgICAgICAgbmFtZS5jaGFyQXQoMCkgIT09IFwiX1wiICYmXG4gICAgICAgIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIjtcbn07XG5cbmZ1bmN0aW9uIHByb3BzRmlsdGVyKGtleSkge1xuICAgIHJldHVybiAhbm9Db3B5UHJvcHNQYXR0ZXJuLnRlc3Qoa2V5KTtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNpZmllZChmbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbi5fX2lzUHJvbWlzaWZpZWRfXyA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkge1xuICAgIHZhciB2YWwgPSB1dGlsLmdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSArIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb21pc2lmaWVkKTtcbiAgICByZXR1cm4gdmFsID8gaXNQcm9taXNpZmllZCh2YWwpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gcmV0W2ldO1xuICAgICAgICBpZiAoc3VmZml4UmVnZXhwLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgdmFyIGtleVdpdGhvdXRBc3luY1N1ZmZpeCA9IGtleS5yZXBsYWNlKHN1ZmZpeFJlZ2V4cCwgXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbal0gPT09IGtleVdpdGhvdXRBc3luY1N1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHByb21pc2lmeSBhbiBBUEkgdGhhdCBoYXMgbm9ybWFsIG1ldGhvZHMgd2l0aCAnJXMnLXN1ZmZpeFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCIlc1wiLCBzdWZmaXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyhvYmopO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICB2YXIgcGFzc2VzRGVmYXVsdEZpbHRlciA9IGZpbHRlciA9PT0gZGVmYXVsdEZpbHRlclxuICAgICAgICAgICAgPyB0cnVlIDogZGVmYXVsdEZpbHRlcihrZXksIHZhbHVlLCBvYmopO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICFpc1Byb21pc2lmaWVkKHZhbHVlKSAmJlxuICAgICAgICAgICAgIWhhc1Byb21pc2lmaWVkKG9iaiwga2V5LCBzdWZmaXgpICYmXG4gICAgICAgICAgICBmaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqLCBwYXNzZXNEZWZhdWx0RmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG52YXIgZXNjYXBlSWRlbnRSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFskXSkvLCBcIlxcXFwkXCIpO1xufTtcblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsO1xuaWYgKCF0cnVlKSB7XG52YXIgc3dpdGNoQ2FzZUFyZ3VtZW50T3JkZXIgPSBmdW5jdGlvbihsaWtlbHlBcmd1bWVudENvdW50KSB7XG4gICAgdmFyIHJldCA9IFtsaWtlbHlBcmd1bWVudENvdW50XTtcbiAgICB2YXIgbWluID0gTWF0aC5tYXgoMCwgbGlrZWx5QXJndW1lbnRDb3VudCAtIDEgLSAzKTtcbiAgICBmb3IodmFyIGkgPSBsaWtlbHlBcmd1bWVudENvdW50IC0gMTsgaSA+PSBtaW47IC0taSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCArIDE7IGkgPD0gMzsgKytpKSB7XG4gICAgICAgIHJldC5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxudmFyIGFyZ3VtZW50U2VxdWVuY2UgPSBmdW5jdGlvbihhcmd1bWVudENvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoYXJndW1lbnRDb3VudCwgXCJfYXJnXCIsIFwiXCIpO1xufTtcblxudmFyIHBhcmFtZXRlckRlY2xhcmF0aW9uID0gZnVuY3Rpb24ocGFyYW1ldGVyQ291bnQpIHtcbiAgICByZXR1cm4gdXRpbC5maWxsZWRSYW5nZShcbiAgICAgICAgTWF0aC5tYXgocGFyYW1ldGVyQ291bnQsIDMpLCBcIl9hcmdcIiwgXCJcIik7XG59O1xuXG52YXIgcGFyYW1ldGVyQ291bnQgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihmbi5sZW5ndGgsIDEwMjMgKyAxKSwgMCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxubWFrZU5vZGVQcm9taXNpZmllZEV2YWwgPVxuZnVuY3Rpb24oY2FsbGJhY2ssIHJlY2VpdmVyLCBvcmlnaW5hbE5hbWUsIGZuLCBfLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgbmV3UGFyYW1ldGVyQ291bnQgPSBNYXRoLm1heCgwLCBwYXJhbWV0ZXJDb3VudChmbikgLSAxKTtcbiAgICB2YXIgYXJndW1lbnRPcmRlciA9IHN3aXRjaENhc2VBcmd1bWVudE9yZGVyKG5ld1BhcmFtZXRlckNvdW50KTtcbiAgICB2YXIgc2hvdWxkUHJveHlUaGlzID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiIHx8IHJlY2VpdmVyID09PSBUSElTO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudChjb3VudCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50U2VxdWVuY2UoY291bnQpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIGNvbW1hID0gY291bnQgPiAwID8gXCIsIFwiIDogXCJcIjtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYgKHNob3VsZFByb3h5VGhpcykge1xuICAgICAgICAgICAgcmV0ID0gXCJyZXQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gcmVjZWl2ZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gXCJyZXQgPSBjYWxsYmFjayh7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIlxuICAgICAgICAgICAgICAgIDogXCJyZXQgPSBjYWxsYmFjay5jYWxsKHJlY2VpdmVyLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0LnJlcGxhY2UoXCJ7e2FyZ3N9fVwiLCBhcmdzKS5yZXBsYWNlKFwiLCBcIiwgY29tbWEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkge1xuICAgICAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudE9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXQgKz0gXCJjYXNlIFwiICsgYXJndW1lbnRPcmRlcltpXSArXCI6XCIgK1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoYXJndW1lbnRPcmRlcltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgKz0gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBpID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBub2RlYmFjazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFtDb2RlRm9yQ2FsbF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcIltDb2RlRm9yQ2FsbF1cIiwgKHNob3VsZFByb3h5VGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwicmV0ID0gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XFxuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcXG5cIikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHZhciBnZXRGdW5jdGlvbkNvZGUgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoXCJ0aGlzICE9IG51bGwgPyB0aGlzWydcIitjYWxsYmFjaytcIiddIDogZm5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImZuXCI7XG4gICAgdmFyIGJvZHkgPSBcIid1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB2YXIgcmV0ID0gZnVuY3Rpb24gKFBhcmFtZXRlcnMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIG5vZGViYWNrID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIFwiICsgbXVsdGlBcmdzICsgXCIpOyAgIFxcblxcXG4gICAgICAgICAgICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB0cnlDYXRjaChbR2V0RnVuY3Rpb25Db2RlXSk7ICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW0NvZGVGb3JTd2l0Y2hDYXNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sobWF5YmVXcmFwQXNFcnJvcihyZXQuZSksIHRydWUsIHRydWUpO1xcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBpZiAoIXByb21pc2UuX2lzRmF0ZVNlYWxlZCgpKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTsgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHJldCwgJ19faXNQcm9taXNpZmllZF9fJywgdHJ1ZSk7ICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiByZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgXCIucmVwbGFjZShcIltDb2RlRm9yU3dpdGNoQ2FzZV1cIiwgZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSlcbiAgICAgICAgLnJlcGxhY2UoXCJbR2V0RnVuY3Rpb25Db2RlXVwiLCBnZXRGdW5jdGlvbkNvZGUpO1xuICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoXCJQYXJhbWV0ZXJzXCIsIHBhcmFtZXRlckRlY2xhcmF0aW9uKG5ld1BhcmFtZXRlckNvdW50KSk7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIlByb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVjZWl2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2l0aEFwcGVuZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1heWJlV3JhcEFzRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm9kZWJhY2tGb3JQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRyeUNhdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImVycm9yT2JqXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vdEVudW1lcmFibGVQcm9wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIklOVEVSTkFMXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5KShcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICB3aXRoQXBwZW5kZWQsXG4gICAgICAgICAgICAgICAgICAgIG1heWJlV3JhcEFzRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG5vZGViYWNrRm9yUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgdXRpbC50cnlDYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5lcnJvck9iaixcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwpO1xufTtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmUoY2FsbGJhY2ssIHJlY2VpdmVyLCBfLCBmbiwgX18sIG11bHRpQXJncykge1xuICAgIHZhciBkZWZhdWx0VGhpcyA9IChmdW5jdGlvbigpIHtyZXR1cm4gdGhpczt9KSgpO1xuICAgIHZhciBtZXRob2QgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYWxsYmFjayA9IGZuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9taXNpZmllZCgpIHtcbiAgICAgICAgdmFyIF9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IFRISVMpIF9yZWNlaXZlciA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICB2YXIgY2IgPSB0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiICYmIHRoaXMgIT09IGRlZmF1bHRUaGlzXG4gICAgICAgICAgICA/IHRoaXNbbWV0aG9kXSA6IGNhbGxiYWNrO1xuICAgICAgICB2YXIgZm4gPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgbXVsdGlBcmdzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiLmFwcGx5KF9yZWNlaXZlciwgd2l0aEFwcGVuZGVkKGFyZ3VtZW50cywgZm4pKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKGUpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb21pc2UuX2lzRmF0ZVNlYWxlZCgpKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AocHJvbWlzaWZpZWQsIFwiX19pc1Byb21pc2lmaWVkX19cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHByb21pc2lmaWVkO1xufVxuXG52YXIgbWFrZU5vZGVQcm9taXNpZmllZCA9IGNhbkV2YWx1YXRlXG4gICAgPyBtYWtlTm9kZVByb21pc2lmaWVkRXZhbFxuICAgIDogbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmU7XG5cbmZ1bmN0aW9uIHByb21pc2lmeUFsbChvYmosIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKSB7XG4gICAgdmFyIHN1ZmZpeFJlZ2V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlSWRlbnRSZWdleChzdWZmaXgpICsgXCIkXCIpO1xuICAgIHZhciBtZXRob2RzID1cbiAgICAgICAgcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IG1ldGhvZHNbaV07XG4gICAgICAgIHZhciBmbiA9IG1ldGhvZHNbaSsxXTtcbiAgICAgICAgdmFyIHByb21pc2lmaWVkS2V5ID0ga2V5ICsgc3VmZml4O1xuICAgICAgICBpZiAocHJvbWlzaWZpZXIgPT09IG1ha2VOb2RlUHJvbWlzaWZpZWQpIHtcbiAgICAgICAgICAgIG9ialtwcm9taXNpZmllZEtleV0gPVxuICAgICAgICAgICAgICAgIG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksIGZuLCBzdWZmaXgsIG11bHRpQXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzaWZpZWQgPSBwcm9taXNpZmllcihmbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4sIHN1ZmZpeCwgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgICAgIG9ialtwcm9taXNpZmllZEtleV0gPSBwcm9taXNpZmllZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkoY2FsbGJhY2ssIHJlY2VpdmVyLCBtdWx0aUFyZ3MpIHtcbiAgICByZXR1cm4gbWFrZU5vZGVQcm9taXNpZmllZChjYWxsYmFjaywgcmVjZWl2ZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssIG51bGwsIG11bHRpQXJncyk7XG59XG5cblByb21pc2UucHJvbWlzaWZ5ID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICBpZiAoaXNQcm9taXNpZmllZChmbikpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0KG9wdGlvbnMpO1xuICAgIHZhciByZWNlaXZlciA9IG9wdGlvbnMuY29udGV4dCA9PT0gdW5kZWZpbmVkID8gVEhJUyA6IG9wdGlvbnMuY29udGV4dDtcbiAgICB2YXIgbXVsdGlBcmdzID0gISFvcHRpb25zLm11bHRpQXJncztcbiAgICB2YXIgcmV0ID0gcHJvbWlzaWZ5KGZuLCByZWNlaXZlciwgbXVsdGlBcmdzKTtcbiAgICB1dGlsLmNvcHlEZXNjcmlwdG9ycyhmbiwgcmV0LCBwcm9wc0ZpbHRlcik7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvbWlzaWZ5QWxsID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhlIHRhcmdldCBvZiBwcm9taXNpZnlBbGwgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIG11bHRpQXJncyA9ICEhb3B0aW9ucy5tdWx0aUFyZ3M7XG4gICAgdmFyIHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4O1xuICAgIGlmICh0eXBlb2Ygc3VmZml4ICE9PSBcInN0cmluZ1wiKSBzdWZmaXggPSBkZWZhdWx0U3VmZml4O1xuICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgIHZhciBwcm9taXNpZmllciA9IG9wdGlvbnMucHJvbWlzaWZpZXI7XG4gICAgaWYgKHR5cGVvZiBwcm9taXNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBwcm9taXNpZmllciA9IG1ha2VOb2RlUHJvbWlzaWZpZWQ7XG5cbiAgICBpZiAoIXV0aWwuaXNJZGVudGlmaWVyKHN1ZmZpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzdWZmaXggbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyh0YXJnZXQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0YXJnZXRba2V5c1tpXV07XG4gICAgICAgIGlmIChrZXlzW2ldICE9PSBcImNvbnN0cnVjdG9yXCIgJiZcbiAgICAgICAgICAgIHV0aWwuaXNDbGFzcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZS5wcm90b3R5cGUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllcixcbiAgICAgICAgICAgICAgICBtdWx0aUFyZ3MpO1xuICAgICAgICAgICAgcHJvbWlzaWZ5QWxsKHZhbHVlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzaWZ5QWxsKHRhcmdldCwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpO1xufTtcbn07XG5cblxufSx7XCIuL2Vycm9yc1wiOjEyLFwiLi9ub2RlYmFja1wiOjIwLFwiLi91dGlsXCI6MzZ9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oXG4gICAgUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG52YXIgZXM1ID0gX2RlcmVxXyhcIi4vZXM1XCIpO1xudmFyIEVzNk1hcDtcbmlmICh0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIpIEVzNk1hcCA9IE1hcDtcblxudmFyIG1hcFRvRW50cmllcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaXplID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RFbnRyeSh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHRoaXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXNbaW5kZXggKyBzaXplXSA9IGtleTtcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwVG9FbnRyaWVzKG1hcCkge1xuICAgICAgICBzaXplID0gbWFwLnNpemU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBBcnJheShtYXAuc2l6ZSAqIDIpO1xuICAgICAgICBtYXAuZm9yRWFjaChleHRyYWN0RW50cnksIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBlbnRyaWVzVG9NYXAgPSBmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBFczZNYXAoKTtcbiAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGggLyAyIHwgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2xlbmd0aCArIGldO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyaWVzW2ldO1xuICAgICAgICByZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gUHJvcGVydGllc1Byb21pc2VBcnJheShvYmopIHtcbiAgICB2YXIgaXNNYXAgPSBmYWxzZTtcbiAgICB2YXIgZW50cmllcztcbiAgICBpZiAoRXM2TWFwICE9PSB1bmRlZmluZWQgJiYgb2JqIGluc3RhbmNlb2YgRXM2TWFwKSB7XG4gICAgICAgIGVudHJpZXMgPSBtYXBUb0VudHJpZXMob2JqKTtcbiAgICAgICAgaXNNYXAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBlbnRyaWVzID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGVudHJpZXNbaV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGVudHJpZXNbaSArIGxlbl0gPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQoZW50cmllcyk7XG4gICAgdGhpcy5faXNNYXAgPSBpc01hcDtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIGlzTWFwID8gLTYgOiAtMyk7XG59XG51dGlsLmluaGVyaXRzKFByb3BlcnRpZXNQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgaWYgKHRoaXMuX2lzTWFwKSB7XG4gICAgICAgICAgICB2YWwgPSBlbnRyaWVzVG9NYXAodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleU9mZnNldCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGgoKTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFsW3RoaXMuX3ZhbHVlc1tpICsga2V5T2Zmc2V0XV0gPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbiA+PiAxO1xufTtcblxuZnVuY3Rpb24gcHJvcHMocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBjYXN0VmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzKTtcblxuICAgIGlmICghaXNPYmplY3QoY2FzdFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiY2Fubm90IGF3YWl0IHByb3BlcnRpZXMgb2YgYSBub24tb2JqZWN0XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9IGVsc2UgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0ID0gY2FzdFZhbHVlLl90aGVuKFxuICAgICAgICAgICAgUHJvbWlzZS5wcm9wcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvcGVydGllc1Byb21pc2VBcnJheShjYXN0VmFsdWUpLnByb21pc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoY2FzdFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20oY2FzdFZhbHVlLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzKHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm9wcyA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBwcm9wcyhwcm9taXNlcyk7XG59O1xufTtcblxufSx7XCIuL2VzNVwiOjEzLFwiLi91dGlsXCI6MzZ9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFycmF5TW92ZShzcmMsIHNyY0luZGV4LCBkc3QsIGRzdEluZGV4LCBsZW4pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgIGRzdFtqICsgZHN0SW5kZXhdID0gc3JjW2ogKyBzcmNJbmRleF07XG4gICAgICAgIHNyY1tqICsgc3JjSW5kZXhdID0gdm9pZCAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUXVldWUoY2FwYWNpdHkpIHtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJvbnQgPSAwO1xufVxuXG5RdWV1ZS5wcm90b3R5cGUuX3dpbGxCZU92ZXJDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFjaXR5IDwgc2l6ZTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcHVzaE9uZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB0aGlzLl9jaGVja0NhcGFjaXR5KGxlbmd0aCArIDEpO1xuICAgIHZhciBpID0gKHRoaXMuX2Zyb250ICsgbGVuZ3RoKSAmICh0aGlzLl9jYXBhY2l0eSAtIDEpO1xuICAgIHRoaXNbaV0gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoICsgMTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCkgKyAzO1xuICAgIGlmICh0aGlzLl93aWxsQmVPdmVyQ2FwYWNpdHkobGVuZ3RoKSkge1xuICAgICAgICB0aGlzLl9wdXNoT25lKGZuKTtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShyZWNlaXZlcik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUoYXJnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaiA9IHRoaXMuX2Zyb250ICsgbGVuZ3RoIC0gMztcbiAgICB0aGlzLl9jaGVja0NhcGFjaXR5KGxlbmd0aCk7XG4gICAgdmFyIHdyYXBNYXNrID0gdGhpcy5fY2FwYWNpdHkgLSAxO1xuICAgIHRoaXNbKGogKyAwKSAmIHdyYXBNYXNrXSA9IGZuO1xuICAgIHRoaXNbKGogKyAxKSAmIHdyYXBNYXNrXSA9IHJlY2VpdmVyO1xuICAgIHRoaXNbKGogKyAyKSAmIHdyYXBNYXNrXSA9IGFyZztcbiAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQsXG4gICAgICAgIHJldCA9IHRoaXNbZnJvbnRdO1xuXG4gICAgdGhpc1tmcm9udF0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJvbnQgPSAoZnJvbnQgKyAxKSAmICh0aGlzLl9jYXBhY2l0eSAtIDEpO1xuICAgIHRoaXMuX2xlbmd0aC0tO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX2NoZWNrQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIGlmICh0aGlzLl9jYXBhY2l0eSA8IHNpemUpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplVG8odGhpcy5fY2FwYWNpdHkgPDwgMSk7XG4gICAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLl9yZXNpemVUbyA9IGZ1bmN0aW9uIChjYXBhY2l0eSkge1xuICAgIHZhciBvbGRDYXBhY2l0eSA9IHRoaXMuX2NhcGFjaXR5O1xuICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICB2YXIgbW92ZUl0ZW1zQ291bnQgPSAoZnJvbnQgKyBsZW5ndGgpICYgKG9sZENhcGFjaXR5IC0gMSk7XG4gICAgYXJyYXlNb3ZlKHRoaXMsIDAsIHRoaXMsIG9sZENhcGFjaXR5LCBtb3ZlSXRlbXNDb3VudCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuXG59LHt9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oXG4gICAgUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG52YXIgcmFjZUxhdGVyID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIHJldHVybiByYWNlKGFycmF5LCBwcm9taXNlKTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIHJhY2UocHJvbWlzZXMsIHBhcmVudCkge1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzKTtcblxuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByYWNlTGF0ZXIobWF5YmVQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlcyA9IHV0aWwuYXNBcnJheShwcm9taXNlcyk7XG4gICAgICAgIGlmIChwcm9taXNlcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYW4gYXJyYXkgb3IgYW4gaXRlcmFibGUgb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKHByb21pc2VzKSk7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHBhcmVudCwgMyk7XG4gICAgfVxuICAgIHZhciBmdWxmaWxsID0gcmV0Ll9mdWxmaWxsO1xuICAgIHZhciByZWplY3QgPSByZXQuX3JlamVjdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvbWlzZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbCA9IHByb21pc2VzW2ldO1xuXG4gICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuY2FzdCh2YWwpLl90aGVuKGZ1bGZpbGwsIHJlamVjdCwgdW5kZWZpbmVkLCByZXQsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gcmFjZShwcm9taXNlcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhY2UodGhpcywgdW5kZWZpbmVkKTtcbn07XG5cbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cbmZ1bmN0aW9uIFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2ZuID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IFByb21pc2UucmVzb2x2ZShpbml0aWFsVmFsdWUpO1xuICAgICAgICBpbml0aWFsVmFsdWUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gbnVsbDtcbiAgICBpZihfZWFjaCA9PT0gSU5URVJOQUwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IEFycmF5KHRoaXMuX2xlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChfZWFjaCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xufVxudXRpbC5pbmhlcml0cyhSZWR1Y3Rpb25Qcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2dvdEFjY3VtID0gZnVuY3Rpb24oYWNjdW0pIHtcbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzICE9PSBudWxsICYmIFxuICAgICAgICBhY2N1bSAhPT0gSU5URVJOQUwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKGFjY3VtKTtcbiAgICB9XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9lYWNoQ29tcGxldGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lYWNoVmFsdWVzO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge307XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgPyB0aGlzLl9lYWNoVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9pbml0aWFsVmFsdWUpO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3Byb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKHNlbmRlcikge1xuICAgIGlmIChzZW5kZXIgPT09IHRoaXMuX2luaXRpYWxWYWx1ZSkgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB0aGlzLl9yZXN1bHRDYW5jZWxsZWQkKCk7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlLmNhbmNlbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2luaXRpYWxWYWx1ZTtcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBQcm9taXNlLnJlc29sdmUodmFsdWVzWzBdKTtcbiAgICAgICAgaSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG5cbiAgICBpZiAoIXZhbHVlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0ge1xuICAgICAgICAgICAgICAgIGFjY3VtOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJyYXk6IHRoaXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLl90aGVuKGdvdEFjY3VtLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY3R4LCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICAuX3RoZW4odGhpcy5fZWFjaENvbXBsZXRlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsdWUuX3RoZW4oY29tcGxldGVkLCBjb21wbGV0ZWQsIHVuZGVmaW5lZCwgdmFsdWUsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIGZuLCBpbml0aWFsVmFsdWUsIG51bGwpO1xufTtcblxuUHJvbWlzZS5yZWR1Y2UgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgcmV0dXJuIHJlZHVjZShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xufTtcblxuZnVuY3Rpb24gY29tcGxldGVkKHZhbHVlT3JSZWFzb24sIGFycmF5KSB7XG4gICAgaWYgKHRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICBhcnJheS5fcmVzb2x2ZSh2YWx1ZU9yUmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheS5fcmVqZWN0KHZhbHVlT3JSZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gbmV3IFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xuICAgIHJldHVybiBhcnJheS5wcm9taXNlKCk7XG59XG5cbmZ1bmN0aW9uIGdvdEFjY3VtKGFjY3VtKSB7XG4gICAgdGhpcy5hY2N1bSA9IGFjY3VtO1xuICAgIHRoaXMuYXJyYXkuX2dvdEFjY3VtKGFjY3VtKTtcbiAgICB2YXIgdmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMudmFsdWUsIHRoaXMuYXJyYXkuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5hcnJheS5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fdGhlbihnb3RWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdvdFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ290VmFsdWUodmFsdWUpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgIHZhciBwcm9taXNlID0gYXJyYXkuX3Byb21pc2U7XG4gICAgdmFyIGZuID0gdHJ5Q2F0Y2goYXJyYXkuX2ZuKTtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXQ7XG4gICAgaWYgKGFycmF5Ll9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHZhbHVlLCB0aGlzLmluZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY3VtLCB2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBhcnJheS5fY3VycmVudENhbmNlbGxhYmxlID0gcmV0O1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICByZXQsXG4gICAgICAgIHByb21pc2VDcmVhdGVkLFxuICAgICAgICBhcnJheS5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gXCJQcm9taXNlLmVhY2hcIiA6IFwiUHJvbWlzZS5yZWR1Y2VcIixcbiAgICAgICAgcHJvbWlzZVxuICAgICk7XG4gICAgcmV0dXJuIHJldDtcbn1cbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBzY2hlZHVsZTtcbnZhciBub0FzeW5jU2NoZWR1bGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIE5hdGl2ZVByb21pc2UgPSB1dGlsLmdldE5hdGl2ZVByb21pc2UoKTtcbmlmICh1dGlsLmlzTm9kZSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBHbG9iYWxTZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBQcm9jZXNzTmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgIHNjaGVkdWxlID0gdXRpbC5pc1JlY2VudE5vZGVcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGZuKSB7IEdsb2JhbFNldEltbWVkaWF0ZS5jYWxsKGdsb2JhbCwgZm4pOyB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbihmbikgeyBQcm9jZXNzTmV4dFRpY2suY2FsbChwcm9jZXNzLCBmbik7IH07XG59IGVsc2UgaWYgKHR5cGVvZiBOYXRpdmVQcm9taXNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgdHlwZW9mIE5hdGl2ZVByb21pc2UucmVzb2x2ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIG5hdGl2ZVByb21pc2UgPSBOYXRpdmVQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIG5hdGl2ZVByb21pc2UudGhlbihmbik7XG4gICAgfTtcbn0gZWxzZSBpZiAoKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSAmJlxuICAgICAgICAgICEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvciAmJlxuICAgICAgICAgICAgKHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSB8fCB3aW5kb3cuY29yZG92YSkpKSB7XG4gICAgc2NoZWR1bGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb3B0cyA9IHthdHRyaWJ1dGVzOiB0cnVlfTtcbiAgICAgICAgdmFyIHRvZ2dsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZGl2MiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBvMiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIik7XG4gICAgICAgICAgICB0b2dnbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIG8yLm9ic2VydmUoZGl2Miwgb3B0cyk7XG5cbiAgICAgICAgdmFyIHNjaGVkdWxlVG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodG9nZ2xlU2NoZWR1bGVkKSByZXR1cm47XG4gICAgICAgICAgICB0b2dnbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGl2Mi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2hlZHVsZShmbikge1xuICAgICAgICAgICAgdmFyIG8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvLm9ic2VydmUoZGl2LCBvcHRzKTtcbiAgICAgICAgICAgIHNjaGVkdWxlVG9nZ2xlKCk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldFRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBzY2hlZHVsZSA9IG5vQXN5bmNTY2hlZHVsZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNjaGVkdWxlO1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG4gICAgZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBkZWJ1Zykge1xudmFyIFByb21pc2VJbnNwZWN0aW9uID0gUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gU2V0dGxlZFByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJCh2YWx1ZXMpO1xufVxudXRpbC5pbmhlcml0cyhTZXR0bGVkUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlc29sdmVkID0gZnVuY3Rpb24gKGluZGV4LCBpbnNwZWN0aW9uKSB7XG4gICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IGluc3BlY3Rpb247XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICByZXQuX2JpdEZpZWxkID0gMzM1NTQ0MzI7XG4gICAgcmV0Ll9zZXR0bGVkVmFsdWVGaWVsZCA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlUmVzb2x2ZWQoaW5kZXgsIHJldCk7XG59O1xuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24sIGluZGV4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgIHJldC5fYml0RmllbGQgPSAxNjc3NzIxNjtcbiAgICByZXQuX3NldHRsZWRWYWx1ZUZpZWxkID0gcmVhc29uO1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlUmVzb2x2ZWQoaW5kZXgsIHJldCk7XG59O1xuXG5Qcm9taXNlLnNldHRsZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIGRlYnVnLmRlcHJlY2F0ZWQoXCIuc2V0dGxlKClcIiwgXCIucmVmbGVjdCgpXCIpO1xuICAgIHJldHVybiBuZXcgU2V0dGxlZFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0dGxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQcm9taXNlLnNldHRsZSh0aGlzKTtcbn07XG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIFJhbmdlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIikuUmFuZ2VFcnJvcjtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5BZ2dyZWdhdGVFcnJvcjtcbnZhciBpc0FycmF5ID0gdXRpbC5pc0FycmF5O1xudmFyIENBTkNFTExBVElPTiA9IHt9O1xuXG5cbmZ1bmN0aW9uIFNvbWVQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbiAgICB0aGlzLl9ob3dNYW55ID0gMDtcbiAgICB0aGlzLl91bndyYXAgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xufVxudXRpbC5pbmhlcml0cyhTb21lUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2hvd01hbnkgPT09IDApIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZShbXSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtNSk7XG4gICAgdmFyIGlzQXJyYXlSZXNvbHZlZCA9IGlzQXJyYXkodGhpcy5fdmFsdWVzKTtcbiAgICBpZiAoIXRoaXMuX2lzUmVzb2x2ZWQoKSAmJlxuICAgICAgICBpc0FycmF5UmVzb2x2ZWQgJiZcbiAgICAgICAgdGhpcy5faG93TWFueSA+IHRoaXMuX2NhblBvc3NpYmx5RnVsZmlsbCgpKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKHRoaXMubGVuZ3RoKCkpKTtcbiAgICB9XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pbml0KCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zZXRVbndyYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdW53cmFwID0gdHJ1ZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmhvd01hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvd01hbnk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zZXRIb3dNYW55ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdGhpcy5faG93TWFueSA9IGNvdW50O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9hZGRGdWxmaWxsZWQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9mdWxmaWxsZWQoKSA9PT0gdGhpcy5ob3dNYW55KCkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IHRoaXMuaG93TWFueSgpO1xuICAgICAgICBpZiAodGhpcy5ob3dNYW55KCkgPT09IDEgJiYgdGhpcy5fdW53cmFwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcblxufTtcblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fYWRkUmVqZWN0ZWQocmVhc29uKTtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tPdXRjb21lKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSB8fCB0aGlzLl92YWx1ZXMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgfVxuICAgIHRoaXMuX2FkZFJlamVjdGVkKENBTkNFTExBVElPTik7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrT3V0Y29tZSgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2NoZWNrT3V0Y29tZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmhvd01hbnkoKSA+IHRoaXMuX2NhblBvc3NpYmx5RnVsZmlsbCgpKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEFnZ3JlZ2F0ZUVycm9yKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCgpOyBpIDwgdGhpcy5fdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWVzW2ldICE9PSBDQU5DRUxMQVRJT04pIHtcbiAgICAgICAgICAgICAgICBlLnB1c2godGhpcy5fdmFsdWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxSZXNvbHZlZDtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aCAtIHRoaXMubGVuZ3RoKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYWRkUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdmFsdWVzLnB1c2gocmVhc29uKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hZGRGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZXNbdGhpcy5fdG90YWxSZXNvbHZlZCsrXSA9IHZhbHVlO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2NhblBvc3NpYmx5RnVsZmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGgoKSAtIHRoaXMuX3JlamVjdGVkKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZ2V0UmFuZ2VFcnJvciA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHZhciBtZXNzYWdlID0gXCJJbnB1dCBhcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgXCIgK1xuICAgICAgICAgICAgdGhpcy5faG93TWFueSArIFwiIGl0ZW1zIGJ1dCBjb250YWlucyBvbmx5IFwiICsgY291bnQgKyBcIiBpdGVtc1wiO1xuICAgIHJldHVybiBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlRW1wdHlBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZWplY3QodGhpcy5fZ2V0UmFuZ2VFcnJvcigwKSk7XG59O1xuXG5mdW5jdGlvbiBzb21lKHByb21pc2VzLCBob3dNYW55KSB7XG4gICAgaWYgKChob3dNYW55IHwgMCkgIT09IGhvd01hbnkgfHwgaG93TWFueSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIHBvc2l0aXZlIGludGVnZXJcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFNvbWVQcm9taXNlQXJyYXkocHJvbWlzZXMpO1xuICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICByZXQuc2V0SG93TWFueShob3dNYW55KTtcbiAgICByZXQuaW5pdCgpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnNvbWUgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGhvd01hbnkpIHtcbiAgICByZXR1cm4gc29tZShwcm9taXNlcywgaG93TWFueSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGhvd01hbnkpIHtcbiAgICByZXR1cm4gc29tZSh0aGlzLCBob3dNYW55KTtcbn07XG5cblByb21pc2UuX1NvbWVQcm9taXNlQXJyYXkgPSBTb21lUHJvbWlzZUFycmF5O1xufTtcblxufSx7XCIuL2Vycm9yc1wiOjEyLFwiLi91dGlsXCI6MzZ9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xuZnVuY3Rpb24gUHJvbWlzZUluc3BlY3Rpb24ocHJvbWlzZSkge1xuICAgIGlmIChwcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZCA9IHByb21pc2UuX2lzRmF0ZVNlYWxlZCgpXG4gICAgICAgICAgICA/IHByb21pc2UuX3NldHRsZWRWYWx1ZSgpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSAwO1xuICAgICAgICB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5fc2V0dGxlZFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkO1xufTtcblxudmFyIHZhbHVlID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIG9mIGEgbm9uLWZ1bGZpbGxlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxudmFyIHJlYXNvbiA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5lcnJvciA9XG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUucmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgcmVqZWN0aW9uIHJlYXNvbiBvZiBhIG5vbi1yZWplY3RlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxudmFyIGlzRnVsZmlsbGVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMDtcbn07XG5cbnZhciBpc1JlamVjdGVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMDtcbn07XG5cbnZhciBpc1BlbmRpbmcgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDA7XG59O1xuXG52YXIgaXNSZXNvbHZlZCA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MDMzMTY0OCkgIT09IDA7XG59O1xuXG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgODQ1NDE0NCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fX2lzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDY1NTM2KSA9PT0gNjU1MzY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX19pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3RhcmdldCgpLl9iaXRGaWVsZCAmIDg0NTQxNDQpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZy5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZC5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1Jlc29sdmVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWUuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdGFyZ2V0Ll91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHJlYXNvbi5jYWxsKHRhcmdldCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVhc29uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlSW5zcGVjdGlvbjtcbn07XG5cbn0se31dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIHRyeUNvbnZlcnRUb1Byb21pc2Uob2JqLCBjb250ZXh0KSB7XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBvYmo7XG4gICAgICAgIHZhciB0aGVuID0gZ2V0VGhlbihvYmopO1xuICAgICAgICBpZiAodGhlbiA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KHRoZW4uZSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgb2JqLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICByZXQuX2Z1bGZpbGwsXG4gICAgICAgICAgICAgICAgICAgIHJldC5fcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb1RoZW5hYmxlKG9iaiwgdGhlbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gZG9HZXRUaGVuKG9iaikge1xuICAgIHJldHVybiBvYmoudGhlbjtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZG9HZXRUaGVuKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cblxudmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGlzQW55Qmx1ZWJpcmRQcm9taXNlKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBoYXNQcm9wLmNhbGwob2JqLCBcIl9wcm9taXNlMFwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRvVGhlbmFibGUoeCwgdGhlbiwgY29udGV4dCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciByZXQgPSBwcm9taXNlO1xuICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICB2YXIgc3luY2hyb25vdXMgPSB0cnVlO1xuICAgIHZhciByZXN1bHQgPSB1dGlsLnRyeUNhdGNoKHRoZW4pLmNhbGwoeCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICBzeW5jaHJvbm91cyA9IGZhbHNlO1xuXG4gICAgaWYgKHByb21pc2UgJiYgcmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlKSByZXR1cm47XG4gICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgICAgaWYgKCFwcm9taXNlKSByZXR1cm47XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgc3luY2hyb25vdXMsIHRydWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxucmV0dXJuIHRyeUNvbnZlcnRUb1Byb21pc2U7XG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCBkZWJ1Zykge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IFByb21pc2UuVGltZW91dEVycm9yO1xuXG5mdW5jdGlvbiBIYW5kbGVXcmFwcGVyKGhhbmRsZSkgIHtcbiAgICB0aGlzLmhhbmRsZSA9IGhhbmRsZTtcbn1cblxuSGFuZGxlV3JhcHBlci5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG59O1xuXG52YXIgYWZ0ZXJWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBkZWxheSgrdGhpcykudGhlblJldHVybih2YWx1ZSk7IH07XG52YXIgZGVsYXkgPSBQcm9taXNlLmRlbGF5ID0gZnVuY3Rpb24gKG1zLCB2YWx1ZSkge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGhhbmRsZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQgPSBQcm9taXNlLnJlc29sdmUodmFsdWUpXG4gICAgICAgICAgICAgICAgLl90aGVuKGFmdGVyVmFsdWUsIG51bGwsIG51bGwsIG1zLCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkgJiYgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgaGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgcmV0Ll9mdWxmaWxsKCk7IH0sICttcyk7XG4gICAgICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChuZXcgSGFuZGxlV3JhcHBlcihoYW5kbGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgfVxuICAgIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKG1zKSB7XG4gICAgcmV0dXJuIGRlbGF5KG1zLCB0aGlzKTtcbn07XG5cbnZhciBhZnRlclRpbWVvdXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgbWVzc2FnZSwgcGFyZW50KSB7XG4gICAgdmFyIGVycjtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgZXJyID0gbWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBUaW1lb3V0RXJyb3IoXCJvcGVyYXRpb24gdGltZWQgb3V0XCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyID0gbmV3IFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdXRpbC5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24oZXJyKTtcbiAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKGVycik7XG4gICAgcHJvbWlzZS5fcmVqZWN0KGVycik7XG5cbiAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50LmNhbmNlbCgpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHN1Y2Nlc3NDbGVhcih2YWx1ZSkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBmYWlsdXJlQ2xlYXIocmVhc29uKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICB0aHJvdyByZWFzb247XG59XG5cblByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIG1lc3NhZ2UpIHtcbiAgICBtcyA9ICttcztcbiAgICB2YXIgcmV0LCBwYXJlbnQ7XG5cbiAgICB2YXIgaGFuZGxlV3JhcHBlciA9IG5ldyBIYW5kbGVXcmFwcGVyKHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZW91dFRpbWVvdXQoKSB7XG4gICAgICAgIGlmIChyZXQuaXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgIGFmdGVyVGltZW91dChyZXQsIG1lc3NhZ2UsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9LCBtcykpO1xuXG4gICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpKSB7XG4gICAgICAgIHBhcmVudCA9IHRoaXMudGhlbigpO1xuICAgICAgICByZXQgPSBwYXJlbnQuX3RoZW4oc3VjY2Vzc0NsZWFyLCBmYWlsdXJlQ2xlYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCBoYW5kbGVXcmFwcGVyLCB1bmRlZmluZWQpO1xuICAgICAgICByZXQuX3NldE9uQ2FuY2VsKGhhbmRsZVdyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IHRoaXMuX3RoZW4oc3VjY2Vzc0NsZWFyLCBmYWlsdXJlQ2xlYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCBoYW5kbGVXcmFwcGVyLCB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKSB7XG4gICAgdmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuICAgIHZhciBUeXBlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIikuVHlwZUVycm9yO1xuICAgIHZhciBpbmhlcml0cyA9IF9kZXJlcV8oXCIuL3V0aWxcIikuaW5oZXJpdHM7XG4gICAgdmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbiAgICB2YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuICAgIHZhciBOVUxMID0ge307XG5cbiAgICBmdW5jdGlvbiB0aHJvd2VyKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGU7fSwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHRoZW5hYmxlKSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoZW5hYmxlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5faXNEaXNwb3NhYmxlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5fZ2V0RGlzcG9zZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdGhlbmFibGUuX2lzRGlzcG9zYWJsZSgpKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuX3NldERpc3Bvc2FibGUodGhlbmFibGUuX2dldERpc3Bvc2VyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXliZVByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3Bvc2UocmVzb3VyY2VzLCBpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHJlc291cmNlcy5sZW5ndGg7XG4gICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSByZXR1cm4gcmV0Ll9mdWxmaWxsKCk7XG4gICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHJlc291cmNlc1tpKytdKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlICYmXG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9pc0Rpc3Bvc2FibGUoKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2dldERpc3Bvc2VyKCkudHJ5RGlzcG9zZShpbnNwZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlcy5wcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd2VyKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl90aGVuKGl0ZXJhdG9yLCB0aHJvd2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlcmF0b3IoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEaXNwb3NlcihkYXRhLCBwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5yZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZSgpLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UoKS52YWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOVUxMO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUudHJ5RGlzcG9zZSA9IGZ1bmN0aW9uKGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5yZXNvdXJjZSgpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSByZXNvdXJjZSAhPT0gTlVMTFxuICAgICAgICAgICAgPyB0aGlzLmRvRGlzcG9zZShyZXNvdXJjZSwgaW5zcGVjdGlvbikgOiBudWxsO1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3Vuc2V0RGlzcG9zYWJsZSgpO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIuaXNEaXNwb3NlciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAoZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQucmVzb3VyY2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkLnRyeURpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGlzcG9zZXIoZm4sIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQoZm4sIHByb21pc2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpbmhlcml0cyhGdW5jdGlvbkRpc3Bvc2VyLCBEaXNwb3Nlcik7XG5cbiAgICBGdW5jdGlvbkRpc3Bvc2VyLnByb3RvdHlwZS5kb0Rpc3Bvc2UgPSBmdW5jdGlvbiAocmVzb3VyY2UsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGZuID0gdGhpcy5kYXRhKCk7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHJlc291cmNlLCByZXNvdXJjZSwgaW5zcGVjdGlvbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1heWJlVW53cmFwRGlzcG9zZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKERpc3Bvc2VyLmlzRGlzcG9zZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1t0aGlzLmluZGV4XS5fc2V0RGlzcG9zYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZXNvdXJjZUxpc3QobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzW2xlbmd0aC0xXSA9IG51bGw7XG4gICAgfVxuXG4gICAgUmVzb3VyY2VMaXN0LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQcm9taXNlLnVzaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IDIpIHJldHVybiBhcGlSZWplY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlvdSBtdXN0IHBhc3MgYXQgbGVhc3QgMiBhcmd1bWVudHMgdG8gUHJvbWlzZS51c2luZ1wiKTtcbiAgICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2xlbiAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgdmFyIHNwcmVhZEFyZ3MgPSB0cnVlO1xuICAgICAgICBpZiAobGVuID09PSAyICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBzcHJlYWRBcmdzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dCA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvdXJjZXMgPSBuZXcgUmVzb3VyY2VMaXN0KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgaWYgKERpc3Bvc2VyLmlzRGlzcG9zZXIocmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3Bvc2VyID0gcmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuX3NldERpc3Bvc2FibGUoZGlzcG9zZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKG1heWJlVW53cmFwRGlzcG9zZXIsIG51bGwsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IHJlc291cmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc291cmNlc1tpXSA9IHJlc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZmxlY3RlZFJlc291cmNlcyA9IG5ldyBBcnJheShyZXNvdXJjZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZsZWN0ZWRSZXNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlZmxlY3RlZFJlc291cmNlc1tpXSA9IFByb21pc2UucmVzb2x2ZShyZXNvdXJjZXNbaV0pLnJlZmxlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRQcm9taXNlID0gUHJvbWlzZS5hbGwocmVmbGVjdGVkUmVzb3VyY2VzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5zcGVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3BlY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gaW5zcGVjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNwZWN0aW9uLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JPYmouZSA9IGluc3BlY3Rpb24uZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5zcGVjdGlvbi5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3BlY3Rpb25zW2ldID0gaW5zcGVjdGlvbi52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuXG4gICAgICAgICAgICAgICAgZm4gPSB0cnlDYXRjaChmbik7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHNwcmVhZEFyZ3NcbiAgICAgICAgICAgICAgICAgICAgPyBmbi5hcHBseSh1bmRlZmluZWQsIGluc3BlY3Rpb25zKSA6IGZuKGluc3BlY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgICAgICAgICByZXQsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudXNpbmdcIiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwcm9taXNlID0gcmVzdWx0UHJvbWlzZS5sYXN0bHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5zcGVjdGlvbiA9IG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHJlc3VsdFByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2UocmVzb3VyY2VzLCBpbnNwZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc291cmNlcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZS5fc2V0T25DYW5jZWwocmVzb3VyY2VzKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKGRpc3Bvc2VyKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzEwNzI7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gZGlzcG9zZXI7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9pc0Rpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMzEwNzIpID4gMDtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2dldERpc3Bvc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZXI7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl91bnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjEzMTA3Mik7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5kaXNwb3NlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25EaXNwb3NlcihmbiwgdGhpcywgY3JlYXRlQ29udGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfTtcblxufTtcblxufSx7XCIuL2Vycm9yc1wiOjEyLFwiLi91dGlsXCI6MzZ9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwidW5kZWZpbmVkXCI7XG5cbnZhciBlcnJvck9iaiA9IHtlOiB7fX07XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG52YXIgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDpcbiAgICB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDpcbiAgICB0aGlzICE9PSB1bmRlZmluZWQgPyB0aGlzIDogbnVsbDtcblxuZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdHJ5Q2F0Y2hUYXJnZXQ7XG4gICAgICAgIHRyeUNhdGNoVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uKENoaWxkLCBQYXJlbnQpIHtcbiAgICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gVCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJCA9IFBhcmVudDtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIFBhcmVudC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoUGFyZW50LnByb3RvdHlwZSwgcHJvcGVydHlOYW1lKSAmJlxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZS5jaGFyQXQocHJvcGVydHlOYW1lLmxlbmd0aC0xKSAhPT0gXCIkXCJcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWUgKyBcIiRcIl0gPSBQYXJlbnQucHJvdG90eXBlW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVC5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgIENoaWxkLnByb3RvdHlwZSA9IG5ldyBUKCk7XG4gICAgcmV0dXJuIENoaWxkLnByb3RvdHlwZTtcbn07XG5cblxuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlIHx8XG4gICAgICAgIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIjtcblxufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIG1heWJlV3JhcEFzRXJyb3IobWF5YmVFcnJvcikge1xuICAgIGlmICghaXNQcmltaXRpdmUobWF5YmVFcnJvcikpIHJldHVybiBtYXliZUVycm9yO1xuXG4gICAgcmV0dXJuIG5ldyBFcnJvcihzYWZlVG9TdHJpbmcobWF5YmVFcnJvcikpO1xufVxuXG5mdW5jdGlvbiB3aXRoQXBwZW5kZWQodGFyZ2V0LCBhcHBlbmRlZSkge1xuICAgIHZhciBsZW4gPSB0YXJnZXQubGVuZ3RoO1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHJldFtpXSA9IHRhcmdldFtpXTtcbiAgICB9XG4gICAgcmV0W2ldID0gYXBwZW5kZWU7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0KG9iaiwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG5cbiAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IGRlc2MudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vdEVudW1lcmFibGVQcm9wKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqKSkgcmV0dXJuIG9iajtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH07XG4gICAgZXM1LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gdGhyb3dlcihyKSB7XG4gICAgdGhyb3cgcjtcbn1cblxudmFyIGluaGVyaXRlZERhdGFLZXlzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBleGNsdWRlZFByb3RvdHlwZXMgPSBbXG4gICAgICAgIEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlXG4gICAgXTtcblxuICAgIHZhciBpc0V4Y2x1ZGVkUHJvdG8gPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGNsdWRlZFByb3RvdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChleGNsdWRlZFByb3RvdHlwZXNbaV0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgaWYgKGVzNS5pc0VTNSkge1xuICAgICAgICB2YXIgZ2V0S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICB2YXIgdmlzaXRlZEtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgd2hpbGUgKG9iaiAhPSBudWxsICYmICFpc0V4Y2x1ZGVkUHJvdG8ob2JqKSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBnZXRLZXlzKG9iaik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkS2V5c1trZXldKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICE9IG51bGwgJiYgZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iaiA9IGVzNS5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAoaXNFeGNsdWRlZFByb3RvKG9iaikpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICAgICAgLypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbiAgICAgICAgICAgIGVudW1lcmF0aW9uOiBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGVkUHJvdG90eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChleGNsdWRlZFByb3RvdHlwZXNbaV0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBlbnVtZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG59KSgpO1xuXG52YXIgdGhpc0Fzc2lnbm1lbnRQYXR0ZXJuID0gL3RoaXNcXHMqXFwuXFxzKlxcUytcXHMqPS87XG5mdW5jdGlvbiBpc0NsYXNzKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmbi5wcm90b3R5cGUpO1xuXG4gICAgICAgICAgICB2YXIgaGFzTWV0aG9kcyA9IGVzNS5pc0VTNSAmJiBrZXlzLmxlbmd0aCA+IDE7XG4gICAgICAgICAgICB2YXIgaGFzTWV0aG9kc090aGVyVGhhbkNvbnN0cnVjdG9yID0ga2V5cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgIShrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSBcImNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgdmFyIGhhc1RoaXNBc3NpZ25tZW50QW5kU3RhdGljTWV0aG9kcyA9XG4gICAgICAgICAgICAgICAgdGhpc0Fzc2lnbm1lbnRQYXR0ZXJuLnRlc3QoZm4gKyBcIlwiKSAmJiBlczUubmFtZXMoZm4pLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICAgIGlmIChoYXNNZXRob2RzIHx8IGhhc01ldGhvZHNPdGhlclRoYW5Db25zdHJ1Y3RvciB8fFxuICAgICAgICAgICAgICAgIGhhc1RoaXNBc3NpZ25tZW50QW5kU3RhdGljTWV0aG9kcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvRmFzdFByb3BlcnRpZXMob2JqKSB7XG4gICAgLypqc2hpbnQgLVcwMjcsLVcwNTUsLVcwMzEqL1xuICAgIGZ1bmN0aW9uIEZha2VDb25zdHJ1Y3RvcigpIHt9XG4gICAgRmFrZUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG9iajtcbiAgICB2YXIgcmVjZWl2ZXIgPSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgZnVuY3Rpb24gaWMoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVjZWl2ZXIuZm9vO1xuICAgIH1cbiAgICBpYygpO1xuICAgIGljKCk7XG4gICAgcmV0dXJuIG9iajtcbiAgICBldmFsKG9iaik7XG59XG5cbnZhciByaWRlbnQgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgICByZXR1cm4gcmlkZW50LnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gZmlsbGVkUmFuZ2UoY291bnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gcHJlZml4ICsgaSArIHN1ZmZpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2FmZVRvU3RyaW5nKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgIChvYmogIT09IG51bGwgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iai5uYW1lID09PSBcInN0cmluZ1wiKTtcbn1cblxuZnVuY3Rpb24gbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICB0cnkge1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChlLCBcImlzT3BlcmF0aW9uYWxcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGNhdGNoKGlnbm9yZSkge31cbn1cblxuZnVuY3Rpb24gb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24oZSkge1xuICAgIGlmIChlID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKChlIGluc3RhbmNlb2YgRXJyb3JbXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCJdLk9wZXJhdGlvbmFsRXJyb3IpIHx8XG4gICAgICAgIGVbXCJpc09wZXJhdGlvbmFsXCJdID09PSB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY2FuQXR0YWNoVHJhY2Uob2JqKSB7XG4gICAgcmV0dXJuIGlzRXJyb3Iob2JqKSAmJiBlczUucHJvcGVydHlJc1dyaXRhYmxlKG9iaiwgXCJzdGFja1wiKTtcbn1cblxudmFyIGVuc3VyZUVycm9yT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICghKFwic3RhY2tcIiBpbiBuZXcgRXJyb3IoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB0cnkge3Rocm93IG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTt9XG4gICAgICAgICAgICBjYXRjaChlcnIpIHtyZXR1cm4gZXJyO31cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gY2xhc3NTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gY29weURlc2NyaXB0b3JzKGZyb20sIHRvLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmcm9tKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChmaWx0ZXIoa2V5KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlczUuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgZXM1LmdldERlc2NyaXB0b3IoZnJvbSwga2V5KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgIGlmIChlczUuaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICB2YXIgQXJyYXlGcm9tID0gdHlwZW9mIEFycmF5LmZyb20gPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odik7XG4gICAgfSA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIgaXQgPSB2W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgdmFyIGl0UmVzdWx0O1xuICAgICAgICB3aGlsZSAoISgoaXRSZXN1bHQgPSBpdC5uZXh0KCkpLmRvbmUpKSB7XG4gICAgICAgICAgICByZXQucHVzaChpdFJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgYXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKGVzNS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2ICE9IG51bGwgJiYgdHlwZW9mIHZbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlGcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbnZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBjbGFzc1N0cmluZyhwcm9jZXNzKS50b0xvd2VyQ2FzZSgpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIjtcblxudmFyIGhhc0VudlZhcmlhYmxlcyA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5mdW5jdGlvbiBlbnYoa2V5KSB7XG4gICAgcmV0dXJuIGhhc0VudlZhcmlhYmxlcyA/IHByb2Nlc3MuZW52W2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldE5hdGl2ZVByb21pc2UoKSB7XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oKXt9KTtcbiAgICAgICAgICAgIGlmICh7fS50b1N0cmluZy5jYWxsKHByb21pc2UpID09PSBcIltvYmplY3QgUHJvbWlzZV1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZG9tYWluQmluZChzZWxmLCBjYikge1xuICAgIHJldHVybiBzZWxmLmJpbmQoY2IpO1xufVxuXG52YXIgcmV0ID0ge1xuICAgIGlzQ2xhc3M6IGlzQ2xhc3MsXG4gICAgaXNJZGVudGlmaWVyOiBpc0lkZW50aWZpZXIsXG4gICAgaW5oZXJpdGVkRGF0YUtleXM6IGluaGVyaXRlZERhdGFLZXlzLFxuICAgIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdDogZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0LFxuICAgIHRocm93ZXI6IHRocm93ZXIsXG4gICAgaXNBcnJheTogZXM1LmlzQXJyYXksXG4gICAgYXNBcnJheTogYXNBcnJheSxcbiAgICBub3RFbnVtZXJhYmxlUHJvcDogbm90RW51bWVyYWJsZVByb3AsXG4gICAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBpc0Vycm9yOiBpc0Vycm9yLFxuICAgIGNhbkV2YWx1YXRlOiBjYW5FdmFsdWF0ZSxcbiAgICBlcnJvck9iajogZXJyb3JPYmosXG4gICAgdHJ5Q2F0Y2g6IHRyeUNhdGNoLFxuICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICB3aXRoQXBwZW5kZWQ6IHdpdGhBcHBlbmRlZCxcbiAgICBtYXliZVdyYXBBc0Vycm9yOiBtYXliZVdyYXBBc0Vycm9yLFxuICAgIHRvRmFzdFByb3BlcnRpZXM6IHRvRmFzdFByb3BlcnRpZXMsXG4gICAgZmlsbGVkUmFuZ2U6IGZpbGxlZFJhbmdlLFxuICAgIHRvU3RyaW5nOiBzYWZlVG9TdHJpbmcsXG4gICAgY2FuQXR0YWNoVHJhY2U6IGNhbkF0dGFjaFRyYWNlLFxuICAgIGVuc3VyZUVycm9yT2JqZWN0OiBlbnN1cmVFcnJvck9iamVjdCxcbiAgICBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbjogb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sXG4gICAgbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uOiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24sXG4gICAgY2xhc3NTdHJpbmc6IGNsYXNzU3RyaW5nLFxuICAgIGNvcHlEZXNjcmlwdG9yczogY29weURlc2NyaXB0b3JzLFxuICAgIGhhc0RldlRvb2xzOiB0eXBlb2YgY2hyb21lICE9PSBcInVuZGVmaW5lZFwiICYmIGNocm9tZSAmJlxuICAgICAgICAgICAgICAgICB0eXBlb2YgY2hyb21lLmxvYWRUaW1lcyA9PT0gXCJmdW5jdGlvblwiLFxuICAgIGlzTm9kZTogaXNOb2RlLFxuICAgIGhhc0VudlZhcmlhYmxlczogaGFzRW52VmFyaWFibGVzLFxuICAgIGVudjogZW52LFxuICAgIGdsb2JhbDogZ2xvYmFsT2JqZWN0LFxuICAgIGdldE5hdGl2ZVByb21pc2U6IGdldE5hdGl2ZVByb21pc2UsXG4gICAgZG9tYWluQmluZDogZG9tYWluQmluZFxufTtcbnJldC5pc1JlY2VudE5vZGUgPSByZXQuaXNOb2RlICYmIChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7XG4gICAgcmV0dXJuICh2ZXJzaW9uWzBdID09PSAwICYmIHZlcnNpb25bMV0gPiAxMCkgfHwgKHZlcnNpb25bMF0gPiAwKTtcbn0pKCk7XG5cbmlmIChyZXQuaXNOb2RlKSByZXQudG9GYXN0UHJvcGVydGllcyhwcm9jZXNzKTtcblxudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge3JldC5sYXN0TGluZUVycm9yID0gZTt9XG5tb2R1bGUuZXhwb3J0cyA9IHJldDtcblxufSx7XCIuL2VzNVwiOjEzfV19LHt9LFs0XSkoNClcbn0pOyAgICAgICAgICAgICAgICAgICAgO2lmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgIT09IG51bGwpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LlAgPSB3aW5kb3cuUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgIT09IG51bGwpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuUCA9IHNlbGYuUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiJdfQ==
